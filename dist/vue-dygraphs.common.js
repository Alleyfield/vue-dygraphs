(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["VueDygraphs"] = factory();
	else
		root["VueDygraphs"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 28);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"N\", function() { return LOG_SCALE; });\n/* unused harmony export LN_TEN */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return log10; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return logRangeFraction; });\n/* unused harmony export DOTTED_LINE */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"G\", function() { return DASHED_LINE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"H\", function() { return DOT_DASH_LINE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return HORIZONTAL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"o\", function() { return VERTICAL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return getContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"F\", function() { return addEvent; });\n/* harmony export (immutable) */ __webpack_exports__[\"i\"] = removeEvent;\n/* harmony export (immutable) */ __webpack_exports__[\"O\"] = cancelEvent;\n/* harmony export (immutable) */ __webpack_exports__[\"j\"] = hsvToRGB;\n/* harmony export (immutable) */ __webpack_exports__[\"k\"] = findPos;\n/* harmony export (immutable) */ __webpack_exports__[\"q\"] = pageX;\n/* harmony export (immutable) */ __webpack_exports__[\"r\"] = pageY;\n/* harmony export (immutable) */ __webpack_exports__[\"l\"] = dragGetX_;\n/* harmony export (immutable) */ __webpack_exports__[\"m\"] = dragGetY_;\n/* harmony export (immutable) */ __webpack_exports__[\"S\"] = isOK;\n/* harmony export (immutable) */ __webpack_exports__[\"s\"] = isValidPoint;\n/* harmony export (immutable) */ __webpack_exports__[\"J\"] = floatFormat;\n/* unused harmony export zeropad */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"M\", function() { return DateAccessorsLocal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"L\", function() { return DateAccessorsUTC; });\n/* unused harmony export hmsString_ */\n/* harmony export (immutable) */ __webpack_exports__[\"I\"] = dateString_;\n/* unused harmony export round_ */\n/* harmony export (immutable) */ __webpack_exports__[\"K\"] = binarySearch;\n/* harmony export (immutable) */ __webpack_exports__[\"v\"] = dateParser;\n/* unused harmony export dateStrToMillis */\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = update;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = updateDeep;\n/* harmony export (immutable) */ __webpack_exports__[\"B\"] = isArrayLike;\n/* harmony export (immutable) */ __webpack_exports__[\"A\"] = isDateLike;\n/* harmony export (immutable) */ __webpack_exports__[\"C\"] = clone;\n/* harmony export (immutable) */ __webpack_exports__[\"e\"] = createCanvas;\n/* harmony export (immutable) */ __webpack_exports__[\"h\"] = getContextPixelRatio;\n/* unused harmony export Iterator */\n/* harmony export (immutable) */ __webpack_exports__[\"R\"] = createIterator;\n/* unused harmony export requestAnimFrame */\n/* harmony export (immutable) */ __webpack_exports__[\"p\"] = repeatAndCleanup;\n/* harmony export (immutable) */ __webpack_exports__[\"E\"] = isPixelChangingOptionList;\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"u\", function() { return Circles; });\n/* harmony export (immutable) */ __webpack_exports__[\"y\"] = detectLineDelimiter;\n/* harmony export (immutable) */ __webpack_exports__[\"g\"] = isNodeContainedBy;\n/* unused harmony export pow */\n/* harmony export (immutable) */ __webpack_exports__[\"t\"] = toRGB_;\n/* harmony export (immutable) */ __webpack_exports__[\"Q\"] = isCanvasSupported;\n/* harmony export (immutable) */ __webpack_exports__[\"z\"] = parseFloat_;\n/* harmony export (immutable) */ __webpack_exports__[\"P\"] = numberValueFormatter;\n/* harmony export (immutable) */ __webpack_exports__[\"D\"] = numberAxisLabelFormatter;\n/* harmony export (immutable) */ __webpack_exports__[\"x\"] = dateAxisLabelFormatter;\n/* harmony export (immutable) */ __webpack_exports__[\"w\"] = dateValueFormatter;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__ = __webpack_require__(4);\n/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview This file contains utility functions used by dygraphs. These\n * are typically static (i.e. not related to any particular dygraph). Examples\n * include date/time formatting functions, basic algorithms (e.g. binary\n * search) and generic DOM-manipulation functions.\n */\n\n/*global Dygraph:false, Node:false */\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n\n\nvar LOG_SCALE = 10;\nvar LN_TEN = Math.log(LOG_SCALE);\n\n/**\n * @private\n * @param {number} x\n * @return {number}\n */\nvar log10 = function log10(x) {\n  return Math.log(x) / LN_TEN;\n};\n\n/**\n * @private\n * @param {number} r0\n * @param {number} r1\n * @param {number} pct\n * @return {number}\n */\nvar logRangeFraction = function logRangeFraction(r0, r1, pct) {\n  // Computing the inverse of toPercentXCoord. The function was arrived at with\n  // the following steps:\n  //\n  // Original calcuation:\n  // pct = (log(x) - log(xRange[0])) / (log(xRange[1]) - log(xRange[0])));\n  //\n  // Multiply both sides by the right-side denominator.\n  // pct * (log(xRange[1] - log(xRange[0]))) = log(x) - log(xRange[0])\n  //\n  // add log(xRange[0]) to both sides\n  // log(xRange[0]) + (pct * (log(xRange[1]) - log(xRange[0])) = log(x);\n  //\n  // Swap both sides of the equation,\n  // log(x) = log(xRange[0]) + (pct * (log(xRange[1]) - log(xRange[0]))\n  //\n  // Use both sides as the exponent in 10^exp and we're done.\n  // x = 10 ^ (log(xRange[0]) + (pct * (log(xRange[1]) - log(xRange[0])))\n\n  var logr0 = log10(r0);\n  var logr1 = log10(r1);\n  var exponent = logr0 + pct * (logr1 - logr0);\n  var value = Math.pow(LOG_SCALE, exponent);\n  return value;\n};\n\n/** A dotted line stroke pattern. */\nvar DOTTED_LINE = [2, 2];\n/** A dashed line stroke pattern. */\nvar DASHED_LINE = [7, 3];\n/** A dot dash stroke pattern. */\nvar DOT_DASH_LINE = [7, 2, 2, 2];\n\n// Directions for panning and zooming. Use bit operations when combined\n// values are possible.\nvar HORIZONTAL = 1;\nvar VERTICAL = 2;\n\n/**\n * Return the 2d context for a dygraph canvas.\n *\n * This method is only exposed for the sake of replacing the function in\n * automated tests.\n *\n * @param {!HTMLCanvasElement} canvas\n * @return {!CanvasRenderingContext2D}\n * @private\n */\nvar getContext = function getContext(canvas) {\n  return (/** @type{!CanvasRenderingContext2D}*/canvas.getContext(\"2d\")\n  );\n};\n\n/**\n * Add an event handler.\n * @param {!Node} elem The element to add the event to.\n * @param {string} type The type of the event, e.g. 'click' or 'mousemove'.\n * @param {function(Event):(boolean|undefined)} fn The function to call\n *     on the event. The function takes one parameter: the event object.\n * @private\n */\nvar addEvent = function addEvent(elem, type, fn) {\n  elem.addEventListener(type, fn, false);\n};\n\n/**\n * Remove an event handler.\n * @param {!Node} elem The element to remove the event from.\n * @param {string} type The type of the event, e.g. 'click' or 'mousemove'.\n * @param {function(Event):(boolean|undefined)} fn The function to call\n *     on the event. The function takes one parameter: the event object.\n */\nfunction removeEvent(elem, type, fn) {\n  elem.removeEventListener(type, fn, false);\n};\n\n/**\n * Cancels further processing of an event. This is useful to prevent default\n * browser actions, e.g. highlighting text on a double-click.\n * Based on the article at\n * http://www.switchonthecode.com/tutorials/javascript-tutorial-the-scroll-wheel\n * @param {!Event} e The event whose normal behavior should be canceled.\n * @private\n */\nfunction cancelEvent(e) {\n  e = e ? e : window.event;\n  if (e.stopPropagation) {\n    e.stopPropagation();\n  }\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n  e.cancelBubble = true;\n  e.cancel = true;\n  e.returnValue = false;\n  return false;\n};\n\n/**\n * Convert hsv values to an rgb(r,g,b) string. Taken from MochiKit.Color. This\n * is used to generate default series colors which are evenly spaced on the\n * color wheel.\n * @param { number } hue Range is 0.0-1.0.\n * @param { number } saturation Range is 0.0-1.0.\n * @param { number } value Range is 0.0-1.0.\n * @return { string } \"rgb(r,g,b)\" where r, g and b range from 0-255.\n * @private\n */\nfunction hsvToRGB(hue, saturation, value) {\n  var red;\n  var green;\n  var blue;\n  if (saturation === 0) {\n    red = value;\n    green = value;\n    blue = value;\n  } else {\n    var i = Math.floor(hue * 6);\n    var f = hue * 6 - i;\n    var p = value * (1 - saturation);\n    var q = value * (1 - saturation * f);\n    var t = value * (1 - saturation * (1 - f));\n    switch (i) {\n      case 1:\n        red = q;green = value;blue = p;break;\n      case 2:\n        red = p;green = value;blue = t;break;\n      case 3:\n        red = p;green = q;blue = value;break;\n      case 4:\n        red = t;green = p;blue = value;break;\n      case 5:\n        red = value;green = p;blue = q;break;\n      case 6: // fall through\n      case 0:\n        red = value;green = t;blue = p;break;\n    }\n  }\n  red = Math.floor(255 * red + 0.5);\n  green = Math.floor(255 * green + 0.5);\n  blue = Math.floor(255 * blue + 0.5);\n  return 'rgb(' + red + ',' + green + ',' + blue + ')';\n};\n\n/**\n * Find the coordinates of an object relative to the top left of the page.\n *\n * @param {Node} obj\n * @return {{x:number,y:number}}\n * @private\n */\nfunction findPos(obj) {\n  var p = obj.getBoundingClientRect(),\n      w = window,\n      d = document.documentElement;\n\n  return {\n    x: p.left + (w.pageXOffset || d.scrollLeft),\n    y: p.top + (w.pageYOffset || d.scrollTop)\n  };\n};\n\n/**\n * Returns the x-coordinate of the event in a coordinate system where the\n * top-left corner of the page (not the window) is (0,0).\n * Taken from MochiKit.Signal\n * @param {!Event} e\n * @return {number}\n * @private\n */\nfunction pageX(e) {\n  return !e.pageX || e.pageX < 0 ? 0 : e.pageX;\n};\n\n/**\n * Returns the y-coordinate of the event in a coordinate system where the\n * top-left corner of the page (not the window) is (0,0).\n * Taken from MochiKit.Signal\n * @param {!Event} e\n * @return {number}\n * @private\n */\nfunction pageY(e) {\n  return !e.pageY || e.pageY < 0 ? 0 : e.pageY;\n};\n\n/**\n * Converts page the x-coordinate of the event to pixel x-coordinates on the\n * canvas (i.e. DOM Coords).\n * @param {!Event} e Drag event.\n * @param {!DygraphInteractionContext} context Interaction context object.\n * @return {number} The amount by which the drag has moved to the right.\n */\nfunction dragGetX_(e, context) {\n  return pageX(e) - context.px;\n};\n\n/**\n * Converts page the y-coordinate of the event to pixel y-coordinates on the\n * canvas (i.e. DOM Coords).\n * @param {!Event} e Drag event.\n * @param {!DygraphInteractionContext} context Interaction context object.\n * @return {number} The amount by which the drag has moved down.\n */\nfunction dragGetY_(e, context) {\n  return pageY(e) - context.py;\n};\n\n/**\n * This returns true unless the parameter is 0, null, undefined or NaN.\n * TODO(danvk): rename this function to something like 'isNonZeroNan'.\n *\n * @param {number} x The number to consider.\n * @return {boolean} Whether the number is zero or NaN.\n * @private\n */\nfunction isOK(x) {\n  return !!x && !isNaN(x);\n};\n\n/**\n * @param {{x:?number,y:?number,yval:?number}} p The point to consider, valid\n *     points are {x, y} objects\n * @param {boolean=} opt_allowNaNY Treat point with y=NaN as valid\n * @return {boolean} Whether the point has numeric x and y.\n * @private\n */\nfunction isValidPoint(p, opt_allowNaNY) {\n  if (!p) return false; // null or undefined object\n  if (p.yval === null) return false; // missing point\n  if (p.x === null || p.x === undefined) return false;\n  if (p.y === null || p.y === undefined) return false;\n  if (isNaN(p.x) || !opt_allowNaNY && isNaN(p.y)) return false;\n  return true;\n};\n\n/**\n * Number formatting function which mimics the behavior of %g in printf, i.e.\n * either exponential or fixed format (without trailing 0s) is used depending on\n * the length of the generated string.  The advantage of this format is that\n * there is a predictable upper bound on the resulting string length,\n * significant figures are not dropped, and normal numbers are not displayed in\n * exponential notation.\n *\n * NOTE: JavaScript's native toPrecision() is NOT a drop-in replacement for %g.\n * It creates strings which are too long for absolute values between 10^-4 and\n * 10^-6, e.g. '0.00001' instead of '1e-5'. See tests/number-format.html for\n * output examples.\n *\n * @param {number} x The number to format\n * @param {number=} opt_precision The precision to use, default 2.\n * @return {string} A string formatted like %g in printf.  The max generated\n *                  string length should be precision + 6 (e.g 1.123e+300).\n */\nfunction floatFormat(x, opt_precision) {\n  // Avoid invalid precision values; [1, 21] is the valid range.\n  var p = Math.min(Math.max(1, opt_precision || 2), 21);\n\n  // This is deceptively simple.  The actual algorithm comes from:\n  //\n  // Max allowed length = p + 4\n  // where 4 comes from 'e+n' and '.'.\n  //\n  // Length of fixed format = 2 + y + p\n  // where 2 comes from '0.' and y = # of leading zeroes.\n  //\n  // Equating the two and solving for y yields y = 2, or 0.00xxxx which is\n  // 1.0e-3.\n  //\n  // Since the behavior of toPrecision() is identical for larger numbers, we\n  // don't have to worry about the other bound.\n  //\n  // Finally, the argument for toExponential() is the number of trailing digits,\n  // so we take off 1 for the value before the '.'.\n  return Math.abs(x) < 1.0e-3 && x !== 0.0 ? x.toExponential(p - 1) : x.toPrecision(p);\n};\n\n/**\n * Converts '9' to '09' (useful for dates)\n * @param {number} x\n * @return {string}\n * @private\n */\nfunction zeropad(x) {\n  if (x < 10) return \"0\" + x;else return \"\" + x;\n};\n\n/**\n * Date accessors to get the parts of a calendar date (year, month,\n * day, hour, minute, second and millisecond) according to local time,\n * and factory method to call the Date constructor with an array of arguments.\n */\nvar DateAccessorsLocal = {\n  getFullYear: function getFullYear(d) {\n    return d.getFullYear();\n  },\n  getMonth: function getMonth(d) {\n    return d.getMonth();\n  },\n  getDate: function getDate(d) {\n    return d.getDate();\n  },\n  getHours: function getHours(d) {\n    return d.getHours();\n  },\n  getMinutes: function getMinutes(d) {\n    return d.getMinutes();\n  },\n  getSeconds: function getSeconds(d) {\n    return d.getSeconds();\n  },\n  getMilliseconds: function getMilliseconds(d) {\n    return d.getMilliseconds();\n  },\n  getDay: function getDay(d) {\n    return d.getDay();\n  },\n  makeDate: function makeDate(y, m, d, hh, mm, ss, ms) {\n    return new Date(y, m, d, hh, mm, ss, ms);\n  }\n};\n\n/**\n * Date accessors to get the parts of a calendar date (year, month,\n * day of month, hour, minute, second and millisecond) according to UTC time,\n * and factory method to call the Date constructor with an array of arguments.\n */\nvar DateAccessorsUTC = {\n  getFullYear: function getFullYear(d) {\n    return d.getUTCFullYear();\n  },\n  getMonth: function getMonth(d) {\n    return d.getUTCMonth();\n  },\n  getDate: function getDate(d) {\n    return d.getUTCDate();\n  },\n  getHours: function getHours(d) {\n    return d.getUTCHours();\n  },\n  getMinutes: function getMinutes(d) {\n    return d.getUTCMinutes();\n  },\n  getSeconds: function getSeconds(d) {\n    return d.getUTCSeconds();\n  },\n  getMilliseconds: function getMilliseconds(d) {\n    return d.getUTCMilliseconds();\n  },\n  getDay: function getDay(d) {\n    return d.getUTCDay();\n  },\n  makeDate: function makeDate(y, m, d, hh, mm, ss, ms) {\n    return new Date(Date.UTC(y, m, d, hh, mm, ss, ms));\n  }\n};\n\n/**\n * Return a string version of the hours, minutes and seconds portion of a date.\n * @param {number} hh The hours (from 0-23)\n * @param {number} mm The minutes (from 0-59)\n * @param {number} ss The seconds (from 0-59)\n * @return {string} A time of the form \"HH:MM\" or \"HH:MM:SS\"\n * @private\n */\nfunction hmsString_(hh, mm, ss, ms) {\n  var ret = zeropad(hh) + \":\" + zeropad(mm);\n  if (ss) {\n    ret += \":\" + zeropad(ss);\n    if (ms) {\n      var str = \"\" + ms;\n      ret += \".\" + ('000' + str).substring(str.length);\n    }\n  }\n  return ret;\n};\n\n/**\n * Convert a JS date (millis since epoch) to a formatted string.\n * @param {number} time The JavaScript time value (ms since epoch)\n * @param {boolean} utc Whether output UTC or local time\n * @return {string} A date of one of these forms:\n *     \"YYYY/MM/DD\", \"YYYY/MM/DD HH:MM\" or \"YYYY/MM/DD HH:MM:SS\"\n * @private\n */\nfunction dateString_(time, utc) {\n  var accessors = utc ? DateAccessorsUTC : DateAccessorsLocal;\n  var date = new Date(time);\n  var y = accessors.getFullYear(date);\n  var m = accessors.getMonth(date);\n  var d = accessors.getDate(date);\n  var hh = accessors.getHours(date);\n  var mm = accessors.getMinutes(date);\n  var ss = accessors.getSeconds(date);\n  var ms = accessors.getMilliseconds(date);\n  // Get a year string:\n  var year = \"\" + y;\n  // Get a 0 padded month string\n  var month = zeropad(m + 1); //months are 0-offset, sigh\n  // Get a 0 padded day string\n  var day = zeropad(d);\n  var frac = hh * 3600 + mm * 60 + ss + 1e-3 * ms;\n  var ret = year + \"/\" + month + \"/\" + day;\n  if (frac) {\n    ret += \" \" + hmsString_(hh, mm, ss, ms);\n  }\n  return ret;\n};\n\n/**\n * Round a number to the specified number of digits past the decimal point.\n * @param {number} num The number to round\n * @param {number} places The number of decimals to which to round\n * @return {number} The rounded number\n * @private\n */\nfunction round_(num, places) {\n  var shift = Math.pow(10, places);\n  return Math.round(num * shift) / shift;\n};\n\n/**\n * Implementation of binary search over an array.\n * Currently does not work when val is outside the range of arry's values.\n * @param {number} val the value to search for\n * @param {Array.<number>} arry is the value over which to search\n * @param {number} abs If abs > 0, find the lowest entry greater than val\n *     If abs < 0, find the highest entry less than val.\n *     If abs == 0, find the entry that equals val.\n * @param {number=} low The first index in arry to consider (optional)\n * @param {number=} high The last index in arry to consider (optional)\n * @return {number} Index of the element, or -1 if it isn't found.\n * @private\n */\nfunction binarySearch(val, arry, abs, low, high) {\n  if (low === null || low === undefined || high === null || high === undefined) {\n    low = 0;\n    high = arry.length - 1;\n  }\n  if (low > high) {\n    return -1;\n  }\n  if (abs === null || abs === undefined) {\n    abs = 0;\n  }\n  var validIndex = function validIndex(idx) {\n    return idx >= 0 && idx < arry.length;\n  };\n  var mid = parseInt((low + high) / 2, 10);\n  var element = arry[mid];\n  var idx;\n  if (element == val) {\n    return mid;\n  } else if (element > val) {\n    if (abs > 0) {\n      // Accept if element > val, but also if prior element < val.\n      idx = mid - 1;\n      if (validIndex(idx) && arry[idx] < val) {\n        return mid;\n      }\n    }\n    return binarySearch(val, arry, abs, low, mid - 1);\n  } else if (element < val) {\n    if (abs < 0) {\n      // Accept if element < val, but also if prior element > val.\n      idx = mid + 1;\n      if (validIndex(idx) && arry[idx] > val) {\n        return mid;\n      }\n    }\n    return binarySearch(val, arry, abs, mid + 1, high);\n  }\n  return -1; // can't actually happen, but makes closure compiler happy\n};\n\n/**\n * Parses a date, returning the number of milliseconds since epoch. This can be\n * passed in as an xValueParser in the Dygraph constructor.\n * TODO(danvk): enumerate formats that this understands.\n *\n * @param {string} dateStr A date in a variety of possible string formats.\n * @return {number} Milliseconds since epoch.\n * @private\n */\nfunction dateParser(dateStr) {\n  var dateStrSlashed;\n  var d;\n\n  // Let the system try the format first, with one caveat:\n  // YYYY-MM-DD[ HH:MM:SS] is interpreted as UTC by a variety of browsers.\n  // dygraphs displays dates in local time, so this will result in surprising\n  // inconsistencies. But if you specify \"T\" or \"Z\" (i.e. YYYY-MM-DDTHH:MM:SS),\n  // then you probably know what you're doing, so we'll let you go ahead.\n  // Issue: http://code.google.com/p/dygraphs/issues/detail?id=255\n  if (dateStr.search(\"-\") == -1 || dateStr.search(\"T\") != -1 || dateStr.search(\"Z\") != -1) {\n    d = dateStrToMillis(dateStr);\n    if (d && !isNaN(d)) return d;\n  }\n\n  if (dateStr.search(\"-\") != -1) {\n    // e.g. '2009-7-12' or '2009-07-12'\n    dateStrSlashed = dateStr.replace(\"-\", \"/\", \"g\");\n    while (dateStrSlashed.search(\"-\") != -1) {\n      dateStrSlashed = dateStrSlashed.replace(\"-\", \"/\");\n    }\n    d = dateStrToMillis(dateStrSlashed);\n  } else if (dateStr.length == 8) {\n    // e.g. '20090712'\n    // TODO(danvk): remove support for this format. It's confusing.\n    dateStrSlashed = dateStr.substr(0, 4) + \"/\" + dateStr.substr(4, 2) + \"/\" + dateStr.substr(6, 2);\n    d = dateStrToMillis(dateStrSlashed);\n  } else {\n    // Any format that Date.parse will accept, e.g. \"2009/07/12\" or\n    // \"2009/07/12 12:34:56\"\n    d = dateStrToMillis(dateStr);\n  }\n\n  if (!d || isNaN(d)) {\n    console.error(\"Couldn't parse \" + dateStr + \" as a date\");\n  }\n  return d;\n};\n\n/**\n * This is identical to JavaScript's built-in Date.parse() method, except that\n * it doesn't get replaced with an incompatible method by aggressive JS\n * libraries like MooTools or Joomla.\n * @param {string} str The date string, e.g. \"2011/05/06\"\n * @return {number} millis since epoch\n * @private\n */\nfunction dateStrToMillis(str) {\n  return new Date(str).getTime();\n};\n\n// These functions are all based on MochiKit.\n/**\n * Copies all the properties from o to self.\n *\n * @param {!Object} self\n * @param {!Object} o\n * @return {!Object}\n */\nfunction update(self, o) {\n  if (typeof o != 'undefined' && o !== null) {\n    for (var k in o) {\n      if (o.hasOwnProperty(k)) {\n        self[k] = o[k];\n      }\n    }\n  }\n  return self;\n};\n\n/**\n * Copies all the properties from o to self.\n *\n * @param {!Object} self\n * @param {!Object} o\n * @return {!Object}\n * @private\n */\nfunction updateDeep(self, o) {\n  // Taken from http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n  function isNode(o) {\n    return (typeof Node === \"undefined\" ? \"undefined\" : _typeof(Node)) === \"object\" ? o instanceof Node : (typeof o === \"undefined\" ? \"undefined\" : _typeof(o)) === \"object\" && typeof o.nodeType === \"number\" && typeof o.nodeName === \"string\";\n  }\n\n  if (typeof o != 'undefined' && o !== null) {\n    for (var k in o) {\n      if (o.hasOwnProperty(k)) {\n        if (o[k] === null) {\n          self[k] = null;\n        } else if (isArrayLike(o[k])) {\n          self[k] = o[k].slice();\n        } else if (isNode(o[k])) {\n          // DOM objects are shallowly-copied.\n          self[k] = o[k];\n        } else if (_typeof(o[k]) == 'object') {\n          if (_typeof(self[k]) != 'object' || self[k] === null) {\n            self[k] = {};\n          }\n          updateDeep(self[k], o[k]);\n        } else {\n          self[k] = o[k];\n        }\n      }\n    }\n  }\n  return self;\n};\n\n/**\n * @param {*} o\n * @return {boolean}\n * @private\n */\nfunction isArrayLike(o) {\n  var typ = typeof o === \"undefined\" ? \"undefined\" : _typeof(o);\n  if (typ != 'object' && !(typ == 'function' && typeof o.item == 'function') || o === null || typeof o.length != 'number' || o.nodeType === 3) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @param {Object} o\n * @return {boolean}\n * @private\n */\nfunction isDateLike(o) {\n  if ((typeof o === \"undefined\" ? \"undefined\" : _typeof(o)) != \"object\" || o === null || typeof o.getTime != 'function') {\n    return false;\n  }\n  return true;\n};\n\n/**\n * Note: this only seems to work for arrays.\n * @param {!Array} o\n * @return {!Array}\n * @private\n */\nfunction clone(o) {\n  // TODO(danvk): figure out how MochiKit's version works\n  var r = [];\n  for (var i = 0; i < o.length; i++) {\n    if (isArrayLike(o[i])) {\n      r.push(clone(o[i]));\n    } else {\n      r.push(o[i]);\n    }\n  }\n  return r;\n};\n\n/**\n * Create a new canvas element.\n *\n * @return {!HTMLCanvasElement}\n * @private\n */\nfunction createCanvas() {\n  return document.createElement('canvas');\n};\n\n/**\n * Returns the context's pixel ratio, which is the ratio between the device\n * pixel ratio and the backing store ratio. Typically this is 1 for conventional\n * displays, and > 1 for HiDPI displays (such as the Retina MBP).\n * See http://www.html5rocks.com/en/tutorials/canvas/hidpi/ for more details.\n *\n * @param {!CanvasRenderingContext2D} context The canvas's 2d context.\n * @return {number} The ratio of the device pixel ratio and the backing store\n * ratio for the specified context.\n */\nfunction getContextPixelRatio(context) {\n  try {\n    var devicePixelRatio = window.devicePixelRatio;\n    var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n    if (devicePixelRatio !== undefined) {\n      return devicePixelRatio / backingStoreRatio;\n    } else {\n      // At least devicePixelRatio must be defined for this ratio to make sense.\n      // We default backingStoreRatio to 1: this does not exist on some browsers\n      // (i.e. desktop Chrome).\n      return 1;\n    }\n  } catch (e) {\n    return 1;\n  }\n};\n\n/**\n * TODO(danvk): use @template here when it's better supported for classes.\n * @param {!Array} array\n * @param {number} start\n * @param {number} length\n * @param {function(!Array,?):boolean=} predicate\n * @constructor\n */\nfunction Iterator(array, start, length, predicate) {\n  start = start || 0;\n  length = length || array.length;\n  this.hasNext = true; // Use to identify if there's another element.\n  this.peek = null; // Use for look-ahead\n  this.start_ = start;\n  this.array_ = array;\n  this.predicate_ = predicate;\n  this.end_ = Math.min(array.length, start + length);\n  this.nextIdx_ = start - 1; // use -1 so initial advance works.\n  this.next(); // ignoring result.\n};\n\n/**\n * @return {Object}\n */\nIterator.prototype.next = function () {\n  if (!this.hasNext) {\n    return null;\n  }\n  var obj = this.peek;\n\n  var nextIdx = this.nextIdx_ + 1;\n  var found = false;\n  while (nextIdx < this.end_) {\n    if (!this.predicate_ || this.predicate_(this.array_, nextIdx)) {\n      this.peek = this.array_[nextIdx];\n      found = true;\n      break;\n    }\n    nextIdx++;\n  }\n  this.nextIdx_ = nextIdx;\n  if (!found) {\n    this.hasNext = false;\n    this.peek = null;\n  }\n  return obj;\n};\n\n/**\n * Returns a new iterator over array, between indexes start and\n * start + length, and only returns entries that pass the accept function\n *\n * @param {!Array} array the array to iterate over.\n * @param {number} start the first index to iterate over, 0 if absent.\n * @param {number} length the number of elements in the array to iterate over.\n *     This, along with start, defines a slice of the array, and so length\n *     doesn't imply the number of elements in the iterator when accept doesn't\n *     always accept all values. array.length when absent.\n * @param {function(?):boolean=} opt_predicate a function that takes\n *     parameters array and idx, which returns true when the element should be\n *     returned.  If omitted, all elements are accepted.\n * @private\n */\nfunction createIterator(array, start, length, opt_predicate) {\n  return new Iterator(array, start, length, opt_predicate);\n};\n\n// Shim layer with setTimeout fallback.\n// From: http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// Should be called with the window context:\n//   Dygraph.requestAnimFrame.call(window, function() {})\nvar requestAnimFrame = function () {\n  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n    window.setTimeout(callback, 1000 / 60);\n  };\n}();\n\n/**\n * Call a function at most maxFrames times at an attempted interval of\n * framePeriodInMillis, then call a cleanup function once. repeatFn is called\n * once immediately, then at most (maxFrames - 1) times asynchronously. If\n * maxFrames==1, then cleanup_fn() is also called synchronously.  This function\n * is used to sequence animation.\n * @param {function(number)} repeatFn Called repeatedly -- takes the frame\n *     number (from 0 to maxFrames-1) as an argument.\n * @param {number} maxFrames The max number of times to call repeatFn\n * @param {number} framePeriodInMillis Max requested time between frames.\n * @param {function()} cleanupFn A function to call after all repeatFn calls.\n * @private\n */\nfunction repeatAndCleanup(repeatFn, maxFrames, framePeriodInMillis, cleanupFn) {\n  var frameNumber = 0;\n  var previousFrameNumber;\n  var startTime = new Date().getTime();\n  repeatFn(frameNumber);\n  if (maxFrames == 1) {\n    cleanupFn();\n    return;\n  }\n  var maxFrameArg = maxFrames - 1;\n\n  (function loop() {\n    if (frameNumber >= maxFrames) return;\n    requestAnimFrame.call(window, function () {\n      // Determine which frame to draw based on the delay so far.  Will skip\n      // frames if necessary.\n      var currentTime = new Date().getTime();\n      var delayInMillis = currentTime - startTime;\n      previousFrameNumber = frameNumber;\n      frameNumber = Math.floor(delayInMillis / framePeriodInMillis);\n      var frameDelta = frameNumber - previousFrameNumber;\n      // If we predict that the subsequent repeatFn call will overshoot our\n      // total frame target, so our last call will cause a stutter, then jump to\n      // the last call immediately.  If we're going to cause a stutter, better\n      // to do it faster than slower.\n      var predictOvershootStutter = frameNumber + frameDelta > maxFrameArg;\n      if (predictOvershootStutter || frameNumber >= maxFrameArg) {\n        repeatFn(maxFrameArg); // Ensure final call with maxFrameArg.\n        cleanupFn();\n      } else {\n        if (frameDelta !== 0) {\n          // Don't call repeatFn with duplicate frames.\n          repeatFn(frameNumber);\n        }\n        loop();\n      }\n    });\n  })();\n};\n\n// A whitelist of options that do not change pixel positions.\nvar pixelSafeOptions = {\n  'annotationClickHandler': true,\n  'annotationDblClickHandler': true,\n  'annotationMouseOutHandler': true,\n  'annotationMouseOverHandler': true,\n  'axisLineColor': true,\n  'axisLineWidth': true,\n  'clickCallback': true,\n  'drawCallback': true,\n  'drawHighlightPointCallback': true,\n  'drawPoints': true,\n  'drawPointCallback': true,\n  'drawGrid': true,\n  'fillAlpha': true,\n  'gridLineColor': true,\n  'gridLineWidth': true,\n  'hideOverlayOnMouseOut': true,\n  'highlightCallback': true,\n  'highlightCircleSize': true,\n  'interactionModel': true,\n  'labelsDiv': true,\n  'labelsKMB': true,\n  'labelsKMG2': true,\n  'labelsSeparateLines': true,\n  'labelsShowZeroValues': true,\n  'legend': true,\n  'panEdgeFraction': true,\n  'pixelsPerYLabel': true,\n  'pointClickCallback': true,\n  'pointSize': true,\n  'rangeSelectorPlotFillColor': true,\n  'rangeSelectorPlotFillGradientColor': true,\n  'rangeSelectorPlotStrokeColor': true,\n  'rangeSelectorBackgroundStrokeColor': true,\n  'rangeSelectorBackgroundLineWidth': true,\n  'rangeSelectorPlotLineWidth': true,\n  'rangeSelectorForegroundStrokeColor': true,\n  'rangeSelectorForegroundLineWidth': true,\n  'rangeSelectorAlpha': true,\n  'showLabelsOnHighlight': true,\n  'showRoller': true,\n  'strokeWidth': true,\n  'underlayCallback': true,\n  'unhighlightCallback': true,\n  'zoomCallback': true\n};\n\n/**\n * This function will scan the option list and determine if they\n * require us to recalculate the pixel positions of each point.\n * TODO: move this into dygraph-options.js\n * @param {!Array.<string>} labels a list of options to check.\n * @param {!Object} attrs\n * @return {boolean} true if the graph needs new points else false.\n * @private\n */\nfunction isPixelChangingOptionList(labels, attrs) {\n  // Assume that we do not require new points.\n  // This will change to true if we actually do need new points.\n\n  // Create a dictionary of series names for faster lookup.\n  // If there are no labels, then the dictionary stays empty.\n  var seriesNamesDictionary = {};\n  if (labels) {\n    for (var i = 1; i < labels.length; i++) {\n      seriesNamesDictionary[labels[i]] = true;\n    }\n  }\n\n  // Scan through a flat (i.e. non-nested) object of options.\n  // Returns true/false depending on whether new points are needed.\n  var scanFlatOptions = function scanFlatOptions(options) {\n    for (var property in options) {\n      if (options.hasOwnProperty(property) && !pixelSafeOptions[property]) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // Iterate through the list of updated options.\n  for (var property in attrs) {\n    if (!attrs.hasOwnProperty(property)) continue;\n\n    // Find out of this field is actually a series specific options list.\n    if (property == 'highlightSeriesOpts' || seriesNamesDictionary[property] && !attrs.series) {\n      // This property value is a list of options for this series.\n      if (scanFlatOptions(attrs[property])) return true;\n    } else if (property == 'series' || property == 'axes') {\n      // This is twice-nested options list.\n      var perSeries = attrs[property];\n      for (var series in perSeries) {\n        if (perSeries.hasOwnProperty(series) && scanFlatOptions(perSeries[series])) {\n          return true;\n        }\n      }\n    } else {\n      // If this was not a series specific option list, check if it's a pixel\n      // changing property.\n      if (!pixelSafeOptions[property]) return true;\n    }\n  }\n\n  return false;\n};\n\nvar Circles = {\n  DEFAULT: function DEFAULT(g, name, ctx, canvasx, canvasy, color, radius) {\n    ctx.beginPath();\n    ctx.fillStyle = color;\n    ctx.arc(canvasx, canvasy, radius, 0, 2 * Math.PI, false);\n    ctx.fill();\n  }\n  // For more shapes, include extras/shapes.js\n};\n\n/**\n * Determine whether |data| is delimited by CR, CRLF, LF, LFCR.\n * @param {string} data\n * @return {?string} the delimiter that was detected (or null on failure).\n */\nfunction detectLineDelimiter(data) {\n  for (var i = 0; i < data.length; i++) {\n    var code = data.charAt(i);\n    if (code === '\\r') {\n      // Might actually be \"\\r\\n\".\n      if (i + 1 < data.length && data.charAt(i + 1) === '\\n') {\n        return '\\r\\n';\n      }\n      return code;\n    }\n    if (code === '\\n') {\n      // Might actually be \"\\n\\r\".\n      if (i + 1 < data.length && data.charAt(i + 1) === '\\r') {\n        return '\\n\\r';\n      }\n      return code;\n    }\n  }\n\n  return null;\n};\n\n/**\n * Is one node contained by another?\n * @param {Node} containee The contained node.\n * @param {Node} container The container node.\n * @return {boolean} Whether containee is inside (or equal to) container.\n * @private\n */\nfunction isNodeContainedBy(containee, container) {\n  if (container === null || containee === null) {\n    return false;\n  }\n  var containeeNode = /** @type {Node} */containee;\n  while (containeeNode && containeeNode !== container) {\n    containeeNode = containeeNode.parentNode;\n  }\n  return containeeNode === container;\n};\n\n// This masks some numeric issues in older versions of Firefox,\n// where 1.0/Math.pow(10,2) != Math.pow(10,-2).\n/** @type {function(number,number):number} */\nfunction pow(base, exp) {\n  if (exp < 0) {\n    return 1.0 / Math.pow(base, -exp);\n  }\n  return Math.pow(base, exp);\n};\n\nvar RGBA_RE = /^rgba?\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})(?:,\\s*([01](?:\\.\\d+)?))?\\)$/;\n\n/**\n * Helper for toRGB_ which parses strings of the form:\n * rgb(123, 45, 67)\n * rgba(123, 45, 67, 0.5)\n * @return parsed {r,g,b,a?} tuple or null.\n */\nfunction parseRGBA(rgbStr) {\n  var bits = RGBA_RE.exec(rgbStr);\n  if (!bits) return null;\n  var r = parseInt(bits[1], 10),\n      g = parseInt(bits[2], 10),\n      b = parseInt(bits[3], 10);\n  if (bits[4]) {\n    return { r: r, g: g, b: b, a: parseFloat(bits[4]) };\n  } else {\n    return { r: r, g: g, b: b };\n  }\n}\n\n/**\n * Converts any valid CSS color (hex, rgb(), named color) to an RGB tuple.\n *\n * @param {!string} colorStr Any valid CSS color string.\n * @return {{r:number,g:number,b:number,a:number?}} Parsed RGB tuple.\n * @private\n */\nfunction toRGB_(colorStr) {\n  // Strategy: First try to parse colorStr directly. This is fast & avoids DOM\n  // manipulation.  If that fails (e.g. for named colors like 'red'), then\n  // create a hidden DOM element and parse its computed color.\n  var rgb = parseRGBA(colorStr);\n  if (rgb) return rgb;\n\n  var div = document.createElement('div');\n  div.style.backgroundColor = colorStr;\n  div.style.visibility = 'hidden';\n  document.body.appendChild(div);\n  var rgbStr = window.getComputedStyle(div, null).backgroundColor;\n  document.body.removeChild(div);\n  return parseRGBA(rgbStr);\n};\n\n/**\n * Checks whether the browser supports the &lt;canvas&gt; tag.\n * @param {HTMLCanvasElement=} opt_canvasElement Pass a canvas element as an\n *     optimization if you have one.\n * @return {boolean} Whether the browser supports canvas.\n */\nfunction isCanvasSupported(opt_canvasElement) {\n  try {\n    var canvas = opt_canvasElement || document.createElement(\"canvas\");\n    canvas.getContext(\"2d\");\n  } catch (e) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * Parses the value as a floating point number. This is like the parseFloat()\n * built-in, but with a few differences:\n * - the empty string is parsed as null, rather than NaN.\n * - if the string cannot be parsed at all, an error is logged.\n * If the string can't be parsed, this method returns null.\n * @param {string} x The string to be parsed\n * @param {number=} opt_line_no The line number from which the string comes.\n * @param {string=} opt_line The text of the line from which the string comes.\n */\nfunction parseFloat_(x, opt_line_no, opt_line) {\n  var val = parseFloat(x);\n  if (!isNaN(val)) return val;\n\n  // Try to figure out what happeend.\n  // If the value is the empty string, parse it as null.\n  if (/^ *$/.test(x)) return null;\n\n  // If it was actually \"NaN\", return it as NaN.\n  if (/^ *nan *$/i.test(x)) return NaN;\n\n  // Looks like a parsing error.\n  var msg = \"Unable to parse '\" + x + \"' as a number\";\n  if (opt_line !== undefined && opt_line_no !== undefined) {\n    msg += \" on line \" + (1 + (opt_line_no || 0)) + \" ('\" + opt_line + \"') of CSV.\";\n  }\n  console.error(msg);\n\n  return null;\n};\n\n// Label constants for the labelsKMB and labelsKMG2 options.\n// (i.e. '100000' -> '100K')\nvar KMB_LABELS = ['K', 'M', 'B', 'T', 'Q'];\nvar KMG2_BIG_LABELS = ['k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];\nvar KMG2_SMALL_LABELS = ['m', 'u', 'n', 'p', 'f', 'a', 'z', 'y'];\n\n/**\n * @private\n * Return a string version of a number. This respects the digitsAfterDecimal\n * and maxNumberWidth options.\n * @param {number} x The number to be formatted\n * @param {Dygraph} opts An options view\n */\nfunction numberValueFormatter(x, opts) {\n  var sigFigs = opts('sigFigs');\n\n  if (sigFigs !== null) {\n    // User has opted for a fixed number of significant figures.\n    return floatFormat(x, sigFigs);\n  }\n\n  var digits = opts('digitsAfterDecimal');\n  var maxNumberWidth = opts('maxNumberWidth');\n\n  var kmb = opts('labelsKMB');\n  var kmg2 = opts('labelsKMG2');\n\n  var label;\n\n  // switch to scientific notation if we underflow or overflow fixed display.\n  if (x !== 0.0 && (Math.abs(x) >= Math.pow(10, maxNumberWidth) || Math.abs(x) < Math.pow(10, -digits))) {\n    label = x.toExponential(digits);\n  } else {\n    label = '' + round_(x, digits);\n  }\n\n  if (kmb || kmg2) {\n    var k;\n    var k_labels = [];\n    var m_labels = [];\n    if (kmb) {\n      k = 1000;\n      k_labels = KMB_LABELS;\n    }\n    if (kmg2) {\n      if (kmb) console.warn(\"Setting both labelsKMB and labelsKMG2. Pick one!\");\n      k = 1024;\n      k_labels = KMG2_BIG_LABELS;\n      m_labels = KMG2_SMALL_LABELS;\n    }\n\n    var absx = Math.abs(x);\n    var n = pow(k, k_labels.length);\n    for (var j = k_labels.length - 1; j >= 0; j--, n /= k) {\n      if (absx >= n) {\n        label = round_(x / n, digits) + k_labels[j];\n        break;\n      }\n    }\n    if (kmg2) {\n      // TODO(danvk): clean up this logic. Why so different than kmb?\n      var x_parts = String(x.toExponential()).split('e-');\n      if (x_parts.length === 2 && x_parts[1] >= 3 && x_parts[1] <= 24) {\n        if (x_parts[1] % 3 > 0) {\n          label = round_(x_parts[0] / pow(10, x_parts[1] % 3), digits);\n        } else {\n          label = Number(x_parts[0]).toFixed(2);\n        }\n        label += m_labels[Math.floor(x_parts[1] / 3) - 1];\n      }\n    }\n  }\n\n  return label;\n};\n\n/**\n * variant for use as an axisLabelFormatter.\n * @private\n */\nfunction numberAxisLabelFormatter(x, granularity, opts) {\n  return numberValueFormatter.call(this, x, opts);\n};\n\n/**\n * @type {!Array.<string>}\n * @private\n * @constant\n */\nvar SHORT_MONTH_NAMES_ = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\n/**\n * Convert a JS date to a string appropriate to display on an axis that\n * is displaying values at the stated granularity. This respects the\n * labelsUTC option.\n * @param {Date} date The date to format\n * @param {number} granularity One of the Dygraph granularity constants\n * @param {Dygraph} opts An options view\n * @return {string} The date formatted as local time\n * @private\n */\nfunction dateAxisLabelFormatter(date, granularity, opts) {\n  var utc = opts('labelsUTC');\n  var accessors = utc ? DateAccessorsUTC : DateAccessorsLocal;\n\n  var year = accessors.getFullYear(date),\n      month = accessors.getMonth(date),\n      day = accessors.getDate(date),\n      hours = accessors.getHours(date),\n      mins = accessors.getMinutes(date),\n      secs = accessors.getSeconds(date),\n      millis = accessors.getMilliseconds(date);\n\n  if (granularity >= __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__[\"d\" /* Granularity */].DECADAL) {\n    return '' + year;\n  } else if (granularity >= __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__[\"d\" /* Granularity */].MONTHLY) {\n    return SHORT_MONTH_NAMES_[month] + '&#160;' + year;\n  } else {\n    var frac = hours * 3600 + mins * 60 + secs + 1e-3 * millis;\n    if (frac === 0 || granularity >= __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__[\"d\" /* Granularity */].DAILY) {\n      // e.g. '21 Jan' (%d%b)\n      return zeropad(day) + '&#160;' + SHORT_MONTH_NAMES_[month];\n    } else if (granularity < __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__[\"d\" /* Granularity */].SECONDLY) {\n      // e.g. 40.310 (meaning 40 seconds and 310 milliseconds)\n      var str = \"\" + millis;\n      return zeropad(secs) + \".\" + ('000' + str).substring(str.length);\n    } else if (granularity > __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__[\"d\" /* Granularity */].MINUTELY) {\n      return hmsString_(hours, mins, secs, 0);\n    } else {\n      return hmsString_(hours, mins, secs, millis);\n    }\n  }\n};\n// alias in case anyone is referencing the old method.\n// Dygraph.dateAxisFormatter = Dygraph.dateAxisLabelFormatter;\n\n/**\n * Return a string version of a JS date for a value label. This respects the\n * labelsUTC option.\n * @param {Date} date The date to be formatted\n * @param {Dygraph} opts An options view\n * @private\n */\nfunction dateValueFormatter(d, opts) {\n  return dateString_(d, opts('labelsUTC'));\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLXV0aWxzLmpzPzllM2MiXSwibmFtZXMiOlsiTE9HX1NDQUxFIiwiTE5fVEVOIiwiTWF0aCIsImxvZyIsImxvZzEwIiwieCIsImxvZ1JhbmdlRnJhY3Rpb24iLCJyMCIsInIxIiwicGN0IiwibG9ncjAiLCJsb2dyMSIsImV4cG9uZW50IiwidmFsdWUiLCJwb3ciLCJET1RURURfTElORSIsIkRBU0hFRF9MSU5FIiwiRE9UX0RBU0hfTElORSIsIkhPUklaT05UQUwiLCJWRVJUSUNBTCIsImdldENvbnRleHQiLCJjYW52YXMiLCJhZGRFdmVudCIsImVsZW0iLCJ0eXBlIiwiZm4iLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FuY2VsRXZlbnQiLCJlIiwid2luZG93IiwiZXZlbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsImNhbmNlbEJ1YmJsZSIsImNhbmNlbCIsInJldHVyblZhbHVlIiwiaHN2VG9SR0IiLCJodWUiLCJzYXR1cmF0aW9uIiwicmVkIiwiZ3JlZW4iLCJibHVlIiwiaSIsImZsb29yIiwiZiIsInAiLCJxIiwidCIsImZpbmRQb3MiLCJvYmoiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3IiwiZCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwibGVmdCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsTGVmdCIsInkiLCJ0b3AiLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsInBhZ2VYIiwicGFnZVkiLCJkcmFnR2V0WF8iLCJjb250ZXh0IiwicHgiLCJkcmFnR2V0WV8iLCJweSIsImlzT0siLCJpc05hTiIsImlzVmFsaWRQb2ludCIsIm9wdF9hbGxvd05hTlkiLCJ5dmFsIiwidW5kZWZpbmVkIiwiZmxvYXRGb3JtYXQiLCJvcHRfcHJlY2lzaW9uIiwibWluIiwibWF4IiwiYWJzIiwidG9FeHBvbmVudGlhbCIsInRvUHJlY2lzaW9uIiwiemVyb3BhZCIsIkRhdGVBY2Nlc3NvcnNMb2NhbCIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsImdldERheSIsIm1ha2VEYXRlIiwibSIsImhoIiwibW0iLCJzcyIsIm1zIiwiRGF0ZSIsIkRhdGVBY2Nlc3NvcnNVVEMiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJnZXRVVENNaWxsaXNlY29uZHMiLCJnZXRVVENEYXkiLCJVVEMiLCJobXNTdHJpbmdfIiwicmV0Iiwic3RyIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiZGF0ZVN0cmluZ18iLCJ0aW1lIiwidXRjIiwiYWNjZXNzb3JzIiwiZGF0ZSIsInllYXIiLCJtb250aCIsImRheSIsImZyYWMiLCJyb3VuZF8iLCJudW0iLCJwbGFjZXMiLCJzaGlmdCIsInJvdW5kIiwiYmluYXJ5U2VhcmNoIiwidmFsIiwiYXJyeSIsImxvdyIsImhpZ2giLCJ2YWxpZEluZGV4IiwiaWR4IiwibWlkIiwicGFyc2VJbnQiLCJlbGVtZW50IiwiZGF0ZVBhcnNlciIsImRhdGVTdHIiLCJkYXRlU3RyU2xhc2hlZCIsInNlYXJjaCIsImRhdGVTdHJUb01pbGxpcyIsInJlcGxhY2UiLCJzdWJzdHIiLCJjb25zb2xlIiwiZXJyb3IiLCJnZXRUaW1lIiwidXBkYXRlIiwic2VsZiIsIm8iLCJrIiwiaGFzT3duUHJvcGVydHkiLCJ1cGRhdGVEZWVwIiwiaXNOb2RlIiwiTm9kZSIsIm5vZGVUeXBlIiwibm9kZU5hbWUiLCJpc0FycmF5TGlrZSIsInNsaWNlIiwidHlwIiwiaXRlbSIsImlzRGF0ZUxpa2UiLCJjbG9uZSIsInIiLCJwdXNoIiwiY3JlYXRlQ2FudmFzIiwiY3JlYXRlRWxlbWVudCIsImdldENvbnRleHRQaXhlbFJhdGlvIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImJhY2tpbmdTdG9yZVJhdGlvIiwid2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsIm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJtc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJvQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsImJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJJdGVyYXRvciIsImFycmF5Iiwic3RhcnQiLCJwcmVkaWNhdGUiLCJoYXNOZXh0IiwicGVlayIsInN0YXJ0XyIsImFycmF5XyIsInByZWRpY2F0ZV8iLCJlbmRfIiwibmV4dElkeF8iLCJuZXh0IiwicHJvdG90eXBlIiwibmV4dElkeCIsImZvdW5kIiwiY3JlYXRlSXRlcmF0b3IiLCJvcHRfcHJlZGljYXRlIiwicmVxdWVzdEFuaW1GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbGxiYWNrIiwic2V0VGltZW91dCIsInJlcGVhdEFuZENsZWFudXAiLCJyZXBlYXRGbiIsIm1heEZyYW1lcyIsImZyYW1lUGVyaW9kSW5NaWxsaXMiLCJjbGVhbnVwRm4iLCJmcmFtZU51bWJlciIsInByZXZpb3VzRnJhbWVOdW1iZXIiLCJzdGFydFRpbWUiLCJtYXhGcmFtZUFyZyIsImxvb3AiLCJjYWxsIiwiY3VycmVudFRpbWUiLCJkZWxheUluTWlsbGlzIiwiZnJhbWVEZWx0YSIsInByZWRpY3RPdmVyc2hvb3RTdHV0dGVyIiwicGl4ZWxTYWZlT3B0aW9ucyIsImlzUGl4ZWxDaGFuZ2luZ09wdGlvbkxpc3QiLCJsYWJlbHMiLCJhdHRycyIsInNlcmllc05hbWVzRGljdGlvbmFyeSIsInNjYW5GbGF0T3B0aW9ucyIsIm9wdGlvbnMiLCJwcm9wZXJ0eSIsInNlcmllcyIsInBlclNlcmllcyIsIkNpcmNsZXMiLCJERUZBVUxUIiwiZyIsIm5hbWUiLCJjdHgiLCJjYW52YXN4IiwiY2FudmFzeSIsImNvbG9yIiwicmFkaXVzIiwiYmVnaW5QYXRoIiwiZmlsbFN0eWxlIiwiYXJjIiwiUEkiLCJmaWxsIiwiZGV0ZWN0TGluZURlbGltaXRlciIsImRhdGEiLCJjb2RlIiwiY2hhckF0IiwiaXNOb2RlQ29udGFpbmVkQnkiLCJjb250YWluZWUiLCJjb250YWluZXIiLCJjb250YWluZWVOb2RlIiwicGFyZW50Tm9kZSIsImJhc2UiLCJleHAiLCJSR0JBX1JFIiwicGFyc2VSR0JBIiwicmdiU3RyIiwiYml0cyIsImV4ZWMiLCJiIiwiYSIsInBhcnNlRmxvYXQiLCJ0b1JHQl8iLCJjb2xvclN0ciIsInJnYiIsImRpdiIsInN0eWxlIiwiYmFja2dyb3VuZENvbG9yIiwidmlzaWJpbGl0eSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImdldENvbXB1dGVkU3R5bGUiLCJyZW1vdmVDaGlsZCIsImlzQ2FudmFzU3VwcG9ydGVkIiwib3B0X2NhbnZhc0VsZW1lbnQiLCJwYXJzZUZsb2F0XyIsIm9wdF9saW5lX25vIiwib3B0X2xpbmUiLCJ0ZXN0IiwiTmFOIiwibXNnIiwiS01CX0xBQkVMUyIsIktNRzJfQklHX0xBQkVMUyIsIktNRzJfU01BTExfTEFCRUxTIiwibnVtYmVyVmFsdWVGb3JtYXR0ZXIiLCJvcHRzIiwic2lnRmlncyIsImRpZ2l0cyIsIm1heE51bWJlcldpZHRoIiwia21iIiwia21nMiIsImxhYmVsIiwia19sYWJlbHMiLCJtX2xhYmVscyIsIndhcm4iLCJhYnN4IiwibiIsImoiLCJ4X3BhcnRzIiwiU3RyaW5nIiwic3BsaXQiLCJOdW1iZXIiLCJ0b0ZpeGVkIiwibnVtYmVyQXhpc0xhYmVsRm9ybWF0dGVyIiwiZ3JhbnVsYXJpdHkiLCJTSE9SVF9NT05USF9OQU1FU18iLCJkYXRlQXhpc0xhYmVsRm9ybWF0dGVyIiwiaG91cnMiLCJtaW5zIiwic2VjcyIsIm1pbGxpcyIsIkRFQ0FEQUwiLCJNT05USExZIiwiREFJTFkiLCJTRUNPTkRMWSIsIk1JTlVURUxZIiwiZGF0ZVZhbHVlRm9ybWF0dGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBOzs7Ozs7QUFNQTs7Ozs7OztBQU9BO0FBQ0E7Ozs7QUFFQTs7QUFFTyxJQUFJQSxZQUFZLEVBQWhCO0FBQ0EsSUFBSUMsU0FBU0MsS0FBS0MsR0FBTCxDQUFTSCxTQUFULENBQWI7O0FBRVA7Ozs7O0FBS08sSUFBSUksUUFBUSxTQUFSQSxLQUFRLENBQVNDLENBQVQsRUFBWTtBQUM3QixTQUFPSCxLQUFLQyxHQUFMLENBQVNFLENBQVQsSUFBY0osTUFBckI7QUFDRCxDQUZNOztBQUlQOzs7Ozs7O0FBT08sSUFBSUssbUJBQW1CLFNBQW5CQSxnQkFBbUIsQ0FBU0MsRUFBVCxFQUFhQyxFQUFiLEVBQWlCQyxHQUFqQixFQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUlDLFFBQVFOLE1BQU1HLEVBQU4sQ0FBWjtBQUNBLE1BQUlJLFFBQVFQLE1BQU1JLEVBQU4sQ0FBWjtBQUNBLE1BQUlJLFdBQVdGLFFBQVNELE9BQU9FLFFBQVFELEtBQWYsQ0FBeEI7QUFDQSxNQUFJRyxRQUFRWCxLQUFLWSxHQUFMLENBQVNkLFNBQVQsRUFBb0JZLFFBQXBCLENBQVo7QUFDQSxTQUFPQyxLQUFQO0FBQ0QsQ0F4Qk07O0FBMEJQO0FBQ08sSUFBSUUsY0FBYyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQWxCO0FBQ1A7QUFDTyxJQUFJQyxjQUFjLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBbEI7QUFDUDtBQUNPLElBQUlDLGdCQUFnQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBcEI7O0FBRVA7QUFDQTtBQUNPLElB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QixFQUE4QixDQUE5QixDQUFQO0FBQ0QsS0FGTSxNQUVBO0FBQ0wsYUFBT3JNLFdBQVdtTSxLQUFYLEVBQWtCQyxJQUFsQixFQUF3QkMsSUFBeEIsRUFBOEJDLE1BQTlCLENBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRDtBQUNBOztBQUVBOzs7Ozs7O0FBT08sU0FBU00sa0JBQVQsQ0FBNEJyUSxDQUE1QixFQUErQnNPLElBQS9CLEVBQXFDO0FBQzFDLFNBQU94SyxZQUFZOUQsQ0FBWixFQUFlc08sS0FBSyxXQUFMLENBQWYsQ0FBUDtBQUNEIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMSBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIGZpbGUgY29udGFpbnMgdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCBieSBkeWdyYXBocy4gVGhlc2VcbiAqIGFyZSB0eXBpY2FsbHkgc3RhdGljIChpLmUuIG5vdCByZWxhdGVkIHRvIGFueSBwYXJ0aWN1bGFyIGR5Z3JhcGgpLiBFeGFtcGxlc1xuICogaW5jbHVkZSBkYXRlL3RpbWUgZm9ybWF0dGluZyBmdW5jdGlvbnMsIGJhc2ljIGFsZ29yaXRobXMgKGUuZy4gYmluYXJ5XG4gKiBzZWFyY2gpIGFuZCBnZW5lcmljIERPTS1tYW5pcHVsYXRpb24gZnVuY3Rpb25zLlxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UsIE5vZGU6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgKiBhcyBEeWdyYXBoVGlja2VycyBmcm9tICcuL2R5Z3JhcGgtdGlja2Vycyc7XG5cbmV4cG9ydCB2YXIgTE9HX1NDQUxFID0gMTA7XG5leHBvcnQgdmFyIExOX1RFTiA9IE1hdGgubG9nKExPR19TQ0FMRSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgbG9nMTAgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBNYXRoLmxvZyh4KSAvIExOX1RFTjtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByMFxuICogQHBhcmFtIHtudW1iZXJ9IHIxXG4gKiBAcGFyYW0ge251bWJlcn0gcGN0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgbG9nUmFuZ2VGcmFjdGlvbiA9IGZ1bmN0aW9uKHIwLCByMSwgcGN0KSB7XG4gIC8vIENvbXB1dGluZyB0aGUgaW52ZXJzZSBvZiB0b1BlcmNlbnRYQ29vcmQuIFRoZSBmdW5jdGlvbiB3YXMgYXJyaXZlZCBhdCB3aXRoXG4gIC8vIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gIC8vXG4gIC8vIE9yaWdpbmFsIGNhbGN1YXRpb246XG4gIC8vIHBjdCA9IChsb2coeCkgLSBsb2coeFJhbmdlWzBdKSkgLyAobG9nKHhSYW5nZVsxXSkgLSBsb2coeFJhbmdlWzBdKSkpO1xuICAvL1xuICAvLyBNdWx0aXBseSBib3RoIHNpZGVzIGJ5IHRoZSByaWdodC1zaWRlIGRlbm9taW5hdG9yLlxuICAvLyBwY3QgKiAobG9nKHhSYW5nZVsxXSAtIGxvZyh4UmFuZ2VbMF0pKSkgPSBsb2coeCkgLSBsb2coeFJhbmdlWzBdKVxuICAvL1xuICAvLyBhZGQgbG9nKHhSYW5nZVswXSkgdG8gYm90aCBzaWRlc1xuICAvLyBsb2coeFJhbmdlWzBdKSArIChwY3QgKiAobG9nKHhSYW5nZVsxXSkgLSBsb2coeFJhbmdlWzBdKSkgPSBsb2coeCk7XG4gIC8vXG4gIC8vIFN3YXAgYm90aCBzaWRlcyBvZiB0aGUgZXF1YXRpb24sXG4gIC8vIGxvZyh4KSA9IGxvZyh4UmFuZ2VbMF0pICsgKHBjdCAqIChsb2coeFJhbmdlWzFdKSAtIGxvZyh4UmFuZ2VbMF0pKVxuICAvL1xuICAvLyBVc2UgYm90aCBzaWRlcyBhcyB0aGUgZXhwb25lbnQgaW4gMTBeZXhwIGFuZCB3ZSdyZSBkb25lLlxuICAvLyB4ID0gMTAgXiAobG9nKHhSYW5nZVswXSkgKyAocGN0ICogKGxvZyh4UmFuZ2VbMV0pIC0gbG9nKHhSYW5nZVswXSkpKVxuXG4gIHZhciBsb2dyMCA9IGxvZzEwKHIwKTtcbiAgdmFyIGxvZ3IxID0gbG9nMTAocjEpO1xuICB2YXIgZXhwb25lbnQgPSBsb2dyMCArIChwY3QgKiAobG9ncjEgLSBsb2dyMCkpO1xuICB2YXIgdmFsdWUgPSBNYXRoLnBvdyhMT0dfU0NBTEUsIGV4cG9uZW50KTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqIEEgZG90dGVkIGxpbmUgc3Ryb2tlIHBhdHRlcm4uICovXG5leHBvcnQgdmFyIERPVFRFRF9MSU5FID0gWzIsIDJdO1xuLyoqIEEgZGFzaGVkIGxpbmUgc3Ryb2tlIHBhdHRlcm4uICovXG5leHBvcnQgdmFyIERBU0hFRF9MSU5FID0gWzcsIDNdO1xuLyoqIEEgZG90IGRhc2ggc3Ryb2tlIHBhdHRlcm4uICovXG5leHBvcnQgdmFyIERPVF9EQVNIX0xJTkUgPSBbNywgMiwgMiwgMl07XG5cbi8vIERpcmVjdGlvbnMgZm9yIHBhbm5pbmcgYW5kIHpvb21pbmcuIFVzZSBiaXQgb3BlcmF0aW9ucyB3aGVuIGNvbWJpbmVkXG4vLyB2YWx1ZXMgYXJlIHBvc3NpYmxlLlxuZXhwb3J0IHZhciBIT1JJWk9OVEFMID0gMTtcbmV4cG9ydCB2YXIgVkVSVElDQUwgPSAyO1xuXG4vKipcbiAqIFJldHVybiB0aGUgMmQgY29udGV4dCBmb3IgYSBkeWdyYXBoIGNhbnZhcy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBvbmx5IGV4cG9zZWQgZm9yIHRoZSBzYWtlIG9mIHJlcGxhY2luZyB0aGUgZnVuY3Rpb24gaW5cbiAqIGF1dG9tYXRlZCB0ZXN0cy5cbiAqXG4gKiBAcGFyYW0geyFIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gKiBAcmV0dXJuIHshQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IHZhciBnZXRDb250ZXh0ID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gIHJldHVybiAvKiogQHR5cGV7IUNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0qLyhjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpKTtcbn07XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGhhbmRsZXIuXG4gKiBAcGFyYW0geyFOb2RlfSBlbGVtIFRoZSBlbGVtZW50IHRvIGFkZCB0aGUgZXZlbnQgdG8uXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2Vtb3ZlJy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnQpOihib29sZWFufHVuZGVmaW5lZCl9IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsXG4gKiAgICAgb24gdGhlIGV2ZW50LiBUaGUgZnVuY3Rpb24gdGFrZXMgb25lIHBhcmFtZXRlcjogdGhlIGV2ZW50IG9iamVjdC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCB2YXIgYWRkRXZlbnQgPSBmdW5jdGlvbiBhZGRFdmVudChlbGVtLCB0eXBlLCBmbikge1xuICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGZhbHNlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXIuXG4gKiBAcGFyYW0geyFOb2RlfSBlbGVtIFRoZSBlbGVtZW50IHRvIHJlbW92ZSB0aGUgZXZlbnQgZnJvbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBldmVudCwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW1vdmUnLlxuICogQHBhcmFtIHtmdW5jdGlvbihFdmVudCk6KGJvb2xlYW58dW5kZWZpbmVkKX0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGxcbiAqICAgICBvbiB0aGUgZXZlbnQuIFRoZSBmdW5jdGlvbiB0YWtlcyBvbmUgcGFyYW1ldGVyOiB0aGUgZXZlbnQgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZWxlbSwgdHlwZSwgZm4pIHtcbiAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIENhbmNlbHMgZnVydGhlciBwcm9jZXNzaW5nIG9mIGFuIGV2ZW50LiBUaGlzIGlzIHVzZWZ1bCB0byBwcmV2ZW50IGRlZmF1bHRcbiAqIGJyb3dzZXIgYWN0aW9ucywgZS5nLiBoaWdobGlnaHRpbmcgdGV4dCBvbiBhIGRvdWJsZS1jbGljay5cbiAqIEJhc2VkIG9uIHRoZSBhcnRpY2xlIGF0XG4gKiBodHRwOi8vd3d3LnN3aXRjaG9udGhlY29kZS5jb20vdHV0b3JpYWxzL2phdmFzY3JpcHQtdHV0b3JpYWwtdGhlLXNjcm9sbC13aGVlbFxuICogQHBhcmFtIHshRXZlbnR9IGUgVGhlIGV2ZW50IHdob3NlIG5vcm1hbCBiZWhhdmlvciBzaG91bGQgYmUgY2FuY2VsZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FuY2VsRXZlbnQoZSkge1xuICBlID0gZSA/IGUgOiB3aW5kb3cuZXZlbnQ7XG4gIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICBlLmNhbmNlbCA9IHRydWU7XG4gIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGhzdiB2YWx1ZXMgdG8gYW4gcmdiKHIsZyxiKSBzdHJpbmcuIFRha2VuIGZyb20gTW9jaGlLaXQuQ29sb3IuIFRoaXNcbiAqIGlzIHVzZWQgdG8gZ2VuZXJhdGUgZGVmYXVsdCBzZXJpZXMgY29sb3JzIHdoaWNoIGFyZSBldmVubHkgc3BhY2VkIG9uIHRoZVxuICogY29sb3Igd2hlZWwuXG4gKiBAcGFyYW0geyBudW1iZXIgfSBodWUgUmFuZ2UgaXMgMC4wLTEuMC5cbiAqIEBwYXJhbSB7IG51bWJlciB9IHNhdHVyYXRpb24gUmFuZ2UgaXMgMC4wLTEuMC5cbiAqIEBwYXJhbSB7IG51bWJlciB9IHZhbHVlIFJhbmdlIGlzIDAuMC0xLjAuXG4gKiBAcmV0dXJuIHsgc3RyaW5nIH0gXCJyZ2IocixnLGIpXCIgd2hlcmUgciwgZyBhbmQgYiByYW5nZSBmcm9tIDAtMjU1LlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhzdlRvUkdCKGh1ZSwgc2F0dXJhdGlvbiwgdmFsdWUpIHtcbiAgdmFyIHJlZDtcbiAgdmFyIGdyZWVuO1xuICB2YXIgYmx1ZTtcbiAgaWYgKHNhdHVyYXRpb24gPT09IDApIHtcbiAgICByZWQgPSB2YWx1ZTtcbiAgICBncmVlbiA9IHZhbHVlO1xuICAgIGJsdWUgPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoaHVlICogNik7XG4gICAgdmFyIGYgPSAoaHVlICogNikgLSBpO1xuICAgIHZhciBwID0gdmFsdWUgKiAoMSAtIHNhdHVyYXRpb24pO1xuICAgIHZhciBxID0gdmFsdWUgKiAoMSAtIChzYXR1cmF0aW9uICogZikpO1xuICAgIHZhciB0ID0gdmFsdWUgKiAoMSAtIChzYXR1cmF0aW9uICogKDEgLSBmKSkpO1xuICAgIHN3aXRjaCAoaSkge1xuICAgICAgY2FzZSAxOiByZWQgPSBxOyBncmVlbiA9IHZhbHVlOyBibHVlID0gcDsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHJlZCA9IHA7IGdyZWVuID0gdmFsdWU7IGJsdWUgPSB0OyBicmVhaztcbiAgICAgIGNhc2UgMzogcmVkID0gcDsgZ3JlZW4gPSBxOyBibHVlID0gdmFsdWU7IGJyZWFrO1xuICAgICAgY2FzZSA0OiByZWQgPSB0OyBncmVlbiA9IHA7IGJsdWUgPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlIDU6IHJlZCA9IHZhbHVlOyBncmVlbiA9IHA7IGJsdWUgPSBxOyBicmVhaztcbiAgICAgIGNhc2UgNjogLy8gZmFsbCB0aHJvdWdoXG4gICAgICBjYXNlIDA6IHJlZCA9IHZhbHVlOyBncmVlbiA9IHQ7IGJsdWUgPSBwOyBicmVhaztcbiAgICB9XG4gIH1cbiAgcmVkID0gTWF0aC5mbG9vcigyNTUgKiByZWQgKyAwLjUpO1xuICBncmVlbiA9IE1hdGguZmxvb3IoMjU1ICogZ3JlZW4gKyAwLjUpO1xuICBibHVlID0gTWF0aC5mbG9vcigyNTUgKiBibHVlICsgMC41KTtcbiAgcmV0dXJuICdyZ2IoJyArIHJlZCArICcsJyArIGdyZWVuICsgJywnICsgYmx1ZSArICcpJztcbn07XG5cbi8qKlxuICogRmluZCB0aGUgY29vcmRpbmF0ZXMgb2YgYW4gb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSB0b3AgbGVmdCBvZiB0aGUgcGFnZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG9ialxuICogQHJldHVybiB7e3g6bnVtYmVyLHk6bnVtYmVyfX1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUG9zKG9iaikge1xuICB2YXIgcCA9IG9iai5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHcgPSB3aW5kb3csXG4gICAgICBkID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gIHJldHVybiB7XG4gICAgeDogcC5sZWZ0ICsgKHcucGFnZVhPZmZzZXQgfHwgZC5zY3JvbGxMZWZ0KSxcbiAgICB5OiBwLnRvcCAgKyAody5wYWdlWU9mZnNldCB8fCBkLnNjcm9sbFRvcClcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IGluIGEgY29vcmRpbmF0ZSBzeXN0ZW0gd2hlcmUgdGhlXG4gKiB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIHBhZ2UgKG5vdCB0aGUgd2luZG93KSBpcyAoMCwwKS5cbiAqIFRha2VuIGZyb20gTW9jaGlLaXQuU2lnbmFsXG4gKiBAcGFyYW0geyFFdmVudH0gZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZ2VYKGUpIHtcbiAgcmV0dXJuICghZS5wYWdlWCB8fCBlLnBhZ2VYIDwgMCkgPyAwIDogZS5wYWdlWDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgeS1jb29yZGluYXRlIG9mIHRoZSBldmVudCBpbiBhIGNvb3JkaW5hdGUgc3lzdGVtIHdoZXJlIHRoZVxuICogdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBwYWdlIChub3QgdGhlIHdpbmRvdykgaXMgKDAsMCkuXG4gKiBUYWtlbiBmcm9tIE1vY2hpS2l0LlNpZ25hbFxuICogQHBhcmFtIHshRXZlbnR9IGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWdlWShlKSB7XG4gIHJldHVybiAoIWUucGFnZVkgfHwgZS5wYWdlWSA8IDApID8gMCA6IGUucGFnZVk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHBhZ2UgdGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgdG8gcGl4ZWwgeC1jb29yZGluYXRlcyBvbiB0aGVcbiAqIGNhbnZhcyAoaS5lLiBET00gQ29vcmRzKS5cbiAqIEBwYXJhbSB7IUV2ZW50fSBlIERyYWcgZXZlbnQuXG4gKiBAcGFyYW0geyFEeWdyYXBoSW50ZXJhY3Rpb25Db250ZXh0fSBjb250ZXh0IEludGVyYWN0aW9uIGNvbnRleHQgb2JqZWN0LlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW1vdW50IGJ5IHdoaWNoIHRoZSBkcmFnIGhhcyBtb3ZlZCB0byB0aGUgcmlnaHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkcmFnR2V0WF8oZSwgY29udGV4dCkge1xuICByZXR1cm4gcGFnZVgoZSkgLSBjb250ZXh0LnB4O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBwYWdlIHRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IHRvIHBpeGVsIHktY29vcmRpbmF0ZXMgb24gdGhlXG4gKiBjYW52YXMgKGkuZS4gRE9NIENvb3JkcykuXG4gKiBAcGFyYW0geyFFdmVudH0gZSBEcmFnIGV2ZW50LlxuICogQHBhcmFtIHshRHlncmFwaEludGVyYWN0aW9uQ29udGV4dH0gY29udGV4dCBJbnRlcmFjdGlvbiBjb250ZXh0IG9iamVjdC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFtb3VudCBieSB3aGljaCB0aGUgZHJhZyBoYXMgbW92ZWQgZG93bi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRyYWdHZXRZXyhlLCBjb250ZXh0KSB7XG4gIHJldHVybiBwYWdlWShlKSAtIGNvbnRleHQucHk7XG59O1xuXG4vKipcbiAqIFRoaXMgcmV0dXJucyB0cnVlIHVubGVzcyB0aGUgcGFyYW1ldGVyIGlzIDAsIG51bGwsIHVuZGVmaW5lZCBvciBOYU4uXG4gKiBUT0RPKGRhbnZrKTogcmVuYW1lIHRoaXMgZnVuY3Rpb24gdG8gc29tZXRoaW5nIGxpa2UgJ2lzTm9uWmVyb05hbicuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIG51bWJlciB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIG51bWJlciBpcyB6ZXJvIG9yIE5hTi5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09LKHgpIHtcbiAgcmV0dXJuICEheCAmJiAhaXNOYU4oeCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7e3g6P251bWJlcix5Oj9udW1iZXIseXZhbDo/bnVtYmVyfX0gcCBUaGUgcG9pbnQgdG8gY29uc2lkZXIsIHZhbGlkXG4gKiAgICAgcG9pbnRzIGFyZSB7eCwgeX0gb2JqZWN0c1xuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2FsbG93TmFOWSBUcmVhdCBwb2ludCB3aXRoIHk9TmFOIGFzIHZhbGlkXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwb2ludCBoYXMgbnVtZXJpYyB4IGFuZCB5LlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRQb2ludChwLCBvcHRfYWxsb3dOYU5ZKSB7XG4gIGlmICghcCkgcmV0dXJuIGZhbHNlOyAgLy8gbnVsbCBvciB1bmRlZmluZWQgb2JqZWN0XG4gIGlmIChwLnl2YWwgPT09IG51bGwpIHJldHVybiBmYWxzZTsgIC8vIG1pc3NpbmcgcG9pbnRcbiAgaWYgKHAueCA9PT0gbnVsbCB8fCBwLnggPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICBpZiAocC55ID09PSBudWxsIHx8IHAueSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG4gIGlmIChpc05hTihwLngpIHx8ICghb3B0X2FsbG93TmFOWSAmJiBpc05hTihwLnkpKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogTnVtYmVyIGZvcm1hdHRpbmcgZnVuY3Rpb24gd2hpY2ggbWltaWNzIHRoZSBiZWhhdmlvciBvZiAlZyBpbiBwcmludGYsIGkuZS5cbiAqIGVpdGhlciBleHBvbmVudGlhbCBvciBmaXhlZCBmb3JtYXQgKHdpdGhvdXQgdHJhaWxpbmcgMHMpIGlzIHVzZWQgZGVwZW5kaW5nIG9uXG4gKiB0aGUgbGVuZ3RoIG9mIHRoZSBnZW5lcmF0ZWQgc3RyaW5nLiAgVGhlIGFkdmFudGFnZSBvZiB0aGlzIGZvcm1hdCBpcyB0aGF0XG4gKiB0aGVyZSBpcyBhIHByZWRpY3RhYmxlIHVwcGVyIGJvdW5kIG9uIHRoZSByZXN1bHRpbmcgc3RyaW5nIGxlbmd0aCxcbiAqIHNpZ25pZmljYW50IGZpZ3VyZXMgYXJlIG5vdCBkcm9wcGVkLCBhbmQgbm9ybWFsIG51bWJlcnMgYXJlIG5vdCBkaXNwbGF5ZWQgaW5cbiAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxuICpcbiAqIE5PVEU6IEphdmFTY3JpcHQncyBuYXRpdmUgdG9QcmVjaXNpb24oKSBpcyBOT1QgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciAlZy5cbiAqIEl0IGNyZWF0ZXMgc3RyaW5ncyB3aGljaCBhcmUgdG9vIGxvbmcgZm9yIGFic29sdXRlIHZhbHVlcyBiZXR3ZWVuIDEwXi00IGFuZFxuICogMTBeLTYsIGUuZy4gJzAuMDAwMDEnIGluc3RlYWQgb2YgJzFlLTUnLiBTZWUgdGVzdHMvbnVtYmVyLWZvcm1hdC5odG1sIGZvclxuICogb3V0cHV0IGV4YW1wbGVzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBudW1iZXIgdG8gZm9ybWF0XG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9wcmVjaXNpb24gVGhlIHByZWNpc2lvbiB0byB1c2UsIGRlZmF1bHQgMi5cbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgZm9ybWF0dGVkIGxpa2UgJWcgaW4gcHJpbnRmLiAgVGhlIG1heCBnZW5lcmF0ZWRcbiAqICAgICAgICAgICAgICAgICAgc3RyaW5nIGxlbmd0aCBzaG91bGQgYmUgcHJlY2lzaW9uICsgNiAoZS5nIDEuMTIzZSszMDApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxvYXRGb3JtYXQoeCwgb3B0X3ByZWNpc2lvbikge1xuICAvLyBBdm9pZCBpbnZhbGlkIHByZWNpc2lvbiB2YWx1ZXM7IFsxLCAyMV0gaXMgdGhlIHZhbGlkIHJhbmdlLlxuICB2YXIgcCA9IE1hdGgubWluKE1hdGgubWF4KDEsIG9wdF9wcmVjaXNpb24gfHwgMiksIDIxKTtcblxuICAvLyBUaGlzIGlzIGRlY2VwdGl2ZWx5IHNpbXBsZS4gIFRoZSBhY3R1YWwgYWxnb3JpdGhtIGNvbWVzIGZyb206XG4gIC8vXG4gIC8vIE1heCBhbGxvd2VkIGxlbmd0aCA9IHAgKyA0XG4gIC8vIHdoZXJlIDQgY29tZXMgZnJvbSAnZStuJyBhbmQgJy4nLlxuICAvL1xuICAvLyBMZW5ndGggb2YgZml4ZWQgZm9ybWF0ID0gMiArIHkgKyBwXG4gIC8vIHdoZXJlIDIgY29tZXMgZnJvbSAnMC4nIGFuZCB5ID0gIyBvZiBsZWFkaW5nIHplcm9lcy5cbiAgLy9cbiAgLy8gRXF1YXRpbmcgdGhlIHR3byBhbmQgc29sdmluZyBmb3IgeSB5aWVsZHMgeSA9IDIsIG9yIDAuMDB4eHh4IHdoaWNoIGlzXG4gIC8vIDEuMGUtMy5cbiAgLy9cbiAgLy8gU2luY2UgdGhlIGJlaGF2aW9yIG9mIHRvUHJlY2lzaW9uKCkgaXMgaWRlbnRpY2FsIGZvciBsYXJnZXIgbnVtYmVycywgd2VcbiAgLy8gZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCB0aGUgb3RoZXIgYm91bmQuXG4gIC8vXG4gIC8vIEZpbmFsbHksIHRoZSBhcmd1bWVudCBmb3IgdG9FeHBvbmVudGlhbCgpIGlzIHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgZGlnaXRzLFxuICAvLyBzbyB3ZSB0YWtlIG9mZiAxIGZvciB0aGUgdmFsdWUgYmVmb3JlIHRoZSAnLicuXG4gIHJldHVybiAoTWF0aC5hYnMoeCkgPCAxLjBlLTMgJiYgeCAhPT0gMC4wKSA/XG4gICAgICB4LnRvRXhwb25lbnRpYWwocCAtIDEpIDogeC50b1ByZWNpc2lvbihwKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgJzknIHRvICcwOScgKHVzZWZ1bCBmb3IgZGF0ZXMpXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHplcm9wYWQoeCkge1xuICBpZiAoeCA8IDEwKSByZXR1cm4gXCIwXCIgKyB4OyBlbHNlIHJldHVybiBcIlwiICsgeDtcbn07XG5cbi8qKlxuICogRGF0ZSBhY2Nlc3NvcnMgdG8gZ2V0IHRoZSBwYXJ0cyBvZiBhIGNhbGVuZGFyIGRhdGUgKHllYXIsIG1vbnRoLFxuICogZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCBhbmQgbWlsbGlzZWNvbmQpIGFjY29yZGluZyB0byBsb2NhbCB0aW1lLFxuICogYW5kIGZhY3RvcnkgbWV0aG9kIHRvIGNhbGwgdGhlIERhdGUgY29uc3RydWN0b3Igd2l0aCBhbiBhcnJheSBvZiBhcmd1bWVudHMuXG4gKi9cbmV4cG9ydCB2YXIgRGF0ZUFjY2Vzc29yc0xvY2FsID0ge1xuICBnZXRGdWxsWWVhcjogICAgIGQgPT4gZC5nZXRGdWxsWWVhcigpLFxuICBnZXRNb250aDogICAgICAgIGQgPT4gZC5nZXRNb250aCgpLFxuICBnZXREYXRlOiAgICAgICAgIGQgPT4gZC5nZXREYXRlKCksXG4gIGdldEhvdXJzOiAgICAgICAgZCA9PiBkLmdldEhvdXJzKCksXG4gIGdldE1pbnV0ZXM6ICAgICAgZCA9PiBkLmdldE1pbnV0ZXMoKSxcbiAgZ2V0U2Vjb25kczogICAgICBkID0+IGQuZ2V0U2Vjb25kcygpLFxuICBnZXRNaWxsaXNlY29uZHM6IGQgPT4gZC5nZXRNaWxsaXNlY29uZHMoKSxcbiAgZ2V0RGF5OiAgICAgICAgICBkID0+IGQuZ2V0RGF5KCksXG4gIG1ha2VEYXRlOiAgICAgICAgZnVuY3Rpb24oeSwgbSwgZCwgaGgsIG1tLCBzcywgbXMpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoeSwgbSwgZCwgaGgsIG1tLCBzcywgbXMpO1xuICB9XG59O1xuXG4vKipcbiAqIERhdGUgYWNjZXNzb3JzIHRvIGdldCB0aGUgcGFydHMgb2YgYSBjYWxlbmRhciBkYXRlICh5ZWFyLCBtb250aCxcbiAqIGRheSBvZiBtb250aCwgaG91ciwgbWludXRlLCBzZWNvbmQgYW5kIG1pbGxpc2Vjb25kKSBhY2NvcmRpbmcgdG8gVVRDIHRpbWUsXG4gKiBhbmQgZmFjdG9yeSBtZXRob2QgdG8gY2FsbCB0aGUgRGF0ZSBjb25zdHJ1Y3RvciB3aXRoIGFuIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAqL1xuZXhwb3J0IHZhciBEYXRlQWNjZXNzb3JzVVRDID0ge1xuICBnZXRGdWxsWWVhcjogICAgIGQgPT4gZC5nZXRVVENGdWxsWWVhcigpLFxuICBnZXRNb250aDogICAgICAgIGQgPT4gZC5nZXRVVENNb250aCgpLFxuICBnZXREYXRlOiAgICAgICAgIGQgPT4gZC5nZXRVVENEYXRlKCksXG4gIGdldEhvdXJzOiAgICAgICAgZCA9PiBkLmdldFVUQ0hvdXJzKCksXG4gIGdldE1pbnV0ZXM6ICAgICAgZCA9PiBkLmdldFVUQ01pbnV0ZXMoKSxcbiAgZ2V0U2Vjb25kczogICAgICBkID0+IGQuZ2V0VVRDU2Vjb25kcygpLFxuICBnZXRNaWxsaXNlY29uZHM6IGQgPT4gZC5nZXRVVENNaWxsaXNlY29uZHMoKSxcbiAgZ2V0RGF5OiAgICAgICAgICBkID0+IGQuZ2V0VVRDRGF5KCksXG4gIG1ha2VEYXRlOiAgICAgICAgZnVuY3Rpb24oeSwgbSwgZCwgaGgsIG1tLCBzcywgbXMpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeSwgbSwgZCwgaGgsIG1tLCBzcywgbXMpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgdmVyc2lvbiBvZiB0aGUgaG91cnMsIG1pbnV0ZXMgYW5kIHNlY29uZHMgcG9ydGlvbiBvZiBhIGRhdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gaGggVGhlIGhvdXJzIChmcm9tIDAtMjMpXG4gKiBAcGFyYW0ge251bWJlcn0gbW0gVGhlIG1pbnV0ZXMgKGZyb20gMC01OSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzcyBUaGUgc2Vjb25kcyAoZnJvbSAwLTU5KVxuICogQHJldHVybiB7c3RyaW5nfSBBIHRpbWUgb2YgdGhlIGZvcm0gXCJISDpNTVwiIG9yIFwiSEg6TU06U1NcIlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhtc1N0cmluZ18oaGgsIG1tLCBzcywgbXMpIHtcbiAgdmFyIHJldCA9IHplcm9wYWQoaGgpICsgXCI6XCIgKyB6ZXJvcGFkKG1tKTtcbiAgaWYgKHNzKSB7XG4gICAgcmV0ICs9IFwiOlwiICsgemVyb3BhZChzcyk7XG4gICAgaWYgKG1zKSB7XG4gICAgICB2YXIgc3RyID0gXCJcIiArIG1zO1xuICAgICAgcmV0ICs9IFwiLlwiICsgKCcwMDAnK3N0cikuc3Vic3RyaW5nKHN0ci5sZW5ndGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgSlMgZGF0ZSAobWlsbGlzIHNpbmNlIGVwb2NoKSB0byBhIGZvcm1hdHRlZCBzdHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaGUgSmF2YVNjcmlwdCB0aW1lIHZhbHVlIChtcyBzaW5jZSBlcG9jaClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXRjIFdoZXRoZXIgb3V0cHV0IFVUQyBvciBsb2NhbCB0aW1lXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgZGF0ZSBvZiBvbmUgb2YgdGhlc2UgZm9ybXM6XG4gKiAgICAgXCJZWVlZL01NL0REXCIsIFwiWVlZWS9NTS9ERCBISDpNTVwiIG9yIFwiWVlZWS9NTS9ERCBISDpNTTpTU1wiXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0ZVN0cmluZ18odGltZSwgdXRjKSB7XG4gIHZhciBhY2Nlc3NvcnMgPSB1dGMgPyBEYXRlQWNjZXNzb3JzVVRDIDogRGF0ZUFjY2Vzc29yc0xvY2FsO1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHRpbWUpO1xuICB2YXIgeSA9IGFjY2Vzc29ycy5nZXRGdWxsWWVhcihkYXRlKTtcbiAgdmFyIG0gPSBhY2Nlc3NvcnMuZ2V0TW9udGgoZGF0ZSk7XG4gIHZhciBkID0gYWNjZXNzb3JzLmdldERhdGUoZGF0ZSk7XG4gIHZhciBoaCA9IGFjY2Vzc29ycy5nZXRIb3VycyhkYXRlKTtcbiAgdmFyIG1tID0gYWNjZXNzb3JzLmdldE1pbnV0ZXMoZGF0ZSk7XG4gIHZhciBzcyA9IGFjY2Vzc29ycy5nZXRTZWNvbmRzKGRhdGUpO1xuICB2YXIgbXMgPSBhY2Nlc3NvcnMuZ2V0TWlsbGlzZWNvbmRzKGRhdGUpO1xuICAvLyBHZXQgYSB5ZWFyIHN0cmluZzpcbiAgdmFyIHllYXIgPSBcIlwiICsgeTtcbiAgLy8gR2V0IGEgMCBwYWRkZWQgbW9udGggc3RyaW5nXG4gIHZhciBtb250aCA9IHplcm9wYWQobSArIDEpOyAgLy9tb250aHMgYXJlIDAtb2Zmc2V0LCBzaWdoXG4gIC8vIEdldCBhIDAgcGFkZGVkIGRheSBzdHJpbmdcbiAgdmFyIGRheSA9IHplcm9wYWQoZCk7XG4gIHZhciBmcmFjID0gaGggKiAzNjAwICsgbW0gKiA2MCArIHNzICsgMWUtMyAqIG1zO1xuICB2YXIgcmV0ID0geWVhciArIFwiL1wiICsgbW9udGggKyBcIi9cIiArIGRheTtcbiAgaWYgKGZyYWMpIHtcbiAgICByZXQgKz0gXCIgXCIgKyBobXNTdHJpbmdfKGhoLCBtbSwgc3MsIG1zKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBSb3VuZCBhIG51bWJlciB0byB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBkaWdpdHMgcGFzdCB0aGUgZGVjaW1hbCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0byByb3VuZFxuICogQHBhcmFtIHtudW1iZXJ9IHBsYWNlcyBUaGUgbnVtYmVyIG9mIGRlY2ltYWxzIHRvIHdoaWNoIHRvIHJvdW5kXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByb3VuZGVkIG51bWJlclxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kXyhudW0sIHBsYWNlcykge1xuICB2YXIgc2hpZnQgPSBNYXRoLnBvdygxMCwgcGxhY2VzKTtcbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICogc2hpZnQpL3NoaWZ0O1xufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIG92ZXIgYW4gYXJyYXkuXG4gKiBDdXJyZW50bHkgZG9lcyBub3Qgd29yayB3aGVuIHZhbCBpcyBvdXRzaWRlIHRoZSByYW5nZSBvZiBhcnJ5J3MgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCB0aGUgdmFsdWUgdG8gc2VhcmNoIGZvclxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyeSBpcyB0aGUgdmFsdWUgb3ZlciB3aGljaCB0byBzZWFyY2hcbiAqIEBwYXJhbSB7bnVtYmVyfSBhYnMgSWYgYWJzID4gMCwgZmluZCB0aGUgbG93ZXN0IGVudHJ5IGdyZWF0ZXIgdGhhbiB2YWxcbiAqICAgICBJZiBhYnMgPCAwLCBmaW5kIHRoZSBoaWdoZXN0IGVudHJ5IGxlc3MgdGhhbiB2YWwuXG4gKiAgICAgSWYgYWJzID09IDAsIGZpbmQgdGhlIGVudHJ5IHRoYXQgZXF1YWxzIHZhbC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gbG93IFRoZSBmaXJzdCBpbmRleCBpbiBhcnJ5IHRvIGNvbnNpZGVyIChvcHRpb25hbClcbiAqIEBwYXJhbSB7bnVtYmVyPX0gaGlnaCBUaGUgbGFzdCBpbmRleCBpbiBhcnJ5IHRvIGNvbnNpZGVyIChvcHRpb25hbClcbiAqIEByZXR1cm4ge251bWJlcn0gSW5kZXggb2YgdGhlIGVsZW1lbnQsIG9yIC0xIGlmIGl0IGlzbid0IGZvdW5kLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaCh2YWwsIGFycnksIGFicywgbG93LCBoaWdoKSB7XG4gIGlmIChsb3cgPT09IG51bGwgfHwgbG93ID09PSB1bmRlZmluZWQgfHxcbiAgICAgIGhpZ2ggPT09IG51bGwgfHwgaGlnaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbG93ID0gMDtcbiAgICBoaWdoID0gYXJyeS5sZW5ndGggLSAxO1xuICB9XG4gIGlmIChsb3cgPiBoaWdoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmIChhYnMgPT09IG51bGwgfHwgYWJzID09PSB1bmRlZmluZWQpIHtcbiAgICBhYnMgPSAwO1xuICB9XG4gIHZhciB2YWxpZEluZGV4ID0gZnVuY3Rpb24oaWR4KSB7XG4gICAgcmV0dXJuIGlkeCA+PSAwICYmIGlkeCA8IGFycnkubGVuZ3RoO1xuICB9O1xuICB2YXIgbWlkID0gcGFyc2VJbnQoKGxvdyArIGhpZ2gpIC8gMiwgMTApO1xuICB2YXIgZWxlbWVudCA9IGFycnlbbWlkXTtcbiAgdmFyIGlkeDtcbiAgaWYgKGVsZW1lbnQgPT0gdmFsKSB7XG4gICAgcmV0dXJuIG1pZDtcbiAgfSBlbHNlIGlmIChlbGVtZW50ID4gdmFsKSB7XG4gICAgaWYgKGFicyA+IDApIHtcbiAgICAgIC8vIEFjY2VwdCBpZiBlbGVtZW50ID4gdmFsLCBidXQgYWxzbyBpZiBwcmlvciBlbGVtZW50IDwgdmFsLlxuICAgICAgaWR4ID0gbWlkIC0gMTtcbiAgICAgIGlmICh2YWxpZEluZGV4KGlkeCkgJiYgYXJyeVtpZHhdIDwgdmFsKSB7XG4gICAgICAgIHJldHVybiBtaWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiaW5hcnlTZWFyY2godmFsLCBhcnJ5LCBhYnMsIGxvdywgbWlkIC0gMSk7XG4gIH0gZWxzZSBpZiAoZWxlbWVudCA8IHZhbCkge1xuICAgIGlmIChhYnMgPCAwKSB7XG4gICAgICAvLyBBY2NlcHQgaWYgZWxlbWVudCA8IHZhbCwgYnV0IGFsc28gaWYgcHJpb3IgZWxlbWVudCA+IHZhbC5cbiAgICAgIGlkeCA9IG1pZCArIDE7XG4gICAgICBpZiAodmFsaWRJbmRleChpZHgpICYmIGFycnlbaWR4XSA+IHZhbCkge1xuICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmluYXJ5U2VhcmNoKHZhbCwgYXJyeSwgYWJzLCBtaWQgKyAxLCBoaWdoKTtcbiAgfVxuICByZXR1cm4gLTE7ICAvLyBjYW4ndCBhY3R1YWxseSBoYXBwZW4sIGJ1dCBtYWtlcyBjbG9zdXJlIGNvbXBpbGVyIGhhcHB5XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIGRhdGUsIHJldHVybmluZyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaC4gVGhpcyBjYW4gYmVcbiAqIHBhc3NlZCBpbiBhcyBhbiB4VmFsdWVQYXJzZXIgaW4gdGhlIER5Z3JhcGggY29uc3RydWN0b3IuXG4gKiBUT0RPKGRhbnZrKTogZW51bWVyYXRlIGZvcm1hdHMgdGhhdCB0aGlzIHVuZGVyc3RhbmRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlU3RyIEEgZGF0ZSBpbiBhIHZhcmlldHkgb2YgcG9zc2libGUgc3RyaW5nIGZvcm1hdHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRlUGFyc2VyKGRhdGVTdHIpIHtcbiAgdmFyIGRhdGVTdHJTbGFzaGVkO1xuICB2YXIgZDtcblxuICAvLyBMZXQgdGhlIHN5c3RlbSB0cnkgdGhlIGZvcm1hdCBmaXJzdCwgd2l0aCBvbmUgY2F2ZWF0OlxuICAvLyBZWVlZLU1NLUREWyBISDpNTTpTU10gaXMgaW50ZXJwcmV0ZWQgYXMgVVRDIGJ5IGEgdmFyaWV0eSBvZiBicm93c2Vycy5cbiAgLy8gZHlncmFwaHMgZGlzcGxheXMgZGF0ZXMgaW4gbG9jYWwgdGltZSwgc28gdGhpcyB3aWxsIHJlc3VsdCBpbiBzdXJwcmlzaW5nXG4gIC8vIGluY29uc2lzdGVuY2llcy4gQnV0IGlmIHlvdSBzcGVjaWZ5IFwiVFwiIG9yIFwiWlwiIChpLmUuIFlZWVktTU0tRERUSEg6TU06U1MpLFxuICAvLyB0aGVuIHlvdSBwcm9iYWJseSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLCBzbyB3ZSdsbCBsZXQgeW91IGdvIGFoZWFkLlxuICAvLyBJc3N1ZTogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2R5Z3JhcGhzL2lzc3Vlcy9kZXRhaWw/aWQ9MjU1XG4gIGlmIChkYXRlU3RyLnNlYXJjaChcIi1cIikgPT0gLTEgfHxcbiAgICAgIGRhdGVTdHIuc2VhcmNoKFwiVFwiKSAhPSAtMSB8fCBkYXRlU3RyLnNlYXJjaChcIlpcIikgIT0gLTEpIHtcbiAgICBkID0gZGF0ZVN0clRvTWlsbGlzKGRhdGVTdHIpO1xuICAgIGlmIChkICYmICFpc05hTihkKSkgcmV0dXJuIGQ7XG4gIH1cblxuICBpZiAoZGF0ZVN0ci5zZWFyY2goXCItXCIpICE9IC0xKSB7ICAvLyBlLmcuICcyMDA5LTctMTInIG9yICcyMDA5LTA3LTEyJ1xuICAgIGRhdGVTdHJTbGFzaGVkID0gZGF0ZVN0ci5yZXBsYWNlKFwiLVwiLCBcIi9cIiwgXCJnXCIpO1xuICAgIHdoaWxlIChkYXRlU3RyU2xhc2hlZC5zZWFyY2goXCItXCIpICE9IC0xKSB7XG4gICAgICBkYXRlU3RyU2xhc2hlZCA9IGRhdGVTdHJTbGFzaGVkLnJlcGxhY2UoXCItXCIsIFwiL1wiKTtcbiAgICB9XG4gICAgZCA9IGRhdGVTdHJUb01pbGxpcyhkYXRlU3RyU2xhc2hlZCk7XG4gIH0gZWxzZSBpZiAoZGF0ZVN0ci5sZW5ndGggPT0gOCkgeyAgLy8gZS5nLiAnMjAwOTA3MTInXG4gICAgLy8gVE9ETyhkYW52ayk6IHJlbW92ZSBzdXBwb3J0IGZvciB0aGlzIGZvcm1hdC4gSXQncyBjb25mdXNpbmcuXG4gICAgZGF0ZVN0clNsYXNoZWQgPSBkYXRlU3RyLnN1YnN0cigwLDQpICsgXCIvXCIgKyBkYXRlU3RyLnN1YnN0cig0LDIpICsgXCIvXCIgK1xuICAgICAgICBkYXRlU3RyLnN1YnN0cig2LDIpO1xuICAgIGQgPSBkYXRlU3RyVG9NaWxsaXMoZGF0ZVN0clNsYXNoZWQpO1xuICB9IGVsc2Uge1xuICAgIC8vIEFueSBmb3JtYXQgdGhhdCBEYXRlLnBhcnNlIHdpbGwgYWNjZXB0LCBlLmcuIFwiMjAwOS8wNy8xMlwiIG9yXG4gICAgLy8gXCIyMDA5LzA3LzEyIDEyOjM0OjU2XCJcbiAgICBkID0gZGF0ZVN0clRvTWlsbGlzKGRhdGVTdHIpO1xuICB9XG5cbiAgaWYgKCFkIHx8IGlzTmFOKGQpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkNvdWxkbid0IHBhcnNlIFwiICsgZGF0ZVN0ciArIFwiIGFzIGEgZGF0ZVwiKTtcbiAgfVxuICByZXR1cm4gZDtcbn07XG5cbi8qKlxuICogVGhpcyBpcyBpZGVudGljYWwgdG8gSmF2YVNjcmlwdCdzIGJ1aWx0LWluIERhdGUucGFyc2UoKSBtZXRob2QsIGV4Y2VwdCB0aGF0XG4gKiBpdCBkb2Vzbid0IGdldCByZXBsYWNlZCB3aXRoIGFuIGluY29tcGF0aWJsZSBtZXRob2QgYnkgYWdncmVzc2l2ZSBKU1xuICogbGlicmFyaWVzIGxpa2UgTW9vVG9vbHMgb3IgSm9vbWxhLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgZGF0ZSBzdHJpbmcsIGUuZy4gXCIyMDExLzA1LzA2XCJcbiAqIEByZXR1cm4ge251bWJlcn0gbWlsbGlzIHNpbmNlIGVwb2NoXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0ZVN0clRvTWlsbGlzKHN0cikge1xuICByZXR1cm4gbmV3IERhdGUoc3RyKS5nZXRUaW1lKCk7XG59O1xuXG4vLyBUaGVzZSBmdW5jdGlvbnMgYXJlIGFsbCBiYXNlZCBvbiBNb2NoaUtpdC5cbi8qKlxuICogQ29waWVzIGFsbCB0aGUgcHJvcGVydGllcyBmcm9tIG8gdG8gc2VsZi5cbiAqXG4gKiBAcGFyYW0geyFPYmplY3R9IHNlbGZcbiAqIEBwYXJhbSB7IU9iamVjdH0gb1xuICogQHJldHVybiB7IU9iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZShzZWxmLCBvKSB7XG4gIGlmICh0eXBlb2YobykgIT0gJ3VuZGVmaW5lZCcgJiYgbyAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIGsgaW4gbykge1xuICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgc2VsZltrXSA9IG9ba107XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWxmO1xufTtcblxuLyoqXG4gKiBDb3BpZXMgYWxsIHRoZSBwcm9wZXJ0aWVzIGZyb20gbyB0byBzZWxmLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gc2VsZlxuICogQHBhcmFtIHshT2JqZWN0fSBvXG4gKiBAcmV0dXJuIHshT2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZURlZXAoc2VsZiwgbykge1xuICAvLyBUYWtlbiBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzg0Mjg2L2phdmFzY3JpcHQtaXNkb20taG93LWRvLXlvdS1jaGVjay1pZi1hLWphdmFzY3JpcHQtb2JqZWN0LWlzLWEtZG9tLW9iamVjdFxuICBmdW5jdGlvbiBpc05vZGUobykge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgTm9kZSA9PT0gXCJvYmplY3RcIiA/IG8gaW5zdGFuY2VvZiBOb2RlIDpcbiAgICAgIHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvLm5vZGVUeXBlID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBvLm5vZGVOYW1lPT09XCJzdHJpbmdcIlxuICAgICk7XG4gIH1cblxuICBpZiAodHlwZW9mKG8pICE9ICd1bmRlZmluZWQnICYmIG8gIT09IG51bGwpIHtcbiAgICBmb3IgKHZhciBrIGluIG8pIHtcbiAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgIGlmIChvW2tdID09PSBudWxsKSB7XG4gICAgICAgICAgc2VsZltrXSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUxpa2Uob1trXSkpIHtcbiAgICAgICAgICBzZWxmW2tdID0gb1trXS5zbGljZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShvW2tdKSkge1xuICAgICAgICAgIC8vIERPTSBvYmplY3RzIGFyZSBzaGFsbG93bHktY29waWVkLlxuICAgICAgICAgIHNlbGZba10gPSBvW2tdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihvW2tdKSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmICh0eXBlb2Yoc2VsZltrXSkgIT0gJ29iamVjdCcgfHwgc2VsZltrXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc2VsZltrXSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVEZWVwKHNlbGZba10sIG9ba10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGZba10gPSBvW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWxmO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG9cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheUxpa2Uobykge1xuICB2YXIgdHlwID0gdHlwZW9mKG8pO1xuICBpZiAoXG4gICAgICAodHlwICE9ICdvYmplY3QnICYmICEodHlwID09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mKG8uaXRlbSkgPT0gJ2Z1bmN0aW9uJykpIHx8XG4gICAgICBvID09PSBudWxsIHx8XG4gICAgICB0eXBlb2Yoby5sZW5ndGgpICE9ICdudW1iZXInIHx8XG4gICAgICBvLm5vZGVUeXBlID09PSAzXG4gICAgICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlTGlrZShvKSB7XG4gIGlmICh0eXBlb2YobykgIT0gXCJvYmplY3RcIiB8fCBvID09PSBudWxsIHx8XG4gICAgICB0eXBlb2Yoby5nZXRUaW1lKSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBOb3RlOiB0aGlzIG9ubHkgc2VlbXMgdG8gd29yayBmb3IgYXJyYXlzLlxuICogQHBhcmFtIHshQXJyYXl9IG9cbiAqIEByZXR1cm4geyFBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShvKSB7XG4gIC8vIFRPRE8oZGFudmspOiBmaWd1cmUgb3V0IGhvdyBNb2NoaUtpdCdzIHZlcnNpb24gd29ya3NcbiAgdmFyIHIgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9baV0pKSB7XG4gICAgICByLnB1c2goY2xvbmUob1tpXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByLnB1c2gob1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgY2FudmFzIGVsZW1lbnQuXG4gKlxuICogQHJldHVybiB7IUhUTUxDYW52YXNFbGVtZW50fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcygpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250ZXh0J3MgcGl4ZWwgcmF0aW8sIHdoaWNoIGlzIHRoZSByYXRpbyBiZXR3ZWVuIHRoZSBkZXZpY2VcbiAqIHBpeGVsIHJhdGlvIGFuZCB0aGUgYmFja2luZyBzdG9yZSByYXRpby4gVHlwaWNhbGx5IHRoaXMgaXMgMSBmb3IgY29udmVudGlvbmFsXG4gKiBkaXNwbGF5cywgYW5kID4gMSBmb3IgSGlEUEkgZGlzcGxheXMgKHN1Y2ggYXMgdGhlIFJldGluYSBNQlApLlxuICogU2VlIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2NhbnZhcy9oaWRwaS8gZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAcGFyYW0geyFDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgVGhlIGNhbnZhcydzIDJkIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByYXRpbyBvZiB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvIGFuZCB0aGUgYmFja2luZyBzdG9yZVxuICogcmF0aW8gZm9yIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRleHRQaXhlbFJhdGlvKGNvbnRleHQpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIHZhciBiYWNraW5nU3RvcmVSYXRpbyA9IGNvbnRleHQud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuICAgIGlmIChkZXZpY2VQaXhlbFJhdGlvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0IGxlYXN0IGRldmljZVBpeGVsUmF0aW8gbXVzdCBiZSBkZWZpbmVkIGZvciB0aGlzIHJhdGlvIHRvIG1ha2Ugc2Vuc2UuXG4gICAgICAvLyBXZSBkZWZhdWx0IGJhY2tpbmdTdG9yZVJhdGlvIHRvIDE6IHRoaXMgZG9lcyBub3QgZXhpc3Qgb24gc29tZSBicm93c2Vyc1xuICAgICAgLy8gKGkuZS4gZGVza3RvcCBDaHJvbWUpLlxuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn07XG5cbi8qKlxuICogVE9ETyhkYW52ayk6IHVzZSBAdGVtcGxhdGUgaGVyZSB3aGVuIGl0J3MgYmV0dGVyIHN1cHBvcnRlZCBmb3IgY2xhc3Nlcy5cbiAqIEBwYXJhbSB7IUFycmF5fSBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCFBcnJheSw/KTpib29sZWFuPX0gcHJlZGljYXRlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEl0ZXJhdG9yKGFycmF5LCBzdGFydCwgbGVuZ3RoLCBwcmVkaWNhdGUpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBsZW5ndGggPSBsZW5ndGggfHwgYXJyYXkubGVuZ3RoO1xuICB0aGlzLmhhc05leHQgPSB0cnVlOyAvLyBVc2UgdG8gaWRlbnRpZnkgaWYgdGhlcmUncyBhbm90aGVyIGVsZW1lbnQuXG4gIHRoaXMucGVlayA9IG51bGw7IC8vIFVzZSBmb3IgbG9vay1haGVhZFxuICB0aGlzLnN0YXJ0XyA9IHN0YXJ0O1xuICB0aGlzLmFycmF5XyA9IGFycmF5O1xuICB0aGlzLnByZWRpY2F0ZV8gPSBwcmVkaWNhdGU7XG4gIHRoaXMuZW5kXyA9IE1hdGgubWluKGFycmF5Lmxlbmd0aCwgc3RhcnQgKyBsZW5ndGgpO1xuICB0aGlzLm5leHRJZHhfID0gc3RhcnQgLSAxOyAvLyB1c2UgLTEgc28gaW5pdGlhbCBhZHZhbmNlIHdvcmtzLlxuICB0aGlzLm5leHQoKTsgLy8gaWdub3JpbmcgcmVzdWx0LlxufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5oYXNOZXh0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG9iaiA9IHRoaXMucGVlaztcblxuICB2YXIgbmV4dElkeCA9IHRoaXMubmV4dElkeF8gKyAxO1xuICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgd2hpbGUgKG5leHRJZHggPCB0aGlzLmVuZF8pIHtcbiAgICBpZiAoIXRoaXMucHJlZGljYXRlXyB8fCB0aGlzLnByZWRpY2F0ZV8odGhpcy5hcnJheV8sIG5leHRJZHgpKSB7XG4gICAgICB0aGlzLnBlZWsgPSB0aGlzLmFycmF5X1tuZXh0SWR4XTtcbiAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBuZXh0SWR4Kys7XG4gIH1cbiAgdGhpcy5uZXh0SWR4XyA9IG5leHRJZHg7XG4gIGlmICghZm91bmQpIHtcbiAgICB0aGlzLmhhc05leHQgPSBmYWxzZTtcbiAgICB0aGlzLnBlZWsgPSBudWxsO1xuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgaXRlcmF0b3Igb3ZlciBhcnJheSwgYmV0d2VlbiBpbmRleGVzIHN0YXJ0IGFuZFxuICogc3RhcnQgKyBsZW5ndGgsIGFuZCBvbmx5IHJldHVybnMgZW50cmllcyB0aGF0IHBhc3MgdGhlIGFjY2VwdCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7IUFycmF5fSBhcnJheSB0aGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IHRoZSBmaXJzdCBpbmRleCB0byBpdGVyYXRlIG92ZXIsIDAgaWYgYWJzZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiAgICAgVGhpcywgYWxvbmcgd2l0aCBzdGFydCwgZGVmaW5lcyBhIHNsaWNlIG9mIHRoZSBhcnJheSwgYW5kIHNvIGxlbmd0aFxuICogICAgIGRvZXNuJ3QgaW1wbHkgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaXRlcmF0b3Igd2hlbiBhY2NlcHQgZG9lc24ndFxuICogICAgIGFsd2F5cyBhY2NlcHQgYWxsIHZhbHVlcy4gYXJyYXkubGVuZ3RoIHdoZW4gYWJzZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbig/KTpib29sZWFuPX0gb3B0X3ByZWRpY2F0ZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXNcbiAqICAgICBwYXJhbWV0ZXJzIGFycmF5IGFuZCBpZHgsIHdoaWNoIHJldHVybnMgdHJ1ZSB3aGVuIHRoZSBlbGVtZW50IHNob3VsZCBiZVxuICogICAgIHJldHVybmVkLiAgSWYgb21pdHRlZCwgYWxsIGVsZW1lbnRzIGFyZSBhY2NlcHRlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJdGVyYXRvcihhcnJheSwgc3RhcnQsIGxlbmd0aCwgb3B0X3ByZWRpY2F0ZSkge1xuICByZXR1cm4gbmV3IEl0ZXJhdG9yKGFycmF5LCBzdGFydCwgbGVuZ3RoLCBvcHRfcHJlZGljYXRlKTtcbn07XG5cbi8vIFNoaW0gbGF5ZXIgd2l0aCBzZXRUaW1lb3V0IGZhbGxiYWNrLlxuLy8gRnJvbTogaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbi8vIFNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgd2luZG93IGNvbnRleHQ6XG4vLyAgIER5Z3JhcGgucmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24oKSB7fSlcbmV4cG9ydCB2YXIgcmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICAgfHxcbiAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICB8fFxuICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgfHxcbiAgICAgICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgIHx8XG4gICAgICAgICAgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgICAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gYXQgbW9zdCBtYXhGcmFtZXMgdGltZXMgYXQgYW4gYXR0ZW1wdGVkIGludGVydmFsIG9mXG4gKiBmcmFtZVBlcmlvZEluTWlsbGlzLCB0aGVuIGNhbGwgYSBjbGVhbnVwIGZ1bmN0aW9uIG9uY2UuIHJlcGVhdEZuIGlzIGNhbGxlZFxuICogb25jZSBpbW1lZGlhdGVseSwgdGhlbiBhdCBtb3N0IChtYXhGcmFtZXMgLSAxKSB0aW1lcyBhc3luY2hyb25vdXNseS4gSWZcbiAqIG1heEZyYW1lcz09MSwgdGhlbiBjbGVhbnVwX2ZuKCkgaXMgYWxzbyBjYWxsZWQgc3luY2hyb25vdXNseS4gIFRoaXMgZnVuY3Rpb25cbiAqIGlzIHVzZWQgdG8gc2VxdWVuY2UgYW5pbWF0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpfSByZXBlYXRGbiBDYWxsZWQgcmVwZWF0ZWRseSAtLSB0YWtlcyB0aGUgZnJhbWVcbiAqICAgICBudW1iZXIgKGZyb20gMCB0byBtYXhGcmFtZXMtMSkgYXMgYW4gYXJndW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RnJhbWVzIFRoZSBtYXggbnVtYmVyIG9mIHRpbWVzIHRvIGNhbGwgcmVwZWF0Rm5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcmFtZVBlcmlvZEluTWlsbGlzIE1heCByZXF1ZXN0ZWQgdGltZSBiZXR3ZWVuIGZyYW1lcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2xlYW51cEZuIEEgZnVuY3Rpb24gdG8gY2FsbCBhZnRlciBhbGwgcmVwZWF0Rm4gY2FsbHMuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwZWF0QW5kQ2xlYW51cChyZXBlYXRGbiwgbWF4RnJhbWVzLCBmcmFtZVBlcmlvZEluTWlsbGlzLFxuICAgIGNsZWFudXBGbikge1xuICB2YXIgZnJhbWVOdW1iZXIgPSAwO1xuICB2YXIgcHJldmlvdXNGcmFtZU51bWJlcjtcbiAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICByZXBlYXRGbihmcmFtZU51bWJlcik7XG4gIGlmIChtYXhGcmFtZXMgPT0gMSkge1xuICAgIGNsZWFudXBGbigpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF4RnJhbWVBcmcgPSBtYXhGcmFtZXMgLSAxO1xuXG4gIChmdW5jdGlvbiBsb29wKCkge1xuICAgIGlmIChmcmFtZU51bWJlciA+PSBtYXhGcmFtZXMpIHJldHVybjtcbiAgICByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbigpIHtcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBmcmFtZSB0byBkcmF3IGJhc2VkIG9uIHRoZSBkZWxheSBzbyBmYXIuICBXaWxsIHNraXBcbiAgICAgIC8vIGZyYW1lcyBpZiBuZWNlc3NhcnkuXG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHZhciBkZWxheUluTWlsbGlzID0gY3VycmVudFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBwcmV2aW91c0ZyYW1lTnVtYmVyID0gZnJhbWVOdW1iZXI7XG4gICAgICBmcmFtZU51bWJlciA9IE1hdGguZmxvb3IoZGVsYXlJbk1pbGxpcyAvIGZyYW1lUGVyaW9kSW5NaWxsaXMpO1xuICAgICAgdmFyIGZyYW1lRGVsdGEgPSBmcmFtZU51bWJlciAtIHByZXZpb3VzRnJhbWVOdW1iZXI7XG4gICAgICAvLyBJZiB3ZSBwcmVkaWN0IHRoYXQgdGhlIHN1YnNlcXVlbnQgcmVwZWF0Rm4gY2FsbCB3aWxsIG92ZXJzaG9vdCBvdXJcbiAgICAgIC8vIHRvdGFsIGZyYW1lIHRhcmdldCwgc28gb3VyIGxhc3QgY2FsbCB3aWxsIGNhdXNlIGEgc3R1dHRlciwgdGhlbiBqdW1wIHRvXG4gICAgICAvLyB0aGUgbGFzdCBjYWxsIGltbWVkaWF0ZWx5LiAgSWYgd2UncmUgZ29pbmcgdG8gY2F1c2UgYSBzdHV0dGVyLCBiZXR0ZXJcbiAgICAgIC8vIHRvIGRvIGl0IGZhc3RlciB0aGFuIHNsb3dlci5cbiAgICAgIHZhciBwcmVkaWN0T3ZlcnNob290U3R1dHRlciA9IChmcmFtZU51bWJlciArIGZyYW1lRGVsdGEpID4gbWF4RnJhbWVBcmc7XG4gICAgICBpZiAocHJlZGljdE92ZXJzaG9vdFN0dXR0ZXIgfHwgKGZyYW1lTnVtYmVyID49IG1heEZyYW1lQXJnKSkge1xuICAgICAgICByZXBlYXRGbihtYXhGcmFtZUFyZyk7ICAvLyBFbnN1cmUgZmluYWwgY2FsbCB3aXRoIG1heEZyYW1lQXJnLlxuICAgICAgICBjbGVhbnVwRm4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmcmFtZURlbHRhICE9PSAwKSB7ICAvLyBEb24ndCBjYWxsIHJlcGVhdEZuIHdpdGggZHVwbGljYXRlIGZyYW1lcy5cbiAgICAgICAgICByZXBlYXRGbihmcmFtZU51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgbG9vcCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSgpO1xufTtcblxuLy8gQSB3aGl0ZWxpc3Qgb2Ygb3B0aW9ucyB0aGF0IGRvIG5vdCBjaGFuZ2UgcGl4ZWwgcG9zaXRpb25zLlxudmFyIHBpeGVsU2FmZU9wdGlvbnMgPSB7XG4gICdhbm5vdGF0aW9uQ2xpY2tIYW5kbGVyJzogdHJ1ZSxcbiAgJ2Fubm90YXRpb25EYmxDbGlja0hhbmRsZXInOiB0cnVlLFxuICAnYW5ub3RhdGlvbk1vdXNlT3V0SGFuZGxlcic6IHRydWUsXG4gICdhbm5vdGF0aW9uTW91c2VPdmVySGFuZGxlcic6IHRydWUsXG4gICdheGlzTGluZUNvbG9yJzogdHJ1ZSxcbiAgJ2F4aXNMaW5lV2lkdGgnOiB0cnVlLFxuICAnY2xpY2tDYWxsYmFjayc6IHRydWUsXG4gICdkcmF3Q2FsbGJhY2snOiB0cnVlLFxuICAnZHJhd0hpZ2hsaWdodFBvaW50Q2FsbGJhY2snOiB0cnVlLFxuICAnZHJhd1BvaW50cyc6IHRydWUsXG4gICdkcmF3UG9pbnRDYWxsYmFjayc6IHRydWUsXG4gICdkcmF3R3JpZCc6IHRydWUsXG4gICdmaWxsQWxwaGEnOiB0cnVlLFxuICAnZ3JpZExpbmVDb2xvcic6IHRydWUsXG4gICdncmlkTGluZVdpZHRoJzogdHJ1ZSxcbiAgJ2hpZGVPdmVybGF5T25Nb3VzZU91dCc6IHRydWUsXG4gICdoaWdobGlnaHRDYWxsYmFjayc6IHRydWUsXG4gICdoaWdobGlnaHRDaXJjbGVTaXplJzogdHJ1ZSxcbiAgJ2ludGVyYWN0aW9uTW9kZWwnOiB0cnVlLFxuICAnbGFiZWxzRGl2JzogdHJ1ZSxcbiAgJ2xhYmVsc0tNQic6IHRydWUsXG4gICdsYWJlbHNLTUcyJzogdHJ1ZSxcbiAgJ2xhYmVsc1NlcGFyYXRlTGluZXMnOiB0cnVlLFxuICAnbGFiZWxzU2hvd1plcm9WYWx1ZXMnOiB0cnVlLFxuICAnbGVnZW5kJzogdHJ1ZSxcbiAgJ3BhbkVkZ2VGcmFjdGlvbic6IHRydWUsXG4gICdwaXhlbHNQZXJZTGFiZWwnOiB0cnVlLFxuICAncG9pbnRDbGlja0NhbGxiYWNrJzogdHJ1ZSxcbiAgJ3BvaW50U2l6ZSc6IHRydWUsXG4gICdyYW5nZVNlbGVjdG9yUGxvdEZpbGxDb2xvcic6IHRydWUsXG4gICdyYW5nZVNlbGVjdG9yUGxvdEZpbGxHcmFkaWVudENvbG9yJzogdHJ1ZSxcbiAgJ3JhbmdlU2VsZWN0b3JQbG90U3Ryb2tlQ29sb3InOiB0cnVlLFxuICAncmFuZ2VTZWxlY3RvckJhY2tncm91bmRTdHJva2VDb2xvcic6IHRydWUsXG4gICdyYW5nZVNlbGVjdG9yQmFja2dyb3VuZExpbmVXaWR0aCc6IHRydWUsXG4gICdyYW5nZVNlbGVjdG9yUGxvdExpbmVXaWR0aCc6IHRydWUsXG4gICdyYW5nZVNlbGVjdG9yRm9yZWdyb3VuZFN0cm9rZUNvbG9yJzogdHJ1ZSxcbiAgJ3JhbmdlU2VsZWN0b3JGb3JlZ3JvdW5kTGluZVdpZHRoJzogdHJ1ZSxcbiAgJ3JhbmdlU2VsZWN0b3JBbHBoYSc6IHRydWUsXG4gICdzaG93TGFiZWxzT25IaWdobGlnaHQnOiB0cnVlLFxuICAnc2hvd1JvbGxlcic6IHRydWUsXG4gICdzdHJva2VXaWR0aCc6IHRydWUsXG4gICd1bmRlcmxheUNhbGxiYWNrJzogdHJ1ZSxcbiAgJ3VuaGlnaGxpZ2h0Q2FsbGJhY2snOiB0cnVlLFxuICAnem9vbUNhbGxiYWNrJzogdHJ1ZVxufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgc2NhbiB0aGUgb3B0aW9uIGxpc3QgYW5kIGRldGVybWluZSBpZiB0aGV5XG4gKiByZXF1aXJlIHVzIHRvIHJlY2FsY3VsYXRlIHRoZSBwaXhlbCBwb3NpdGlvbnMgb2YgZWFjaCBwb2ludC5cbiAqIFRPRE86IG1vdmUgdGhpcyBpbnRvIGR5Z3JhcGgtb3B0aW9ucy5qc1xuICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz59IGxhYmVscyBhIGxpc3Qgb2Ygb3B0aW9ucyB0byBjaGVjay5cbiAqIEBwYXJhbSB7IU9iamVjdH0gYXR0cnNcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGdyYXBoIG5lZWRzIG5ldyBwb2ludHMgZWxzZSBmYWxzZS5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1BpeGVsQ2hhbmdpbmdPcHRpb25MaXN0KGxhYmVscywgYXR0cnMpIHtcbiAgLy8gQXNzdW1lIHRoYXQgd2UgZG8gbm90IHJlcXVpcmUgbmV3IHBvaW50cy5cbiAgLy8gVGhpcyB3aWxsIGNoYW5nZSB0byB0cnVlIGlmIHdlIGFjdHVhbGx5IGRvIG5lZWQgbmV3IHBvaW50cy5cblxuICAvLyBDcmVhdGUgYSBkaWN0aW9uYXJ5IG9mIHNlcmllcyBuYW1lcyBmb3IgZmFzdGVyIGxvb2t1cC5cbiAgLy8gSWYgdGhlcmUgYXJlIG5vIGxhYmVscywgdGhlbiB0aGUgZGljdGlvbmFyeSBzdGF5cyBlbXB0eS5cbiAgdmFyIHNlcmllc05hbWVzRGljdGlvbmFyeSA9IHsgfTtcbiAgaWYgKGxhYmVscykge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZXJpZXNOYW1lc0RpY3Rpb25hcnlbbGFiZWxzW2ldXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gU2NhbiB0aHJvdWdoIGEgZmxhdCAoaS5lLiBub24tbmVzdGVkKSBvYmplY3Qgb2Ygb3B0aW9ucy5cbiAgLy8gUmV0dXJucyB0cnVlL2ZhbHNlIGRlcGVuZGluZyBvbiB3aGV0aGVyIG5ldyBwb2ludHMgYXJlIG5lZWRlZC5cbiAgdmFyIHNjYW5GbGF0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkgJiZcbiAgICAgICAgICAhcGl4ZWxTYWZlT3B0aW9uc1twcm9wZXJ0eV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2YgdXBkYXRlZCBvcHRpb25zLlxuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBhdHRycykge1xuICAgIGlmICghYXR0cnMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSBjb250aW51ZTtcblxuICAgIC8vIEZpbmQgb3V0IG9mIHRoaXMgZmllbGQgaXMgYWN0dWFsbHkgYSBzZXJpZXMgc3BlY2lmaWMgb3B0aW9ucyBsaXN0LlxuICAgIGlmIChwcm9wZXJ0eSA9PSAnaGlnaGxpZ2h0U2VyaWVzT3B0cycgfHxcbiAgICAgICAgKHNlcmllc05hbWVzRGljdGlvbmFyeVtwcm9wZXJ0eV0gJiYgIWF0dHJzLnNlcmllcykpIHtcbiAgICAgIC8vIFRoaXMgcHJvcGVydHkgdmFsdWUgaXMgYSBsaXN0IG9mIG9wdGlvbnMgZm9yIHRoaXMgc2VyaWVzLlxuICAgICAgaWYgKHNjYW5GbGF0T3B0aW9ucyhhdHRyc1twcm9wZXJ0eV0pKSByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5ID09ICdzZXJpZXMnIHx8IHByb3BlcnR5ID09ICdheGVzJykge1xuICAgICAgLy8gVGhpcyBpcyB0d2ljZS1uZXN0ZWQgb3B0aW9ucyBsaXN0LlxuICAgICAgdmFyIHBlclNlcmllcyA9IGF0dHJzW3Byb3BlcnR5XTtcbiAgICAgIGZvciAodmFyIHNlcmllcyBpbiBwZXJTZXJpZXMpIHtcbiAgICAgICAgaWYgKHBlclNlcmllcy5oYXNPd25Qcm9wZXJ0eShzZXJpZXMpICYmXG4gICAgICAgICAgICBzY2FuRmxhdE9wdGlvbnMocGVyU2VyaWVzW3Nlcmllc10pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhpcyB3YXMgbm90IGEgc2VyaWVzIHNwZWNpZmljIG9wdGlvbiBsaXN0LCBjaGVjayBpZiBpdCdzIGEgcGl4ZWxcbiAgICAgIC8vIGNoYW5naW5nIHByb3BlcnR5LlxuICAgICAgaWYgKCFwaXhlbFNhZmVPcHRpb25zW3Byb3BlcnR5XSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IHZhciBDaXJjbGVzID0ge1xuICBERUZBVUxUIDogZnVuY3Rpb24oZywgbmFtZSwgY3R4LCBjYW52YXN4LCBjYW52YXN5LCBjb2xvciwgcmFkaXVzKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICBjdHguYXJjKGNhbnZhc3gsIGNhbnZhc3ksIHJhZGl1cywgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICBjdHguZmlsbCgpO1xuICB9XG4gIC8vIEZvciBtb3JlIHNoYXBlcywgaW5jbHVkZSBleHRyYXMvc2hhcGVzLmpzXG59O1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIHxkYXRhfCBpcyBkZWxpbWl0ZWQgYnkgQ1IsIENSTEYsIExGLCBMRkNSLlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiAqIEByZXR1cm4gez9zdHJpbmd9IHRoZSBkZWxpbWl0ZXIgdGhhdCB3YXMgZGV0ZWN0ZWQgKG9yIG51bGwgb24gZmFpbHVyZSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RMaW5lRGVsaW1pdGVyKGRhdGEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvZGUgPSBkYXRhLmNoYXJBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gJ1xccicpIHtcbiAgICAgIC8vIE1pZ2h0IGFjdHVhbGx5IGJlIFwiXFxyXFxuXCIuXG4gICAgICBpZiAoKChpICsgMSkgPCBkYXRhLmxlbmd0aCkgJiYgKGRhdGEuY2hhckF0KGkgKyAxKSA9PT0gJ1xcbicpKSB7XG4gICAgICAgIHJldHVybiAnXFxyXFxuJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gJ1xcbicpIHtcbiAgICAgIC8vIE1pZ2h0IGFjdHVhbGx5IGJlIFwiXFxuXFxyXCIuXG4gICAgICBpZiAoKChpICsgMSkgPCBkYXRhLmxlbmd0aCkgJiYgKGRhdGEuY2hhckF0KGkgKyAxKSA9PT0gJ1xccicpKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxyJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBJcyBvbmUgbm9kZSBjb250YWluZWQgYnkgYW5vdGhlcj9cbiAqIEBwYXJhbSB7Tm9kZX0gY29udGFpbmVlIFRoZSBjb250YWluZWQgbm9kZS5cbiAqIEBwYXJhbSB7Tm9kZX0gY29udGFpbmVyIFRoZSBjb250YWluZXIgbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgY29udGFpbmVlIGlzIGluc2lkZSAob3IgZXF1YWwgdG8pIGNvbnRhaW5lci5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVDb250YWluZWRCeShjb250YWluZWUsIGNvbnRhaW5lcikge1xuICBpZiAoY29udGFpbmVyID09PSBudWxsIHx8IGNvbnRhaW5lZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgY29udGFpbmVlTm9kZSA9IC8qKiBAdHlwZSB7Tm9kZX0gKi8gKGNvbnRhaW5lZSk7XG4gIHdoaWxlIChjb250YWluZWVOb2RlICYmIGNvbnRhaW5lZU5vZGUgIT09IGNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lZU5vZGUgPSBjb250YWluZWVOb2RlLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIChjb250YWluZWVOb2RlID09PSBjb250YWluZXIpO1xufTtcblxuLy8gVGhpcyBtYXNrcyBzb21lIG51bWVyaWMgaXNzdWVzIGluIG9sZGVyIHZlcnNpb25zIG9mIEZpcmVmb3gsXG4vLyB3aGVyZSAxLjAvTWF0aC5wb3coMTAsMikgIT0gTWF0aC5wb3coMTAsLTIpLlxuLyoqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyKTpudW1iZXJ9ICovXG5leHBvcnQgZnVuY3Rpb24gcG93KGJhc2UsIGV4cCkge1xuICBpZiAoZXhwIDwgMCkge1xuICAgIHJldHVybiAxLjAgLyBNYXRoLnBvdyhiYXNlLCAtZXhwKTtcbiAgfVxuICByZXR1cm4gTWF0aC5wb3coYmFzZSwgZXhwKTtcbn07XG5cbnZhciBSR0JBX1JFID0gL15yZ2JhP1xcKChcXGR7MSwzfSksXFxzKihcXGR7MSwzfSksXFxzKihcXGR7MSwzfSkoPzosXFxzKihbMDFdKD86XFwuXFxkKyk/KSk/XFwpJC87XG5cbi8qKlxuICogSGVscGVyIGZvciB0b1JHQl8gd2hpY2ggcGFyc2VzIHN0cmluZ3Mgb2YgdGhlIGZvcm06XG4gKiByZ2IoMTIzLCA0NSwgNjcpXG4gKiByZ2JhKDEyMywgNDUsIDY3LCAwLjUpXG4gKiBAcmV0dXJuIHBhcnNlZCB7cixnLGIsYT99IHR1cGxlIG9yIG51bGwuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUkdCQShyZ2JTdHIpIHtcbiAgdmFyIGJpdHMgPSBSR0JBX1JFLmV4ZWMocmdiU3RyKTtcbiAgaWYgKCFiaXRzKSByZXR1cm4gbnVsbDtcbiAgdmFyIHIgPSBwYXJzZUludChiaXRzWzFdLCAxMCksXG4gICAgICBnID0gcGFyc2VJbnQoYml0c1syXSwgMTApLFxuICAgICAgYiA9IHBhcnNlSW50KGJpdHNbM10sIDEwKTtcbiAgaWYgKGJpdHNbNF0pIHtcbiAgICByZXR1cm4ge3I6IHIsIGc6IGcsIGI6IGIsIGE6IHBhcnNlRmxvYXQoYml0c1s0XSl9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7cjogciwgZzogZywgYjogYn07XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbnkgdmFsaWQgQ1NTIGNvbG9yIChoZXgsIHJnYigpLCBuYW1lZCBjb2xvcikgdG8gYW4gUkdCIHR1cGxlLlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gY29sb3JTdHIgQW55IHZhbGlkIENTUyBjb2xvciBzdHJpbmcuXG4gKiBAcmV0dXJuIHt7cjpudW1iZXIsZzpudW1iZXIsYjpudW1iZXIsYTpudW1iZXI/fX0gUGFyc2VkIFJHQiB0dXBsZS5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JHQl8oY29sb3JTdHIpIHtcbiAgLy8gU3RyYXRlZ3k6IEZpcnN0IHRyeSB0byBwYXJzZSBjb2xvclN0ciBkaXJlY3RseS4gVGhpcyBpcyBmYXN0ICYgYXZvaWRzIERPTVxuICAvLyBtYW5pcHVsYXRpb24uICBJZiB0aGF0IGZhaWxzIChlLmcuIGZvciBuYW1lZCBjb2xvcnMgbGlrZSAncmVkJyksIHRoZW5cbiAgLy8gY3JlYXRlIGEgaGlkZGVuIERPTSBlbGVtZW50IGFuZCBwYXJzZSBpdHMgY29tcHV0ZWQgY29sb3IuXG4gIHZhciByZ2IgPSBwYXJzZVJHQkEoY29sb3JTdHIpO1xuICBpZiAocmdiKSByZXR1cm4gcmdiO1xuXG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yU3RyO1xuICBkaXYuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gIHZhciByZ2JTdHIgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkaXYsIG51bGwpLmJhY2tncm91bmRDb2xvcjtcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICByZXR1cm4gcGFyc2VSR0JBKHJnYlN0cik7XG59O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSAmbHQ7Y2FudmFzJmd0OyB0YWcuXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50PX0gb3B0X2NhbnZhc0VsZW1lbnQgUGFzcyBhIGNhbnZhcyBlbGVtZW50IGFzIGFuXG4gKiAgICAgb3B0aW1pemF0aW9uIGlmIHlvdSBoYXZlIG9uZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgY2FudmFzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDYW52YXNTdXBwb3J0ZWQob3B0X2NhbnZhc0VsZW1lbnQpIHtcbiAgdHJ5IHtcbiAgICB2YXIgY2FudmFzID0gb3B0X2NhbnZhc0VsZW1lbnQgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIHZhbHVlIGFzIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLiBUaGlzIGlzIGxpa2UgdGhlIHBhcnNlRmxvYXQoKVxuICogYnVpbHQtaW4sIGJ1dCB3aXRoIGEgZmV3IGRpZmZlcmVuY2VzOlxuICogLSB0aGUgZW1wdHkgc3RyaW5nIGlzIHBhcnNlZCBhcyBudWxsLCByYXRoZXIgdGhhbiBOYU4uXG4gKiAtIGlmIHRoZSBzdHJpbmcgY2Fubm90IGJlIHBhcnNlZCBhdCBhbGwsIGFuIGVycm9yIGlzIGxvZ2dlZC5cbiAqIElmIHRoZSBzdHJpbmcgY2FuJ3QgYmUgcGFyc2VkLCB0aGlzIG1ldGhvZCByZXR1cm5zIG51bGwuXG4gKiBAcGFyYW0ge3N0cmluZ30geCBUaGUgc3RyaW5nIHRvIGJlIHBhcnNlZFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfbGluZV9ubyBUaGUgbGluZSBudW1iZXIgZnJvbSB3aGljaCB0aGUgc3RyaW5nIGNvbWVzLlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbGluZSBUaGUgdGV4dCBvZiB0aGUgbGluZSBmcm9tIHdoaWNoIHRoZSBzdHJpbmcgY29tZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZsb2F0Xyh4LCBvcHRfbGluZV9ubywgb3B0X2xpbmUpIHtcbiAgdmFyIHZhbCA9IHBhcnNlRmxvYXQoeCk7XG4gIGlmICghaXNOYU4odmFsKSkgcmV0dXJuIHZhbDtcblxuICAvLyBUcnkgdG8gZmlndXJlIG91dCB3aGF0IGhhcHBlZW5kLlxuICAvLyBJZiB0aGUgdmFsdWUgaXMgdGhlIGVtcHR5IHN0cmluZywgcGFyc2UgaXQgYXMgbnVsbC5cbiAgaWYgKC9eICokLy50ZXN0KHgpKSByZXR1cm4gbnVsbDtcblxuICAvLyBJZiBpdCB3YXMgYWN0dWFsbHkgXCJOYU5cIiwgcmV0dXJuIGl0IGFzIE5hTi5cbiAgaWYgKC9eICpuYW4gKiQvaS50ZXN0KHgpKSByZXR1cm4gTmFOO1xuXG4gIC8vIExvb2tzIGxpa2UgYSBwYXJzaW5nIGVycm9yLlxuICB2YXIgbXNnID0gXCJVbmFibGUgdG8gcGFyc2UgJ1wiICsgeCArIFwiJyBhcyBhIG51bWJlclwiO1xuICBpZiAob3B0X2xpbmUgIT09IHVuZGVmaW5lZCAmJiBvcHRfbGluZV9ubyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbXNnICs9IFwiIG9uIGxpbmUgXCIgKyAoMSsob3B0X2xpbmVfbm98fDApKSArIFwiICgnXCIgKyBvcHRfbGluZSArIFwiJykgb2YgQ1NWLlwiO1xuICB9XG4gIGNvbnNvbGUuZXJyb3IobXNnKTtcblxuICByZXR1cm4gbnVsbDtcbn07XG5cblxuLy8gTGFiZWwgY29uc3RhbnRzIGZvciB0aGUgbGFiZWxzS01CIGFuZCBsYWJlbHNLTUcyIG9wdGlvbnMuXG4vLyAoaS5lLiAnMTAwMDAwJyAtPiAnMTAwSycpXG52YXIgS01CX0xBQkVMUyA9IFsgJ0snLCAnTScsICdCJywgJ1QnLCAnUScgXTtcbnZhciBLTUcyX0JJR19MQUJFTFMgPSBbICdrJywgJ00nLCAnRycsICdUJywgJ1AnLCAnRScsICdaJywgJ1knIF07XG52YXIgS01HMl9TTUFMTF9MQUJFTFMgPSBbICdtJywgJ3UnLCAnbicsICdwJywgJ2YnLCAnYScsICd6JywgJ3knIF07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJldHVybiBhIHN0cmluZyB2ZXJzaW9uIG9mIGEgbnVtYmVyLiBUaGlzIHJlc3BlY3RzIHRoZSBkaWdpdHNBZnRlckRlY2ltYWxcbiAqIGFuZCBtYXhOdW1iZXJXaWR0aCBvcHRpb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIG51bWJlciB0byBiZSBmb3JtYXR0ZWRcbiAqIEBwYXJhbSB7RHlncmFwaH0gb3B0cyBBbiBvcHRpb25zIHZpZXdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclZhbHVlRm9ybWF0dGVyKHgsIG9wdHMpIHtcbiAgdmFyIHNpZ0ZpZ3MgPSBvcHRzKCdzaWdGaWdzJyk7XG5cbiAgaWYgKHNpZ0ZpZ3MgIT09IG51bGwpIHtcbiAgICAvLyBVc2VyIGhhcyBvcHRlZCBmb3IgYSBmaXhlZCBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZmlndXJlcy5cbiAgICByZXR1cm4gZmxvYXRGb3JtYXQoeCwgc2lnRmlncyk7XG4gIH1cblxuICB2YXIgZGlnaXRzID0gb3B0cygnZGlnaXRzQWZ0ZXJEZWNpbWFsJyk7XG4gIHZhciBtYXhOdW1iZXJXaWR0aCA9IG9wdHMoJ21heE51bWJlcldpZHRoJyk7XG5cbiAgdmFyIGttYiA9IG9wdHMoJ2xhYmVsc0tNQicpO1xuICB2YXIga21nMiA9IG9wdHMoJ2xhYmVsc0tNRzInKTtcblxuICB2YXIgbGFiZWw7XG5cbiAgLy8gc3dpdGNoIHRvIHNjaWVudGlmaWMgbm90YXRpb24gaWYgd2UgdW5kZXJmbG93IG9yIG92ZXJmbG93IGZpeGVkIGRpc3BsYXkuXG4gIGlmICh4ICE9PSAwLjAgJiZcbiAgICAgIChNYXRoLmFicyh4KSA+PSBNYXRoLnBvdygxMCwgbWF4TnVtYmVyV2lkdGgpIHx8XG4gICAgICAgTWF0aC5hYnMoeCkgPCBNYXRoLnBvdygxMCwgLWRpZ2l0cykpKSB7XG4gICAgbGFiZWwgPSB4LnRvRXhwb25lbnRpYWwoZGlnaXRzKTtcbiAgfSBlbHNlIHtcbiAgICBsYWJlbCA9ICcnICsgcm91bmRfKHgsIGRpZ2l0cyk7XG4gIH1cblxuICBpZiAoa21iIHx8IGttZzIpIHtcbiAgICB2YXIgaztcbiAgICB2YXIga19sYWJlbHMgPSBbXTtcbiAgICB2YXIgbV9sYWJlbHMgPSBbXTtcbiAgICBpZiAoa21iKSB7XG4gICAgICBrID0gMTAwMDtcbiAgICAgIGtfbGFiZWxzID0gS01CX0xBQkVMUztcbiAgICB9XG4gICAgaWYgKGttZzIpIHtcbiAgICAgIGlmIChrbWIpIGNvbnNvbGUud2FybihcIlNldHRpbmcgYm90aCBsYWJlbHNLTUIgYW5kIGxhYmVsc0tNRzIuIFBpY2sgb25lIVwiKTtcbiAgICAgIGsgPSAxMDI0O1xuICAgICAga19sYWJlbHMgPSBLTUcyX0JJR19MQUJFTFM7XG4gICAgICBtX2xhYmVscyA9IEtNRzJfU01BTExfTEFCRUxTO1xuICAgIH1cblxuICAgIHZhciBhYnN4ID0gTWF0aC5hYnMoeCk7XG4gICAgdmFyIG4gPSBwb3coaywga19sYWJlbHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBqID0ga19sYWJlbHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0sIG4gLz0gaykge1xuICAgICAgaWYgKGFic3ggPj0gbikge1xuICAgICAgICBsYWJlbCA9IHJvdW5kXyh4IC8gbiwgZGlnaXRzKSArIGtfbGFiZWxzW2pdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGttZzIpIHtcbiAgICAgIC8vIFRPRE8oZGFudmspOiBjbGVhbiB1cCB0aGlzIGxvZ2ljLiBXaHkgc28gZGlmZmVyZW50IHRoYW4ga21iP1xuICAgICAgdmFyIHhfcGFydHMgPSBTdHJpbmcoeC50b0V4cG9uZW50aWFsKCkpLnNwbGl0KCdlLScpO1xuICAgICAgaWYgKHhfcGFydHMubGVuZ3RoID09PSAyICYmIHhfcGFydHNbMV0gPj0gMyAmJiB4X3BhcnRzWzFdIDw9IDI0KSB7XG4gICAgICAgIGlmICh4X3BhcnRzWzFdICUgMyA+IDApIHtcbiAgICAgICAgICBsYWJlbCA9IHJvdW5kXyh4X3BhcnRzWzBdIC9cbiAgICAgICAgICAgICAgcG93KDEwLCAoeF9wYXJ0c1sxXSAlIDMpKSxcbiAgICAgICAgICAgICAgZGlnaXRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYWJlbCA9IE51bWJlcih4X3BhcnRzWzBdKS50b0ZpeGVkKDIpO1xuICAgICAgICB9XG4gICAgICAgIGxhYmVsICs9IG1fbGFiZWxzW01hdGguZmxvb3IoeF9wYXJ0c1sxXSAvIDMpIC0gMV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxhYmVsO1xufTtcblxuLyoqXG4gKiB2YXJpYW50IGZvciB1c2UgYXMgYW4gYXhpc0xhYmVsRm9ybWF0dGVyLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bWJlckF4aXNMYWJlbEZvcm1hdHRlcih4LCBncmFudWxhcml0eSwgb3B0cykge1xuICByZXR1cm4gbnVtYmVyVmFsdWVGb3JtYXR0ZXIuY2FsbCh0aGlzLCB4LCBvcHRzKTtcbn07XG5cbi8qKlxuICogQHR5cGUgeyFBcnJheS48c3RyaW5nPn1cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnRcbiAqL1xudmFyIFNIT1JUX01PTlRIX05BTUVTXyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuXG4vKipcbiAqIENvbnZlcnQgYSBKUyBkYXRlIHRvIGEgc3RyaW5nIGFwcHJvcHJpYXRlIHRvIGRpc3BsYXkgb24gYW4gYXhpcyB0aGF0XG4gKiBpcyBkaXNwbGF5aW5nIHZhbHVlcyBhdCB0aGUgc3RhdGVkIGdyYW51bGFyaXR5LiBUaGlzIHJlc3BlY3RzIHRoZVxuICogbGFiZWxzVVRDIG9wdGlvbi5cbiAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBUaGUgZGF0ZSB0byBmb3JtYXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBncmFudWxhcml0eSBPbmUgb2YgdGhlIER5Z3JhcGggZ3JhbnVsYXJpdHkgY29uc3RhbnRzXG4gKiBAcGFyYW0ge0R5Z3JhcGh9IG9wdHMgQW4gb3B0aW9ucyB2aWV3XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBkYXRlIGZvcm1hdHRlZCBhcyBsb2NhbCB0aW1lXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0ZUF4aXNMYWJlbEZvcm1hdHRlcihkYXRlLCBncmFudWxhcml0eSwgb3B0cykge1xuICB2YXIgdXRjID0gb3B0cygnbGFiZWxzVVRDJyk7XG4gIHZhciBhY2Nlc3NvcnMgPSB1dGMgPyBEYXRlQWNjZXNzb3JzVVRDIDogRGF0ZUFjY2Vzc29yc0xvY2FsO1xuXG4gIHZhciB5ZWFyID0gYWNjZXNzb3JzLmdldEZ1bGxZZWFyKGRhdGUpLFxuICAgICAgbW9udGggPSBhY2Nlc3NvcnMuZ2V0TW9udGgoZGF0ZSksXG4gICAgICBkYXkgPSBhY2Nlc3NvcnMuZ2V0RGF0ZShkYXRlKSxcbiAgICAgIGhvdXJzID0gYWNjZXNzb3JzLmdldEhvdXJzKGRhdGUpLFxuICAgICAgbWlucyA9IGFjY2Vzc29ycy5nZXRNaW51dGVzKGRhdGUpLFxuICAgICAgc2VjcyA9IGFjY2Vzc29ycy5nZXRTZWNvbmRzKGRhdGUpLFxuICAgICAgbWlsbGlzID0gYWNjZXNzb3JzLmdldE1pbGxpc2Vjb25kcyhkYXRlKTtcblxuICBpZiAoZ3JhbnVsYXJpdHkgPj0gRHlncmFwaFRpY2tlcnMuR3JhbnVsYXJpdHkuREVDQURBTCkge1xuICAgIHJldHVybiAnJyArIHllYXI7XG4gIH0gZWxzZSBpZiAoZ3JhbnVsYXJpdHkgPj0gRHlncmFwaFRpY2tlcnMuR3JhbnVsYXJpdHkuTU9OVEhMWSkge1xuICAgIHJldHVybiBTSE9SVF9NT05USF9OQU1FU19bbW9udGhdICsgJyYjMTYwOycgKyB5ZWFyO1xuICB9IGVsc2Uge1xuICAgIHZhciBmcmFjID0gaG91cnMgKiAzNjAwICsgbWlucyAqIDYwICsgc2VjcyArIDFlLTMgKiBtaWxsaXM7XG4gICAgaWYgKGZyYWMgPT09IDAgfHwgZ3JhbnVsYXJpdHkgPj0gRHlncmFwaFRpY2tlcnMuR3JhbnVsYXJpdHkuREFJTFkpIHtcbiAgICAgIC8vIGUuZy4gJzIxIEphbicgKCVkJWIpXG4gICAgICByZXR1cm4gemVyb3BhZChkYXkpICsgJyYjMTYwOycgKyBTSE9SVF9NT05USF9OQU1FU19bbW9udGhdO1xuICAgIH0gZWxzZSBpZiAoZ3JhbnVsYXJpdHkgPCBEeWdyYXBoVGlja2Vycy5HcmFudWxhcml0eS5TRUNPTkRMWSkge1xuICAgICAgLy8gZS5nLiA0MC4zMTAgKG1lYW5pbmcgNDAgc2Vjb25kcyBhbmQgMzEwIG1pbGxpc2Vjb25kcylcbiAgICAgIHZhciBzdHIgPSBcIlwiICsgbWlsbGlzO1xuICAgICAgcmV0dXJuIHplcm9wYWQoc2VjcykgKyBcIi5cIiArICgnMDAwJytzdHIpLnN1YnN0cmluZyhzdHIubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGdyYW51bGFyaXR5ID4gRHlncmFwaFRpY2tlcnMuR3JhbnVsYXJpdHkuTUlOVVRFTFkpIHtcbiAgICAgIHJldHVybiBobXNTdHJpbmdfKGhvdXJzLCBtaW5zLCBzZWNzLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGhtc1N0cmluZ18oaG91cnMsIG1pbnMsIHNlY3MsIG1pbGxpcyk7XG4gICAgfVxuICB9XG59O1xuLy8gYWxpYXMgaW4gY2FzZSBhbnlvbmUgaXMgcmVmZXJlbmNpbmcgdGhlIG9sZCBtZXRob2QuXG4vLyBEeWdyYXBoLmRhdGVBeGlzRm9ybWF0dGVyID0gRHlncmFwaC5kYXRlQXhpc0xhYmVsRm9ybWF0dGVyO1xuXG4vKipcbiAqIFJldHVybiBhIHN0cmluZyB2ZXJzaW9uIG9mIGEgSlMgZGF0ZSBmb3IgYSB2YWx1ZSBsYWJlbC4gVGhpcyByZXNwZWN0cyB0aGVcbiAqIGxhYmVsc1VUQyBvcHRpb24uXG4gKiBAcGFyYW0ge0RhdGV9IGRhdGUgVGhlIGRhdGUgdG8gYmUgZm9ybWF0dGVkXG4gKiBAcGFyYW0ge0R5Z3JhcGh9IG9wdHMgQW4gb3B0aW9ucyB2aWV3XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0ZVZhbHVlRm9ybWF0dGVyKGQsIG9wdHMpIHtcbiAgcmV0dXJuIGRhdGVTdHJpbmdfKGQsIG9wdHMoJ2xhYmVsc1VUQycpKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLXV0aWxzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__datahandler__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dygraph_layout__ = __webpack_require__(11);\n/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler base implementation for the \"bar\" \n * data formats. This implementation must be extended and the\n * extractSeries and rollingAverage must be implemented.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n/*global DygraphLayout:false */\n\n\n\n\n\n/**\n * @constructor\n * @extends {Dygraph.DataHandler}\n */\nvar BarsHandler = function BarsHandler() {\n  __WEBPACK_IMPORTED_MODULE_0__datahandler__[\"a\" /* default */].call(this);\n};\nBarsHandler.prototype = new __WEBPACK_IMPORTED_MODULE_0__datahandler__[\"a\" /* default */]();\n\n// TODO(danvk): figure out why the jsdoc has to be copy/pasted from superclass.\n//   (I get closure compiler errors if this isn't here.)\n/**\n * @override\n * @param {!Array.<Array>} rawData The raw data passed into dygraphs where \n *     rawData[i] = [x,ySeries1,...,ySeriesN].\n * @param {!number} seriesIndex Index of the series to extract. All other\n *     series should be ignored.\n * @param {!DygraphOptions} options Dygraph options.\n * @return {Array.<[!number,?number,?]>} The series in the unified data format\n *     where series[i] = [x,y,{extras}]. \n */\nBarsHandler.prototype.extractSeries = function (rawData, seriesIndex, options) {\n  // Not implemented here must be extended\n};\n\n/**\n * @override\n * @param {!Array.<[!number,?number,?]>} series The series in the unified \n *          data format where series[i] = [x,y,{extras}].\n * @param {!number} rollPeriod The number of points over which to average the data\n * @param {!DygraphOptions} options The dygraph options.\n * TODO(danvk): be more specific than \"Array\" here.\n * @return {!Array.<[!number,?number,?]>} the rolled series.\n */\nBarsHandler.prototype.rollingAverage = function (series, rollPeriod, options) {\n  // Not implemented here, must be extended.\n};\n\n/** @inheritDoc */\nBarsHandler.prototype.onPointsCreated_ = function (series, points) {\n  for (var i = 0; i < series.length; ++i) {\n    var item = series[i];\n    var point = points[i];\n    point.y_top = NaN;\n    point.y_bottom = NaN;\n    point.yval_minus = __WEBPACK_IMPORTED_MODULE_0__datahandler__[\"a\" /* default */].parseFloat(item[2][0]);\n    point.yval_plus = __WEBPACK_IMPORTED_MODULE_0__datahandler__[\"a\" /* default */].parseFloat(item[2][1]);\n  }\n};\n\n/** @inheritDoc */\nBarsHandler.prototype.getExtremeYValues = function (series, dateWindow, options) {\n  var minY = null,\n      maxY = null,\n      y;\n\n  var firstIdx = 0;\n  var lastIdx = series.length - 1;\n\n  for (var j = firstIdx; j <= lastIdx; j++) {\n    y = series[j][1];\n    if (y === null || isNaN(y)) continue;\n\n    var low = series[j][2][0];\n    var high = series[j][2][1];\n\n    if (low > y) low = y; // this can happen with custom bars,\n    if (high < y) high = y; // e.g. in tests/custom-bars.html\n\n    if (maxY === null || high > maxY) maxY = high;\n    if (minY === null || low < minY) minY = low;\n  }\n\n  return [minY, maxY];\n};\n\n/** @inheritDoc */\nBarsHandler.prototype.onLineEvaluated = function (points, axis, logscale) {\n  var point;\n  for (var j = 0; j < points.length; j++) {\n    // Copy over the error terms\n    point = points[j];\n    point.y_top = __WEBPACK_IMPORTED_MODULE_1__dygraph_layout__[\"a\" /* default */].calcYNormal_(axis, point.yval_minus, logscale);\n    point.y_bottom = __WEBPACK_IMPORTED_MODULE_1__dygraph_layout__[\"a\" /* default */].calcYNormal_(axis, point.yval_plus, logscale);\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (BarsHandler);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9iYXJzLmpzPzhmNGYiXSwibmFtZXMiOlsiQmFyc0hhbmRsZXIiLCJEeWdyYXBoRGF0YUhhbmRsZXIiLCJjYWxsIiwicHJvdG90eXBlIiwiZXh0cmFjdFNlcmllcyIsInJhd0RhdGEiLCJzZXJpZXNJbmRleCIsIm9wdGlvbnMiLCJyb2xsaW5nQXZlcmFnZSIsInNlcmllcyIsInJvbGxQZXJpb2QiLCJvblBvaW50c0NyZWF0ZWRfIiwicG9pbnRzIiwiaSIsImxlbmd0aCIsIml0ZW0iLCJwb2ludCIsInlfdG9wIiwiTmFOIiwieV9ib3R0b20iLCJ5dmFsX21pbnVzIiwicGFyc2VGbG9hdCIsInl2YWxfcGx1cyIsImdldEV4dHJlbWVZVmFsdWVzIiwiZGF0ZVdpbmRvdyIsIm1pblkiLCJtYXhZIiwieSIsImZpcnN0SWR4IiwibGFzdElkeCIsImoiLCJpc05hTiIsImxvdyIsImhpZ2giLCJvbkxpbmVFdmFsdWF0ZWQiLCJheGlzIiwibG9nc2NhbGUiLCJEeWdyYXBoTGF5b3V0IiwiY2FsY1lOb3JtYWxfIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFBQTs7Ozs7O0FBTUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7OztBQUlBLElBQUlBLGNBQWMsU0FBZEEsV0FBYyxHQUFXO0FBQzNCQyxFQUFBLDZEQUFBQSxDQUFtQkMsSUFBbkIsQ0FBd0IsSUFBeEI7QUFDRCxDQUZEO0FBR0FGLFlBQVlHLFNBQVosR0FBd0IsSUFBSSw2REFBSixFQUF4Qjs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQUgsWUFBWUcsU0FBWixDQUFzQkMsYUFBdEIsR0FBc0MsVUFBU0MsT0FBVCxFQUFrQkMsV0FBbEIsRUFBK0JDLE9BQS9CLEVBQXdDO0FBQzVFO0FBQ0QsQ0FGRDs7QUFJQTs7Ozs7Ozs7O0FBU0FQLFlBQVlHLFNBQVosQ0FBc0JLLGNBQXRCLEdBQ0ksVUFBU0MsTUFBVCxFQUFpQkMsVUFBakIsRUFBNkJILE9BQTdCLEVBQXNDO0FBQ3hDO0FBQ0QsQ0FIRDs7QUFLQTtBQUNBUCxZQUFZRyxTQUFaLENBQXNCUSxnQkFBdEIsR0FBeUMsVUFBU0YsTUFBVCxFQUFpQkcsTUFBakIsRUFBeUI7QUFDaEUsT0FBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlKLE9BQU9LLE1BQTNCLEVBQW1DLEVBQUVELENBQXJDLEVBQXdDO0FBQ3RDLFFBQUlFLE9BQU9OLE9BQU9JLENBQVAsQ0FBWDtBQUNBLFFBQUlHLFFBQVFKLE9BQU9DLENBQVAsQ0FBWjtBQUNBRyxVQUFNQyxLQUFOLEdBQWNDLEdBQWQ7QUFDQUYsVUFBTUcsUUFBTixHQUFpQkQsR0FBakI7QUFDQUYsVUFBTUksVUFBTixHQUFtQiw2REFBQW5CLENBQW1Cb0IsVUFBbkIsQ0FBOEJOLEtBQUssQ0FBTCxFQUFRLENBQVIsQ0FBOUIsQ0FBbkI7QUFDQUMsVUFBTU0sU0FBTixHQUFrQiw2REFBQXJCLENBQW1Cb0IsVUFBbkIsQ0FBOEJOLEtBQUssQ0FBTCxFQUFRLENBQVIsQ0FBOUIsQ0FBbEI7QUFDRDtBQUNGLENBVEQ7O0FBV0E7QUFDQWYsWUFBWUcsU0FBWixDQUFzQm9CLGlCQUF0QixHQUEwQyxVQUFTZCxNQUFULEVBQWlCZSxVQUFqQixFQUE2QmpCLE9BQTdCLEVBQXNDO0FBQzlFLE1BQUlrQixPQUFPLElBQVg7QUFBQSxNQUFpQkMsT0FBTyxJQUF4QjtBQUFBLE1BQThCQyxDQUE5Qjs7QUFFQSxNQUFJQyxXQUFXLENBQWY7QUFDQSxNQUFJQyxVQUFVcEIsT0FBT0ssTUFBUCxHQUFnQixDQUE5Qjs7QUFFQSxPQUFNLElBQUlnQixJQUFJRixRQUFkLEVBQXdCRSxLQUFLRCxPQUE3QixFQUFzQ0MsR0FBdEMsRUFBMkM7QUFDekNILFFBQUlsQixPQUFPcUIsQ0FBUCxFQUFVLENBQVYsQ0FBSjtBQUNBLFFBQUlILE1BQU0sSUFBTixJQUFjSSxNQUFNSixDQUFOLENBQWxCLEVBQTRCOztBQUU1QixRQUFJSyxNQUFNdkIsT0FBT3FCLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixDQUFWO0FBQ0EsUUFBSUcsT0FBT3hCLE9BQU9xQixDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsQ0FBWDs7QUFFQSxRQUFJRSxNQUFNTCxDQUFWLEVBQWFLLE1BQU1MLENBQU4sQ0FQNEIsQ0FPbkI7QUFDdEIsUUFBSU0sT0FBT04sQ0FBWCxFQUFjTSxPQUFPTixDQUFQLENBUjJCLENBUWpCOztBQUV4QixRQUFJRCxTQUFTLElBQVQsSUFBaUJPLE9BQU9QLElBQTVCLEVBQWtDQSxPQUFPTyxJQUFQO0FBQ2xDLFFBQUlSLFNBQVMsSUFBVCxJQUFpQk8sTUFBTVAsSUFBM0IsRUFBaUNBLE9BQU9PLEdBQVA7QUFDbEM7O0FBRUQsU0FBTyxDQUFFUCxJQUFGLEVBQVFDLElBQVIsQ0FBUDtBQUNELENBckJEOztBQXVCQTtBQUNBMUIsWUFBWUcsU0FBWixDQUFzQitCLGVBQXRCLEdBQXdDLFVBQVN0QixNQUFULEVBQWlCdUIsSUFBakIsRUFBdUJDLFFBQXZCLEVBQWlDO0FBQ3ZFLE1BQUlwQixLQUFKO0FBQ0EsT0FBSyxJQUFJYyxJQUFJLENBQWIsRUFBZ0JBLElBQUlsQixPQUFPRSxNQUEzQixFQUFtQ2dCLEdBQW5DLEVBQXdDO0FBQ3RDO0FBQ0FkLFlBQVFKLE9BQU9rQixDQUFQLENBQVI7QUFDQWQsVUFBTUMsS0FBTixHQUFjLGdFQUFBb0IsQ0FBY0MsWUFBZCxDQUEyQkgsSUFBM0IsRUFBaUNuQixNQUFNSSxVQUF2QyxFQUFtRGdCLFFBQW5ELENBQWQ7QUFDQXBCLFVBQU1HLFFBQU4sR0FBaUIsZ0VBQUFrQixDQUFjQyxZQUFkLENBQTJCSCxJQUEzQixFQUFpQ25CLE1BQU1NLFNBQXZDLEVBQWtEYyxRQUFsRCxDQUFqQjtBQUNEO0FBQ0YsQ0FSRDs7QUFVQSx5REFBZXBDLFdBQWYiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEzIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEYXRhSGFuZGxlciBiYXNlIGltcGxlbWVudGF0aW9uIGZvciB0aGUgXCJiYXJcIiBcbiAqIGRhdGEgZm9ybWF0cy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBtdXN0IGJlIGV4dGVuZGVkIGFuZCB0aGVcbiAqIGV4dHJhY3RTZXJpZXMgYW5kIHJvbGxpbmdBdmVyYWdlIG11c3QgYmUgaW1wbGVtZW50ZWQuXG4gKiBAYXV0aG9yIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cbi8qZ2xvYmFsIER5Z3JhcGhMYXlvdXQ6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRHlncmFwaERhdGFIYW5kbGVyIGZyb20gJy4vZGF0YWhhbmRsZXInO1xuaW1wb3J0IER5Z3JhcGhMYXlvdXQgZnJvbSAnLi4vZHlncmFwaC1sYXlvdXQnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0R5Z3JhcGguRGF0YUhhbmRsZXJ9XG4gKi9cbnZhciBCYXJzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICBEeWdyYXBoRGF0YUhhbmRsZXIuY2FsbCh0aGlzKTtcbn07XG5CYXJzSGFuZGxlci5wcm90b3R5cGUgPSBuZXcgRHlncmFwaERhdGFIYW5kbGVyKCk7XG5cbi8vIFRPRE8oZGFudmspOiBmaWd1cmUgb3V0IHdoeSB0aGUganNkb2MgaGFzIHRvIGJlIGNvcHkvcGFzdGVkIGZyb20gc3VwZXJjbGFzcy5cbi8vICAgKEkgZ2V0IGNsb3N1cmUgY29tcGlsZXIgZXJyb3JzIGlmIHRoaXMgaXNuJ3QgaGVyZS4pXG4vKipcbiAqIEBvdmVycmlkZVxuICogQHBhcmFtIHshQXJyYXkuPEFycmF5Pn0gcmF3RGF0YSBUaGUgcmF3IGRhdGEgcGFzc2VkIGludG8gZHlncmFwaHMgd2hlcmUgXG4gKiAgICAgcmF3RGF0YVtpXSA9IFt4LHlTZXJpZXMxLC4uLix5U2VyaWVzTl0uXG4gKiBAcGFyYW0geyFudW1iZXJ9IHNlcmllc0luZGV4IEluZGV4IG9mIHRoZSBzZXJpZXMgdG8gZXh0cmFjdC4gQWxsIG90aGVyXG4gKiAgICAgc2VyaWVzIHNob3VsZCBiZSBpZ25vcmVkLlxuICogQHBhcmFtIHshRHlncmFwaE9wdGlvbnN9IG9wdGlvbnMgRHlncmFwaCBvcHRpb25zLlxuICogQHJldHVybiB7QXJyYXkuPFshbnVtYmVyLD9udW1iZXIsP10+fSBUaGUgc2VyaWVzIGluIHRoZSB1bmlmaWVkIGRhdGEgZm9ybWF0XG4gKiAgICAgd2hlcmUgc2VyaWVzW2ldID0gW3gseSx7ZXh0cmFzfV0uIFxuICovXG5CYXJzSGFuZGxlci5wcm90b3R5cGUuZXh0cmFjdFNlcmllcyA9IGZ1bmN0aW9uKHJhd0RhdGEsIHNlcmllc0luZGV4LCBvcHRpb25zKSB7XG4gIC8vIE5vdCBpbXBsZW1lbnRlZCBoZXJlIG11c3QgYmUgZXh0ZW5kZWRcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKiBAcGFyYW0geyFBcnJheS48WyFudW1iZXIsP251bWJlciw/XT59IHNlcmllcyBUaGUgc2VyaWVzIGluIHRoZSB1bmlmaWVkIFxuICogICAgICAgICAgZGF0YSBmb3JtYXQgd2hlcmUgc2VyaWVzW2ldID0gW3gseSx7ZXh0cmFzfV0uXG4gKiBAcGFyYW0geyFudW1iZXJ9IHJvbGxQZXJpb2QgVGhlIG51bWJlciBvZiBwb2ludHMgb3ZlciB3aGljaCB0byBhdmVyYWdlIHRoZSBkYXRhXG4gKiBAcGFyYW0geyFEeWdyYXBoT3B0aW9uc30gb3B0aW9ucyBUaGUgZHlncmFwaCBvcHRpb25zLlxuICogVE9ETyhkYW52ayk6IGJlIG1vcmUgc3BlY2lmaWMgdGhhbiBcIkFycmF5XCIgaGVyZS5cbiAqIEByZXR1cm4geyFBcnJheS48WyFudW1iZXIsP251bWJlciw/XT59IHRoZSByb2xsZWQgc2VyaWVzLlxuICovXG5CYXJzSGFuZGxlci5wcm90b3R5cGUucm9sbGluZ0F2ZXJhZ2UgPVxuICAgIGZ1bmN0aW9uKHNlcmllcywgcm9sbFBlcmlvZCwgb3B0aW9ucykge1xuICAvLyBOb3QgaW1wbGVtZW50ZWQgaGVyZSwgbXVzdCBiZSBleHRlbmRlZC5cbn07XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuQmFyc0hhbmRsZXIucHJvdG90eXBlLm9uUG9pbnRzQ3JlYXRlZF8gPSBmdW5jdGlvbihzZXJpZXMsIHBvaW50cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBpdGVtID0gc2VyaWVzW2ldO1xuICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcbiAgICBwb2ludC55X3RvcCA9IE5hTjtcbiAgICBwb2ludC55X2JvdHRvbSA9IE5hTjtcbiAgICBwb2ludC55dmFsX21pbnVzID0gRHlncmFwaERhdGFIYW5kbGVyLnBhcnNlRmxvYXQoaXRlbVsyXVswXSk7XG4gICAgcG9pbnQueXZhbF9wbHVzID0gRHlncmFwaERhdGFIYW5kbGVyLnBhcnNlRmxvYXQoaXRlbVsyXVsxXSk7XG4gIH1cbn07XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuQmFyc0hhbmRsZXIucHJvdG90eXBlLmdldEV4dHJlbWVZVmFsdWVzID0gZnVuY3Rpb24oc2VyaWVzLCBkYXRlV2luZG93LCBvcHRpb25zKSB7XG4gIHZhciBtaW5ZID0gbnVsbCwgbWF4WSA9IG51bGwsIHk7XG5cbiAgdmFyIGZpcnN0SWR4ID0gMDtcbiAgdmFyIGxhc3RJZHggPSBzZXJpZXMubGVuZ3RoIC0gMTtcblxuICBmb3IgKCB2YXIgaiA9IGZpcnN0SWR4OyBqIDw9IGxhc3RJZHg7IGorKykge1xuICAgIHkgPSBzZXJpZXNbal1bMV07XG4gICAgaWYgKHkgPT09IG51bGwgfHwgaXNOYU4oeSkpIGNvbnRpbnVlO1xuXG4gICAgdmFyIGxvdyA9IHNlcmllc1tqXVsyXVswXTtcbiAgICB2YXIgaGlnaCA9IHNlcmllc1tqXVsyXVsxXTtcblxuICAgIGlmIChsb3cgPiB5KSBsb3cgPSB5OyAvLyB0aGlzIGNhbiBoYXBwZW4gd2l0aCBjdXN0b20gYmFycyxcbiAgICBpZiAoaGlnaCA8IHkpIGhpZ2ggPSB5OyAvLyBlLmcuIGluIHRlc3RzL2N1c3RvbS1iYXJzLmh0bWxcblxuICAgIGlmIChtYXhZID09PSBudWxsIHx8IGhpZ2ggPiBtYXhZKSBtYXhZID0gaGlnaDtcbiAgICBpZiAobWluWSA9PT0gbnVsbCB8fCBsb3cgPCBtaW5ZKSBtaW5ZID0gbG93O1xuICB9XG5cbiAgcmV0dXJuIFsgbWluWSwgbWF4WSBdO1xufTtcblxuLyoqIEBpbmhlcml0RG9jICovXG5CYXJzSGFuZGxlci5wcm90b3R5cGUub25MaW5lRXZhbHVhdGVkID0gZnVuY3Rpb24ocG9pbnRzLCBheGlzLCBsb2dzY2FsZSkge1xuICB2YXIgcG9pbnQ7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgLy8gQ29weSBvdmVyIHRoZSBlcnJvciB0ZXJtc1xuICAgIHBvaW50ID0gcG9pbnRzW2pdO1xuICAgIHBvaW50LnlfdG9wID0gRHlncmFwaExheW91dC5jYWxjWU5vcm1hbF8oYXhpcywgcG9pbnQueXZhbF9taW51cywgbG9nc2NhbGUpO1xuICAgIHBvaW50LnlfYm90dG9tID0gRHlncmFwaExheW91dC5jYWxjWU5vcm1hbF8oYXhpcywgcG9pbnQueXZhbF9wbHVzLCBsb2dzY2FsZSk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJhcnNIYW5kbGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9keWdyYXBocy9zcmMvZGF0YWhhbmRsZXIvYmFycy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview This file contains the managment of data handlers\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n *\n * The idea is to define a common, generic data format that works for all data\n * structures supported by dygraphs. To make this possible, the DataHandler\n * interface is introduced. This makes it possible, that dygraph itself can work\n * with the same logic for every data type independent of the actual format and\n * the DataHandler takes care of the data format specific jobs.\n * DataHandlers are implemented for all data types supported by Dygraphs and\n * return Dygraphs compliant formats.\n * By default the correct DataHandler is chosen based on the options set.\n * Optionally the user may use his own DataHandler (similar to the plugin\n * system).\n *\n *\n * The unified data format returend by each handler is defined as so:\n * series[n][point] = [x,y,(extras)]\n *\n * This format contains the common basis that is needed to draw a simple line\n * series extended by optional extras for more complex graphing types. It\n * contains a primitive x value as first array entry, a primitive y value as\n * second array entry and an optional extras object for additional data needed.\n *\n * x must always be a number.\n * y must always be a number, NaN of type number or null.\n * extras is optional and must be interpreted by the DataHandler. It may be of\n * any type.\n *\n * In practice this might look something like this:\n * default: [x, yVal]\n * errorBar / customBar: [x, yVal, [yTopVariance, yBottomVariance] ]\n *\n */\n/*global Dygraph:false */\n/*global DygraphLayout:false */\n\n\n\n/**\n *\n * The data handler is responsible for all data specific operations. All of the\n * series data it receives and returns is always in the unified data format.\n * Initially the unified data is created by the extractSeries method\n * @constructor\n */\n\nvar DygraphDataHandler = function DygraphDataHandler() {};\n\nvar handler = DygraphDataHandler;\n\n/**\n * X-value array index constant for unified data samples.\n * @const\n * @type {number}\n */\nhandler.X = 0;\n\n/**\n * Y-value array index constant for unified data samples.\n * @const\n * @type {number}\n */\nhandler.Y = 1;\n\n/**\n * Extras-value array index constant for unified data samples.\n * @const\n * @type {number}\n */\nhandler.EXTRAS = 2;\n\n/**\n * Extracts one series from the raw data (a 2D array) into an array of the\n * unified data format.\n * This is where undesirable points (i.e. negative values on log scales and\n * missing values through which we wish to connect lines) are dropped.\n * TODO(danvk): the \"missing values\" bit above doesn't seem right.\n *\n * @param {!Array.<Array>} rawData The raw data passed into dygraphs where\n *     rawData[i] = [x,ySeries1,...,ySeriesN].\n * @param {!number} seriesIndex Index of the series to extract. All other\n *     series should be ignored.\n * @param {!DygraphOptions} options Dygraph options.\n * @return {Array.<[!number,?number,?]>} The series in the unified data format\n *     where series[i] = [x,y,{extras}].\n */\nhandler.prototype.extractSeries = function (rawData, seriesIndex, options) {};\n\n/**\n * Converts a series to a Point array.  The resulting point array must be\n * returned in increasing order of idx property.\n *\n * @param {!Array.<[!number,?number,?]>} series The series in the unified\n *          data format where series[i] = [x,y,{extras}].\n * @param {!string} setName Name of the series.\n * @param {!number} boundaryIdStart Index offset of the first point, equal to the\n *          number of skipped points left of the date window minimum (if any).\n * @return {!Array.<Dygraph.PointType>} List of points for this series.\n */\nhandler.prototype.seriesToPoints = function (series, setName, boundaryIdStart) {\n  // TODO(bhs): these loops are a hot-spot for high-point-count charts. In\n  // fact,\n  // on chrome+linux, they are 6 times more expensive than iterating through\n  // the\n  // points and drawing the lines. The brunt of the cost comes from allocating\n  // the |point| structures.\n  var points = [];\n  for (var i = 0; i < series.length; ++i) {\n    var item = series[i];\n    var yraw = item[1];\n    var yval = yraw === null ? null : handler.parseFloat(yraw);\n    var point = {\n      x: NaN,\n      y: NaN,\n      xval: handler.parseFloat(item[0]),\n      yval: yval,\n      name: setName, // TODO(danvk): is this really necessary?\n      idx: i + boundaryIdStart\n    };\n    points.push(point);\n  }\n  this.onPointsCreated_(series, points);\n  return points;\n};\n\n/**\n * Callback called for each series after the series points have been generated\n * which will later be used by the plotters to draw the graph.\n * Here data may be added to the seriesPoints which is needed by the plotters.\n * The indexes of series and points are in sync meaning the original data\n * sample for series[i] is points[i].\n *\n * @param {!Array.<[!number,?number,?]>} series The series in the unified\n *     data format where series[i] = [x,y,{extras}].\n * @param {!Array.<Dygraph.PointType>} points The corresponding points passed\n *     to the plotter.\n * @protected\n */\nhandler.prototype.onPointsCreated_ = function (series, points) {};\n\n/**\n * Calculates the rolling average of a data set.\n *\n * @param {!Array.<[!number,?number,?]>} series The series in the unified\n *          data format where series[i] = [x,y,{extras}].\n * @param {!number} rollPeriod The number of points over which to average the data\n * @param {!DygraphOptions} options The dygraph options.\n * @return {!Array.<[!number,?number,?]>} the rolled series.\n */\nhandler.prototype.rollingAverage = function (series, rollPeriod, options) {};\n\n/**\n * Computes the range of the data series (including confidence intervals).\n *\n * @param {!Array.<[!number,?number,?]>} series The series in the unified\n *     data format where series[i] = [x, y, {extras}].\n * @param {!Array.<number>} dateWindow The x-value range to display with\n *     the format: [min, max].\n * @param {!DygraphOptions} options The dygraph options.\n * @return {Array.<number>} The low and high extremes of the series in the\n *     given window with the format: [low, high].\n */\nhandler.prototype.getExtremeYValues = function (series, dateWindow, options) {};\n\n/**\n * Callback called for each series after the layouting data has been\n * calculated before the series is drawn. Here normalized positioning data\n * should be calculated for the extras of each point.\n *\n * @param {!Array.<Dygraph.PointType>} points The points passed to\n *          the plotter.\n * @param {!Object} axis The axis on which the series will be plotted.\n * @param {!boolean} logscale Weather or not to use a logscale.\n */\nhandler.prototype.onLineEvaluated = function (points, axis, logscale) {};\n\n/**\n * Optimized replacement for parseFloat, which was way too slow when almost\n * all values were type number, with few edge cases, none of which were strings.\n * @param {?number} val\n * @return {number}\n * @protected\n */\nhandler.parseFloat = function (val) {\n  // parseFloat(null) is NaN\n  if (val === null) {\n    return NaN;\n  }\n\n  // Assume it's a number or NaN. If it's something else, I'll be shocked.\n  return val;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DygraphDataHandler);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9kYXRhaGFuZGxlci5qcz82ZmRjIl0sIm5hbWVzIjpbIkR5Z3JhcGhEYXRhSGFuZGxlciIsImhhbmRsZXIiLCJYIiwiWSIsIkVYVFJBUyIsInByb3RvdHlwZSIsImV4dHJhY3RTZXJpZXMiLCJyYXdEYXRhIiwic2VyaWVzSW5kZXgiLCJvcHRpb25zIiwic2VyaWVzVG9Qb2ludHMiLCJzZXJpZXMiLCJzZXROYW1lIiwiYm91bmRhcnlJZFN0YXJ0IiwicG9pbnRzIiwiaSIsImxlbmd0aCIsIml0ZW0iLCJ5cmF3IiwieXZhbCIsInBhcnNlRmxvYXQiLCJwb2ludCIsIngiLCJOYU4iLCJ5IiwieHZhbCIsIm5hbWUiLCJpZHgiLCJwdXNoIiwib25Qb2ludHNDcmVhdGVkXyIsInJvbGxpbmdBdmVyYWdlIiwicm9sbFBlcmlvZCIsImdldEV4dHJlbWVZVmFsdWVzIiwiZGF0ZVdpbmRvdyIsIm9uTGluZUV2YWx1YXRlZCIsImF4aXMiLCJsb2dzY2FsZSIsInZhbCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQU1BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FBT0EsSUFBSUEscUJBQXFCLFNBQXJCQSxrQkFBcUIsR0FBWSxDQUNwQyxDQUREOztBQUdBLElBQUlDLFVBQVVELGtCQUFkOztBQUVBOzs7OztBQUtBQyxRQUFRQyxDQUFSLEdBQVksQ0FBWjs7QUFFQTs7Ozs7QUFLQUQsUUFBUUUsQ0FBUixHQUFZLENBQVo7O0FBRUE7Ozs7O0FBS0FGLFFBQVFHLE1BQVIsR0FBaUIsQ0FBakI7O0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQWVBSCxRQUFRSSxTQUFSLENBQWtCQyxhQUFsQixHQUFrQyxVQUFTQyxPQUFULEVBQWtCQyxXQUFsQixFQUErQkMsT0FBL0IsRUFBd0MsQ0FDekUsQ0FERDs7QUFHQTs7Ozs7Ozs7Ozs7QUFXQVIsUUFBUUksU0FBUixDQUFrQkssY0FBbEIsR0FBbUMsVUFBU0MsTUFBVCxFQUFpQkMsT0FBakIsRUFBMEJDLGVBQTFCLEVBQTJDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUlDLFNBQVMsRUFBYjtBQUNBLE9BQU0sSUFBSUMsSUFBSSxDQUFkLEVBQWlCQSxJQUFJSixPQUFPSyxNQUE1QixFQUFvQyxFQUFFRCxDQUF0QyxFQUF5QztBQUN2QyxRQUFJRSxPQUFPTixPQUFPSSxDQUFQLENBQVg7QUFDQSxRQUFJRyxPQUFPRCxLQUFLLENBQUwsQ0FBWDtBQUNBLFFBQUlFLE9BQU9ELFNBQVMsSUFBVCxHQUFnQixJQUFoQixHQUF1QmpCLFFBQVFtQixVQUFSLENBQW1CRixJQUFuQixDQUFsQztBQUNBLFFBQUlHLFFBQVE7QUFDVkMsU0FBSUMsR0FETTtBQUVWQyxTQUFJRCxHQUZNO0FBR1ZFLFlBQU94QixRQUFRbUIsVUFBUixDQUFtQkgsS0FBSyxDQUFMLENBQW5CLENBSEc7QUFJVkUsWUFBT0EsSUFKRztBQUtWTyxZQUFPZCxPQUxHLEVBS007QUFDaEJlLFdBQU1aLElBQUlGO0FBTkEsS0FBWjtBQVFBQyxXQUFPYyxJQUFQLENBQVlQLEtBQVo7QUFDRDtBQUNELE9BQUtRLGdCQUFMLENBQXNCbEIsTUFBdEIsRUFBOEJHLE1BQTlCO0FBQ0EsU0FBT0EsTUFBUDtBQUNELENBeEJEOztBQTBCQTs7Ozs7Ozs7Ozs7OztBQWFBYixRQUFRSSxTQUFSLENBQWtCd0IsZ0JBQWxCLEdBQXFDLFVBQVNsQixNQUFULEVBQWlCRyxNQUFqQixFQUF5QixDQUM3RCxDQUREOztBQUdBOzs7Ozs7Ozs7QUFTQWIsUUFBUUksU0FBUixDQUFrQnlCLGNBQWxCLEdBQW1DLFVBQVNuQixNQUFULEVBQWlCb0IsVUFBakIsRUFBNkJ0QixPQUE3QixFQUFzQyxDQUN4RSxDQUREOztBQUdBOzs7Ozs7Ozs7OztBQVdBUixRQUFRSSxTQUFSLENBQWtCMkIsaUJBQWxCLEdBQXNDLFVBQVNyQixNQUFULEVBQWlCc0IsVUFBakIsRUFBNkJ4QixPQUE3QixFQUFzQyxDQUMzRSxDQUREOztBQUdBOzs7Ozs7Ozs7O0FBVUFSLFFBQVFJLFNBQVIsQ0FBa0I2QixlQUFsQixHQUFvQyxVQUFTcEIsTUFBVCxFQUFpQnFCLElBQWpCLEVBQXVCQyxRQUF2QixFQUFpQyxDQUNwRSxDQUREOztBQUdBOzs7Ozs7O0FBT0FuQyxRQUFRbUIsVUFBUixHQUFxQixVQUFTaUIsR0FBVCxFQUFjO0FBQ2pDO0FBQ0EsTUFBSUEsUUFBUSxJQUFaLEVBQWtCO0FBQ2hCLFdBQU9kLEdBQVA7QUFDRDs7QUFFRDtBQUNBLFNBQU9jLEdBQVA7QUFDRCxDQVJEOztBQVVBLHlEQUFlckMsa0JBQWYiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEzIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIGZpbGUgY29udGFpbnMgdGhlIG1hbmFnbWVudCBvZiBkYXRhIGhhbmRsZXJzXG4gKiBAYXV0aG9yIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICpcbiAqIFRoZSBpZGVhIGlzIHRvIGRlZmluZSBhIGNvbW1vbiwgZ2VuZXJpYyBkYXRhIGZvcm1hdCB0aGF0IHdvcmtzIGZvciBhbGwgZGF0YVxuICogc3RydWN0dXJlcyBzdXBwb3J0ZWQgYnkgZHlncmFwaHMuIFRvIG1ha2UgdGhpcyBwb3NzaWJsZSwgdGhlIERhdGFIYW5kbGVyXG4gKiBpbnRlcmZhY2UgaXMgaW50cm9kdWNlZC4gVGhpcyBtYWtlcyBpdCBwb3NzaWJsZSwgdGhhdCBkeWdyYXBoIGl0c2VsZiBjYW4gd29ya1xuICogd2l0aCB0aGUgc2FtZSBsb2dpYyBmb3IgZXZlcnkgZGF0YSB0eXBlIGluZGVwZW5kZW50IG9mIHRoZSBhY3R1YWwgZm9ybWF0IGFuZFxuICogdGhlIERhdGFIYW5kbGVyIHRha2VzIGNhcmUgb2YgdGhlIGRhdGEgZm9ybWF0IHNwZWNpZmljIGpvYnMuXG4gKiBEYXRhSGFuZGxlcnMgYXJlIGltcGxlbWVudGVkIGZvciBhbGwgZGF0YSB0eXBlcyBzdXBwb3J0ZWQgYnkgRHlncmFwaHMgYW5kXG4gKiByZXR1cm4gRHlncmFwaHMgY29tcGxpYW50IGZvcm1hdHMuXG4gKiBCeSBkZWZhdWx0IHRoZSBjb3JyZWN0IERhdGFIYW5kbGVyIGlzIGNob3NlbiBiYXNlZCBvbiB0aGUgb3B0aW9ucyBzZXQuXG4gKiBPcHRpb25hbGx5IHRoZSB1c2VyIG1heSB1c2UgaGlzIG93biBEYXRhSGFuZGxlciAoc2ltaWxhciB0byB0aGUgcGx1Z2luXG4gKiBzeXN0ZW0pLlxuICpcbiAqXG4gKiBUaGUgdW5pZmllZCBkYXRhIGZvcm1hdCByZXR1cmVuZCBieSBlYWNoIGhhbmRsZXIgaXMgZGVmaW5lZCBhcyBzbzpcbiAqIHNlcmllc1tuXVtwb2ludF0gPSBbeCx5LChleHRyYXMpXVxuICpcbiAqIFRoaXMgZm9ybWF0IGNvbnRhaW5zIHRoZSBjb21tb24gYmFzaXMgdGhhdCBpcyBuZWVkZWQgdG8gZHJhdyBhIHNpbXBsZSBsaW5lXG4gKiBzZXJpZXMgZXh0ZW5kZWQgYnkgb3B0aW9uYWwgZXh0cmFzIGZvciBtb3JlIGNvbXBsZXggZ3JhcGhpbmcgdHlwZXMuIEl0XG4gKiBjb250YWlucyBhIHByaW1pdGl2ZSB4IHZhbHVlIGFzIGZpcnN0IGFycmF5IGVudHJ5LCBhIHByaW1pdGl2ZSB5IHZhbHVlIGFzXG4gKiBzZWNvbmQgYXJyYXkgZW50cnkgYW5kIGFuIG9wdGlvbmFsIGV4dHJhcyBvYmplY3QgZm9yIGFkZGl0aW9uYWwgZGF0YSBuZWVkZWQuXG4gKlxuICogeCBtdXN0IGFsd2F5cyBiZSBhIG51bWJlci5cbiAqIHkgbXVzdCBhbHdheXMgYmUgYSBudW1iZXIsIE5hTiBvZiB0eXBlIG51bWJlciBvciBudWxsLlxuICogZXh0cmFzIGlzIG9wdGlvbmFsIGFuZCBtdXN0IGJlIGludGVycHJldGVkIGJ5IHRoZSBEYXRhSGFuZGxlci4gSXQgbWF5IGJlIG9mXG4gKiBhbnkgdHlwZS5cbiAqXG4gKiBJbiBwcmFjdGljZSB0aGlzIG1pZ2h0IGxvb2sgc29tZXRoaW5nIGxpa2UgdGhpczpcbiAqIGRlZmF1bHQ6IFt4LCB5VmFsXVxuICogZXJyb3JCYXIgLyBjdXN0b21CYXI6IFt4LCB5VmFsLCBbeVRvcFZhcmlhbmNlLCB5Qm90dG9tVmFyaWFuY2VdIF1cbiAqXG4gKi9cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cbi8qZ2xvYmFsIER5Z3JhcGhMYXlvdXQ6ZmFsc2UgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICpcbiAqIFRoZSBkYXRhIGhhbmRsZXIgaXMgcmVzcG9uc2libGUgZm9yIGFsbCBkYXRhIHNwZWNpZmljIG9wZXJhdGlvbnMuIEFsbCBvZiB0aGVcbiAqIHNlcmllcyBkYXRhIGl0IHJlY2VpdmVzIGFuZCByZXR1cm5zIGlzIGFsd2F5cyBpbiB0aGUgdW5pZmllZCBkYXRhIGZvcm1hdC5cbiAqIEluaXRpYWxseSB0aGUgdW5pZmllZCBkYXRhIGlzIGNyZWF0ZWQgYnkgdGhlIGV4dHJhY3RTZXJpZXMgbWV0aG9kXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIER5Z3JhcGhEYXRhSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbn07XG5cbnZhciBoYW5kbGVyID0gRHlncmFwaERhdGFIYW5kbGVyO1xuXG4vKipcbiAqIFgtdmFsdWUgYXJyYXkgaW5kZXggY29uc3RhbnQgZm9yIHVuaWZpZWQgZGF0YSBzYW1wbGVzLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5oYW5kbGVyLlggPSAwO1xuXG4vKipcbiAqIFktdmFsdWUgYXJyYXkgaW5kZXggY29uc3RhbnQgZm9yIHVuaWZpZWQgZGF0YSBzYW1wbGVzLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5oYW5kbGVyLlkgPSAxO1xuXG4vKipcbiAqIEV4dHJhcy12YWx1ZSBhcnJheSBpbmRleCBjb25zdGFudCBmb3IgdW5pZmllZCBkYXRhIHNhbXBsZXMuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmhhbmRsZXIuRVhUUkFTID0gMjtcblxuLyoqXG4gKiBFeHRyYWN0cyBvbmUgc2VyaWVzIGZyb20gdGhlIHJhdyBkYXRhIChhIDJEIGFycmF5KSBpbnRvIGFuIGFycmF5IG9mIHRoZVxuICogdW5pZmllZCBkYXRhIGZvcm1hdC5cbiAqIFRoaXMgaXMgd2hlcmUgdW5kZXNpcmFibGUgcG9pbnRzIChpLmUuIG5lZ2F0aXZlIHZhbHVlcyBvbiBsb2cgc2NhbGVzIGFuZFxuICogbWlzc2luZyB2YWx1ZXMgdGhyb3VnaCB3aGljaCB3ZSB3aXNoIHRvIGNvbm5lY3QgbGluZXMpIGFyZSBkcm9wcGVkLlxuICogVE9ETyhkYW52ayk6IHRoZSBcIm1pc3NpbmcgdmFsdWVzXCIgYml0IGFib3ZlIGRvZXNuJ3Qgc2VlbSByaWdodC5cbiAqXG4gKiBAcGFyYW0geyFBcnJheS48QXJyYXk+fSByYXdEYXRhIFRoZSByYXcgZGF0YSBwYXNzZWQgaW50byBkeWdyYXBocyB3aGVyZVxuICogICAgIHJhd0RhdGFbaV0gPSBbeCx5U2VyaWVzMSwuLi4seVNlcmllc05dLlxuICogQHBhcmFtIHshbnVtYmVyfSBzZXJpZXNJbmRleCBJbmRleCBvZiB0aGUgc2VyaWVzIHRvIGV4dHJhY3QuIEFsbCBvdGhlclxuICogICAgIHNlcmllcyBzaG91bGQgYmUgaWdub3JlZC5cbiAqIEBwYXJhbSB7IUR5Z3JhcGhPcHRpb25zfSBvcHRpb25zIER5Z3JhcGggb3B0aW9ucy5cbiAqIEByZXR1cm4ge0FycmF5LjxbIW51bWJlciw/bnVtYmVyLD9dPn0gVGhlIHNlcmllcyBpbiB0aGUgdW5pZmllZCBkYXRhIGZvcm1hdFxuICogICAgIHdoZXJlIHNlcmllc1tpXSA9IFt4LHkse2V4dHJhc31dLlxuICovXG5oYW5kbGVyLnByb3RvdHlwZS5leHRyYWN0U2VyaWVzID0gZnVuY3Rpb24ocmF3RGF0YSwgc2VyaWVzSW5kZXgsIG9wdGlvbnMpIHtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzZXJpZXMgdG8gYSBQb2ludCBhcnJheS4gIFRoZSByZXN1bHRpbmcgcG9pbnQgYXJyYXkgbXVzdCBiZVxuICogcmV0dXJuZWQgaW4gaW5jcmVhc2luZyBvcmRlciBvZiBpZHggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHshQXJyYXkuPFshbnVtYmVyLD9udW1iZXIsP10+fSBzZXJpZXMgVGhlIHNlcmllcyBpbiB0aGUgdW5pZmllZFxuICogICAgICAgICAgZGF0YSBmb3JtYXQgd2hlcmUgc2VyaWVzW2ldID0gW3gseSx7ZXh0cmFzfV0uXG4gKiBAcGFyYW0geyFzdHJpbmd9IHNldE5hbWUgTmFtZSBvZiB0aGUgc2VyaWVzLlxuICogQHBhcmFtIHshbnVtYmVyfSBib3VuZGFyeUlkU3RhcnQgSW5kZXggb2Zmc2V0IG9mIHRoZSBmaXJzdCBwb2ludCwgZXF1YWwgdG8gdGhlXG4gKiAgICAgICAgICBudW1iZXIgb2Ygc2tpcHBlZCBwb2ludHMgbGVmdCBvZiB0aGUgZGF0ZSB3aW5kb3cgbWluaW11bSAoaWYgYW55KS5cbiAqIEByZXR1cm4geyFBcnJheS48RHlncmFwaC5Qb2ludFR5cGU+fSBMaXN0IG9mIHBvaW50cyBmb3IgdGhpcyBzZXJpZXMuXG4gKi9cbmhhbmRsZXIucHJvdG90eXBlLnNlcmllc1RvUG9pbnRzID0gZnVuY3Rpb24oc2VyaWVzLCBzZXROYW1lLCBib3VuZGFyeUlkU3RhcnQpIHtcbiAgLy8gVE9ETyhiaHMpOiB0aGVzZSBsb29wcyBhcmUgYSBob3Qtc3BvdCBmb3IgaGlnaC1wb2ludC1jb3VudCBjaGFydHMuIEluXG4gIC8vIGZhY3QsXG4gIC8vIG9uIGNocm9tZStsaW51eCwgdGhleSBhcmUgNiB0aW1lcyBtb3JlIGV4cGVuc2l2ZSB0aGFuIGl0ZXJhdGluZyB0aHJvdWdoXG4gIC8vIHRoZVxuICAvLyBwb2ludHMgYW5kIGRyYXdpbmcgdGhlIGxpbmVzLiBUaGUgYnJ1bnQgb2YgdGhlIGNvc3QgY29tZXMgZnJvbSBhbGxvY2F0aW5nXG4gIC8vIHRoZSB8cG9pbnR8IHN0cnVjdHVyZXMuXG4gIHZhciBwb2ludHMgPSBbXTtcbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgc2VyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGl0ZW0gPSBzZXJpZXNbaV07XG4gICAgdmFyIHlyYXcgPSBpdGVtWzFdO1xuICAgIHZhciB5dmFsID0geXJhdyA9PT0gbnVsbCA/IG51bGwgOiBoYW5kbGVyLnBhcnNlRmxvYXQoeXJhdyk7XG4gICAgdmFyIHBvaW50ID0ge1xuICAgICAgeCA6IE5hTixcbiAgICAgIHkgOiBOYU4sXG4gICAgICB4dmFsIDogaGFuZGxlci5wYXJzZUZsb2F0KGl0ZW1bMF0pLFxuICAgICAgeXZhbCA6IHl2YWwsXG4gICAgICBuYW1lIDogc2V0TmFtZSwgLy8gVE9ETyhkYW52ayk6IGlzIHRoaXMgcmVhbGx5IG5lY2Vzc2FyeT9cbiAgICAgIGlkeCA6IGkgKyBib3VuZGFyeUlkU3RhcnRcbiAgICB9O1xuICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgfVxuICB0aGlzLm9uUG9pbnRzQ3JlYXRlZF8oc2VyaWVzLCBwb2ludHMpO1xuICByZXR1cm4gcG9pbnRzO1xufTtcblxuLyoqXG4gKiBDYWxsYmFjayBjYWxsZWQgZm9yIGVhY2ggc2VyaWVzIGFmdGVyIHRoZSBzZXJpZXMgcG9pbnRzIGhhdmUgYmVlbiBnZW5lcmF0ZWRcbiAqIHdoaWNoIHdpbGwgbGF0ZXIgYmUgdXNlZCBieSB0aGUgcGxvdHRlcnMgdG8gZHJhdyB0aGUgZ3JhcGguXG4gKiBIZXJlIGRhdGEgbWF5IGJlIGFkZGVkIHRvIHRoZSBzZXJpZXNQb2ludHMgd2hpY2ggaXMgbmVlZGVkIGJ5IHRoZSBwbG90dGVycy5cbiAqIFRoZSBpbmRleGVzIG9mIHNlcmllcyBhbmQgcG9pbnRzIGFyZSBpbiBzeW5jIG1lYW5pbmcgdGhlIG9yaWdpbmFsIGRhdGFcbiAqIHNhbXBsZSBmb3Igc2VyaWVzW2ldIGlzIHBvaW50c1tpXS5cbiAqXG4gKiBAcGFyYW0geyFBcnJheS48WyFudW1iZXIsP251bWJlciw/XT59IHNlcmllcyBUaGUgc2VyaWVzIGluIHRoZSB1bmlmaWVkXG4gKiAgICAgZGF0YSBmb3JtYXQgd2hlcmUgc2VyaWVzW2ldID0gW3gseSx7ZXh0cmFzfV0uXG4gKiBAcGFyYW0geyFBcnJheS48RHlncmFwaC5Qb2ludFR5cGU+fSBwb2ludHMgVGhlIGNvcnJlc3BvbmRpbmcgcG9pbnRzIHBhc3NlZFxuICogICAgIHRvIHRoZSBwbG90dGVyLlxuICogQHByb3RlY3RlZFxuICovXG5oYW5kbGVyLnByb3RvdHlwZS5vblBvaW50c0NyZWF0ZWRfID0gZnVuY3Rpb24oc2VyaWVzLCBwb2ludHMpIHtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgcm9sbGluZyBhdmVyYWdlIG9mIGEgZGF0YSBzZXQuXG4gKlxuICogQHBhcmFtIHshQXJyYXkuPFshbnVtYmVyLD9udW1iZXIsP10+fSBzZXJpZXMgVGhlIHNlcmllcyBpbiB0aGUgdW5pZmllZFxuICogICAgICAgICAgZGF0YSBmb3JtYXQgd2hlcmUgc2VyaWVzW2ldID0gW3gseSx7ZXh0cmFzfV0uXG4gKiBAcGFyYW0geyFudW1iZXJ9IHJvbGxQZXJpb2QgVGhlIG51bWJlciBvZiBwb2ludHMgb3ZlciB3aGljaCB0byBhdmVyYWdlIHRoZSBkYXRhXG4gKiBAcGFyYW0geyFEeWdyYXBoT3B0aW9uc30gb3B0aW9ucyBUaGUgZHlncmFwaCBvcHRpb25zLlxuICogQHJldHVybiB7IUFycmF5LjxbIW51bWJlciw/bnVtYmVyLD9dPn0gdGhlIHJvbGxlZCBzZXJpZXMuXG4gKi9cbmhhbmRsZXIucHJvdG90eXBlLnJvbGxpbmdBdmVyYWdlID0gZnVuY3Rpb24oc2VyaWVzLCByb2xsUGVyaW9kLCBvcHRpb25zKSB7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSByYW5nZSBvZiB0aGUgZGF0YSBzZXJpZXMgKGluY2x1ZGluZyBjb25maWRlbmNlIGludGVydmFscykuXG4gKlxuICogQHBhcmFtIHshQXJyYXkuPFshbnVtYmVyLD9udW1iZXIsP10+fSBzZXJpZXMgVGhlIHNlcmllcyBpbiB0aGUgdW5pZmllZFxuICogICAgIGRhdGEgZm9ybWF0IHdoZXJlIHNlcmllc1tpXSA9IFt4LCB5LCB7ZXh0cmFzfV0uXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gZGF0ZVdpbmRvdyBUaGUgeC12YWx1ZSByYW5nZSB0byBkaXNwbGF5IHdpdGhcbiAqICAgICB0aGUgZm9ybWF0OiBbbWluLCBtYXhdLlxuICogQHBhcmFtIHshRHlncmFwaE9wdGlvbnN9IG9wdGlvbnMgVGhlIGR5Z3JhcGggb3B0aW9ucy5cbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBUaGUgbG93IGFuZCBoaWdoIGV4dHJlbWVzIG9mIHRoZSBzZXJpZXMgaW4gdGhlXG4gKiAgICAgZ2l2ZW4gd2luZG93IHdpdGggdGhlIGZvcm1hdDogW2xvdywgaGlnaF0uXG4gKi9cbmhhbmRsZXIucHJvdG90eXBlLmdldEV4dHJlbWVZVmFsdWVzID0gZnVuY3Rpb24oc2VyaWVzLCBkYXRlV2luZG93LCBvcHRpb25zKSB7XG59O1xuXG4vKipcbiAqIENhbGxiYWNrIGNhbGxlZCBmb3IgZWFjaCBzZXJpZXMgYWZ0ZXIgdGhlIGxheW91dGluZyBkYXRhIGhhcyBiZWVuXG4gKiBjYWxjdWxhdGVkIGJlZm9yZSB0aGUgc2VyaWVzIGlzIGRyYXduLiBIZXJlIG5vcm1hbGl6ZWQgcG9zaXRpb25pbmcgZGF0YVxuICogc2hvdWxkIGJlIGNhbGN1bGF0ZWQgZm9yIHRoZSBleHRyYXMgb2YgZWFjaCBwb2ludC5cbiAqXG4gKiBAcGFyYW0geyFBcnJheS48RHlncmFwaC5Qb2ludFR5cGU+fSBwb2ludHMgVGhlIHBvaW50cyBwYXNzZWQgdG9cbiAqICAgICAgICAgIHRoZSBwbG90dGVyLlxuICogQHBhcmFtIHshT2JqZWN0fSBheGlzIFRoZSBheGlzIG9uIHdoaWNoIHRoZSBzZXJpZXMgd2lsbCBiZSBwbG90dGVkLlxuICogQHBhcmFtIHshYm9vbGVhbn0gbG9nc2NhbGUgV2VhdGhlciBvciBub3QgdG8gdXNlIGEgbG9nc2NhbGUuXG4gKi9cbmhhbmRsZXIucHJvdG90eXBlLm9uTGluZUV2YWx1YXRlZCA9IGZ1bmN0aW9uKHBvaW50cywgYXhpcywgbG9nc2NhbGUpIHtcbn07XG5cbi8qKlxuICogT3B0aW1pemVkIHJlcGxhY2VtZW50IGZvciBwYXJzZUZsb2F0LCB3aGljaCB3YXMgd2F5IHRvbyBzbG93IHdoZW4gYWxtb3N0XG4gKiBhbGwgdmFsdWVzIHdlcmUgdHlwZSBudW1iZXIsIHdpdGggZmV3IGVkZ2UgY2FzZXMsIG5vbmUgb2Ygd2hpY2ggd2VyZSBzdHJpbmdzLlxuICogQHBhcmFtIHs/bnVtYmVyfSB2YWxcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuaGFuZGxlci5wYXJzZUZsb2F0ID0gZnVuY3Rpb24odmFsKSB7XG4gIC8vIHBhcnNlRmxvYXQobnVsbCkgaXMgTmFOXG4gIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgLy8gQXNzdW1lIGl0J3MgYSBudW1iZXIgb3IgTmFOLiBJZiBpdCdzIHNvbWV0aGluZyBlbHNlLCBJJ2xsIGJlIHNob2NrZWQuXG4gIHJldHVybiB2YWw7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEeWdyYXBoRGF0YUhhbmRsZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9kYXRhaGFuZGxlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__ = __webpack_require__(0);\n/**\n * @license\n * Copyright 2011 Robert Konigsberg (konigsberg@google.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview The default interaction model for Dygraphs. This is kept out\n * of dygraph.js for better navigability.\n * @author Robert Konigsberg (konigsberg@google.com)\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * You can drag this many pixels past the edge of the chart and still have it\n * be considered a zoom. This makes it easier to zoom to the exact edge of the\n * chart, a fairly common operation.\n */\nvar DRAG_EDGE_MARGIN = 100;\n\n/**\n * A collection of functions to facilitate build custom interaction models.\n * @class\n */\nvar DygraphInteraction = {};\n\n/**\n * Checks whether the beginning & ending of an event were close enough that it\n * should be considered a click. If it should, dispatch appropriate events.\n * Returns true if the event was treated as a click.\n *\n * @param {Event} event\n * @param {Dygraph} g\n * @param {Object} context\n */\nDygraphInteraction.maybeTreatMouseOpAsClick = function (event, g, context) {\n  context.dragEndX = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"l\" /* dragGetX_ */](event, context);\n  context.dragEndY = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"m\" /* dragGetY_ */](event, context);\n  var regionWidth = Math.abs(context.dragEndX - context.dragStartX);\n  var regionHeight = Math.abs(context.dragEndY - context.dragStartY);\n\n  if (regionWidth < 2 && regionHeight < 2 && g.lastx_ !== undefined && g.lastx_ != -1) {\n    DygraphInteraction.treatMouseOpAsClick(g, event, context);\n  }\n\n  context.regionWidth = regionWidth;\n  context.regionHeight = regionHeight;\n};\n\n/**\n * Called in response to an interaction model operation that\n * should start the default panning behavior.\n *\n * It's used in the default callback for \"mousedown\" operations.\n * Custom interaction model builders can use it to provide the default\n * panning behavior.\n *\n * @param {Event} event the event object which led to the startPan call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\nDygraphInteraction.startPan = function (event, g, context) {\n  var i, axis;\n  context.isPanning = true;\n  var xRange = g.xAxisRange();\n\n  if (g.getOptionForAxis(\"logscale\", \"x\")) {\n    context.initialLeftmostDate = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](xRange[0]);\n    context.dateRange = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](xRange[1]) - __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](xRange[0]);\n  } else {\n    context.initialLeftmostDate = xRange[0];\n    context.dateRange = xRange[1] - xRange[0];\n  }\n  context.xUnitsPerPixel = context.dateRange / (g.plotter_.area.w - 1);\n\n  if (g.getNumericOption(\"panEdgeFraction\")) {\n    var maxXPixelsToDraw = g.width_ * g.getNumericOption(\"panEdgeFraction\");\n    var xExtremes = g.xAxisExtremes(); // I REALLY WANT TO CALL THIS xTremes!\n\n    var boundedLeftX = g.toDomXCoord(xExtremes[0]) - maxXPixelsToDraw;\n    var boundedRightX = g.toDomXCoord(xExtremes[1]) + maxXPixelsToDraw;\n\n    var boundedLeftDate = g.toDataXCoord(boundedLeftX);\n    var boundedRightDate = g.toDataXCoord(boundedRightX);\n    context.boundedDates = [boundedLeftDate, boundedRightDate];\n\n    var boundedValues = [];\n    var maxYPixelsToDraw = g.height_ * g.getNumericOption(\"panEdgeFraction\");\n\n    for (i = 0; i < g.axes_.length; i++) {\n      axis = g.axes_[i];\n      var yExtremes = axis.extremeRange;\n\n      var boundedTopY = g.toDomYCoord(yExtremes[0], i) + maxYPixelsToDraw;\n      var boundedBottomY = g.toDomYCoord(yExtremes[1], i) - maxYPixelsToDraw;\n\n      var boundedTopValue = g.toDataYCoord(boundedTopY, i);\n      var boundedBottomValue = g.toDataYCoord(boundedBottomY, i);\n\n      boundedValues[i] = [boundedTopValue, boundedBottomValue];\n    }\n    context.boundedValues = boundedValues;\n  }\n\n  // Record the range of each y-axis at the start of the drag.\n  // If any axis has a valueRange, then we want a 2D pan.\n  // We can't store data directly in g.axes_, because it does not belong to us\n  // and could change out from under us during a pan (say if there's a data\n  // update).\n  context.is2DPan = false;\n  context.axes = [];\n  for (i = 0; i < g.axes_.length; i++) {\n    axis = g.axes_[i];\n    var axis_data = {};\n    var yRange = g.yAxisRange(i);\n    // TODO(konigsberg): These values should be in |context|.\n    // In log scale, initialTopValue, dragValueRange and unitsPerPixel are log scale.\n    var logscale = g.attributes_.getForAxis(\"logscale\", i);\n    if (logscale) {\n      axis_data.initialTopValue = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](yRange[1]);\n      axis_data.dragValueRange = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](yRange[1]) - __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](yRange[0]);\n    } else {\n      axis_data.initialTopValue = yRange[1];\n      axis_data.dragValueRange = yRange[1] - yRange[0];\n    }\n    axis_data.unitsPerPixel = axis_data.dragValueRange / (g.plotter_.area.h - 1);\n    context.axes.push(axis_data);\n\n    // While calculating axes, set 2dpan.\n    if (axis.valueRange) context.is2DPan = true;\n  }\n};\n\n/**\n * Called in response to an interaction model operation that\n * responds to an event that pans the view.\n *\n * It's used in the default callback for \"mousemove\" operations.\n * Custom interaction model builders can use it to provide the default\n * panning behavior.\n *\n * @param {Event} event the event object which led to the movePan call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\nDygraphInteraction.movePan = function (event, g, context) {\n  context.dragEndX = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"l\" /* dragGetX_ */](event, context);\n  context.dragEndY = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"m\" /* dragGetY_ */](event, context);\n\n  var minDate = context.initialLeftmostDate - (context.dragEndX - context.dragStartX) * context.xUnitsPerPixel;\n  if (context.boundedDates) {\n    minDate = Math.max(minDate, context.boundedDates[0]);\n  }\n  var maxDate = minDate + context.dateRange;\n  if (context.boundedDates) {\n    if (maxDate > context.boundedDates[1]) {\n      // Adjust minDate, and recompute maxDate.\n      minDate = minDate - (maxDate - context.boundedDates[1]);\n      maxDate = minDate + context.dateRange;\n    }\n  }\n\n  if (g.getOptionForAxis(\"logscale\", \"x\")) {\n    g.dateWindow_ = [Math.pow(__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"N\" /* LOG_SCALE */], minDate), Math.pow(__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"N\" /* LOG_SCALE */], maxDate)];\n  } else {\n    g.dateWindow_ = [minDate, maxDate];\n  }\n\n  // y-axis scaling is automatic unless this is a full 2D pan.\n  if (context.is2DPan) {\n\n    var pixelsDragged = context.dragEndY - context.dragStartY;\n\n    // Adjust each axis appropriately.\n    for (var i = 0; i < g.axes_.length; i++) {\n      var axis = g.axes_[i];\n      var axis_data = context.axes[i];\n      var unitsDragged = pixelsDragged * axis_data.unitsPerPixel;\n\n      var boundedValue = context.boundedValues ? context.boundedValues[i] : null;\n\n      // In log scale, maxValue and minValue are the logs of those values.\n      var maxValue = axis_data.initialTopValue + unitsDragged;\n      if (boundedValue) {\n        maxValue = Math.min(maxValue, boundedValue[1]);\n      }\n      var minValue = maxValue - axis_data.dragValueRange;\n      if (boundedValue) {\n        if (minValue < boundedValue[0]) {\n          // Adjust maxValue, and recompute minValue.\n          maxValue = maxValue - (minValue - boundedValue[0]);\n          minValue = maxValue - axis_data.dragValueRange;\n        }\n      }\n      if (g.attributes_.getForAxis(\"logscale\", i)) {\n        axis.valueRange = [Math.pow(__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"N\" /* LOG_SCALE */], minValue), Math.pow(__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"N\" /* LOG_SCALE */], maxValue)];\n      } else {\n        axis.valueRange = [minValue, maxValue];\n      }\n    }\n  }\n\n  g.drawGraph_(false);\n};\n\n/**\n * Called in response to an interaction model operation that\n * responds to an event that ends panning.\n *\n * It's used in the default callback for \"mouseup\" operations.\n * Custom interaction model builders can use it to provide the default\n * panning behavior.\n *\n * @param {Event} event the event object which led to the endPan call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\nDygraphInteraction.endPan = DygraphInteraction.maybeTreatMouseOpAsClick;\n\n/**\n * Called in response to an interaction model operation that\n * responds to an event that starts zooming.\n *\n * It's used in the default callback for \"mousedown\" operations.\n * Custom interaction model builders can use it to provide the default\n * zooming behavior.\n *\n * @param {Event} event the event object which led to the startZoom call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\nDygraphInteraction.startZoom = function (event, g, context) {\n  context.isZooming = true;\n  context.zoomMoved = false;\n};\n\n/**\n * Called in response to an interaction model operation that\n * responds to an event that defines zoom boundaries.\n *\n * It's used in the default callback for \"mousemove\" operations.\n * Custom interaction model builders can use it to provide the default\n * zooming behavior.\n *\n * @param {Event} event the event object which led to the moveZoom call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\nDygraphInteraction.moveZoom = function (event, g, context) {\n  context.zoomMoved = true;\n  context.dragEndX = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"l\" /* dragGetX_ */](event, context);\n  context.dragEndY = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"m\" /* dragGetY_ */](event, context);\n\n  var xDelta = Math.abs(context.dragStartX - context.dragEndX);\n  var yDelta = Math.abs(context.dragStartY - context.dragEndY);\n\n  // drag direction threshold for y axis is twice as large as x axis\n  context.dragDirection = xDelta < yDelta / 2 ? __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"o\" /* VERTICAL */] : __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"n\" /* HORIZONTAL */];\n\n  g.drawZoomRect_(context.dragDirection, context.dragStartX, context.dragEndX, context.dragStartY, context.dragEndY, context.prevDragDirection, context.prevEndX, context.prevEndY);\n\n  context.prevEndX = context.dragEndX;\n  context.prevEndY = context.dragEndY;\n  context.prevDragDirection = context.dragDirection;\n};\n\n/**\n * TODO(danvk): move this logic into dygraph.js\n * @param {Dygraph} g\n * @param {Event} event\n * @param {Object} context\n */\nDygraphInteraction.treatMouseOpAsClick = function (g, event, context) {\n  var clickCallback = g.getFunctionOption('clickCallback');\n  var pointClickCallback = g.getFunctionOption('pointClickCallback');\n\n  var selectedPoint = null;\n\n  // Find out if the click occurs on a point.\n  var closestIdx = -1;\n  var closestDistance = Number.MAX_VALUE;\n\n  // check if the click was on a particular point.\n  for (var i = 0; i < g.selPoints_.length; i++) {\n    var p = g.selPoints_[i];\n    var distance = Math.pow(p.canvasx - context.dragEndX, 2) + Math.pow(p.canvasy - context.dragEndY, 2);\n    if (!isNaN(distance) && (closestIdx == -1 || distance < closestDistance)) {\n      closestDistance = distance;\n      closestIdx = i;\n    }\n  }\n\n  // Allow any click within two pixels of the dot.\n  var radius = g.getNumericOption('highlightCircleSize') + 2;\n  if (closestDistance <= radius * radius) {\n    selectedPoint = g.selPoints_[closestIdx];\n  }\n\n  if (selectedPoint) {\n    var e = {\n      cancelable: true,\n      point: selectedPoint,\n      canvasx: context.dragEndX,\n      canvasy: context.dragEndY\n    };\n    var defaultPrevented = g.cascadeEvents_('pointClick', e);\n    if (defaultPrevented) {\n      // Note: this also prevents click / clickCallback from firing.\n      return;\n    }\n    if (pointClickCallback) {\n      pointClickCallback.call(g, event, selectedPoint);\n    }\n  }\n\n  var e = {\n    cancelable: true,\n    xval: g.lastx_, // closest point by x value\n    pts: g.selPoints_,\n    canvasx: context.dragEndX,\n    canvasy: context.dragEndY\n  };\n  if (!g.cascadeEvents_('click', e)) {\n    if (clickCallback) {\n      // TODO(danvk): pass along more info about the points, e.g. 'x'\n      clickCallback.call(g, event, g.lastx_, g.selPoints_);\n    }\n  }\n};\n\n/**\n * Called in response to an interaction model operation that\n * responds to an event that performs a zoom based on previously defined\n * bounds..\n *\n * It's used in the default callback for \"mouseup\" operations.\n * Custom interaction model builders can use it to provide the default\n * zooming behavior.\n *\n * @param {Event} event the event object which led to the endZoom call.\n * @param {Dygraph} g The dygraph on which to end the zoom.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\nDygraphInteraction.endZoom = function (event, g, context) {\n  g.clearZoomRect_();\n  context.isZooming = false;\n  DygraphInteraction.maybeTreatMouseOpAsClick(event, g, context);\n\n  // The zoom rectangle is visibly clipped to the plot area, so its behavior\n  // should be as well.\n  // See http://code.google.com/p/dygraphs/issues/detail?id=280\n  var plotArea = g.getArea();\n  if (context.regionWidth >= 10 && context.dragDirection == __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"n\" /* HORIZONTAL */]) {\n    var left = Math.min(context.dragStartX, context.dragEndX),\n        right = Math.max(context.dragStartX, context.dragEndX);\n    left = Math.max(left, plotArea.x);\n    right = Math.min(right, plotArea.x + plotArea.w);\n    if (left < right) {\n      g.doZoomX_(left, right);\n    }\n    context.cancelNextDblclick = true;\n  } else if (context.regionHeight >= 10 && context.dragDirection == __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"o\" /* VERTICAL */]) {\n    var top = Math.min(context.dragStartY, context.dragEndY),\n        bottom = Math.max(context.dragStartY, context.dragEndY);\n    top = Math.max(top, plotArea.y);\n    bottom = Math.min(bottom, plotArea.y + plotArea.h);\n    if (top < bottom) {\n      g.doZoomY_(top, bottom);\n    }\n    context.cancelNextDblclick = true;\n  }\n  context.dragStartX = null;\n  context.dragStartY = null;\n};\n\n/**\n * @private\n */\nDygraphInteraction.startTouch = function (event, g, context) {\n  event.preventDefault(); // touch browsers are all nice.\n  if (event.touches.length > 1) {\n    // If the user ever puts two fingers down, it's not a double tap.\n    context.startTimeForDoubleTapMs = null;\n  }\n\n  var touches = [];\n  for (var i = 0; i < event.touches.length; i++) {\n    var t = event.touches[i];\n    // we dispense with 'dragGetX_' because all touchBrowsers support pageX\n    touches.push({\n      pageX: t.pageX,\n      pageY: t.pageY,\n      dataX: g.toDataXCoord(t.pageX),\n      dataY: g.toDataYCoord(t.pageY)\n      // identifier: t.identifier\n    });\n  }\n  context.initialTouches = touches;\n\n  if (touches.length == 1) {\n    // This is just a swipe.\n    context.initialPinchCenter = touches[0];\n    context.touchDirections = { x: true, y: true };\n  } else if (touches.length >= 2) {\n    // It's become a pinch!\n    // In case there are 3+ touches, we ignore all but the \"first\" two.\n\n    // only screen coordinates can be averaged (data coords could be log scale).\n    context.initialPinchCenter = {\n      pageX: 0.5 * (touches[0].pageX + touches[1].pageX),\n      pageY: 0.5 * (touches[0].pageY + touches[1].pageY),\n\n      // TODO(danvk): remove\n      dataX: 0.5 * (touches[0].dataX + touches[1].dataX),\n      dataY: 0.5 * (touches[0].dataY + touches[1].dataY)\n    };\n\n    // Make pinches in a 45-degree swath around either axis 1-dimensional zooms.\n    var initialAngle = 180 / Math.PI * Math.atan2(context.initialPinchCenter.pageY - touches[0].pageY, touches[0].pageX - context.initialPinchCenter.pageX);\n\n    // use symmetry to get it into the first quadrant.\n    initialAngle = Math.abs(initialAngle);\n    if (initialAngle > 90) initialAngle = 90 - initialAngle;\n\n    context.touchDirections = {\n      x: initialAngle < 90 - 45 / 2,\n      y: initialAngle > 45 / 2\n    };\n  }\n\n  // save the full x & y ranges.\n  context.initialRange = {\n    x: g.xAxisRange(),\n    y: g.yAxisRange()\n  };\n};\n\n/**\n * @private\n */\nDygraphInteraction.moveTouch = function (event, g, context) {\n  // If the tap moves, then it's definitely not part of a double-tap.\n  context.startTimeForDoubleTapMs = null;\n\n  var i,\n      touches = [];\n  for (i = 0; i < event.touches.length; i++) {\n    var t = event.touches[i];\n    touches.push({\n      pageX: t.pageX,\n      pageY: t.pageY\n    });\n  }\n  var initialTouches = context.initialTouches;\n\n  var c_now;\n\n  // old and new centers.\n  var c_init = context.initialPinchCenter;\n  if (touches.length == 1) {\n    c_now = touches[0];\n  } else {\n    c_now = {\n      pageX: 0.5 * (touches[0].pageX + touches[1].pageX),\n      pageY: 0.5 * (touches[0].pageY + touches[1].pageY)\n    };\n  }\n\n  // this is the \"swipe\" component\n  // we toss it out for now, but could use it in the future.\n  var swipe = {\n    pageX: c_now.pageX - c_init.pageX,\n    pageY: c_now.pageY - c_init.pageY\n  };\n  var dataWidth = context.initialRange.x[1] - context.initialRange.x[0];\n  var dataHeight = context.initialRange.y[0] - context.initialRange.y[1];\n  swipe.dataX = swipe.pageX / g.plotter_.area.w * dataWidth;\n  swipe.dataY = swipe.pageY / g.plotter_.area.h * dataHeight;\n  var xScale, yScale;\n\n  // The residual bits are usually split into scale & rotate bits, but we split\n  // them into x-scale and y-scale bits.\n  if (touches.length == 1) {\n    xScale = 1.0;\n    yScale = 1.0;\n  } else if (touches.length >= 2) {\n    var initHalfWidth = initialTouches[1].pageX - c_init.pageX;\n    xScale = (touches[1].pageX - c_now.pageX) / initHalfWidth;\n\n    var initHalfHeight = initialTouches[1].pageY - c_init.pageY;\n    yScale = (touches[1].pageY - c_now.pageY) / initHalfHeight;\n  }\n\n  // Clip scaling to [1/8, 8] to prevent too much blowup.\n  xScale = Math.min(8, Math.max(0.125, xScale));\n  yScale = Math.min(8, Math.max(0.125, yScale));\n\n  var didZoom = false;\n  if (context.touchDirections.x) {\n    g.dateWindow_ = [c_init.dataX - swipe.dataX + (context.initialRange.x[0] - c_init.dataX) / xScale, c_init.dataX - swipe.dataX + (context.initialRange.x[1] - c_init.dataX) / xScale];\n    didZoom = true;\n  }\n\n  if (context.touchDirections.y) {\n    for (i = 0; i < 1 /*g.axes_.length*/; i++) {\n      var axis = g.axes_[i];\n      var logscale = g.attributes_.getForAxis(\"logscale\", i);\n      if (logscale) {\n        // TODO(danvk): implement\n      } else {\n        axis.valueRange = [c_init.dataY - swipe.dataY + (context.initialRange.y[0] - c_init.dataY) / yScale, c_init.dataY - swipe.dataY + (context.initialRange.y[1] - c_init.dataY) / yScale];\n        didZoom = true;\n      }\n    }\n  }\n\n  g.drawGraph_(false);\n\n  // We only call zoomCallback on zooms, not pans, to mirror desktop behavior.\n  if (didZoom && touches.length > 1 && g.getFunctionOption('zoomCallback')) {\n    var viewWindow = g.xAxisRange();\n    g.getFunctionOption(\"zoomCallback\").call(g, viewWindow[0], viewWindow[1], g.yAxisRanges());\n  }\n};\n\n/**\n * @private\n */\nDygraphInteraction.endTouch = function (event, g, context) {\n  if (event.touches.length !== 0) {\n    // this is effectively a \"reset\"\n    DygraphInteraction.startTouch(event, g, context);\n  } else if (event.changedTouches.length == 1) {\n    // Could be part of a \"double tap\"\n    // The heuristic here is that it's a double-tap if the two touchend events\n    // occur within 500ms and within a 50x50 pixel box.\n    var now = new Date().getTime();\n    var t = event.changedTouches[0];\n    if (context.startTimeForDoubleTapMs && now - context.startTimeForDoubleTapMs < 500 && context.doubleTapX && Math.abs(context.doubleTapX - t.screenX) < 50 && context.doubleTapY && Math.abs(context.doubleTapY - t.screenY) < 50) {\n      g.resetZoom();\n    } else {\n      context.startTimeForDoubleTapMs = now;\n      context.doubleTapX = t.screenX;\n      context.doubleTapY = t.screenY;\n    }\n  }\n};\n\n// Determine the distance from x to [left, right].\nvar distanceFromInterval = function distanceFromInterval(x, left, right) {\n  if (x < left) {\n    return left - x;\n  } else if (x > right) {\n    return x - right;\n  } else {\n    return 0;\n  }\n};\n\n/**\n * Returns the number of pixels by which the event happens from the nearest\n * edge of the chart. For events in the interior of the chart, this returns zero.\n */\nvar distanceFromChart = function distanceFromChart(event, g) {\n  var chartPos = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"k\" /* findPos */](g.canvas_);\n  var box = {\n    left: chartPos.x,\n    right: chartPos.x + g.canvas_.offsetWidth,\n    top: chartPos.y,\n    bottom: chartPos.y + g.canvas_.offsetHeight\n  };\n\n  var pt = {\n    x: __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"q\" /* pageX */](event),\n    y: __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"r\" /* pageY */](event)\n  };\n\n  var dx = distanceFromInterval(pt.x, box.left, box.right),\n      dy = distanceFromInterval(pt.y, box.top, box.bottom);\n  return Math.max(dx, dy);\n};\n\n/**\n * Default interation model for dygraphs. You can refer to specific elements of\n * this when constructing your own interaction model, e.g.:\n * g.updateOptions( {\n *   interactionModel: {\n *     mousedown: DygraphInteraction.defaultInteractionModel.mousedown\n *   }\n * } );\n */\nDygraphInteraction.defaultModel = {\n  // Track the beginning of drag events\n  mousedown: function mousedown(event, g, context) {\n    // Right-click should not initiate a zoom.\n    if (event.button && event.button == 2) return;\n\n    context.initializeMouseDown(event, g, context);\n\n    if (event.altKey || event.shiftKey) {\n      DygraphInteraction.startPan(event, g, context);\n    } else {\n      DygraphInteraction.startZoom(event, g, context);\n    }\n\n    // Note: we register mousemove/mouseup on document to allow some leeway for\n    // events to move outside of the chart. Interaction model events get\n    // registered on the canvas, which is too small to allow this.\n    var mousemove = function mousemove(event) {\n      if (context.isZooming) {\n        // When the mouse moves >200px from the chart edge, cancel the zoom.\n        var d = distanceFromChart(event, g);\n        if (d < DRAG_EDGE_MARGIN) {\n          DygraphInteraction.moveZoom(event, g, context);\n        } else {\n          if (context.dragEndX !== null) {\n            context.dragEndX = null;\n            context.dragEndY = null;\n            g.clearZoomRect_();\n          }\n        }\n      } else if (context.isPanning) {\n        DygraphInteraction.movePan(event, g, context);\n      }\n    };\n    var mouseup = function mouseup(event) {\n      if (context.isZooming) {\n        if (context.dragEndX !== null) {\n          DygraphInteraction.endZoom(event, g, context);\n        } else {\n          DygraphInteraction.maybeTreatMouseOpAsClick(event, g, context);\n        }\n      } else if (context.isPanning) {\n        DygraphInteraction.endPan(event, g, context);\n      }\n\n      __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"i\" /* removeEvent */](document, 'mousemove', mousemove);\n      __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"i\" /* removeEvent */](document, 'mouseup', mouseup);\n      context.destroy();\n    };\n\n    g.addAndTrackEvent(document, 'mousemove', mousemove);\n    g.addAndTrackEvent(document, 'mouseup', mouseup);\n  },\n  willDestroyContextMyself: true,\n\n  touchstart: function touchstart(event, g, context) {\n    DygraphInteraction.startTouch(event, g, context);\n  },\n  touchmove: function touchmove(event, g, context) {\n    DygraphInteraction.moveTouch(event, g, context);\n  },\n  touchend: function touchend(event, g, context) {\n    DygraphInteraction.endTouch(event, g, context);\n  },\n\n  // Disable zooming out if panning.\n  dblclick: function dblclick(event, g, context) {\n    if (context.cancelNextDblclick) {\n      context.cancelNextDblclick = false;\n      return;\n    }\n\n    // Give plugins a chance to grab this event.\n    var e = {\n      canvasx: context.dragEndX,\n      canvasy: context.dragEndY,\n      cancelable: true\n    };\n    if (g.cascadeEvents_('dblclick', e)) {\n      return;\n    }\n\n    if (event.altKey || event.shiftKey) {\n      return;\n    }\n    g.resetZoom();\n  }\n};\n\n/*\nDygraph.DEFAULT_ATTRS.interactionModel = DygraphInteraction.defaultModel;\n\n// old ways of accessing these methods/properties\nDygraph.defaultInteractionModel = DygraphInteraction.defaultModel;\nDygraph.endZoom = DygraphInteraction.endZoom;\nDygraph.moveZoom = DygraphInteraction.moveZoom;\nDygraph.startZoom = DygraphInteraction.startZoom;\nDygraph.endPan = DygraphInteraction.endPan;\nDygraph.movePan = DygraphInteraction.movePan;\nDygraph.startPan = DygraphInteraction.startPan;\n*/\n\nDygraphInteraction.nonInteractiveModel_ = {\n  mousedown: function mousedown(event, g, context) {\n    context.initializeMouseDown(event, g, context);\n  },\n  mouseup: DygraphInteraction.maybeTreatMouseOpAsClick\n};\n\n// Default interaction model when using the range selector.\nDygraphInteraction.dragIsPanInteractionModel = {\n  mousedown: function mousedown(event, g, context) {\n    context.initializeMouseDown(event, g, context);\n    DygraphInteraction.startPan(event, g, context);\n  },\n  mousemove: function mousemove(event, g, context) {\n    if (context.isPanning) {\n      DygraphInteraction.movePan(event, g, context);\n    }\n  },\n  mouseup: function mouseup(event, g, context) {\n    if (context.isPanning) {\n      DygraphInteraction.endPan(event, g, context);\n    }\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DygraphInteraction);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLWludGVyYWN0aW9uLW1vZGVsLmpzP2IzZWQiXSwibmFtZXMiOlsiRFJBR19FREdFX01BUkdJTiIsIkR5Z3JhcGhJbnRlcmFjdGlvbiIsIm1heWJlVHJlYXRNb3VzZU9wQXNDbGljayIsImV2ZW50IiwiZyIsImNvbnRleHQiLCJkcmFnRW5kWCIsImRyYWdFbmRZIiwicmVnaW9uV2lkdGgiLCJNYXRoIiwiYWJzIiwiZHJhZ1N0YXJ0WCIsInJlZ2lvbkhlaWdodCIsImRyYWdTdGFydFkiLCJsYXN0eF8iLCJ1bmRlZmluZWQiLCJ0cmVhdE1vdXNlT3BBc0NsaWNrIiwic3RhcnRQYW4iLCJpIiwiYXhpcyIsImlzUGFubmluZyIsInhSYW5nZSIsInhBeGlzUmFuZ2UiLCJnZXRPcHRpb25Gb3JBeGlzIiwiaW5pdGlhbExlZnRtb3N0RGF0ZSIsImRhdGVSYW5nZSIsInhVbml0c1BlclBpeGVsIiwicGxvdHRlcl8iLCJhcmVhIiwidyIsImdldE51bWVyaWNPcHRpb24iLCJtYXhYUGl4ZWxzVG9EcmF3Iiwid2lkdGhfIiwieEV4dHJlbWVzIiwieEF4aXNFeHRyZW1lcyIsImJvdW5kZWRMZWZ0WCIsInRvRG9tWENvb3JkIiwiYm91bmRlZFJpZ2h0WCIsImJvdW5kZWRMZWZ0RGF0ZSIsInRvRGF0YVhDb29yZCIsImJvdW5kZWRSaWdodERhdGUiLCJib3VuZGVkRGF0ZXMiLCJib3VuZGVkVmFsdWVzIiwibWF4WVBpeGVsc1RvRHJhdyIsImhlaWdodF8iLCJheGVzXyIsImxlbmd0aCIsInlFeHRyZW1lcyIsImV4dHJlbWVSYW5nZSIsImJvdW5kZWRUb3BZIiwidG9Eb21ZQ29vcmQiLCJib3VuZGVkQm90dG9tWSIsImJvdW5kZWRUb3BWYWx1ZSIsInRvRGF0YVlDb29yZCIsImJvdW5kZWRCb3R0b21WYWx1ZSIsImlzMkRQYW4iLCJheGVzIiwiYXhpc19kYXRhIiwieVJhbmdlIiwieUF4aXNSYW5nZSIsImxvZ3NjYWxlIiwiYXR0cmlidXRlc18iLCJnZXRGb3JBeGlzIiwiaW5pdGlhbFRvcFZhbHVlIiwiZHJhZ1ZhbHVlUmFuZ2UiLCJ1bml0c1BlclBpeGVsIiwiaCIsInB1c2giLCJ2YWx1ZVJhbmdlIiwibW92ZVBhbiIsIm1pbkRhdGUiLCJtYXgiLCJtYXhEYXRlIiwiZGF0ZVdpbmRvd18iLCJwb3ciLCJwaXhlbHNEcmFnZ2VkIiwidW5pdHNEcmFnZ2VkIiwiYm91bmRlZFZhbHVlIiwibWF4VmFsdWUiLCJtaW4iLCJtaW5WYWx1ZSIsImRyYXdHcmFwaF8iLCJlbmRQYW4iLCJzdGFydFpvb20iLCJpc1pvb21pbmciLCJ6b29tTW92ZWQiLCJtb3ZlWm9vbSIsInhEZWx0YSIsInlEZWx0YSIsImRyYWdEaXJlY3Rpb24iLCJkcmF3Wm9vbVJlY3RfIiwicHJldkRyYWdEaXJlY3Rpb24iLCJwcmV2RW5kWCIsInByZXZFbmRZIiwiY2xpY2tDYWxsYmFjayIsImdldEZ1bmN0aW9uT3B0aW9uIiwicG9pbnRDbGlja0NhbGxiYWNrIiwic2VsZWN0ZWRQb2ludCIsImNsb3Nlc3RJZHgiLCJjbG9zZXN0RGlzdGFuY2UiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJzZWxQb2ludHNfIiwicCIsImRpc3RhbmNlIiwiY2FudmFzeCIsImNhbnZhc3kiLCJpc05hTiIsInJhZGl1cyIsImUiLCJjYW5jZWxhYmxlIiwicG9pbnQiLCJkZWZhdWx0UHJldmVudGVkIiwiY2FzY2FkZUV2ZW50c18iLCJjYWxsIiwieHZhbCIsInB0cyIsImVuZFpvb20iLCJjbGVhclpvb21SZWN0XyIsInBsb3RBcmVhIiwiZ2V0QXJlYSIsImxlZnQiLCJyaWdodCIsIngiLCJkb1pvb21YXyIsImNhbmNlbE5leHREYmxjbGljayIsInRvcCIsImJvdHRvbSIsInkiLCJkb1pvb21ZXyIsInN0YXJ0VG91Y2giLCJwcmV2ZW50RGVmYXVsdCIsInRvdWNoZXMiLCJzdGFydFRpbWVGb3JEb3VibGVUYXBNcyIsInQiLCJwYWdlWCIsInBhZ2VZIiwiZGF0YVgiLCJkYXRhWSIsImluaXRpYWxUb3VjaGVzIiwiaW5pdGlhbFBpbmNoQ2VudGVyIiwidG91Y2hEaXJlY3Rpb25zIiwiaW5pdGlhbEFuZ2xlIiwiUEkiLCJhdGFuMiIsImluaXRpYWxSYW5nZSIsIm1vdmVUb3VjaCIsImNfbm93IiwiY19pbml0Iiwic3dpcGUiLCJkYXRhV2lkdGgiLCJkYXRhSGVpZ2h0IiwieFNjYWxlIiwieVNjYWxlIiwiaW5pdEhhbGZXaWR0aCIsImluaXRIYWxmSGVpZ2h0IiwiZGlkWm9vbSIsInZpZXdXaW5kb3ciLCJ5QXhpc1JhbmdlcyIsImVuZFRvdWNoIiwiY2hhbmdlZFRvdWNoZXMiLCJub3ciLCJEYXRlIiwiZ2V0VGltZSIsImRvdWJsZVRhcFgiLCJzY3JlZW5YIiwiZG91YmxlVGFwWSIsInNjcmVlblkiLCJyZXNldFpvb20iLCJkaXN0YW5jZUZyb21JbnRlcnZhbCIsImRpc3RhbmNlRnJvbUNoYXJ0IiwiY2hhcnRQb3MiLCJjYW52YXNfIiwiYm94Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJwdCIsImR4IiwiZHkiLCJkZWZhdWx0TW9kZWwiLCJtb3VzZWRvd24iLCJidXR0b24iLCJpbml0aWFsaXplTW91c2VEb3duIiwiYWx0S2V5Iiwic2hpZnRLZXkiLCJtb3VzZW1vdmUiLCJkIiwibW91c2V1cCIsInV0aWxzIiwiZG9jdW1lbnQiLCJkZXN0cm95IiwiYWRkQW5kVHJhY2tFdmVudCIsIndpbGxEZXN0cm95Q29udGV4dE15c2VsZiIsInRvdWNoc3RhcnQiLCJ0b3VjaG1vdmUiLCJ0b3VjaGVuZCIsImRibGNsaWNrIiwibm9uSW50ZXJhY3RpdmVNb2RlbF8iLCJkcmFnSXNQYW5JbnRlcmFjdGlvbk1vZGVsIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7QUFLQSxJQUFJQSxtQkFBbUIsR0FBdkI7O0FBRUE7Ozs7QUFJQSxJQUFJQyxxQkFBcUIsRUFBekI7O0FBRUE7Ozs7Ozs7OztBQVNBQSxtQkFBbUJDLHdC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QUFuQixDQUE0QmQsS0FBNUIsRUFBbUNDLENBQW5DLEVBQXNDQyxPQUF0QztBQUNELEdBSjRDO0FBSzdDb0wsYUFBVyxtQkFBU3RMLEtBQVQsRUFBZ0JDLENBQWhCLEVBQW1CQyxPQUFuQixFQUE0QjtBQUNyQyxRQUFJQSxRQUFRZSxTQUFaLEVBQXVCO0FBQ3JCbkIseUJBQW1Cb0UsT0FBbkIsQ0FBMkJsRSxLQUEzQixFQUFrQ0MsQ0FBbEMsRUFBcUNDLE9BQXJDO0FBQ0Q7QUFDRixHQVQ0QztBQVU3Q3NMLFdBQVMsaUJBQVN4TCxLQUFULEVBQWdCQyxDQUFoQixFQUFtQkMsT0FBbkIsRUFBNEI7QUFDbkMsUUFBSUEsUUFBUWUsU0FBWixFQUF1QjtBQUNyQm5CLHlCQUFtQmlGLE1BQW5CLENBQTBCL0UsS0FBMUIsRUFBaUNDLENBQWpDLEVBQW9DQyxPQUFwQztBQUNEO0FBQ0Y7QUFkNEMsQ0FBL0M7O0FBaUJBLHlEQUFlSixrQkFBZiIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTEgUm9iZXJ0IEtvbmlnc2JlcmcgKGtvbmlnc2JlcmdAZ29vZ2xlLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhlIGRlZmF1bHQgaW50ZXJhY3Rpb24gbW9kZWwgZm9yIER5Z3JhcGhzLiBUaGlzIGlzIGtlcHQgb3V0XG4gKiBvZiBkeWdyYXBoLmpzIGZvciBiZXR0ZXIgbmF2aWdhYmlsaXR5LlxuICogQGF1dGhvciBSb2JlcnQgS29uaWdzYmVyZyAoa29uaWdzYmVyZ0Bnb29nbGUuY29tKVxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2R5Z3JhcGgtdXRpbHMnO1xuXG4vKipcbiAqIFlvdSBjYW4gZHJhZyB0aGlzIG1hbnkgcGl4ZWxzIHBhc3QgdGhlIGVkZ2Ugb2YgdGhlIGNoYXJ0IGFuZCBzdGlsbCBoYXZlIGl0XG4gKiBiZSBjb25zaWRlcmVkIGEgem9vbS4gVGhpcyBtYWtlcyBpdCBlYXNpZXIgdG8gem9vbSB0byB0aGUgZXhhY3QgZWRnZSBvZiB0aGVcbiAqIGNoYXJ0LCBhIGZhaXJseSBjb21tb24gb3BlcmF0aW9uLlxuICovXG52YXIgRFJBR19FREdFX01BUkdJTiA9IDEwMDtcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgZnVuY3Rpb25zIHRvIGZhY2lsaXRhdGUgYnVpbGQgY3VzdG9tIGludGVyYWN0aW9uIG1vZGVscy5cbiAqIEBjbGFzc1xuICovXG52YXIgRHlncmFwaEludGVyYWN0aW9uID0ge307XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGJlZ2lubmluZyAmIGVuZGluZyBvZiBhbiBldmVudCB3ZXJlIGNsb3NlIGVub3VnaCB0aGF0IGl0XG4gKiBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNsaWNrLiBJZiBpdCBzaG91bGQsIGRpc3BhdGNoIGFwcHJvcHJpYXRlIGV2ZW50cy5cbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHRyZWF0ZWQgYXMgYSBjbGljay5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtEeWdyYXBofSBnXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5EeWdyYXBoSW50ZXJhY3Rpb24ubWF5YmVUcmVhdE1vdXNlT3BBc0NsaWNrID0gZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgY29udGV4dC5kcmFnRW5kWCA9IHV0aWxzLmRyYWdHZXRYXyhldmVudCwgY29udGV4dCk7XG4gIGNvbnRleHQuZHJhZ0VuZFkgPSB1dGlscy5kcmFnR2V0WV8oZXZlbnQsIGNvbnRleHQpO1xuICB2YXIgcmVnaW9uV2lkdGggPSBNYXRoLmFicyhjb250ZXh0LmRyYWdFbmRYIC0gY29udGV4dC5kcmFnU3RhcnRYKTtcbiAgdmFyIHJlZ2lvbkhlaWdodCA9IE1hdGguYWJzKGNvbnRleHQuZHJhZ0VuZFkgLSBjb250ZXh0LmRyYWdTdGFydFkpO1xuXG4gIGlmIChyZWdpb25XaWR0aCA8IDIgJiYgcmVnaW9uSGVpZ2h0IDwgMiAmJlxuICAgICAgZy5sYXN0eF8gIT09IHVuZGVmaW5lZCAmJiBnLmxhc3R4XyAhPSAtMSkge1xuICAgIER5Z3JhcGhJbnRlcmFjdGlvbi50cmVhdE1vdXNlT3BBc0NsaWNrKGcsIGV2ZW50LCBjb250ZXh0KTtcbiAgfVxuXG4gIGNvbnRleHQucmVnaW9uV2lkdGggPSByZWdpb25XaWR0aDtcbiAgY29udGV4dC5yZWdpb25IZWlnaHQgPSByZWdpb25IZWlnaHQ7XG59O1xuXG4vKipcbiAqIENhbGxlZCBpbiByZXNwb25zZSB0byBhbiBpbnRlcmFjdGlvbiBtb2RlbCBvcGVyYXRpb24gdGhhdFxuICogc2hvdWxkIHN0YXJ0IHRoZSBkZWZhdWx0IHBhbm5pbmcgYmVoYXZpb3IuXG4gKlxuICogSXQncyB1c2VkIGluIHRoZSBkZWZhdWx0IGNhbGxiYWNrIGZvciBcIm1vdXNlZG93blwiIG9wZXJhdGlvbnMuXG4gKiBDdXN0b20gaW50ZXJhY3Rpb24gbW9kZWwgYnVpbGRlcnMgY2FuIHVzZSBpdCB0byBwcm92aWRlIHRoZSBkZWZhdWx0XG4gKiBwYW5uaW5nIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IHRoZSBldmVudCBvYmplY3Qgd2hpY2ggbGVkIHRvIHRoZSBzdGFydFBhbiBjYWxsLlxuICogQHBhcmFtIHtEeWdyYXBofSBnIFRoZSBkeWdyYXBoIG9uIHdoaWNoIHRvIGFjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBkcmFnZ2luZyBjb250ZXh0IG9iamVjdCAod2l0aFxuICogICAgIGRyYWdTdGFydFgvZHJhZ1N0YXJ0WS9ldGMuIHByb3BlcnRpZXMpLiBUaGlzIGZ1bmN0aW9uIG1vZGlmaWVzIHRoZVxuICogICAgIGNvbnRleHQuXG4gKi9cbkR5Z3JhcGhJbnRlcmFjdGlvbi5zdGFydFBhbiA9IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gIHZhciBpLCBheGlzO1xuICBjb250ZXh0LmlzUGFubmluZyA9IHRydWU7XG4gIHZhciB4UmFuZ2UgPSBnLnhBeGlzUmFuZ2UoKTtcblxuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKFwibG9nc2NhbGVcIiwgXCJ4XCIpKSB7XG4gICAgY29udGV4dC5pbml0aWFsTGVmdG1vc3REYXRlID0gdXRpbHMubG9nMTAoeFJhbmdlWzBdKTtcbiAgICBjb250ZXh0LmRhdGVSYW5nZSA9IHV0aWxzLmxvZzEwKHhSYW5nZVsxXSkgLSB1dGlscy5sb2cxMCh4UmFuZ2VbMF0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuaW5pdGlhbExlZnRtb3N0RGF0ZSA9IHhSYW5nZVswXTtcbiAgICBjb250ZXh0LmRhdGVSYW5nZSA9IHhSYW5nZVsxXSAtIHhSYW5nZVswXTtcbiAgfVxuICBjb250ZXh0LnhVbml0c1BlclBpeGVsID0gY29udGV4dC5kYXRlUmFuZ2UgLyAoZy5wbG90dGVyXy5hcmVhLncgLSAxKTtcblxuICBpZiAoZy5nZXROdW1lcmljT3B0aW9uKFwicGFuRWRnZUZyYWN0aW9uXCIpKSB7XG4gICAgdmFyIG1heFhQaXhlbHNUb0RyYXcgPSBnLndpZHRoXyAqIGcuZ2V0TnVtZXJpY09wdGlvbihcInBhbkVkZ2VGcmFjdGlvblwiKTtcbiAgICB2YXIgeEV4dHJlbWVzID0gZy54QXhpc0V4dHJlbWVzKCk7IC8vIEkgUkVBTExZIFdBTlQgVE8gQ0FMTCBUSElTIHhUcmVtZXMhXG5cbiAgICB2YXIgYm91bmRlZExlZnRYID0gZy50b0RvbVhDb29yZCh4RXh0cmVtZXNbMF0pIC0gbWF4WFBpeGVsc1RvRHJhdztcbiAgICB2YXIgYm91bmRlZFJpZ2h0WCA9IGcudG9Eb21YQ29vcmQoeEV4dHJlbWVzWzFdKSArIG1heFhQaXhlbHNUb0RyYXc7XG5cbiAgICB2YXIgYm91bmRlZExlZnREYXRlID0gZy50b0RhdGFYQ29vcmQoYm91bmRlZExlZnRYKTtcbiAgICB2YXIgYm91bmRlZFJpZ2h0RGF0ZSA9IGcudG9EYXRhWENvb3JkKGJvdW5kZWRSaWdodFgpO1xuICAgIGNvbnRleHQuYm91bmRlZERhdGVzID0gW2JvdW5kZWRMZWZ0RGF0ZSwgYm91bmRlZFJpZ2h0RGF0ZV07XG5cbiAgICB2YXIgYm91bmRlZFZhbHVlcyA9IFtdO1xuICAgIHZhciBtYXhZUGl4ZWxzVG9EcmF3ID0gZy5oZWlnaHRfICogZy5nZXROdW1lcmljT3B0aW9uKFwicGFuRWRnZUZyYWN0aW9uXCIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGcuYXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGF4aXMgPSBnLmF4ZXNfW2ldO1xuICAgICAgdmFyIHlFeHRyZW1lcyA9IGF4aXMuZXh0cmVtZVJhbmdlO1xuXG4gICAgICB2YXIgYm91bmRlZFRvcFkgPSBnLnRvRG9tWUNvb3JkKHlFeHRyZW1lc1swXSwgaSkgKyBtYXhZUGl4ZWxzVG9EcmF3O1xuICAgICAgdmFyIGJvdW5kZWRCb3R0b21ZID0gZy50b0RvbVlDb29yZCh5RXh0cmVtZXNbMV0sIGkpIC0gbWF4WVBpeGVsc1RvRHJhdztcblxuICAgICAgdmFyIGJvdW5kZWRUb3BWYWx1ZSA9IGcudG9EYXRhWUNvb3JkKGJvdW5kZWRUb3BZLCBpKTtcbiAgICAgIHZhciBib3VuZGVkQm90dG9tVmFsdWUgPSBnLnRvRGF0YVlDb29yZChib3VuZGVkQm90dG9tWSwgaSk7XG5cbiAgICAgIGJvdW5kZWRWYWx1ZXNbaV0gPSBbYm91bmRlZFRvcFZhbHVlLCBib3VuZGVkQm90dG9tVmFsdWVdO1xuICAgIH1cbiAgICBjb250ZXh0LmJvdW5kZWRWYWx1ZXMgPSBib3VuZGVkVmFsdWVzO1xuICB9XG5cbiAgLy8gUmVjb3JkIHRoZSByYW5nZSBvZiBlYWNoIHktYXhpcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGRyYWcuXG4gIC8vIElmIGFueSBheGlzIGhhcyBhIHZhbHVlUmFuZ2UsIHRoZW4gd2Ugd2FudCBhIDJEIHBhbi5cbiAgLy8gV2UgY2FuJ3Qgc3RvcmUgZGF0YSBkaXJlY3RseSBpbiBnLmF4ZXNfLCBiZWNhdXNlIGl0IGRvZXMgbm90IGJlbG9uZyB0byB1c1xuICAvLyBhbmQgY291bGQgY2hhbmdlIG91dCBmcm9tIHVuZGVyIHVzIGR1cmluZyBhIHBhbiAoc2F5IGlmIHRoZXJlJ3MgYSBkYXRhXG4gIC8vIHVwZGF0ZSkuXG4gIGNvbnRleHQuaXMyRFBhbiA9IGZhbHNlO1xuICBjb250ZXh0LmF4ZXMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IGcuYXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICBheGlzID0gZy5heGVzX1tpXTtcbiAgICB2YXIgYXhpc19kYXRhID0ge307XG4gICAgdmFyIHlSYW5nZSA9IGcueUF4aXNSYW5nZShpKTtcbiAgICAvLyBUT0RPKGtvbmlnc2JlcmcpOiBUaGVzZSB2YWx1ZXMgc2hvdWxkIGJlIGluIHxjb250ZXh0fC5cbiAgICAvLyBJbiBsb2cgc2NhbGUsIGluaXRpYWxUb3BWYWx1ZSwgZHJhZ1ZhbHVlUmFuZ2UgYW5kIHVuaXRzUGVyUGl4ZWwgYXJlIGxvZyBzY2FsZS5cbiAgICB2YXIgbG9nc2NhbGUgPSBnLmF0dHJpYnV0ZXNfLmdldEZvckF4aXMoXCJsb2dzY2FsZVwiLCBpKTtcbiAgICBpZiAobG9nc2NhbGUpIHtcbiAgICAgIGF4aXNfZGF0YS5pbml0aWFsVG9wVmFsdWUgPSB1dGlscy5sb2cxMCh5UmFuZ2VbMV0pO1xuICAgICAgYXhpc19kYXRhLmRyYWdWYWx1ZVJhbmdlID0gdXRpbHMubG9nMTAoeVJhbmdlWzFdKSAtIHV0aWxzLmxvZzEwKHlSYW5nZVswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF4aXNfZGF0YS5pbml0aWFsVG9wVmFsdWUgPSB5UmFuZ2VbMV07XG4gICAgICBheGlzX2RhdGEuZHJhZ1ZhbHVlUmFuZ2UgPSB5UmFuZ2VbMV0gLSB5UmFuZ2VbMF07XG4gICAgfVxuICAgIGF4aXNfZGF0YS51bml0c1BlclBpeGVsID0gYXhpc19kYXRhLmRyYWdWYWx1ZVJhbmdlIC8gKGcucGxvdHRlcl8uYXJlYS5oIC0gMSk7XG4gICAgY29udGV4dC5heGVzLnB1c2goYXhpc19kYXRhKTtcblxuICAgIC8vIFdoaWxlIGNhbGN1bGF0aW5nIGF4ZXMsIHNldCAyZHBhbi5cbiAgICBpZiAoYXhpcy52YWx1ZVJhbmdlKSBjb250ZXh0LmlzMkRQYW4gPSB0cnVlO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCBpbiByZXNwb25zZSB0byBhbiBpbnRlcmFjdGlvbiBtb2RlbCBvcGVyYXRpb24gdGhhdFxuICogcmVzcG9uZHMgdG8gYW4gZXZlbnQgdGhhdCBwYW5zIHRoZSB2aWV3LlxuICpcbiAqIEl0J3MgdXNlZCBpbiB0aGUgZGVmYXVsdCBjYWxsYmFjayBmb3IgXCJtb3VzZW1vdmVcIiBvcGVyYXRpb25zLlxuICogQ3VzdG9tIGludGVyYWN0aW9uIG1vZGVsIGJ1aWxkZXJzIGNhbiB1c2UgaXQgdG8gcHJvdmlkZSB0aGUgZGVmYXVsdFxuICogcGFubmluZyBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCB0aGUgZXZlbnQgb2JqZWN0IHdoaWNoIGxlZCB0byB0aGUgbW92ZVBhbiBjYWxsLlxuICogQHBhcmFtIHtEeWdyYXBofSBnIFRoZSBkeWdyYXBoIG9uIHdoaWNoIHRvIGFjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBkcmFnZ2luZyBjb250ZXh0IG9iamVjdCAod2l0aFxuICogICAgIGRyYWdTdGFydFgvZHJhZ1N0YXJ0WS9ldGMuIHByb3BlcnRpZXMpLiBUaGlzIGZ1bmN0aW9uIG1vZGlmaWVzIHRoZVxuICogICAgIGNvbnRleHQuXG4gKi9cbkR5Z3JhcGhJbnRlcmFjdGlvbi5tb3ZlUGFuID0gZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgY29udGV4dC5kcmFnRW5kWCA9IHV0aWxzLmRyYWdHZXRYXyhldmVudCwgY29udGV4dCk7XG4gIGNvbnRleHQuZHJhZ0VuZFkgPSB1dGlscy5kcmFnR2V0WV8oZXZlbnQsIGNvbnRleHQpO1xuXG4gIHZhciBtaW5EYXRlID0gY29udGV4dC5pbml0aWFsTGVmdG1vc3REYXRlIC1cbiAgICAoY29udGV4dC5kcmFnRW5kWCAtIGNvbnRleHQuZHJhZ1N0YXJ0WCkgKiBjb250ZXh0LnhVbml0c1BlclBpeGVsO1xuICBpZiAoY29udGV4dC5ib3VuZGVkRGF0ZXMpIHtcbiAgICBtaW5EYXRlID0gTWF0aC5tYXgobWluRGF0ZSwgY29udGV4dC5ib3VuZGVkRGF0ZXNbMF0pO1xuICB9XG4gIHZhciBtYXhEYXRlID0gbWluRGF0ZSArIGNvbnRleHQuZGF0ZVJhbmdlO1xuICBpZiAoY29udGV4dC5ib3VuZGVkRGF0ZXMpIHtcbiAgICBpZiAobWF4RGF0ZSA+IGNvbnRleHQuYm91bmRlZERhdGVzWzFdKSB7XG4gICAgICAvLyBBZGp1c3QgbWluRGF0ZSwgYW5kIHJlY29tcHV0ZSBtYXhEYXRlLlxuICAgICAgbWluRGF0ZSA9IG1pbkRhdGUgLSAobWF4RGF0ZSAtIGNvbnRleHQuYm91bmRlZERhdGVzWzFdKTtcbiAgICAgIG1heERhdGUgPSBtaW5EYXRlICsgY29udGV4dC5kYXRlUmFuZ2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGcuZ2V0T3B0aW9uRm9yQXhpcyhcImxvZ3NjYWxlXCIsIFwieFwiKSkge1xuICAgIGcuZGF0ZVdpbmRvd18gPSBbIE1hdGgucG93KHV0aWxzLkxPR19TQ0FMRSwgbWluRGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3codXRpbHMuTE9HX1NDQUxFLCBtYXhEYXRlKSBdO1xuICB9IGVsc2Uge1xuICAgIGcuZGF0ZVdpbmRvd18gPSBbbWluRGF0ZSwgbWF4RGF0ZV07XG4gIH1cblxuICAvLyB5LWF4aXMgc2NhbGluZyBpcyBhdXRvbWF0aWMgdW5sZXNzIHRoaXMgaXMgYSBmdWxsIDJEIHBhbi5cbiAgaWYgKGNvbnRleHQuaXMyRFBhbikge1xuXG4gICAgdmFyIHBpeGVsc0RyYWdnZWQgPSBjb250ZXh0LmRyYWdFbmRZIC0gY29udGV4dC5kcmFnU3RhcnRZO1xuXG4gICAgLy8gQWRqdXN0IGVhY2ggYXhpcyBhcHByb3ByaWF0ZWx5LlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZy5heGVzXy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF4aXMgPSBnLmF4ZXNfW2ldO1xuICAgICAgdmFyIGF4aXNfZGF0YSA9IGNvbnRleHQuYXhlc1tpXTtcbiAgICAgIHZhciB1bml0c0RyYWdnZWQgPSBwaXhlbHNEcmFnZ2VkICogYXhpc19kYXRhLnVuaXRzUGVyUGl4ZWw7XG5cbiAgICAgIHZhciBib3VuZGVkVmFsdWUgPSBjb250ZXh0LmJvdW5kZWRWYWx1ZXMgPyBjb250ZXh0LmJvdW5kZWRWYWx1ZXNbaV0gOiBudWxsO1xuXG4gICAgICAvLyBJbiBsb2cgc2NhbGUsIG1heFZhbHVlIGFuZCBtaW5WYWx1ZSBhcmUgdGhlIGxvZ3Mgb2YgdGhvc2UgdmFsdWVzLlxuICAgICAgdmFyIG1heFZhbHVlID0gYXhpc19kYXRhLmluaXRpYWxUb3BWYWx1ZSArIHVuaXRzRHJhZ2dlZDtcbiAgICAgIGlmIChib3VuZGVkVmFsdWUpIHtcbiAgICAgICAgbWF4VmFsdWUgPSBNYXRoLm1pbihtYXhWYWx1ZSwgYm91bmRlZFZhbHVlWzFdKTtcbiAgICAgIH1cbiAgICAgIHZhciBtaW5WYWx1ZSA9IG1heFZhbHVlIC0gYXhpc19kYXRhLmRyYWdWYWx1ZVJhbmdlO1xuICAgICAgaWYgKGJvdW5kZWRWYWx1ZSkge1xuICAgICAgICBpZiAobWluVmFsdWUgPCBib3VuZGVkVmFsdWVbMF0pIHtcbiAgICAgICAgICAvLyBBZGp1c3QgbWF4VmFsdWUsIGFuZCByZWNvbXB1dGUgbWluVmFsdWUuXG4gICAgICAgICAgbWF4VmFsdWUgPSBtYXhWYWx1ZSAtIChtaW5WYWx1ZSAtIGJvdW5kZWRWYWx1ZVswXSk7XG4gICAgICAgICAgbWluVmFsdWUgPSBtYXhWYWx1ZSAtIGF4aXNfZGF0YS5kcmFnVmFsdWVSYW5nZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGcuYXR0cmlidXRlc18uZ2V0Rm9yQXhpcyhcImxvZ3NjYWxlXCIsIGkpKSB7XG4gICAgICAgIGF4aXMudmFsdWVSYW5nZSA9IFsgTWF0aC5wb3codXRpbHMuTE9HX1NDQUxFLCBtaW5WYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3codXRpbHMuTE9HX1NDQUxFLCBtYXhWYWx1ZSkgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF4aXMudmFsdWVSYW5nZSA9IFsgbWluVmFsdWUsIG1heFZhbHVlIF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZy5kcmF3R3JhcGhfKGZhbHNlKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGluIHJlc3BvbnNlIHRvIGFuIGludGVyYWN0aW9uIG1vZGVsIG9wZXJhdGlvbiB0aGF0XG4gKiByZXNwb25kcyB0byBhbiBldmVudCB0aGF0IGVuZHMgcGFubmluZy5cbiAqXG4gKiBJdCdzIHVzZWQgaW4gdGhlIGRlZmF1bHQgY2FsbGJhY2sgZm9yIFwibW91c2V1cFwiIG9wZXJhdGlvbnMuXG4gKiBDdXN0b20gaW50ZXJhY3Rpb24gbW9kZWwgYnVpbGRlcnMgY2FuIHVzZSBpdCB0byBwcm92aWRlIHRoZSBkZWZhdWx0XG4gKiBwYW5uaW5nIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IHRoZSBldmVudCBvYmplY3Qgd2hpY2ggbGVkIHRvIHRoZSBlbmRQYW4gY2FsbC5cbiAqIEBwYXJhbSB7RHlncmFwaH0gZyBUaGUgZHlncmFwaCBvbiB3aGljaCB0byBhY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgZHJhZ2dpbmcgY29udGV4dCBvYmplY3QgKHdpdGhcbiAqICAgICBkcmFnU3RhcnRYL2RyYWdTdGFydFkvZXRjLiBwcm9wZXJ0aWVzKS4gVGhpcyBmdW5jdGlvbiBtb2RpZmllcyB0aGVcbiAqICAgICBjb250ZXh0LlxuICovXG5EeWdyYXBoSW50ZXJhY3Rpb24uZW5kUGFuID0gRHlncmFwaEludGVyYWN0aW9uLm1heWJlVHJlYXRNb3VzZU9wQXNDbGljaztcblxuLyoqXG4gKiBDYWxsZWQgaW4gcmVzcG9uc2UgdG8gYW4gaW50ZXJhY3Rpb24gbW9kZWwgb3BlcmF0aW9uIHRoYXRcbiAqIHJlc3BvbmRzIHRvIGFuIGV2ZW50IHRoYXQgc3RhcnRzIHpvb21pbmcuXG4gKlxuICogSXQncyB1c2VkIGluIHRoZSBkZWZhdWx0IGNhbGxiYWNrIGZvciBcIm1vdXNlZG93blwiIG9wZXJhdGlvbnMuXG4gKiBDdXN0b20gaW50ZXJhY3Rpb24gbW9kZWwgYnVpbGRlcnMgY2FuIHVzZSBpdCB0byBwcm92aWRlIHRoZSBkZWZhdWx0XG4gKiB6b29taW5nIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IHRoZSBldmVudCBvYmplY3Qgd2hpY2ggbGVkIHRvIHRoZSBzdGFydFpvb20gY2FsbC5cbiAqIEBwYXJhbSB7RHlncmFwaH0gZyBUaGUgZHlncmFwaCBvbiB3aGljaCB0byBhY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgZHJhZ2dpbmcgY29udGV4dCBvYmplY3QgKHdpdGhcbiAqICAgICBkcmFnU3RhcnRYL2RyYWdTdGFydFkvZXRjLiBwcm9wZXJ0aWVzKS4gVGhpcyBmdW5jdGlvbiBtb2RpZmllcyB0aGVcbiAqICAgICBjb250ZXh0LlxuICovXG5EeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRab29tID0gZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgY29udGV4dC5pc1pvb21pbmcgPSB0cnVlO1xuICBjb250ZXh0Lnpvb21Nb3ZlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaW4gcmVzcG9uc2UgdG8gYW4gaW50ZXJhY3Rpb24gbW9kZWwgb3BlcmF0aW9uIHRoYXRcbiAqIHJlc3BvbmRzIHRvIGFuIGV2ZW50IHRoYXQgZGVmaW5lcyB6b29tIGJvdW5kYXJpZXMuXG4gKlxuICogSXQncyB1c2VkIGluIHRoZSBkZWZhdWx0IGNhbGxiYWNrIGZvciBcIm1vdXNlbW92ZVwiIG9wZXJhdGlvbnMuXG4gKiBDdXN0b20gaW50ZXJhY3Rpb24gbW9kZWwgYnVpbGRlcnMgY2FuIHVzZSBpdCB0byBwcm92aWRlIHRoZSBkZWZhdWx0XG4gKiB6b29taW5nIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IHRoZSBldmVudCBvYmplY3Qgd2hpY2ggbGVkIHRvIHRoZSBtb3ZlWm9vbSBjYWxsLlxuICogQHBhcmFtIHtEeWdyYXBofSBnIFRoZSBkeWdyYXBoIG9uIHdoaWNoIHRvIGFjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBkcmFnZ2luZyBjb250ZXh0IG9iamVjdCAod2l0aFxuICogICAgIGRyYWdTdGFydFgvZHJhZ1N0YXJ0WS9ldGMuIHByb3BlcnRpZXMpLiBUaGlzIGZ1bmN0aW9uIG1vZGlmaWVzIHRoZVxuICogICAgIGNvbnRleHQuXG4gKi9cbkR5Z3JhcGhJbnRlcmFjdGlvbi5tb3ZlWm9vbSA9IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gIGNvbnRleHQuem9vbU1vdmVkID0gdHJ1ZTtcbiAgY29udGV4dC5kcmFnRW5kWCA9IHV0aWxzLmRyYWdHZXRYXyhldmVudCwgY29udGV4dCk7XG4gIGNvbnRleHQuZHJhZ0VuZFkgPSB1dGlscy5kcmFnR2V0WV8oZXZlbnQsIGNvbnRleHQpO1xuXG4gIHZhciB4RGVsdGEgPSBNYXRoLmFicyhjb250ZXh0LmRyYWdTdGFydFggLSBjb250ZXh0LmRyYWdFbmRYKTtcbiAgdmFyIHlEZWx0YSA9IE1hdGguYWJzKGNvbnRleHQuZHJhZ1N0YXJ0WSAtIGNvbnRleHQuZHJhZ0VuZFkpO1xuXG4gIC8vIGRyYWcgZGlyZWN0aW9uIHRocmVzaG9sZCBmb3IgeSBheGlzIGlzIHR3aWNlIGFzIGxhcmdlIGFzIHggYXhpc1xuICBjb250ZXh0LmRyYWdEaXJlY3Rpb24gPSAoeERlbHRhIDwgeURlbHRhIC8gMikgPyB1dGlscy5WRVJUSUNBTCA6IHV0aWxzLkhPUklaT05UQUw7XG5cbiAgZy5kcmF3Wm9vbVJlY3RfKFxuICAgICAgY29udGV4dC5kcmFnRGlyZWN0aW9uLFxuICAgICAgY29udGV4dC5kcmFnU3RhcnRYLFxuICAgICAgY29udGV4dC5kcmFnRW5kWCxcbiAgICAgIGNvbnRleHQuZHJhZ1N0YXJ0WSxcbiAgICAgIGNvbnRleHQuZHJhZ0VuZFksXG4gICAgICBjb250ZXh0LnByZXZEcmFnRGlyZWN0aW9uLFxuICAgICAgY29udGV4dC5wcmV2RW5kWCxcbiAgICAgIGNvbnRleHQucHJldkVuZFkpO1xuXG4gIGNvbnRleHQucHJldkVuZFggPSBjb250ZXh0LmRyYWdFbmRYO1xuICBjb250ZXh0LnByZXZFbmRZID0gY29udGV4dC5kcmFnRW5kWTtcbiAgY29udGV4dC5wcmV2RHJhZ0RpcmVjdGlvbiA9IGNvbnRleHQuZHJhZ0RpcmVjdGlvbjtcbn07XG5cbi8qKlxuICogVE9ETyhkYW52ayk6IG1vdmUgdGhpcyBsb2dpYyBpbnRvIGR5Z3JhcGguanNcbiAqIEBwYXJhbSB7RHlncmFwaH0gZ1xuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKi9cbkR5Z3JhcGhJbnRlcmFjdGlvbi50cmVhdE1vdXNlT3BBc0NsaWNrID0gZnVuY3Rpb24oZywgZXZlbnQsIGNvbnRleHQpIHtcbiAgdmFyIGNsaWNrQ2FsbGJhY2sgPSBnLmdldEZ1bmN0aW9uT3B0aW9uKCdjbGlja0NhbGxiYWNrJyk7XG4gIHZhciBwb2ludENsaWNrQ2FsbGJhY2sgPSBnLmdldEZ1bmN0aW9uT3B0aW9uKCdwb2ludENsaWNrQ2FsbGJhY2snKTtcblxuICB2YXIgc2VsZWN0ZWRQb2ludCA9IG51bGw7XG5cbiAgLy8gRmluZCBvdXQgaWYgdGhlIGNsaWNrIG9jY3VycyBvbiBhIHBvaW50LlxuICB2YXIgY2xvc2VzdElkeCA9IC0xO1xuICB2YXIgY2xvc2VzdERpc3RhbmNlID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAvLyBjaGVjayBpZiB0aGUgY2xpY2sgd2FzIG9uIGEgcGFydGljdWxhciBwb2ludC5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnLnNlbFBvaW50c18ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IGcuc2VsUG9pbnRzX1tpXTtcbiAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnBvdyhwLmNhbnZhc3ggLSBjb250ZXh0LmRyYWdFbmRYLCAyKSArXG4gICAgICAgICAgICAgICAgICAgTWF0aC5wb3cocC5jYW52YXN5IC0gY29udGV4dC5kcmFnRW5kWSwgMik7XG4gICAgaWYgKCFpc05hTihkaXN0YW5jZSkgJiZcbiAgICAgICAgKGNsb3Nlc3RJZHggPT0gLTEgfHwgZGlzdGFuY2UgPCBjbG9zZXN0RGlzdGFuY2UpKSB7XG4gICAgICBjbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgIGNsb3Nlc3RJZHggPSBpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFsbG93IGFueSBjbGljayB3aXRoaW4gdHdvIHBpeGVscyBvZiB0aGUgZG90LlxuICB2YXIgcmFkaXVzID0gZy5nZXROdW1lcmljT3B0aW9uKCdoaWdobGlnaHRDaXJjbGVTaXplJykgKyAyO1xuICBpZiAoY2xvc2VzdERpc3RhbmNlIDw9IHJhZGl1cyAqIHJhZGl1cykge1xuICAgIHNlbGVjdGVkUG9pbnQgPSBnLnNlbFBvaW50c19bY2xvc2VzdElkeF07XG4gIH1cblxuICBpZiAoc2VsZWN0ZWRQb2ludCkge1xuICAgIHZhciBlID0ge1xuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIHBvaW50OiBzZWxlY3RlZFBvaW50LFxuICAgICAgY2FudmFzeDogY29udGV4dC5kcmFnRW5kWCxcbiAgICAgIGNhbnZhc3k6IGNvbnRleHQuZHJhZ0VuZFlcbiAgICB9O1xuICAgIHZhciBkZWZhdWx0UHJldmVudGVkID0gZy5jYXNjYWRlRXZlbnRzXygncG9pbnRDbGljaycsIGUpO1xuICAgIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAvLyBOb3RlOiB0aGlzIGFsc28gcHJldmVudHMgY2xpY2sgLyBjbGlja0NhbGxiYWNrIGZyb20gZmlyaW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocG9pbnRDbGlja0NhbGxiYWNrKSB7XG4gICAgICBwb2ludENsaWNrQ2FsbGJhY2suY2FsbChnLCBldmVudCwgc2VsZWN0ZWRQb2ludCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGUgPSB7XG4gICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICB4dmFsOiBnLmxhc3R4XywgIC8vIGNsb3Nlc3QgcG9pbnQgYnkgeCB2YWx1ZVxuICAgIHB0czogZy5zZWxQb2ludHNfLFxuICAgIGNhbnZhc3g6IGNvbnRleHQuZHJhZ0VuZFgsXG4gICAgY2FudmFzeTogY29udGV4dC5kcmFnRW5kWVxuICB9O1xuICBpZiAoIWcuY2FzY2FkZUV2ZW50c18oJ2NsaWNrJywgZSkpIHtcbiAgICBpZiAoY2xpY2tDYWxsYmFjaykge1xuICAgICAgLy8gVE9ETyhkYW52ayk6IHBhc3MgYWxvbmcgbW9yZSBpbmZvIGFib3V0IHRoZSBwb2ludHMsIGUuZy4gJ3gnXG4gICAgICBjbGlja0NhbGxiYWNrLmNhbGwoZywgZXZlbnQsIGcubGFzdHhfLCBnLnNlbFBvaW50c18pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgaW4gcmVzcG9uc2UgdG8gYW4gaW50ZXJhY3Rpb24gbW9kZWwgb3BlcmF0aW9uIHRoYXRcbiAqIHJlc3BvbmRzIHRvIGFuIGV2ZW50IHRoYXQgcGVyZm9ybXMgYSB6b29tIGJhc2VkIG9uIHByZXZpb3VzbHkgZGVmaW5lZFxuICogYm91bmRzLi5cbiAqXG4gKiBJdCdzIHVzZWQgaW4gdGhlIGRlZmF1bHQgY2FsbGJhY2sgZm9yIFwibW91c2V1cFwiIG9wZXJhdGlvbnMuXG4gKiBDdXN0b20gaW50ZXJhY3Rpb24gbW9kZWwgYnVpbGRlcnMgY2FuIHVzZSBpdCB0byBwcm92aWRlIHRoZSBkZWZhdWx0XG4gKiB6b29taW5nIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IHRoZSBldmVudCBvYmplY3Qgd2hpY2ggbGVkIHRvIHRoZSBlbmRab29tIGNhbGwuXG4gKiBAcGFyYW0ge0R5Z3JhcGh9IGcgVGhlIGR5Z3JhcGggb24gd2hpY2ggdG8gZW5kIHRoZSB6b29tLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgVGhlIGRyYWdnaW5nIGNvbnRleHQgb2JqZWN0ICh3aXRoXG4gKiAgICAgZHJhZ1N0YXJ0WC9kcmFnU3RhcnRZL2V0Yy4gcHJvcGVydGllcykuIFRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdGhlXG4gKiAgICAgY29udGV4dC5cbiAqL1xuRHlncmFwaEludGVyYWN0aW9uLmVuZFpvb20gPSBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICBnLmNsZWFyWm9vbVJlY3RfKCk7XG4gIGNvbnRleHQuaXNab29taW5nID0gZmFsc2U7XG4gIER5Z3JhcGhJbnRlcmFjdGlvbi5tYXliZVRyZWF0TW91c2VPcEFzQ2xpY2soZXZlbnQsIGcsIGNvbnRleHQpO1xuXG4gIC8vIFRoZSB6b29tIHJlY3RhbmdsZSBpcyB2aXNpYmx5IGNsaXBwZWQgdG8gdGhlIHBsb3QgYXJlYSwgc28gaXRzIGJlaGF2aW9yXG4gIC8vIHNob3VsZCBiZSBhcyB3ZWxsLlxuICAvLyBTZWUgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2R5Z3JhcGhzL2lzc3Vlcy9kZXRhaWw/aWQ9MjgwXG4gIHZhciBwbG90QXJlYSA9IGcuZ2V0QXJlYSgpO1xuICBpZiAoY29udGV4dC5yZWdpb25XaWR0aCA+PSAxMCAmJlxuICAgICAgY29udGV4dC5kcmFnRGlyZWN0aW9uID09IHV0aWxzLkhPUklaT05UQUwpIHtcbiAgICB2YXIgbGVmdCA9IE1hdGgubWluKGNvbnRleHQuZHJhZ1N0YXJ0WCwgY29udGV4dC5kcmFnRW5kWCksXG4gICAgICAgIHJpZ2h0ID0gTWF0aC5tYXgoY29udGV4dC5kcmFnU3RhcnRYLCBjb250ZXh0LmRyYWdFbmRYKTtcbiAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCwgcGxvdEFyZWEueCk7XG4gICAgcmlnaHQgPSBNYXRoLm1pbihyaWdodCwgcGxvdEFyZWEueCArIHBsb3RBcmVhLncpO1xuICAgIGlmIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgIGcuZG9ab29tWF8obGVmdCwgcmlnaHQpO1xuICAgIH1cbiAgICBjb250ZXh0LmNhbmNlbE5leHREYmxjbGljayA9IHRydWU7XG4gIH0gZWxzZSBpZiAoY29udGV4dC5yZWdpb25IZWlnaHQgPj0gMTAgJiZcbiAgICAgICAgICAgICBjb250ZXh0LmRyYWdEaXJlY3Rpb24gPT0gdXRpbHMuVkVSVElDQUwpIHtcbiAgICB2YXIgdG9wID0gTWF0aC5taW4oY29udGV4dC5kcmFnU3RhcnRZLCBjb250ZXh0LmRyYWdFbmRZKSxcbiAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoY29udGV4dC5kcmFnU3RhcnRZLCBjb250ZXh0LmRyYWdFbmRZKTtcbiAgICB0b3AgPSBNYXRoLm1heCh0b3AsIHBsb3RBcmVhLnkpO1xuICAgIGJvdHRvbSA9IE1hdGgubWluKGJvdHRvbSwgcGxvdEFyZWEueSArIHBsb3RBcmVhLmgpO1xuICAgIGlmICh0b3AgPCBib3R0b20pIHtcbiAgICAgIGcuZG9ab29tWV8odG9wLCBib3R0b20pO1xuICAgIH1cbiAgICBjb250ZXh0LmNhbmNlbE5leHREYmxjbGljayA9IHRydWU7XG4gIH1cbiAgY29udGV4dC5kcmFnU3RhcnRYID0gbnVsbDtcbiAgY29udGV4dC5kcmFnU3RhcnRZID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaEludGVyYWN0aW9uLnN0YXJ0VG91Y2ggPSBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAgLy8gdG91Y2ggYnJvd3NlcnMgYXJlIGFsbCBuaWNlLlxuICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgLy8gSWYgdGhlIHVzZXIgZXZlciBwdXRzIHR3byBmaW5nZXJzIGRvd24sIGl0J3Mgbm90IGEgZG91YmxlIHRhcC5cbiAgICBjb250ZXh0LnN0YXJ0VGltZUZvckRvdWJsZVRhcE1zID0gbnVsbDtcbiAgfVxuXG4gIHZhciB0b3VjaGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnQudG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0ID0gZXZlbnQudG91Y2hlc1tpXTtcbiAgICAvLyB3ZSBkaXNwZW5zZSB3aXRoICdkcmFnR2V0WF8nIGJlY2F1c2UgYWxsIHRvdWNoQnJvd3NlcnMgc3VwcG9ydCBwYWdlWFxuICAgIHRvdWNoZXMucHVzaCh7XG4gICAgICBwYWdlWDogdC5wYWdlWCxcbiAgICAgIHBhZ2VZOiB0LnBhZ2VZLFxuICAgICAgZGF0YVg6IGcudG9EYXRhWENvb3JkKHQucGFnZVgpLFxuICAgICAgZGF0YVk6IGcudG9EYXRhWUNvb3JkKHQucGFnZVkpXG4gICAgICAvLyBpZGVudGlmaWVyOiB0LmlkZW50aWZpZXJcbiAgICB9KTtcbiAgfVxuICBjb250ZXh0LmluaXRpYWxUb3VjaGVzID0gdG91Y2hlcztcblxuICBpZiAodG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgIC8vIFRoaXMgaXMganVzdCBhIHN3aXBlLlxuICAgIGNvbnRleHQuaW5pdGlhbFBpbmNoQ2VudGVyID0gdG91Y2hlc1swXTtcbiAgICBjb250ZXh0LnRvdWNoRGlyZWN0aW9ucyA9IHsgeDogdHJ1ZSwgeTogdHJ1ZSB9O1xuICB9IGVsc2UgaWYgKHRvdWNoZXMubGVuZ3RoID49IDIpIHtcbiAgICAvLyBJdCdzIGJlY29tZSBhIHBpbmNoIVxuICAgIC8vIEluIGNhc2UgdGhlcmUgYXJlIDMrIHRvdWNoZXMsIHdlIGlnbm9yZSBhbGwgYnV0IHRoZSBcImZpcnN0XCIgdHdvLlxuXG4gICAgLy8gb25seSBzY3JlZW4gY29vcmRpbmF0ZXMgY2FuIGJlIGF2ZXJhZ2VkIChkYXRhIGNvb3JkcyBjb3VsZCBiZSBsb2cgc2NhbGUpLlxuICAgIGNvbnRleHQuaW5pdGlhbFBpbmNoQ2VudGVyID0ge1xuICAgICAgcGFnZVg6IDAuNSAqICh0b3VjaGVzWzBdLnBhZ2VYICsgdG91Y2hlc1sxXS5wYWdlWCksXG4gICAgICBwYWdlWTogMC41ICogKHRvdWNoZXNbMF0ucGFnZVkgKyB0b3VjaGVzWzFdLnBhZ2VZKSxcblxuICAgICAgLy8gVE9ETyhkYW52ayk6IHJlbW92ZVxuICAgICAgZGF0YVg6IDAuNSAqICh0b3VjaGVzWzBdLmRhdGFYICsgdG91Y2hlc1sxXS5kYXRhWCksXG4gICAgICBkYXRhWTogMC41ICogKHRvdWNoZXNbMF0uZGF0YVkgKyB0b3VjaGVzWzFdLmRhdGFZKVxuICAgIH07XG5cbiAgICAvLyBNYWtlIHBpbmNoZXMgaW4gYSA0NS1kZWdyZWUgc3dhdGggYXJvdW5kIGVpdGhlciBheGlzIDEtZGltZW5zaW9uYWwgem9vbXMuXG4gICAgdmFyIGluaXRpYWxBbmdsZSA9IDE4MCAvIE1hdGguUEkgKiBNYXRoLmF0YW4yKFxuICAgICAgICBjb250ZXh0LmluaXRpYWxQaW5jaENlbnRlci5wYWdlWSAtIHRvdWNoZXNbMF0ucGFnZVksXG4gICAgICAgIHRvdWNoZXNbMF0ucGFnZVggLSBjb250ZXh0LmluaXRpYWxQaW5jaENlbnRlci5wYWdlWCk7XG5cbiAgICAvLyB1c2Ugc3ltbWV0cnkgdG8gZ2V0IGl0IGludG8gdGhlIGZpcnN0IHF1YWRyYW50LlxuICAgIGluaXRpYWxBbmdsZSA9IE1hdGguYWJzKGluaXRpYWxBbmdsZSk7XG4gICAgaWYgKGluaXRpYWxBbmdsZSA+IDkwKSBpbml0aWFsQW5nbGUgPSA5MCAtIGluaXRpYWxBbmdsZTtcblxuICAgIGNvbnRleHQudG91Y2hEaXJlY3Rpb25zID0ge1xuICAgICAgeDogKGluaXRpYWxBbmdsZSA8ICg5MCAtIDQ1LzIpKSxcbiAgICAgIHk6IChpbml0aWFsQW5nbGUgPiA0NS8yKVxuICAgIH07XG4gIH1cblxuICAvLyBzYXZlIHRoZSBmdWxsIHggJiB5IHJhbmdlcy5cbiAgY29udGV4dC5pbml0aWFsUmFuZ2UgPSB7XG4gICAgeDogZy54QXhpc1JhbmdlKCksXG4gICAgeTogZy55QXhpc1JhbmdlKClcbiAgfTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaEludGVyYWN0aW9uLm1vdmVUb3VjaCA9IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gIC8vIElmIHRoZSB0YXAgbW92ZXMsIHRoZW4gaXQncyBkZWZpbml0ZWx5IG5vdCBwYXJ0IG9mIGEgZG91YmxlLXRhcC5cbiAgY29udGV4dC5zdGFydFRpbWVGb3JEb3VibGVUYXBNcyA9IG51bGw7XG5cbiAgdmFyIGksIHRvdWNoZXMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IGV2ZW50LnRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdCA9IGV2ZW50LnRvdWNoZXNbaV07XG4gICAgdG91Y2hlcy5wdXNoKHtcbiAgICAgIHBhZ2VYOiB0LnBhZ2VYLFxuICAgICAgcGFnZVk6IHQucGFnZVlcbiAgICB9KTtcbiAgfVxuICB2YXIgaW5pdGlhbFRvdWNoZXMgPSBjb250ZXh0LmluaXRpYWxUb3VjaGVzO1xuXG4gIHZhciBjX25vdztcblxuICAvLyBvbGQgYW5kIG5ldyBjZW50ZXJzLlxuICB2YXIgY19pbml0ID0gY29udGV4dC5pbml0aWFsUGluY2hDZW50ZXI7XG4gIGlmICh0b3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgY19ub3cgPSB0b3VjaGVzWzBdO1xuICB9IGVsc2Uge1xuICAgIGNfbm93ID0ge1xuICAgICAgcGFnZVg6IDAuNSAqICh0b3VjaGVzWzBdLnBhZ2VYICsgdG91Y2hlc1sxXS5wYWdlWCksXG4gICAgICBwYWdlWTogMC41ICogKHRvdWNoZXNbMF0ucGFnZVkgKyB0b3VjaGVzWzFdLnBhZ2VZKVxuICAgIH07XG4gIH1cblxuICAvLyB0aGlzIGlzIHRoZSBcInN3aXBlXCIgY29tcG9uZW50XG4gIC8vIHdlIHRvc3MgaXQgb3V0IGZvciBub3csIGJ1dCBjb3VsZCB1c2UgaXQgaW4gdGhlIGZ1dHVyZS5cbiAgdmFyIHN3aXBlID0ge1xuICAgIHBhZ2VYOiBjX25vdy5wYWdlWCAtIGNfaW5pdC5wYWdlWCxcbiAgICBwYWdlWTogY19ub3cucGFnZVkgLSBjX2luaXQucGFnZVlcbiAgfTtcbiAgdmFyIGRhdGFXaWR0aCA9IGNvbnRleHQuaW5pdGlhbFJhbmdlLnhbMV0gLSBjb250ZXh0LmluaXRpYWxSYW5nZS54WzBdO1xuICB2YXIgZGF0YUhlaWdodCA9IGNvbnRleHQuaW5pdGlhbFJhbmdlLnlbMF0gLSBjb250ZXh0LmluaXRpYWxSYW5nZS55WzFdO1xuICBzd2lwZS5kYXRhWCA9IChzd2lwZS5wYWdlWCAvIGcucGxvdHRlcl8uYXJlYS53KSAqIGRhdGFXaWR0aDtcbiAgc3dpcGUuZGF0YVkgPSAoc3dpcGUucGFnZVkgLyBnLnBsb3R0ZXJfLmFyZWEuaCkgKiBkYXRhSGVpZ2h0O1xuICB2YXIgeFNjYWxlLCB5U2NhbGU7XG5cbiAgLy8gVGhlIHJlc2lkdWFsIGJpdHMgYXJlIHVzdWFsbHkgc3BsaXQgaW50byBzY2FsZSAmIHJvdGF0ZSBiaXRzLCBidXQgd2Ugc3BsaXRcbiAgLy8gdGhlbSBpbnRvIHgtc2NhbGUgYW5kIHktc2NhbGUgYml0cy5cbiAgaWYgKHRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICB4U2NhbGUgPSAxLjA7XG4gICAgeVNjYWxlID0gMS4wO1xuICB9IGVsc2UgaWYgKHRvdWNoZXMubGVuZ3RoID49IDIpIHtcbiAgICB2YXIgaW5pdEhhbGZXaWR0aCA9IChpbml0aWFsVG91Y2hlc1sxXS5wYWdlWCAtIGNfaW5pdC5wYWdlWCk7XG4gICAgeFNjYWxlID0gKHRvdWNoZXNbMV0ucGFnZVggLSBjX25vdy5wYWdlWCkgLyBpbml0SGFsZldpZHRoO1xuXG4gICAgdmFyIGluaXRIYWxmSGVpZ2h0ID0gKGluaXRpYWxUb3VjaGVzWzFdLnBhZ2VZIC0gY19pbml0LnBhZ2VZKTtcbiAgICB5U2NhbGUgPSAodG91Y2hlc1sxXS5wYWdlWSAtIGNfbm93LnBhZ2VZKSAvIGluaXRIYWxmSGVpZ2h0O1xuICB9XG5cbiAgLy8gQ2xpcCBzY2FsaW5nIHRvIFsxLzgsIDhdIHRvIHByZXZlbnQgdG9vIG11Y2ggYmxvd3VwLlxuICB4U2NhbGUgPSBNYXRoLm1pbig4LCBNYXRoLm1heCgwLjEyNSwgeFNjYWxlKSk7XG4gIHlTY2FsZSA9IE1hdGgubWluKDgsIE1hdGgubWF4KDAuMTI1LCB5U2NhbGUpKTtcblxuICB2YXIgZGlkWm9vbSA9IGZhbHNlO1xuICBpZiAoY29udGV4dC50b3VjaERpcmVjdGlvbnMueCkge1xuICAgIGcuZGF0ZVdpbmRvd18gPSBbXG4gICAgICBjX2luaXQuZGF0YVggLSBzd2lwZS5kYXRhWCArIChjb250ZXh0LmluaXRpYWxSYW5nZS54WzBdIC0gY19pbml0LmRhdGFYKSAvIHhTY2FsZSxcbiAgICAgIGNfaW5pdC5kYXRhWCAtIHN3aXBlLmRhdGFYICsgKGNvbnRleHQuaW5pdGlhbFJhbmdlLnhbMV0gLSBjX2luaXQuZGF0YVgpIC8geFNjYWxlXG4gICAgXTtcbiAgICBkaWRab29tID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChjb250ZXh0LnRvdWNoRGlyZWN0aW9ucy55KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IDEgIC8qZy5heGVzXy5sZW5ndGgqLzsgaSsrKSB7XG4gICAgICB2YXIgYXhpcyA9IGcuYXhlc19baV07XG4gICAgICB2YXIgbG9nc2NhbGUgPSBnLmF0dHJpYnV0ZXNfLmdldEZvckF4aXMoXCJsb2dzY2FsZVwiLCBpKTtcbiAgICAgIGlmIChsb2dzY2FsZSkge1xuICAgICAgICAvLyBUT0RPKGRhbnZrKTogaW1wbGVtZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBheGlzLnZhbHVlUmFuZ2UgPSBbXG4gICAgICAgICAgY19pbml0LmRhdGFZIC0gc3dpcGUuZGF0YVkgKyAoY29udGV4dC5pbml0aWFsUmFuZ2UueVswXSAtIGNfaW5pdC5kYXRhWSkgLyB5U2NhbGUsXG4gICAgICAgICAgY19pbml0LmRhdGFZIC0gc3dpcGUuZGF0YVkgKyAoY29udGV4dC5pbml0aWFsUmFuZ2UueVsxXSAtIGNfaW5pdC5kYXRhWSkgLyB5U2NhbGVcbiAgICAgICAgXTtcbiAgICAgICAgZGlkWm9vbSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZy5kcmF3R3JhcGhfKGZhbHNlKTtcblxuICAvLyBXZSBvbmx5IGNhbGwgem9vbUNhbGxiYWNrIG9uIHpvb21zLCBub3QgcGFucywgdG8gbWlycm9yIGRlc2t0b3AgYmVoYXZpb3IuXG4gIGlmIChkaWRab29tICYmIHRvdWNoZXMubGVuZ3RoID4gMSAmJiBnLmdldEZ1bmN0aW9uT3B0aW9uKCd6b29tQ2FsbGJhY2snKSkge1xuICAgIHZhciB2aWV3V2luZG93ID0gZy54QXhpc1JhbmdlKCk7XG4gICAgZy5nZXRGdW5jdGlvbk9wdGlvbihcInpvb21DYWxsYmFja1wiKS5jYWxsKGcsIHZpZXdXaW5kb3dbMF0sIHZpZXdXaW5kb3dbMV0sIGcueUF4aXNSYW5nZXMoKSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaEludGVyYWN0aW9uLmVuZFRvdWNoID0gZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgLy8gdGhpcyBpcyBlZmZlY3RpdmVseSBhIFwicmVzZXRcIlxuICAgIER5Z3JhcGhJbnRlcmFjdGlvbi5zdGFydFRvdWNoKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgfSBlbHNlIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgIC8vIENvdWxkIGJlIHBhcnQgb2YgYSBcImRvdWJsZSB0YXBcIlxuICAgIC8vIFRoZSBoZXVyaXN0aWMgaGVyZSBpcyB0aGF0IGl0J3MgYSBkb3VibGUtdGFwIGlmIHRoZSB0d28gdG91Y2hlbmQgZXZlbnRzXG4gICAgLy8gb2NjdXIgd2l0aGluIDUwMG1zIGFuZCB3aXRoaW4gYSA1MHg1MCBwaXhlbCBib3guXG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHZhciB0ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgaWYgKGNvbnRleHQuc3RhcnRUaW1lRm9yRG91YmxlVGFwTXMgJiZcbiAgICAgICAgbm93IC0gY29udGV4dC5zdGFydFRpbWVGb3JEb3VibGVUYXBNcyA8IDUwMCAmJlxuICAgICAgICBjb250ZXh0LmRvdWJsZVRhcFggJiYgTWF0aC5hYnMoY29udGV4dC5kb3VibGVUYXBYIC0gdC5zY3JlZW5YKSA8IDUwICYmXG4gICAgICAgIGNvbnRleHQuZG91YmxlVGFwWSAmJiBNYXRoLmFicyhjb250ZXh0LmRvdWJsZVRhcFkgLSB0LnNjcmVlblkpIDwgNTApIHtcbiAgICAgIGcucmVzZXRab29tKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuc3RhcnRUaW1lRm9yRG91YmxlVGFwTXMgPSBub3c7XG4gICAgICBjb250ZXh0LmRvdWJsZVRhcFggPSB0LnNjcmVlblg7XG4gICAgICBjb250ZXh0LmRvdWJsZVRhcFkgPSB0LnNjcmVlblk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEZXRlcm1pbmUgdGhlIGRpc3RhbmNlIGZyb20geCB0byBbbGVmdCwgcmlnaHRdLlxudmFyIGRpc3RhbmNlRnJvbUludGVydmFsID0gZnVuY3Rpb24oeCwgbGVmdCwgcmlnaHQpIHtcbiAgaWYgKHggPCBsZWZ0KSB7XG4gICAgcmV0dXJuIGxlZnQgLSB4O1xuICB9IGVsc2UgaWYgKHggPiByaWdodCkge1xuICAgIHJldHVybiB4IC0gcmlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHBpeGVscyBieSB3aGljaCB0aGUgZXZlbnQgaGFwcGVucyBmcm9tIHRoZSBuZWFyZXN0XG4gKiBlZGdlIG9mIHRoZSBjaGFydC4gRm9yIGV2ZW50cyBpbiB0aGUgaW50ZXJpb3Igb2YgdGhlIGNoYXJ0LCB0aGlzIHJldHVybnMgemVyby5cbiAqL1xudmFyIGRpc3RhbmNlRnJvbUNoYXJ0ID0gZnVuY3Rpb24oZXZlbnQsIGcpIHtcbiAgdmFyIGNoYXJ0UG9zID0gdXRpbHMuZmluZFBvcyhnLmNhbnZhc18pO1xuICB2YXIgYm94ID0ge1xuICAgIGxlZnQ6IGNoYXJ0UG9zLngsXG4gICAgcmlnaHQ6IGNoYXJ0UG9zLnggKyBnLmNhbnZhc18ub2Zmc2V0V2lkdGgsXG4gICAgdG9wOiBjaGFydFBvcy55LFxuICAgIGJvdHRvbTogY2hhcnRQb3MueSArIGcuY2FudmFzXy5vZmZzZXRIZWlnaHRcbiAgfTtcblxuICB2YXIgcHQgPSB7XG4gICAgeDogdXRpbHMucGFnZVgoZXZlbnQpLFxuICAgIHk6IHV0aWxzLnBhZ2VZKGV2ZW50KVxuICB9O1xuXG4gIHZhciBkeCA9IGRpc3RhbmNlRnJvbUludGVydmFsKHB0LngsIGJveC5sZWZ0LCBib3gucmlnaHQpLFxuICAgICAgZHkgPSBkaXN0YW5jZUZyb21JbnRlcnZhbChwdC55LCBib3gudG9wLCBib3guYm90dG9tKTtcbiAgcmV0dXJuIE1hdGgubWF4KGR4LCBkeSk7XG59O1xuXG4vKipcbiAqIERlZmF1bHQgaW50ZXJhdGlvbiBtb2RlbCBmb3IgZHlncmFwaHMuIFlvdSBjYW4gcmVmZXIgdG8gc3BlY2lmaWMgZWxlbWVudHMgb2ZcbiAqIHRoaXMgd2hlbiBjb25zdHJ1Y3RpbmcgeW91ciBvd24gaW50ZXJhY3Rpb24gbW9kZWwsIGUuZy46XG4gKiBnLnVwZGF0ZU9wdGlvbnMoIHtcbiAqICAgaW50ZXJhY3Rpb25Nb2RlbDoge1xuICogICAgIG1vdXNlZG93bjogRHlncmFwaEludGVyYWN0aW9uLmRlZmF1bHRJbnRlcmFjdGlvbk1vZGVsLm1vdXNlZG93blxuICogICB9XG4gKiB9ICk7XG4gKi9cbkR5Z3JhcGhJbnRlcmFjdGlvbi5kZWZhdWx0TW9kZWwgPSB7XG4gIC8vIFRyYWNrIHRoZSBiZWdpbm5pbmcgb2YgZHJhZyBldmVudHNcbiAgbW91c2Vkb3duOiBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICAgIC8vIFJpZ2h0LWNsaWNrIHNob3VsZCBub3QgaW5pdGlhdGUgYSB6b29tLlxuICAgIGlmIChldmVudC5idXR0b24gJiYgZXZlbnQuYnV0dG9uID09IDIpIHJldHVybjtcblxuICAgIGNvbnRleHQuaW5pdGlhbGl6ZU1vdXNlRG93bihldmVudCwgZywgY29udGV4dCk7XG5cbiAgICBpZiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICBEeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRQYW4oZXZlbnQsIGcsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBEeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRab29tKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBOb3RlOiB3ZSByZWdpc3RlciBtb3VzZW1vdmUvbW91c2V1cCBvbiBkb2N1bWVudCB0byBhbGxvdyBzb21lIGxlZXdheSBmb3JcbiAgICAvLyBldmVudHMgdG8gbW92ZSBvdXRzaWRlIG9mIHRoZSBjaGFydC4gSW50ZXJhY3Rpb24gbW9kZWwgZXZlbnRzIGdldFxuICAgIC8vIHJlZ2lzdGVyZWQgb24gdGhlIGNhbnZhcywgd2hpY2ggaXMgdG9vIHNtYWxsIHRvIGFsbG93IHRoaXMuXG4gICAgdmFyIG1vdXNlbW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAoY29udGV4dC5pc1pvb21pbmcpIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgbW91c2UgbW92ZXMgPjIwMHB4IGZyb20gdGhlIGNoYXJ0IGVkZ2UsIGNhbmNlbCB0aGUgem9vbS5cbiAgICAgICAgdmFyIGQgPSBkaXN0YW5jZUZyb21DaGFydChldmVudCwgZyk7XG4gICAgICAgIGlmIChkIDwgRFJBR19FREdFX01BUkdJTikge1xuICAgICAgICAgIER5Z3JhcGhJbnRlcmFjdGlvbi5tb3ZlWm9vbShldmVudCwgZywgY29udGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQuZHJhZ0VuZFggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZHJhZ0VuZFggPSBudWxsO1xuICAgICAgICAgICAgY29udGV4dC5kcmFnRW5kWSA9IG51bGw7XG4gICAgICAgICAgICBnLmNsZWFyWm9vbVJlY3RfKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvbnRleHQuaXNQYW5uaW5nKSB7XG4gICAgICAgIER5Z3JhcGhJbnRlcmFjdGlvbi5tb3ZlUGFuKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBtb3VzZXVwID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmIChjb250ZXh0LmlzWm9vbWluZykge1xuICAgICAgICBpZiAoY29udGV4dC5kcmFnRW5kWCAhPT0gbnVsbCkge1xuICAgICAgICAgIER5Z3JhcGhJbnRlcmFjdGlvbi5lbmRab29tKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBEeWdyYXBoSW50ZXJhY3Rpb24ubWF5YmVUcmVhdE1vdXNlT3BBc0NsaWNrKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250ZXh0LmlzUGFubmluZykge1xuICAgICAgICBEeWdyYXBoSW50ZXJhY3Rpb24uZW5kUGFuKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMucmVtb3ZlRXZlbnQoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBtb3VzZW1vdmUpO1xuICAgICAgdXRpbHMucmVtb3ZlRXZlbnQoZG9jdW1lbnQsICdtb3VzZXVwJywgbW91c2V1cCk7XG4gICAgICBjb250ZXh0LmRlc3Ryb3koKTtcbiAgICB9O1xuXG4gICAgZy5hZGRBbmRUcmFja0V2ZW50KGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbW91c2Vtb3ZlKTtcbiAgICBnLmFkZEFuZFRyYWNrRXZlbnQoZG9jdW1lbnQsICdtb3VzZXVwJywgbW91c2V1cCk7XG4gIH0sXG4gIHdpbGxEZXN0cm95Q29udGV4dE15c2VsZjogdHJ1ZSxcblxuICB0b3VjaHN0YXJ0OiBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICAgIER5Z3JhcGhJbnRlcmFjdGlvbi5zdGFydFRvdWNoKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgfSxcbiAgdG91Y2htb3ZlOiBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICAgIER5Z3JhcGhJbnRlcmFjdGlvbi5tb3ZlVG91Y2goZXZlbnQsIGcsIGNvbnRleHQpO1xuICB9LFxuICB0b3VjaGVuZDogZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgICBEeWdyYXBoSW50ZXJhY3Rpb24uZW5kVG91Y2goZXZlbnQsIGcsIGNvbnRleHQpO1xuICB9LFxuXG4gIC8vIERpc2FibGUgem9vbWluZyBvdXQgaWYgcGFubmluZy5cbiAgZGJsY2xpY2s6IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQuY2FuY2VsTmV4dERibGNsaWNrKSB7XG4gICAgICBjb250ZXh0LmNhbmNlbE5leHREYmxjbGljayA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEdpdmUgcGx1Z2lucyBhIGNoYW5jZSB0byBncmFiIHRoaXMgZXZlbnQuXG4gICAgdmFyIGUgPSB7XG4gICAgICBjYW52YXN4OiBjb250ZXh0LmRyYWdFbmRYLFxuICAgICAgY2FudmFzeTogY29udGV4dC5kcmFnRW5kWSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgfTtcbiAgICBpZiAoZy5jYXNjYWRlRXZlbnRzXygnZGJsY2xpY2snLCBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5hbHRLZXkgfHwgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZy5yZXNldFpvb20oKTtcbiAgfVxufTtcblxuLypcbkR5Z3JhcGguREVGQVVMVF9BVFRSUy5pbnRlcmFjdGlvbk1vZGVsID0gRHlncmFwaEludGVyYWN0aW9uLmRlZmF1bHRNb2RlbDtcblxuLy8gb2xkIHdheXMgb2YgYWNjZXNzaW5nIHRoZXNlIG1ldGhvZHMvcHJvcGVydGllc1xuRHlncmFwaC5kZWZhdWx0SW50ZXJhY3Rpb25Nb2RlbCA9IER5Z3JhcGhJbnRlcmFjdGlvbi5kZWZhdWx0TW9kZWw7XG5EeWdyYXBoLmVuZFpvb20gPSBEeWdyYXBoSW50ZXJhY3Rpb24uZW5kWm9vbTtcbkR5Z3JhcGgubW92ZVpvb20gPSBEeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVpvb207XG5EeWdyYXBoLnN0YXJ0Wm9vbSA9IER5Z3JhcGhJbnRlcmFjdGlvbi5zdGFydFpvb207XG5EeWdyYXBoLmVuZFBhbiA9IER5Z3JhcGhJbnRlcmFjdGlvbi5lbmRQYW47XG5EeWdyYXBoLm1vdmVQYW4gPSBEeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVBhbjtcbkR5Z3JhcGguc3RhcnRQYW4gPSBEeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRQYW47XG4qL1xuXG5EeWdyYXBoSW50ZXJhY3Rpb24ubm9uSW50ZXJhY3RpdmVNb2RlbF8gPSB7XG4gIG1vdXNlZG93bjogZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmluaXRpYWxpemVNb3VzZURvd24oZXZlbnQsIGcsIGNvbnRleHQpO1xuICB9LFxuICBtb3VzZXVwOiBEeWdyYXBoSW50ZXJhY3Rpb24ubWF5YmVUcmVhdE1vdXNlT3BBc0NsaWNrXG59O1xuXG4vLyBEZWZhdWx0IGludGVyYWN0aW9uIG1vZGVsIHdoZW4gdXNpbmcgdGhlIHJhbmdlIHNlbGVjdG9yLlxuRHlncmFwaEludGVyYWN0aW9uLmRyYWdJc1BhbkludGVyYWN0aW9uTW9kZWwgPSB7XG4gIG1vdXNlZG93bjogZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmluaXRpYWxpemVNb3VzZURvd24oZXZlbnQsIGcsIGNvbnRleHQpO1xuICAgIER5Z3JhcGhJbnRlcmFjdGlvbi5zdGFydFBhbihldmVudCwgZywgY29udGV4dCk7XG4gIH0sXG4gIG1vdXNlbW92ZTogZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC5pc1Bhbm5pbmcpIHtcbiAgICAgIER5Z3JhcGhJbnRlcmFjdGlvbi5tb3ZlUGFuKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgICB9XG4gIH0sXG4gIG1vdXNldXA6IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQuaXNQYW5uaW5nKSB7XG4gICAgICBEeWdyYXBoSW50ZXJhY3Rpb24uZW5kUGFuKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IER5Z3JhcGhJbnRlcmFjdGlvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZHlncmFwaHMvc3JjL2R5Z3JhcGgtaW50ZXJhY3Rpb24tbW9kZWwuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return numericLinearTicks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return numericTicks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return dateTicker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return Granularity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return getDateAxis; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__ = __webpack_require__(0);\n/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview Description of this file.\n * @author danvk@google.com (Dan Vanderkam)\n *\n * A ticker is a function with the following interface:\n *\n * function(a, b, pixels, options_view, dygraph, forced_values);\n * -> [ { v: tick1_v, label: tick1_label[, label_v: label_v1] },\n *      { v: tick2_v, label: tick2_label[, label_v: label_v2] },\n *      ...\n *    ]\n *\n * The returned value is called a \"tick list\".\n *\n * Arguments\n * ---------\n *\n * [a, b] is the range of the axis for which ticks are being generated. For a\n * numeric axis, these will simply be numbers. For a date axis, these will be\n * millis since epoch (convertable to Date objects using \"new Date(a)\" and \"new\n * Date(b)\").\n *\n * opts provides access to chart- and axis-specific options. It can be used to\n * access number/date formatting code/options, check for a log scale, etc.\n *\n * pixels is the length of the axis in pixels. opts('pixelsPerLabel') is the\n * minimum amount of space to be allotted to each label. For instance, if\n * pixels=400 and opts('pixelsPerLabel')=40 then the ticker should return\n * between zero and ten (400/40) ticks.\n *\n * dygraph is the Dygraph object for which an axis is being constructed.\n *\n * forced_values is used for secondary y-axes. The tick positions are typically\n * set by the primary y-axis, so the secondary y-axis has no choice in where to\n * put these. It simply has to generate labels for these data values.\n *\n * Tick lists\n * ----------\n * Typically a tick will have both a grid/tick line and a label at one end of\n * that line (at the bottom for an x-axis, at left or right for the y-axis).\n *\n * A tick may be missing one of these two components:\n * - If \"label_v\" is specified instead of \"v\", then there will be no tick or\n *   gridline, just a label.\n * - Similarly, if \"label\" is not specified, then there will be a gridline\n *   without a label.\n *\n * This flexibility is useful in a few situations:\n * - For log scales, some of the tick lines may be too close to all have labels.\n * - For date scales where years are being displayed, it is desirable to display\n *   tick marks at the beginnings of years but labels (e.g. \"2006\") in the\n *   middle of the years.\n */\n\n/*jshint sub:true */\n/*global Dygraph:false */\n\n\n\n\n/** @typedef {Array.<{v:number, label:string, label_v:(string|undefined)}>} */\nvar TickList = undefined; // the ' = undefined' keeps jshint happy.\n\n/** @typedef {function(\n *    number,\n *    number,\n *    number,\n *    function(string):*,\n *    Dygraph=,\n *    Array.<number>=\n *  ): TickList}\n */\nvar Ticker = undefined; // the ' = undefined' keeps jshint happy.\n\n/** @type {Ticker} */\nvar numericLinearTicks = function numericLinearTicks(a, b, pixels, opts, dygraph, vals) {\n  var nonLogscaleOpts = function nonLogscaleOpts(opt) {\n    if (opt === 'logscale') return false;\n    return opts(opt);\n  };\n  return numericTicks(a, b, pixels, nonLogscaleOpts, dygraph, vals);\n};\n\n/** @type {Ticker} */\nvar numericTicks = function numericTicks(a, b, pixels, opts, dygraph, vals) {\n  var pixels_per_tick = /** @type{number} */opts('pixelsPerLabel');\n  var ticks = [];\n  var i, j, tickV, nTicks;\n  if (vals) {\n    for (i = 0; i < vals.length; i++) {\n      ticks.push({ v: vals[i] });\n    }\n  } else {\n    // TODO(danvk): factor this log-scale block out into a separate function.\n    if (opts(\"logscale\")) {\n      nTicks = Math.floor(pixels / pixels_per_tick);\n      var minIdx = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"K\" /* binarySearch */](a, PREFERRED_LOG_TICK_VALUES, 1);\n      var maxIdx = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"K\" /* binarySearch */](b, PREFERRED_LOG_TICK_VALUES, -1);\n      if (minIdx == -1) {\n        minIdx = 0;\n      }\n      if (maxIdx == -1) {\n        maxIdx = PREFERRED_LOG_TICK_VALUES.length - 1;\n      }\n      // Count the number of tick values would appear, if we can get at least\n      // nTicks / 4 accept them.\n      var lastDisplayed = null;\n      if (maxIdx - minIdx >= nTicks / 4) {\n        for (var idx = maxIdx; idx >= minIdx; idx--) {\n          var tickValue = PREFERRED_LOG_TICK_VALUES[idx];\n          var pixel_coord = Math.log(tickValue / a) / Math.log(b / a) * pixels;\n          var tick = { v: tickValue };\n          if (lastDisplayed === null) {\n            lastDisplayed = {\n              tickValue: tickValue,\n              pixel_coord: pixel_coord\n            };\n          } else {\n            if (Math.abs(pixel_coord - lastDisplayed.pixel_coord) >= pixels_per_tick) {\n              lastDisplayed = {\n                tickValue: tickValue,\n                pixel_coord: pixel_coord\n              };\n            } else {\n              tick.label = \"\";\n            }\n          }\n          ticks.push(tick);\n        }\n        // Since we went in backwards order.\n        ticks.reverse();\n      }\n    }\n\n    // ticks.length won't be 0 if the log scale function finds values to insert.\n    if (ticks.length === 0) {\n      // Basic idea:\n      // Try labels every 1, 2, 5, 10, 20, 50, 100, etc.\n      // Calculate the resulting tick spacing (i.e. this.height_ / nTicks).\n      // The first spacing greater than pixelsPerYLabel is what we use.\n      // TODO(danvk): version that works on a log scale.\n      var kmg2 = opts(\"labelsKMG2\");\n      var mults, base;\n      if (kmg2) {\n        mults = [1, 2, 4, 8, 16, 32, 64, 128, 256];\n        base = 16;\n      } else {\n        mults = [1, 2, 5, 10, 20, 50, 100];\n        base = 10;\n      }\n\n      // Get the maximum number of permitted ticks based on the\n      // graph's pixel size and pixels_per_tick setting.\n      var max_ticks = Math.ceil(pixels / pixels_per_tick);\n\n      // Now calculate the data unit equivalent of this tick spacing.\n      // Use abs() since graphs may have a reversed Y axis.\n      var units_per_tick = Math.abs(b - a) / max_ticks;\n\n      // Based on this, get a starting scale which is the largest\n      // integer power of the chosen base (10 or 16) that still remains\n      // below the requested pixels_per_tick spacing.\n      var base_power = Math.floor(Math.log(units_per_tick) / Math.log(base));\n      var base_scale = Math.pow(base, base_power);\n\n      // Now try multiples of the starting scale until we find one\n      // that results in tick marks spaced sufficiently far apart.\n      // The \"mults\" array should cover the range 1 .. base^2 to\n      // adjust for rounding and edge effects.\n      var scale, low_val, high_val, spacing;\n      for (j = 0; j < mults.length; j++) {\n        scale = base_scale * mults[j];\n        low_val = Math.floor(a / scale) * scale;\n        high_val = Math.ceil(b / scale) * scale;\n        nTicks = Math.abs(high_val - low_val) / scale;\n        spacing = pixels / nTicks;\n        if (spacing > pixels_per_tick) break;\n      }\n\n      // Construct the set of ticks.\n      // Allow reverse y-axis if it's explicitly requested.\n      if (low_val > high_val) scale *= -1;\n      for (i = 0; i <= nTicks; i++) {\n        tickV = low_val + i * scale;\n        ticks.push({ v: tickV });\n      }\n    }\n  }\n\n  var formatter = /**@type{AxisLabelFormatter}*/opts('axisLabelFormatter');\n\n  // Add labels to the ticks.\n  for (i = 0; i < ticks.length; i++) {\n    if (ticks[i].label !== undefined) continue; // Use current label.\n    // TODO(danvk): set granularity to something appropriate here.\n    ticks[i].label = formatter.call(dygraph, ticks[i].v, 0, opts, dygraph);\n  }\n\n  return ticks;\n};\n\n/** @type {Ticker} */\nvar dateTicker = function dateTicker(a, b, pixels, opts, dygraph, vals) {\n  var chosen = pickDateTickGranularity(a, b, pixels, opts);\n\n  if (chosen >= 0) {\n    return getDateAxis(a, b, chosen, opts, dygraph);\n  } else {\n    // this can happen if self.width_ is zero.\n    return [];\n  }\n};\n\n// Time granularity enumeration\nvar Granularity = {\n  MILLISECONDLY: 0,\n  TWO_MILLISECONDLY: 1,\n  FIVE_MILLISECONDLY: 2,\n  TEN_MILLISECONDLY: 3,\n  FIFTY_MILLISECONDLY: 4,\n  HUNDRED_MILLISECONDLY: 5,\n  FIVE_HUNDRED_MILLISECONDLY: 6,\n  SECONDLY: 7,\n  TWO_SECONDLY: 8,\n  FIVE_SECONDLY: 9,\n  TEN_SECONDLY: 10,\n  THIRTY_SECONDLY: 11,\n  MINUTELY: 12,\n  TWO_MINUTELY: 13,\n  FIVE_MINUTELY: 14,\n  TEN_MINUTELY: 15,\n  THIRTY_MINUTELY: 16,\n  HOURLY: 17,\n  TWO_HOURLY: 18,\n  SIX_HOURLY: 19,\n  DAILY: 20,\n  TWO_DAILY: 21,\n  WEEKLY: 22,\n  MONTHLY: 23,\n  QUARTERLY: 24,\n  BIANNUAL: 25,\n  ANNUAL: 26,\n  DECADAL: 27,\n  CENTENNIAL: 28,\n  NUM_GRANULARITIES: 29\n\n  // Date components enumeration (in the order of the arguments in Date)\n  // TODO: make this an @enum\n};var DateField = {\n  DATEFIELD_Y: 0,\n  DATEFIELD_M: 1,\n  DATEFIELD_D: 2,\n  DATEFIELD_HH: 3,\n  DATEFIELD_MM: 4,\n  DATEFIELD_SS: 5,\n  DATEFIELD_MS: 6,\n  NUM_DATEFIELDS: 7\n};\n\n/**\n * The value of datefield will start at an even multiple of \"step\", i.e.\n *   if datefield=SS and step=5 then the first tick will be on a multiple of 5s.\n *\n * For granularities <= HOURLY, ticks are generated every `spacing` ms.\n *\n * At coarser granularities, ticks are generated by incrementing `datefield` by\n *   `step`. In this case, the `spacing` value is only used to estimate the\n *   number of ticks. It should roughly correspond to the spacing between\n *   adjacent ticks.\n *\n * @type {Array.<{datefield:number, step:number, spacing:number}>}\n */\nvar TICK_PLACEMENT = [];\nTICK_PLACEMENT[Granularity.MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 1, spacing: 1 };\nTICK_PLACEMENT[Granularity.TWO_MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 2, spacing: 2 };\nTICK_PLACEMENT[Granularity.FIVE_MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 5, spacing: 5 };\nTICK_PLACEMENT[Granularity.TEN_MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 10, spacing: 10 };\nTICK_PLACEMENT[Granularity.FIFTY_MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 50, spacing: 50 };\nTICK_PLACEMENT[Granularity.HUNDRED_MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 100, spacing: 100 };\nTICK_PLACEMENT[Granularity.FIVE_HUNDRED_MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 500, spacing: 500 };\nTICK_PLACEMENT[Granularity.SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 1, spacing: 1000 * 1 };\nTICK_PLACEMENT[Granularity.TWO_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 2, spacing: 1000 * 2 };\nTICK_PLACEMENT[Granularity.FIVE_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 5, spacing: 1000 * 5 };\nTICK_PLACEMENT[Granularity.TEN_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 10, spacing: 1000 * 10 };\nTICK_PLACEMENT[Granularity.THIRTY_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 30, spacing: 1000 * 30 };\nTICK_PLACEMENT[Granularity.MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 1, spacing: 1000 * 60 };\nTICK_PLACEMENT[Granularity.TWO_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 2, spacing: 1000 * 60 * 2 };\nTICK_PLACEMENT[Granularity.FIVE_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 5, spacing: 1000 * 60 * 5 };\nTICK_PLACEMENT[Granularity.TEN_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 10, spacing: 1000 * 60 * 10 };\nTICK_PLACEMENT[Granularity.THIRTY_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 30, spacing: 1000 * 60 * 30 };\nTICK_PLACEMENT[Granularity.HOURLY] = { datefield: DateField.DATEFIELD_HH, step: 1, spacing: 1000 * 3600 };\nTICK_PLACEMENT[Granularity.TWO_HOURLY] = { datefield: DateField.DATEFIELD_HH, step: 2, spacing: 1000 * 3600 * 2 };\nTICK_PLACEMENT[Granularity.SIX_HOURLY] = { datefield: DateField.DATEFIELD_HH, step: 6, spacing: 1000 * 3600 * 6 };\nTICK_PLACEMENT[Granularity.DAILY] = { datefield: DateField.DATEFIELD_D, step: 1, spacing: 1000 * 86400 };\nTICK_PLACEMENT[Granularity.TWO_DAILY] = { datefield: DateField.DATEFIELD_D, step: 2, spacing: 1000 * 86400 * 2 };\nTICK_PLACEMENT[Granularity.WEEKLY] = { datefield: DateField.DATEFIELD_D, step: 7, spacing: 1000 * 604800 };\nTICK_PLACEMENT[Granularity.MONTHLY] = { datefield: DateField.DATEFIELD_M, step: 1, spacing: 1000 * 7200 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 / 12\nTICK_PLACEMENT[Granularity.QUARTERLY] = { datefield: DateField.DATEFIELD_M, step: 3, spacing: 1000 * 21600 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 / 4\nTICK_PLACEMENT[Granularity.BIANNUAL] = { datefield: DateField.DATEFIELD_M, step: 6, spacing: 1000 * 43200 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 / 2\nTICK_PLACEMENT[Granularity.ANNUAL] = { datefield: DateField.DATEFIELD_Y, step: 1, spacing: 1000 * 86400 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 * 1\nTICK_PLACEMENT[Granularity.DECADAL] = { datefield: DateField.DATEFIELD_Y, step: 10, spacing: 1000 * 864000 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 * 10\nTICK_PLACEMENT[Granularity.CENTENNIAL] = { datefield: DateField.DATEFIELD_Y, step: 100, spacing: 1000 * 8640000 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 * 100\n\n\n/**\n * This is a list of human-friendly values at which to show tick marks on a log\n * scale. It is k * 10^n, where k=1..9 and n=-39..+39, so:\n * ..., 1, 2, 3, 4, 5, ..., 9, 10, 20, 30, ..., 90, 100, 200, 300, ...\n * NOTE: this assumes that utils.LOG_SCALE = 10.\n * @type {Array.<number>}\n */\nvar PREFERRED_LOG_TICK_VALUES = function () {\n  var vals = [];\n  for (var power = -39; power <= 39; power++) {\n    var range = Math.pow(10, power);\n    for (var mult = 1; mult <= 9; mult++) {\n      var val = range * mult;\n      vals.push(val);\n    }\n  }\n  return vals;\n}();\n\n/**\n * Determine the correct granularity of ticks on a date axis.\n *\n * @param {number} a Left edge of the chart (ms)\n * @param {number} b Right edge of the chart (ms)\n * @param {number} pixels Size of the chart in the relevant dimension (width).\n * @param {function(string):*} opts Function mapping from option name -&gt; value.\n * @return {number} The appropriate axis granularity for this chart. See the\n *     enumeration of possible values in dygraph-tickers.js.\n */\nvar pickDateTickGranularity = function pickDateTickGranularity(a, b, pixels, opts) {\n  var pixels_per_tick = /** @type{number} */opts('pixelsPerLabel');\n  for (var i = 0; i < Granularity.NUM_GRANULARITIES; i++) {\n    var num_ticks = numDateTicks(a, b, i);\n    if (pixels / num_ticks >= pixels_per_tick) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/**\n * Compute the number of ticks on a date axis for a given granularity.\n * @param {number} start_time\n * @param {number} end_time\n * @param {number} granularity (one of the granularities enumerated above)\n * @return {number} (Approximate) number of ticks that would result.\n */\nvar numDateTicks = function numDateTicks(start_time, end_time, granularity) {\n  var spacing = TICK_PLACEMENT[granularity].spacing;\n  return Math.round(1.0 * (end_time - start_time) / spacing);\n};\n\n/**\n * Compute the positions and labels of ticks on a date axis for a given granularity.\n * @param {number} start_time\n * @param {number} end_time\n * @param {number} granularity (one of the granularities enumerated above)\n * @param {function(string):*} opts Function mapping from option name -&gt; value.\n * @param {Dygraph=} dg\n * @return {!TickList}\n */\nvar getDateAxis = function getDateAxis(start_time, end_time, granularity, opts, dg) {\n  var formatter = /** @type{AxisLabelFormatter} */opts(\"axisLabelFormatter\");\n  var utc = opts(\"labelsUTC\");\n  var accessors = utc ? __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"L\" /* DateAccessorsUTC */] : __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"M\" /* DateAccessorsLocal */];\n\n  var datefield = TICK_PLACEMENT[granularity].datefield;\n  var step = TICK_PLACEMENT[granularity].step;\n  var spacing = TICK_PLACEMENT[granularity].spacing;\n\n  // Choose a nice tick position before the initial instant.\n  // Currently, this code deals properly with the existent daily granularities:\n  // DAILY (with step of 1) and WEEKLY (with step of 7 but specially handled).\n  // Other daily granularities (say TWO_DAILY) should also be handled specially\n  // by setting the start_date_offset to 0.\n  var start_date = new Date(start_time);\n  var date_array = [];\n  date_array[DateField.DATEFIELD_Y] = accessors.getFullYear(start_date);\n  date_array[DateField.DATEFIELD_M] = accessors.getMonth(start_date);\n  date_array[DateField.DATEFIELD_D] = accessors.getDate(start_date);\n  date_array[DateField.DATEFIELD_HH] = accessors.getHours(start_date);\n  date_array[DateField.DATEFIELD_MM] = accessors.getMinutes(start_date);\n  date_array[DateField.DATEFIELD_SS] = accessors.getSeconds(start_date);\n  date_array[DateField.DATEFIELD_MS] = accessors.getMilliseconds(start_date);\n\n  var start_date_offset = date_array[datefield] % step;\n  if (granularity == Granularity.WEEKLY) {\n    // This will put the ticks on Sundays.\n    start_date_offset = accessors.getDay(start_date);\n  }\n\n  date_array[datefield] -= start_date_offset;\n  for (var df = datefield + 1; df < DateField.NUM_DATEFIELDS; df++) {\n    // The minimum value is 1 for the day of month, and 0 for all other fields.\n    date_array[df] = df === DateField.DATEFIELD_D ? 1 : 0;\n  }\n\n  // Generate the ticks.\n  // For granularities not coarser than HOURLY we use the fact that:\n  //   the number of milliseconds between ticks is constant\n  //   and equal to the defined spacing.\n  // Otherwise we rely on the 'roll over' property of the Date functions:\n  //   when some date field is set to a value outside of its logical range,\n  //   the excess 'rolls over' the next (more significant) field.\n  // However, when using local time with DST transitions,\n  // there are dates that do not represent any time value at all\n  // (those in the hour skipped at the 'spring forward'),\n  // and the JavaScript engines usually return an equivalent value.\n  // Hence we have to check that the date is properly increased at each step,\n  // returning a date at a nice tick position.\n  var ticks = [];\n  var tick_date = accessors.makeDate.apply(null, date_array);\n  var tick_time = tick_date.getTime();\n  if (granularity <= Granularity.HOURLY) {\n    if (tick_time < start_time) {\n      tick_time += spacing;\n      tick_date = new Date(tick_time);\n    }\n    while (tick_time <= end_time) {\n      ticks.push({ v: tick_time,\n        label: formatter.call(dg, tick_date, granularity, opts, dg)\n      });\n      tick_time += spacing;\n      tick_date = new Date(tick_time);\n    }\n  } else {\n    if (tick_time < start_time) {\n      date_array[datefield] += step;\n      tick_date = accessors.makeDate.apply(null, date_array);\n      tick_time = tick_date.getTime();\n    }\n    while (tick_time <= end_time) {\n      if (granularity >= Granularity.DAILY || accessors.getHours(tick_date) % step === 0) {\n        ticks.push({ v: tick_time,\n          label: formatter.call(dg, tick_date, granularity, opts, dg)\n        });\n      }\n      date_array[datefield] += step;\n      tick_date = accessors.makeDate.apply(null, date_array);\n      tick_time = tick_date.getTime();\n    }\n  }\n  return ticks;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLXRpY2tlcnMuanM/MmY0MyJdLCJuYW1lcyI6WyJUaWNrTGlzdCIsInVuZGVmaW5lZCIsIlRpY2tlciIsIm51bWVyaWNMaW5lYXJUaWNrcyIsImEiLCJiIiwicGl4ZWxzIiwib3B0cyIsImR5Z3JhcGgiLCJ2YWxzIiwibm9uTG9nc2NhbGVPcHRzIiwib3B0IiwibnVtZXJpY1RpY2tzIiwicGl4ZWxzX3Blcl90aWNrIiwidGlja3MiLCJpIiwiaiIsInRpY2tWIiwiblRpY2tzIiwibGVuZ3RoIiwicHVzaCIsInYiLCJNYXRoIiwiZmxvb3IiLCJtaW5JZHgiLCJQUkVGRVJSRURfTE9HX1RJQ0tfVkFMVUVTIiwibWF4SWR4IiwibGFzdERpc3BsYXllZCIsImlkeCIsInRpY2tWYWx1ZSIsInBpeGVsX2Nvb3JkIiwibG9nIiwidGljayIsImFicyIsImxhYmVsIiwicmV2ZXJzZSIsImttZzIiLCJtdWx0cyIsImJhc2UiLCJtYXhfdGlja3MiLCJjZWlsIiwidW5pdHNfcGVyX3RpY2siLCJiYXNlX3Bvd2VyIiwiYmFzZV9zY2FsZSIsInBvdyIsInNjYWxlIiwibG93X3ZhbCIsImhpZ2hfdmFsIiwic3BhY2luZyIsImZvcm1hdHRlciIsImNhbGwiLCJkYXRlVGlja2VyIiwiY2hvc2VuIiwicGlja0RhdGVUaWNrR3JhbnVsYXJpdHkiLCJnZXREYXRlQXhpcyIsIkdyYW51bGFyaXR5IiwiTUlMTElTRUNPTkRMWSIsIlRXT19NSUxMSVNFQ09ORExZIiwiRklWRV9NSUxMSVNFQ09ORExZIiwiVEVOX01JTExJU0VDT05ETFkiLCJGSUZUWV9NSUxMSVNFQ09ORExZIiwiSFVORFJFRF9NSUxMSVNFQ09ORExZIiwiRklWRV9IVU5EUkVEX01JTExJU0VDT05ETFkiLCJTRUNPTkRMWSIsIlRXT19TRUNPTkRMWSIsIkZJVkVfU0VDT05ETFkiLCJURU5fU0VDT05ETFkiLCJUSElSVFlfU0VDT05ETFkiLCJNSU5VVEVMWSIsIlRXT19NSU5VVEVMWSIsIkZJVkVfTUlOVVRFTFkiLCJURU5fTUlOVVRFTFkiLCJUSElSVFlfTUlOVVRFTFkiLCJIT1VSTFkiLCJUV09fSE9VUkxZIiwiU0lYX0hPVVJMWSIsIkRBSUxZIiwiVFdPX0RBSUxZIiwiV0VFS0xZIiwiTU9OVEhMWSIsIlFVQVJURVJMWSIsIkJJQU5OVUFMIiwiQU5OVUFMIiwiREVDQURBTCIsIkNFTlRFTk5JQUwiLCJOVU1fR1JBTlVMQVJJVElFUyIsIkRhdGVGaWVsZCIsIkRBVEVGSUVMRF9ZIiwiREFURUZJRUxEX00iLCJEQVRFRklFTERfRCIsIkRBVEVGSUVMRF9ISCIsIkRBVEVGSUVMRF9NTSIsIkRBVEVGSUVMRF9TUyIsIkRBVEVGSUVMRF9NUyIsIk5VTV9EQVRFRklFTERTIiwiVElDS19QTEFDRU1FTlQiLCJkYXRlZmllbGQiLCJzdGVwIiwicG93ZXIiLCJyYW5nZSIsIm11bHQiLCJ2YWwiLCJudW1fdGlja3MiLCJudW1EYXRlVGlja3MiLCJzdGFydF90aW1lIiwiZW5kX3RpbWUiLCJncmFudWxhcml0eSIsInJvdW5kIiwiZGciLCJ1dGMiLCJhY2Nlc3NvcnMiLCJzdGFydF9kYXRlIiwiRGF0ZSIsImRhdGVfYXJyYXkiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXRNaWxsaXNlY29uZHMiLCJzdGFydF9kYXRlX29mZnNldCIsImdldERheSIsImRmIiwidGlja19kYXRlIiwibWFrZURhdGUiLCJhcHBseSIsInRpY2tfdGltZSIsImdldFRpbWUiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFBQTs7Ozs7O0FBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNEQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJQSxXQUFXQyxTQUFmLEMsQ0FBMkI7O0FBRTNCOzs7Ozs7Ozs7QUFTQSxJQUFJQyxTQUFTRCxTQUFi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QVlxQixLQUEzQixJQUNBa0MsVUFBVU8sUUFBVixDQUFtQk8sU0FBbkIsSUFBZ0MzQixJQUFoQyxLQUF5QyxDQUQ3QyxFQUNnRDtBQUM5Q25GLGNBQU1NLElBQU4sQ0FBVyxFQUFFQyxHQUFHMEcsU0FBTDtBQUNFN0YsaUJBQU9lLFVBQVVDLElBQVYsQ0FBZTBELEVBQWYsRUFBbUJnQixTQUFuQixFQUE4QmxCLFdBQTlCLEVBQTJDbkcsSUFBM0MsRUFBaURxRyxFQUFqRDtBQURULFNBQVg7QUFHRDtBQUNESyxpQkFBV2pCLFNBQVgsS0FBeUJDLElBQXpCO0FBQ0EyQixrQkFBWWQsVUFBVWUsUUFBVixDQUFtQkMsS0FBbkIsQ0FBeUIsSUFBekIsRUFBK0JiLFVBQS9CLENBQVo7QUFDQWMsa0JBQVlILFVBQVVJLE9BQVYsRUFBWjtBQUNEO0FBQ0Y7QUFDRCxTQUFPbEgsS0FBUDtBQUNELENBcEZNIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMSBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEZXNjcmlwdGlvbiBvZiB0aGlzIGZpbGUuXG4gKiBAYXV0aG9yIGRhbnZrQGdvb2dsZS5jb20gKERhbiBWYW5kZXJrYW0pXG4gKlxuICogQSB0aWNrZXIgaXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlOlxuICpcbiAqIGZ1bmN0aW9uKGEsIGIsIHBpeGVscywgb3B0aW9uc192aWV3LCBkeWdyYXBoLCBmb3JjZWRfdmFsdWVzKTtcbiAqIC0+IFsgeyB2OiB0aWNrMV92LCBsYWJlbDogdGljazFfbGFiZWxbLCBsYWJlbF92OiBsYWJlbF92MV0gfSxcbiAqICAgICAgeyB2OiB0aWNrMl92LCBsYWJlbDogdGljazJfbGFiZWxbLCBsYWJlbF92OiBsYWJlbF92Ml0gfSxcbiAqICAgICAgLi4uXG4gKiAgICBdXG4gKlxuICogVGhlIHJldHVybmVkIHZhbHVlIGlzIGNhbGxlZCBhIFwidGljayBsaXN0XCIuXG4gKlxuICogQXJndW1lbnRzXG4gKiAtLS0tLS0tLS1cbiAqXG4gKiBbYSwgYl0gaXMgdGhlIHJhbmdlIG9mIHRoZSBheGlzIGZvciB3aGljaCB0aWNrcyBhcmUgYmVpbmcgZ2VuZXJhdGVkLiBGb3IgYVxuICogbnVtZXJpYyBheGlzLCB0aGVzZSB3aWxsIHNpbXBseSBiZSBudW1iZXJzLiBGb3IgYSBkYXRlIGF4aXMsIHRoZXNlIHdpbGwgYmVcbiAqIG1pbGxpcyBzaW5jZSBlcG9jaCAoY29udmVydGFibGUgdG8gRGF0ZSBvYmplY3RzIHVzaW5nIFwibmV3IERhdGUoYSlcIiBhbmQgXCJuZXdcbiAqIERhdGUoYilcIikuXG4gKlxuICogb3B0cyBwcm92aWRlcyBhY2Nlc3MgdG8gY2hhcnQtIGFuZCBheGlzLXNwZWNpZmljIG9wdGlvbnMuIEl0IGNhbiBiZSB1c2VkIHRvXG4gKiBhY2Nlc3MgbnVtYmVyL2RhdGUgZm9ybWF0dGluZyBjb2RlL29wdGlvbnMsIGNoZWNrIGZvciBhIGxvZyBzY2FsZSwgZXRjLlxuICpcbiAqIHBpeGVscyBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBheGlzIGluIHBpeGVscy4gb3B0cygncGl4ZWxzUGVyTGFiZWwnKSBpcyB0aGVcbiAqIG1pbmltdW0gYW1vdW50IG9mIHNwYWNlIHRvIGJlIGFsbG90dGVkIHRvIGVhY2ggbGFiZWwuIEZvciBpbnN0YW5jZSwgaWZcbiAqIHBpeGVscz00MDAgYW5kIG9wdHMoJ3BpeGVsc1BlckxhYmVsJyk9NDAgdGhlbiB0aGUgdGlja2VyIHNob3VsZCByZXR1cm5cbiAqIGJldHdlZW4gemVybyBhbmQgdGVuICg0MDAvNDApIHRpY2tzLlxuICpcbiAqIGR5Z3JhcGggaXMgdGhlIER5Z3JhcGggb2JqZWN0IGZvciB3aGljaCBhbiBheGlzIGlzIGJlaW5nIGNvbnN0cnVjdGVkLlxuICpcbiAqIGZvcmNlZF92YWx1ZXMgaXMgdXNlZCBmb3Igc2Vjb25kYXJ5IHktYXhlcy4gVGhlIHRpY2sgcG9zaXRpb25zIGFyZSB0eXBpY2FsbHlcbiAqIHNldCBieSB0aGUgcHJpbWFyeSB5LWF4aXMsIHNvIHRoZSBzZWNvbmRhcnkgeS1heGlzIGhhcyBubyBjaG9pY2UgaW4gd2hlcmUgdG9cbiAqIHB1dCB0aGVzZS4gSXQgc2ltcGx5IGhhcyB0byBnZW5lcmF0ZSBsYWJlbHMgZm9yIHRoZXNlIGRhdGEgdmFsdWVzLlxuICpcbiAqIFRpY2sgbGlzdHNcbiAqIC0tLS0tLS0tLS1cbiAqIFR5cGljYWxseSBhIHRpY2sgd2lsbCBoYXZlIGJvdGggYSBncmlkL3RpY2sgbGluZSBhbmQgYSBsYWJlbCBhdCBvbmUgZW5kIG9mXG4gKiB0aGF0IGxpbmUgKGF0IHRoZSBib3R0b20gZm9yIGFuIHgtYXhpcywgYXQgbGVmdCBvciByaWdodCBmb3IgdGhlIHktYXhpcykuXG4gKlxuICogQSB0aWNrIG1heSBiZSBtaXNzaW5nIG9uZSBvZiB0aGVzZSB0d28gY29tcG9uZW50czpcbiAqIC0gSWYgXCJsYWJlbF92XCIgaXMgc3BlY2lmaWVkIGluc3RlYWQgb2YgXCJ2XCIsIHRoZW4gdGhlcmUgd2lsbCBiZSBubyB0aWNrIG9yXG4gKiAgIGdyaWRsaW5lLCBqdXN0IGEgbGFiZWwuXG4gKiAtIFNpbWlsYXJseSwgaWYgXCJsYWJlbFwiIGlzIG5vdCBzcGVjaWZpZWQsIHRoZW4gdGhlcmUgd2lsbCBiZSBhIGdyaWRsaW5lXG4gKiAgIHdpdGhvdXQgYSBsYWJlbC5cbiAqXG4gKiBUaGlzIGZsZXhpYmlsaXR5IGlzIHVzZWZ1bCBpbiBhIGZldyBzaXR1YXRpb25zOlxuICogLSBGb3IgbG9nIHNjYWxlcywgc29tZSBvZiB0aGUgdGljayBsaW5lcyBtYXkgYmUgdG9vIGNsb3NlIHRvIGFsbCBoYXZlIGxhYmVscy5cbiAqIC0gRm9yIGRhdGUgc2NhbGVzIHdoZXJlIHllYXJzIGFyZSBiZWluZyBkaXNwbGF5ZWQsIGl0IGlzIGRlc2lyYWJsZSB0byBkaXNwbGF5XG4gKiAgIHRpY2sgbWFya3MgYXQgdGhlIGJlZ2lubmluZ3Mgb2YgeWVhcnMgYnV0IGxhYmVscyAoZS5nLiBcIjIwMDZcIikgaW4gdGhlXG4gKiAgIG1pZGRsZSBvZiB0aGUgeWVhcnMuXG4gKi9cblxuLypqc2hpbnQgc3ViOnRydWUgKi9cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2R5Z3JhcGgtdXRpbHMnO1xuXG4vKiogQHR5cGVkZWYge0FycmF5Ljx7djpudW1iZXIsIGxhYmVsOnN0cmluZywgbGFiZWxfdjooc3RyaW5nfHVuZGVmaW5lZCl9Pn0gKi9cbnZhciBUaWNrTGlzdCA9IHVuZGVmaW5lZDsgIC8vIHRoZSAnID0gdW5kZWZpbmVkJyBrZWVwcyBqc2hpbnQgaGFwcHkuXG5cbi8qKiBAdHlwZWRlZiB7ZnVuY3Rpb24oXG4gKiAgICBudW1iZXIsXG4gKiAgICBudW1iZXIsXG4gKiAgICBudW1iZXIsXG4gKiAgICBmdW5jdGlvbihzdHJpbmcpOiosXG4gKiAgICBEeWdyYXBoPSxcbiAqICAgIEFycmF5LjxudW1iZXI+PVxuICogICk6IFRpY2tMaXN0fVxuICovXG52YXIgVGlja2VyID0gdW5kZWZpbmVkOyAgLy8gdGhlICcgPSB1bmRlZmluZWQnIGtlZXBzIGpzaGludCBoYXBweS5cblxuLyoqIEB0eXBlIHtUaWNrZXJ9ICovXG5leHBvcnQgdmFyIG51bWVyaWNMaW5lYXJUaWNrcyA9IGZ1bmN0aW9uKGEsIGIsIHBpeGVscywgb3B0cywgZHlncmFwaCwgdmFscykge1xuICB2YXIgbm9uTG9nc2NhbGVPcHRzID0gZnVuY3Rpb24ob3B0KSB7XG4gICAgaWYgKG9wdCA9PT0gJ2xvZ3NjYWxlJykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBvcHRzKG9wdCk7XG4gIH07XG4gIHJldHVybiBudW1lcmljVGlja3MoYSwgYiwgcGl4ZWxzLCBub25Mb2dzY2FsZU9wdHMsIGR5Z3JhcGgsIHZhbHMpO1xufTtcblxuLyoqIEB0eXBlIHtUaWNrZXJ9ICovXG5leHBvcnQgdmFyIG51bWVyaWNUaWNrcyA9IGZ1bmN0aW9uKGEsIGIsIHBpeGVscywgb3B0cywgZHlncmFwaCwgdmFscykge1xuICB2YXIgcGl4ZWxzX3Blcl90aWNrID0gLyoqIEB0eXBle251bWJlcn0gKi8ob3B0cygncGl4ZWxzUGVyTGFiZWwnKSk7XG4gIHZhciB0aWNrcyA9IFtdO1xuICB2YXIgaSwgaiwgdGlja1YsIG5UaWNrcztcbiAgaWYgKHZhbHMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgdGlja3MucHVzaCh7djogdmFsc1tpXX0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPKGRhbnZrKTogZmFjdG9yIHRoaXMgbG9nLXNjYWxlIGJsb2NrIG91dCBpbnRvIGEgc2VwYXJhdGUgZnVuY3Rpb24uXG4gICAgaWYgKG9wdHMoXCJsb2dzY2FsZVwiKSkge1xuICAgICAgblRpY2tzICA9IE1hdGguZmxvb3IocGl4ZWxzIC8gcGl4ZWxzX3Blcl90aWNrKTtcbiAgICAgIHZhciBtaW5JZHggPSB1dGlscy5iaW5hcnlTZWFyY2goYSwgUFJFRkVSUkVEX0xPR19USUNLX1ZBTFVFUywgMSk7XG4gICAgICB2YXIgbWF4SWR4ID0gdXRpbHMuYmluYXJ5U2VhcmNoKGIsIFBSRUZFUlJFRF9MT0dfVElDS19WQUxVRVMsIC0xKTtcbiAgICAgIGlmIChtaW5JZHggPT0gLTEpIHtcbiAgICAgICAgbWluSWR4ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhJZHggPT0gLTEpIHtcbiAgICAgICAgbWF4SWR4ID0gUFJFRkVSUkVEX0xPR19USUNLX1ZBTFVFUy5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgICAgLy8gQ291bnQgdGhlIG51bWJlciBvZiB0aWNrIHZhbHVlcyB3b3VsZCBhcHBlYXIsIGlmIHdlIGNhbiBnZXQgYXQgbGVhc3RcbiAgICAgIC8vIG5UaWNrcyAvIDQgYWNjZXB0IHRoZW0uXG4gICAgICB2YXIgbGFzdERpc3BsYXllZCA9IG51bGw7XG4gICAgICBpZiAobWF4SWR4IC0gbWluSWR4ID49IG5UaWNrcyAvIDQpIHtcbiAgICAgICAgZm9yICh2YXIgaWR4ID0gbWF4SWR4OyBpZHggPj0gbWluSWR4OyBpZHgtLSkge1xuICAgICAgICAgIHZhciB0aWNrVmFsdWUgPSBQUkVGRVJSRURfTE9HX1RJQ0tfVkFMVUVTW2lkeF07XG4gICAgICAgICAgdmFyIHBpeGVsX2Nvb3JkID0gTWF0aC5sb2codGlja1ZhbHVlIC8gYSkgLyBNYXRoLmxvZyhiIC8gYSkgKiBwaXhlbHM7XG4gICAgICAgICAgdmFyIHRpY2sgPSB7IHY6IHRpY2tWYWx1ZSB9O1xuICAgICAgICAgIGlmIChsYXN0RGlzcGxheWVkID09PSBudWxsKSB7XG4gICAgICAgICAgICBsYXN0RGlzcGxheWVkID0ge1xuICAgICAgICAgICAgICB0aWNrVmFsdWUgOiB0aWNrVmFsdWUsXG4gICAgICAgICAgICAgIHBpeGVsX2Nvb3JkIDogcGl4ZWxfY29vcmRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhwaXhlbF9jb29yZCAtIGxhc3REaXNwbGF5ZWQucGl4ZWxfY29vcmQpID49IHBpeGVsc19wZXJfdGljaykge1xuICAgICAgICAgICAgICBsYXN0RGlzcGxheWVkID0ge1xuICAgICAgICAgICAgICAgIHRpY2tWYWx1ZSA6IHRpY2tWYWx1ZSxcbiAgICAgICAgICAgICAgICBwaXhlbF9jb29yZCA6IHBpeGVsX2Nvb3JkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aWNrLmxhYmVsID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGlja3MucHVzaCh0aWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5jZSB3ZSB3ZW50IGluIGJhY2t3YXJkcyBvcmRlci5cbiAgICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRpY2tzLmxlbmd0aCB3b24ndCBiZSAwIGlmIHRoZSBsb2cgc2NhbGUgZnVuY3Rpb24gZmluZHMgdmFsdWVzIHRvIGluc2VydC5cbiAgICBpZiAodGlja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBCYXNpYyBpZGVhOlxuICAgICAgLy8gVHJ5IGxhYmVscyBldmVyeSAxLCAyLCA1LCAxMCwgMjAsIDUwLCAxMDAsIGV0Yy5cbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcmVzdWx0aW5nIHRpY2sgc3BhY2luZyAoaS5lLiB0aGlzLmhlaWdodF8gLyBuVGlja3MpLlxuICAgICAgLy8gVGhlIGZpcnN0IHNwYWNpbmcgZ3JlYXRlciB0aGFuIHBpeGVsc1BlcllMYWJlbCBpcyB3aGF0IHdlIHVzZS5cbiAgICAgIC8vIFRPRE8oZGFudmspOiB2ZXJzaW9uIHRoYXQgd29ya3Mgb24gYSBsb2cgc2NhbGUuXG4gICAgICB2YXIga21nMiA9IG9wdHMoXCJsYWJlbHNLTUcyXCIpO1xuICAgICAgdmFyIG11bHRzLCBiYXNlO1xuICAgICAgaWYgKGttZzIpIHtcbiAgICAgICAgbXVsdHMgPSBbMSwgMiwgNCwgOCwgMTYsIDMyLCA2NCwgMTI4LCAyNTZdO1xuICAgICAgICBiYXNlID0gMTY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdWx0cyA9IFsxLCAyLCA1LCAxMCwgMjAsIDUwLCAxMDBdO1xuICAgICAgICBiYXNlID0gMTA7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgbWF4aW11bSBudW1iZXIgb2YgcGVybWl0dGVkIHRpY2tzIGJhc2VkIG9uIHRoZVxuICAgICAgLy8gZ3JhcGgncyBwaXhlbCBzaXplIGFuZCBwaXhlbHNfcGVyX3RpY2sgc2V0dGluZy5cbiAgICAgIHZhciBtYXhfdGlja3MgPSBNYXRoLmNlaWwocGl4ZWxzIC8gcGl4ZWxzX3Blcl90aWNrKTtcblxuICAgICAgLy8gTm93IGNhbGN1bGF0ZSB0aGUgZGF0YSB1bml0IGVxdWl2YWxlbnQgb2YgdGhpcyB0aWNrIHNwYWNpbmcuXG4gICAgICAvLyBVc2UgYWJzKCkgc2luY2UgZ3JhcGhzIG1heSBoYXZlIGEgcmV2ZXJzZWQgWSBheGlzLlxuICAgICAgdmFyIHVuaXRzX3Blcl90aWNrID0gTWF0aC5hYnMoYiAtIGEpIC8gbWF4X3RpY2tzO1xuXG4gICAgICAvLyBCYXNlZCBvbiB0aGlzLCBnZXQgYSBzdGFydGluZyBzY2FsZSB3aGljaCBpcyB0aGUgbGFyZ2VzdFxuICAgICAgLy8gaW50ZWdlciBwb3dlciBvZiB0aGUgY2hvc2VuIGJhc2UgKDEwIG9yIDE2KSB0aGF0IHN0aWxsIHJlbWFpbnNcbiAgICAgIC8vIGJlbG93IHRoZSByZXF1ZXN0ZWQgcGl4ZWxzX3Blcl90aWNrIHNwYWNpbmcuXG4gICAgICB2YXIgYmFzZV9wb3dlciA9IE1hdGguZmxvb3IoTWF0aC5sb2codW5pdHNfcGVyX3RpY2spIC8gTWF0aC5sb2coYmFzZSkpO1xuICAgICAgdmFyIGJhc2Vfc2NhbGUgPSBNYXRoLnBvdyhiYXNlLCBiYXNlX3Bvd2VyKTtcblxuICAgICAgLy8gTm93IHRyeSBtdWx0aXBsZXMgb2YgdGhlIHN0YXJ0aW5nIHNjYWxlIHVudGlsIHdlIGZpbmQgb25lXG4gICAgICAvLyB0aGF0IHJlc3VsdHMgaW4gdGljayBtYXJrcyBzcGFjZWQgc3VmZmljaWVudGx5IGZhciBhcGFydC5cbiAgICAgIC8vIFRoZSBcIm11bHRzXCIgYXJyYXkgc2hvdWxkIGNvdmVyIHRoZSByYW5nZSAxIC4uIGJhc2VeMiB0b1xuICAgICAgLy8gYWRqdXN0IGZvciByb3VuZGluZyBhbmQgZWRnZSBlZmZlY3RzLlxuICAgICAgdmFyIHNjYWxlLCBsb3dfdmFsLCBoaWdoX3ZhbCwgc3BhY2luZztcbiAgICAgIGZvciAoaiA9IDA7IGogPCBtdWx0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBzY2FsZSA9IGJhc2Vfc2NhbGUgKiBtdWx0c1tqXTtcbiAgICAgICAgbG93X3ZhbCA9IE1hdGguZmxvb3IoYSAvIHNjYWxlKSAqIHNjYWxlO1xuICAgICAgICBoaWdoX3ZhbCA9IE1hdGguY2VpbChiIC8gc2NhbGUpICogc2NhbGU7XG4gICAgICAgIG5UaWNrcyA9IE1hdGguYWJzKGhpZ2hfdmFsIC0gbG93X3ZhbCkgLyBzY2FsZTtcbiAgICAgICAgc3BhY2luZyA9IHBpeGVscyAvIG5UaWNrcztcbiAgICAgICAgaWYgKHNwYWNpbmcgPiBwaXhlbHNfcGVyX3RpY2spIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBDb25zdHJ1Y3QgdGhlIHNldCBvZiB0aWNrcy5cbiAgICAgIC8vIEFsbG93IHJldmVyc2UgeS1heGlzIGlmIGl0J3MgZXhwbGljaXRseSByZXF1ZXN0ZWQuXG4gICAgICBpZiAobG93X3ZhbCA+IGhpZ2hfdmFsKSBzY2FsZSAqPSAtMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPD0gblRpY2tzOyBpKyspIHtcbiAgICAgICAgdGlja1YgPSBsb3dfdmFsICsgaSAqIHNjYWxlO1xuICAgICAgICB0aWNrcy5wdXNoKCB7djogdGlja1Z9ICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGZvcm1hdHRlciA9IC8qKkB0eXBle0F4aXNMYWJlbEZvcm1hdHRlcn0qLyhvcHRzKCdheGlzTGFiZWxGb3JtYXR0ZXInKSk7XG5cbiAgLy8gQWRkIGxhYmVscyB0byB0aGUgdGlja3MuXG4gIGZvciAoaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aWNrc1tpXS5sYWJlbCAhPT0gdW5kZWZpbmVkKSBjb250aW51ZTsgIC8vIFVzZSBjdXJyZW50IGxhYmVsLlxuICAgIC8vIFRPRE8oZGFudmspOiBzZXQgZ3JhbnVsYXJpdHkgdG8gc29tZXRoaW5nIGFwcHJvcHJpYXRlIGhlcmUuXG4gICAgdGlja3NbaV0ubGFiZWwgPSBmb3JtYXR0ZXIuY2FsbChkeWdyYXBoLCB0aWNrc1tpXS52LCAwLCBvcHRzLCBkeWdyYXBoKTtcbiAgfVxuXG4gIHJldHVybiB0aWNrcztcbn07XG5cblxuLyoqIEB0eXBlIHtUaWNrZXJ9ICovXG5leHBvcnQgdmFyIGRhdGVUaWNrZXIgPSBmdW5jdGlvbihhLCBiLCBwaXhlbHMsIG9wdHMsIGR5Z3JhcGgsIHZhbHMpIHtcbiAgdmFyIGNob3NlbiA9IHBpY2tEYXRlVGlja0dyYW51bGFyaXR5KGEsIGIsIHBpeGVscywgb3B0cyk7XG5cbiAgaWYgKGNob3NlbiA+PSAwKSB7XG4gICAgcmV0dXJuIGdldERhdGVBeGlzKGEsIGIsIGNob3Nlbiwgb3B0cywgZHlncmFwaCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhpcyBjYW4gaGFwcGVuIGlmIHNlbGYud2lkdGhfIGlzIHplcm8uXG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuXG4vLyBUaW1lIGdyYW51bGFyaXR5IGVudW1lcmF0aW9uXG5leHBvcnQgdmFyIEdyYW51bGFyaXR5ID0ge1xuICBNSUxMSVNFQ09ORExZOiAwLFxuICBUV09fTUlMTElTRUNPTkRMWTogMSxcbiAgRklWRV9NSUxMSVNFQ09ORExZOiAyLFxuICBURU5fTUlMTElTRUNPTkRMWTogMyxcbiAgRklGVFlfTUlMTElTRUNPTkRMWTogNCxcbiAgSFVORFJFRF9NSUxMSVNFQ09ORExZOiA1LFxuICBGSVZFX0hVTkRSRURfTUlMTElTRUNPTkRMWTogNixcbiAgU0VDT05ETFk6IDcsXG4gIFRXT19TRUNPTkRMWTogOCxcbiAgRklWRV9TRUNPTkRMWTogOSxcbiAgVEVOX1NFQ09ORExZOiAxMCxcbiAgVEhJUlRZX1NFQ09ORExZOiAxMSxcbiAgTUlOVVRFTFk6IDEyLFxuICBUV09fTUlOVVRFTFk6IDEzLFxuICBGSVZFX01JTlVURUxZOiAxNCxcbiAgVEVOX01JTlVURUxZOiAxNSxcbiAgVEhJUlRZX01JTlVURUxZOiAxNixcbiAgSE9VUkxZOiAxNyxcbiAgVFdPX0hPVVJMWTogMTgsXG4gIFNJWF9IT1VSTFk6IDE5LFxuICBEQUlMWTogMjAsXG4gIFRXT19EQUlMWTogMjEsXG4gIFdFRUtMWTogMjIsXG4gIE1PTlRITFk6IDIzLFxuICBRVUFSVEVSTFk6IDI0LFxuICBCSUFOTlVBTDogMjUsXG4gIEFOTlVBTDogMjYsXG4gIERFQ0FEQUw6IDI3LFxuICBDRU5URU5OSUFMOiAyOCxcbiAgTlVNX0dSQU5VTEFSSVRJRVM6IDI5XG59XG5cbi8vIERhdGUgY29tcG9uZW50cyBlbnVtZXJhdGlvbiAoaW4gdGhlIG9yZGVyIG9mIHRoZSBhcmd1bWVudHMgaW4gRGF0ZSlcbi8vIFRPRE86IG1ha2UgdGhpcyBhbiBAZW51bVxudmFyIERhdGVGaWVsZCA9IHtcbiAgREFURUZJRUxEX1k6IDAsXG4gIERBVEVGSUVMRF9NOiAxLFxuICBEQVRFRklFTERfRDogMixcbiAgREFURUZJRUxEX0hIOiAzLFxuICBEQVRFRklFTERfTU06IDQsXG4gIERBVEVGSUVMRF9TUzogNSxcbiAgREFURUZJRUxEX01TOiA2LFxuICBOVU1fREFURUZJRUxEUzogN1xufTtcblxuXG4vKipcbiAqIFRoZSB2YWx1ZSBvZiBkYXRlZmllbGQgd2lsbCBzdGFydCBhdCBhbiBldmVuIG11bHRpcGxlIG9mIFwic3RlcFwiLCBpLmUuXG4gKiAgIGlmIGRhdGVmaWVsZD1TUyBhbmQgc3RlcD01IHRoZW4gdGhlIGZpcnN0IHRpY2sgd2lsbCBiZSBvbiBhIG11bHRpcGxlIG9mIDVzLlxuICpcbiAqIEZvciBncmFudWxhcml0aWVzIDw9IEhPVVJMWSwgdGlja3MgYXJlIGdlbmVyYXRlZCBldmVyeSBgc3BhY2luZ2AgbXMuXG4gKlxuICogQXQgY29hcnNlciBncmFudWxhcml0aWVzLCB0aWNrcyBhcmUgZ2VuZXJhdGVkIGJ5IGluY3JlbWVudGluZyBgZGF0ZWZpZWxkYCBieVxuICogICBgc3RlcGAuIEluIHRoaXMgY2FzZSwgdGhlIGBzcGFjaW5nYCB2YWx1ZSBpcyBvbmx5IHVzZWQgdG8gZXN0aW1hdGUgdGhlXG4gKiAgIG51bWJlciBvZiB0aWNrcy4gSXQgc2hvdWxkIHJvdWdobHkgY29ycmVzcG9uZCB0byB0aGUgc3BhY2luZyBiZXR3ZWVuXG4gKiAgIGFkamFjZW50IHRpY2tzLlxuICpcbiAqIEB0eXBlIHtBcnJheS48e2RhdGVmaWVsZDpudW1iZXIsIHN0ZXA6bnVtYmVyLCBzcGFjaW5nOm51bWJlcn0+fVxuICovXG52YXIgVElDS19QTEFDRU1FTlQgPSBbXTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5Lk1JTExJU0VDT05ETFldICAgICAgICAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX01TLCBzdGVwOiAgIDEsIHNwYWNpbmc6IDF9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuVFdPX01JTExJU0VDT05ETFldICAgICAgICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfTVMsIHN0ZXA6ICAgMiwgc3BhY2luZzogMn07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5GSVZFX01JTExJU0VDT05ETFldICAgICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NUywgc3RlcDogICA1LCBzcGFjaW5nOiA1fTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LlRFTl9NSUxMSVNFQ09ORExZXSAgICAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX01TLCBzdGVwOiAgMTAsIHNwYWNpbmc6IDEwfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LkZJRlRZX01JTExJU0VDT05ETFldICAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX01TLCBzdGVwOiAgNTAsIHNwYWNpbmc6IDUwfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LkhVTkRSRURfTUlMTElTRUNPTkRMWV0gICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX01TLCBzdGVwOiAxMDAsIHNwYWNpbmc6IDEwMH07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5GSVZFX0hVTkRSRURfTUlMTElTRUNPTkRMWV0gID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NUywgc3RlcDogNTAwLCBzcGFjaW5nOiA1MDB9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuU0VDT05ETFldICAgICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfU1MsIHN0ZXA6ICAgMSwgc3BhY2luZzogMTAwMCAqIDF9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuVFdPX1NFQ09ORExZXSAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfU1MsIHN0ZXA6ICAgMiwgc3BhY2luZzogMTAwMCAqIDJ9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuRklWRV9TRUNPTkRMWV0gICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfU1MsIHN0ZXA6ICAgNSwgc3BhY2luZzogMTAwMCAqIDV9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuVEVOX1NFQ09ORExZXSAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfU1MsIHN0ZXA6ICAxMCwgc3BhY2luZzogMTAwMCAqIDEwfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LlRISVJUWV9TRUNPTkRMWV0gPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX1NTLCBzdGVwOiAgMzAsIHNwYWNpbmc6IDEwMDAgKiAzMH07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5NSU5VVEVMWV0gICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NTSwgc3RlcDogICAxLCBzcGFjaW5nOiAxMDAwICogNjB9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuVFdPX01JTlVURUxZXSAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfTU0sIHN0ZXA6ICAgMiwgc3BhY2luZzogMTAwMCAqIDYwICogMn07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5GSVZFX01JTlVURUxZXSAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NTSwgc3RlcDogICA1LCBzcGFjaW5nOiAxMDAwICogNjAgKiA1fTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LlRFTl9NSU5VVEVMWV0gICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX01NLCBzdGVwOiAgMTAsIHNwYWNpbmc6IDEwMDAgKiA2MCAqIDEwfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LlRISVJUWV9NSU5VVEVMWV0gPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX01NLCBzdGVwOiAgMzAsIHNwYWNpbmc6IDEwMDAgKiA2MCAqIDMwfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LkhPVVJMWV0gICAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX0hILCBzdGVwOiAgIDEsIHNwYWNpbmc6IDEwMDAgKiAzNjAwfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LlRXT19IT1VSTFldICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX0hILCBzdGVwOiAgIDIsIHNwYWNpbmc6IDEwMDAgKiAzNjAwICogMn07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5TSVhfSE9VUkxZXSAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9ISCwgc3RlcDogICA2LCBzcGFjaW5nOiAxMDAwICogMzYwMCAqIDZ9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuREFJTFldICAgICAgICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfRCwgIHN0ZXA6ICAgMSwgc3BhY2luZzogMTAwMCAqIDg2NDAwfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LlRXT19EQUlMWV0gICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX0QsICBzdGVwOiAgIDIsIHNwYWNpbmc6IDEwMDAgKiA4NjQwMCAqIDJ9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuV0VFS0xZXSAgICAgICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfRCwgIHN0ZXA6ICAgNywgc3BhY2luZzogMTAwMCAqIDYwNDgwMH07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5NT05USExZXSAgICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NLCAgc3RlcDogICAxLCBzcGFjaW5nOiAxMDAwICogNzIwMCAgKiAzNjUuMjUyNH07IC8vIDFlMyAqIDYwICogNjAgKiAyNCAqIDM2NS4yNTI0IC8gMTJcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LlFVQVJURVJMWV0gICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX00sICBzdGVwOiAgIDMsIHNwYWNpbmc6IDEwMDAgKiAyMTYwMCAqIDM2NS4yNTI0fTsgLy8gMWUzICogNjAgKiA2MCAqIDI0ICogMzY1LjI1MjQgLyA0XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5CSUFOTlVBTF0gICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NLCAgc3RlcDogICA2LCBzcGFjaW5nOiAxMDAwICogNDMyMDAgKiAzNjUuMjUyNH07IC8vIDFlMyAqIDYwICogNjAgKiAyNCAqIDM2NS4yNTI0IC8gMlxuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuQU5OVUFMXSAgICAgICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfWSwgIHN0ZXA6ICAgMSwgc3BhY2luZzogMTAwMCAqIDg2NDAwICAgKiAzNjUuMjUyNH07IC8vIDFlMyAqIDYwICogNjAgKiAyNCAqIDM2NS4yNTI0ICogMVxuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuREVDQURBTF0gICAgICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfWSwgIHN0ZXA6ICAxMCwgc3BhY2luZzogMTAwMCAqIDg2NDAwMCAgKiAzNjUuMjUyNH07IC8vIDFlMyAqIDYwICogNjAgKiAyNCAqIDM2NS4yNTI0ICogMTBcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LkNFTlRFTk5JQUxdICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX1ksICBzdGVwOiAxMDAsIHNwYWNpbmc6IDEwMDAgKiA4NjQwMDAwICogMzY1LjI1MjR9OyAvLyAxZTMgKiA2MCAqIDYwICogMjQgKiAzNjUuMjUyNCAqIDEwMFxuXG5cbi8qKlxuICogVGhpcyBpcyBhIGxpc3Qgb2YgaHVtYW4tZnJpZW5kbHkgdmFsdWVzIGF0IHdoaWNoIHRvIHNob3cgdGljayBtYXJrcyBvbiBhIGxvZ1xuICogc2NhbGUuIEl0IGlzIGsgKiAxMF5uLCB3aGVyZSBrPTEuLjkgYW5kIG49LTM5Li4rMzksIHNvOlxuICogLi4uLCAxLCAyLCAzLCA0LCA1LCAuLi4sIDksIDEwLCAyMCwgMzAsIC4uLiwgOTAsIDEwMCwgMjAwLCAzMDAsIC4uLlxuICogTk9URTogdGhpcyBhc3N1bWVzIHRoYXQgdXRpbHMuTE9HX1NDQUxFID0gMTAuXG4gKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gKi9cbnZhciBQUkVGRVJSRURfTE9HX1RJQ0tfVkFMVUVTID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdmFscyA9IFtdO1xuICBmb3IgKHZhciBwb3dlciA9IC0zOTsgcG93ZXIgPD0gMzk7IHBvd2VyKyspIHtcbiAgICB2YXIgcmFuZ2UgPSBNYXRoLnBvdygxMCwgcG93ZXIpO1xuICAgIGZvciAodmFyIG11bHQgPSAxOyBtdWx0IDw9IDk7IG11bHQrKykge1xuICAgICAgdmFyIHZhbCA9IHJhbmdlICogbXVsdDtcbiAgICAgIHZhbHMucHVzaCh2YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFscztcbn0pKCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBjb3JyZWN0IGdyYW51bGFyaXR5IG9mIHRpY2tzIG9uIGEgZGF0ZSBheGlzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIExlZnQgZWRnZSBvZiB0aGUgY2hhcnQgKG1zKVxuICogQHBhcmFtIHtudW1iZXJ9IGIgUmlnaHQgZWRnZSBvZiB0aGUgY2hhcnQgKG1zKVxuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVscyBTaXplIG9mIHRoZSBjaGFydCBpbiB0aGUgcmVsZXZhbnQgZGltZW5zaW9uICh3aWR0aCkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyk6Kn0gb3B0cyBGdW5jdGlvbiBtYXBwaW5nIGZyb20gb3B0aW9uIG5hbWUgLSZndDsgdmFsdWUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhcHByb3ByaWF0ZSBheGlzIGdyYW51bGFyaXR5IGZvciB0aGlzIGNoYXJ0LiBTZWUgdGhlXG4gKiAgICAgZW51bWVyYXRpb24gb2YgcG9zc2libGUgdmFsdWVzIGluIGR5Z3JhcGgtdGlja2Vycy5qcy5cbiAqL1xudmFyIHBpY2tEYXRlVGlja0dyYW51bGFyaXR5ID0gZnVuY3Rpb24oYSwgYiwgcGl4ZWxzLCBvcHRzKSB7XG4gIHZhciBwaXhlbHNfcGVyX3RpY2sgPSAvKiogQHR5cGV7bnVtYmVyfSAqLyhvcHRzKCdwaXhlbHNQZXJMYWJlbCcpKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBHcmFudWxhcml0eS5OVU1fR1JBTlVMQVJJVElFUzsgaSsrKSB7XG4gICAgdmFyIG51bV90aWNrcyA9IG51bURhdGVUaWNrcyhhLCBiLCBpKTtcbiAgICBpZiAocGl4ZWxzIC8gbnVtX3RpY2tzID49IHBpeGVsc19wZXJfdGljaykge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIHRpY2tzIG9uIGEgZGF0ZSBheGlzIGZvciBhIGdpdmVuIGdyYW51bGFyaXR5LlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0X3RpbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRfdGltZVxuICogQHBhcmFtIHtudW1iZXJ9IGdyYW51bGFyaXR5IChvbmUgb2YgdGhlIGdyYW51bGFyaXRpZXMgZW51bWVyYXRlZCBhYm92ZSlcbiAqIEByZXR1cm4ge251bWJlcn0gKEFwcHJveGltYXRlKSBudW1iZXIgb2YgdGlja3MgdGhhdCB3b3VsZCByZXN1bHQuXG4gKi9cbnZhciBudW1EYXRlVGlja3MgPSBmdW5jdGlvbihzdGFydF90aW1lLCBlbmRfdGltZSwgZ3JhbnVsYXJpdHkpIHtcbiAgdmFyIHNwYWNpbmcgPSBUSUNLX1BMQUNFTUVOVFtncmFudWxhcml0eV0uc3BhY2luZztcbiAgcmV0dXJuIE1hdGgucm91bmQoMS4wICogKGVuZF90aW1lIC0gc3RhcnRfdGltZSkgLyBzcGFjaW5nKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgcG9zaXRpb25zIGFuZCBsYWJlbHMgb2YgdGlja3Mgb24gYSBkYXRlIGF4aXMgZm9yIGEgZ2l2ZW4gZ3JhbnVsYXJpdHkuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRfdGltZVxuICogQHBhcmFtIHtudW1iZXJ9IGVuZF90aW1lXG4gKiBAcGFyYW0ge251bWJlcn0gZ3JhbnVsYXJpdHkgKG9uZSBvZiB0aGUgZ3JhbnVsYXJpdGllcyBlbnVtZXJhdGVkIGFib3ZlKVxuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpOip9IG9wdHMgRnVuY3Rpb24gbWFwcGluZyBmcm9tIG9wdGlvbiBuYW1lIC0mZ3Q7IHZhbHVlLlxuICogQHBhcmFtIHtEeWdyYXBoPX0gZGdcbiAqIEByZXR1cm4geyFUaWNrTGlzdH1cbiAqL1xuZXhwb3J0IHZhciBnZXREYXRlQXhpcyA9IGZ1bmN0aW9uKHN0YXJ0X3RpbWUsIGVuZF90aW1lLCBncmFudWxhcml0eSwgb3B0cywgZGcpIHtcbiAgdmFyIGZvcm1hdHRlciA9IC8qKiBAdHlwZXtBeGlzTGFiZWxGb3JtYXR0ZXJ9ICovKFxuICAgICAgb3B0cyhcImF4aXNMYWJlbEZvcm1hdHRlclwiKSk7XG4gIHZhciB1dGMgPSBvcHRzKFwibGFiZWxzVVRDXCIpO1xuICB2YXIgYWNjZXNzb3JzID0gdXRjID8gdXRpbHMuRGF0ZUFjY2Vzc29yc1VUQyA6IHV0aWxzLkRhdGVBY2Nlc3NvcnNMb2NhbDtcblxuICB2YXIgZGF0ZWZpZWxkID0gVElDS19QTEFDRU1FTlRbZ3JhbnVsYXJpdHldLmRhdGVmaWVsZDtcbiAgdmFyIHN0ZXAgPSBUSUNLX1BMQUNFTUVOVFtncmFudWxhcml0eV0uc3RlcDtcbiAgdmFyIHNwYWNpbmcgPSBUSUNLX1BMQUNFTUVOVFtncmFudWxhcml0eV0uc3BhY2luZztcblxuICAvLyBDaG9vc2UgYSBuaWNlIHRpY2sgcG9zaXRpb24gYmVmb3JlIHRoZSBpbml0aWFsIGluc3RhbnQuXG4gIC8vIEN1cnJlbnRseSwgdGhpcyBjb2RlIGRlYWxzIHByb3Blcmx5IHdpdGggdGhlIGV4aXN0ZW50IGRhaWx5IGdyYW51bGFyaXRpZXM6XG4gIC8vIERBSUxZICh3aXRoIHN0ZXAgb2YgMSkgYW5kIFdFRUtMWSAod2l0aCBzdGVwIG9mIDcgYnV0IHNwZWNpYWxseSBoYW5kbGVkKS5cbiAgLy8gT3RoZXIgZGFpbHkgZ3JhbnVsYXJpdGllcyAoc2F5IFRXT19EQUlMWSkgc2hvdWxkIGFsc28gYmUgaGFuZGxlZCBzcGVjaWFsbHlcbiAgLy8gYnkgc2V0dGluZyB0aGUgc3RhcnRfZGF0ZV9vZmZzZXQgdG8gMC5cbiAgdmFyIHN0YXJ0X2RhdGUgPSBuZXcgRGF0ZShzdGFydF90aW1lKTtcbiAgdmFyIGRhdGVfYXJyYXkgPSBbXTtcbiAgZGF0ZV9hcnJheVtEYXRlRmllbGQuREFURUZJRUxEX1ldICA9IGFjY2Vzc29ycy5nZXRGdWxsWWVhcihzdGFydF9kYXRlKTtcbiAgZGF0ZV9hcnJheVtEYXRlRmllbGQuREFURUZJRUxEX01dICA9IGFjY2Vzc29ycy5nZXRNb250aChzdGFydF9kYXRlKTtcbiAgZGF0ZV9hcnJheVtEYXRlRmllbGQuREFURUZJRUxEX0RdICA9IGFjY2Vzc29ycy5nZXREYXRlKHN0YXJ0X2RhdGUpO1xuICBkYXRlX2FycmF5W0RhdGVGaWVsZC5EQVRFRklFTERfSEhdID0gYWNjZXNzb3JzLmdldEhvdXJzKHN0YXJ0X2RhdGUpO1xuICBkYXRlX2FycmF5W0RhdGVGaWVsZC5EQVRFRklFTERfTU1dID0gYWNjZXNzb3JzLmdldE1pbnV0ZXMoc3RhcnRfZGF0ZSk7XG4gIGRhdGVfYXJyYXlbRGF0ZUZpZWxkLkRBVEVGSUVMRF9TU10gPSBhY2Nlc3NvcnMuZ2V0U2Vjb25kcyhzdGFydF9kYXRlKTtcbiAgZGF0ZV9hcnJheVtEYXRlRmllbGQuREFURUZJRUxEX01TXSA9IGFjY2Vzc29ycy5nZXRNaWxsaXNlY29uZHMoc3RhcnRfZGF0ZSk7XG5cbiAgdmFyIHN0YXJ0X2RhdGVfb2Zmc2V0ID0gZGF0ZV9hcnJheVtkYXRlZmllbGRdICUgc3RlcDtcbiAgaWYgKGdyYW51bGFyaXR5ID09IEdyYW51bGFyaXR5LldFRUtMWSkge1xuICAgIC8vIFRoaXMgd2lsbCBwdXQgdGhlIHRpY2tzIG9uIFN1bmRheXMuXG4gICAgc3RhcnRfZGF0ZV9vZmZzZXQgPSBhY2Nlc3NvcnMuZ2V0RGF5KHN0YXJ0X2RhdGUpO1xuICB9XG4gIFxuICBkYXRlX2FycmF5W2RhdGVmaWVsZF0gLT0gc3RhcnRfZGF0ZV9vZmZzZXQ7XG4gIGZvciAodmFyIGRmID0gZGF0ZWZpZWxkICsgMTsgZGYgPCBEYXRlRmllbGQuTlVNX0RBVEVGSUVMRFM7IGRmKyspIHtcbiAgICAvLyBUaGUgbWluaW11bSB2YWx1ZSBpcyAxIGZvciB0aGUgZGF5IG9mIG1vbnRoLCBhbmQgMCBmb3IgYWxsIG90aGVyIGZpZWxkcy5cbiAgICBkYXRlX2FycmF5W2RmXSA9IChkZiA9PT0gRGF0ZUZpZWxkLkRBVEVGSUVMRF9EKSA/IDEgOiAwO1xuICB9XG5cbiAgLy8gR2VuZXJhdGUgdGhlIHRpY2tzLlxuICAvLyBGb3IgZ3JhbnVsYXJpdGllcyBub3QgY29hcnNlciB0aGFuIEhPVVJMWSB3ZSB1c2UgdGhlIGZhY3QgdGhhdDpcbiAgLy8gICB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHRpY2tzIGlzIGNvbnN0YW50XG4gIC8vICAgYW5kIGVxdWFsIHRvIHRoZSBkZWZpbmVkIHNwYWNpbmcuXG4gIC8vIE90aGVyd2lzZSB3ZSByZWx5IG9uIHRoZSAncm9sbCBvdmVyJyBwcm9wZXJ0eSBvZiB0aGUgRGF0ZSBmdW5jdGlvbnM6XG4gIC8vICAgd2hlbiBzb21lIGRhdGUgZmllbGQgaXMgc2V0IHRvIGEgdmFsdWUgb3V0c2lkZSBvZiBpdHMgbG9naWNhbCByYW5nZSxcbiAgLy8gICB0aGUgZXhjZXNzICdyb2xscyBvdmVyJyB0aGUgbmV4dCAobW9yZSBzaWduaWZpY2FudCkgZmllbGQuXG4gIC8vIEhvd2V2ZXIsIHdoZW4gdXNpbmcgbG9jYWwgdGltZSB3aXRoIERTVCB0cmFuc2l0aW9ucyxcbiAgLy8gdGhlcmUgYXJlIGRhdGVzIHRoYXQgZG8gbm90IHJlcHJlc2VudCBhbnkgdGltZSB2YWx1ZSBhdCBhbGxcbiAgLy8gKHRob3NlIGluIHRoZSBob3VyIHNraXBwZWQgYXQgdGhlICdzcHJpbmcgZm9yd2FyZCcpLFxuICAvLyBhbmQgdGhlIEphdmFTY3JpcHQgZW5naW5lcyB1c3VhbGx5IHJldHVybiBhbiBlcXVpdmFsZW50IHZhbHVlLlxuICAvLyBIZW5jZSB3ZSBoYXZlIHRvIGNoZWNrIHRoYXQgdGhlIGRhdGUgaXMgcHJvcGVybHkgaW5jcmVhc2VkIGF0IGVhY2ggc3RlcCxcbiAgLy8gcmV0dXJuaW5nIGEgZGF0ZSBhdCBhIG5pY2UgdGljayBwb3NpdGlvbi5cbiAgdmFyIHRpY2tzID0gW107XG4gIHZhciB0aWNrX2RhdGUgPSBhY2Nlc3NvcnMubWFrZURhdGUuYXBwbHkobnVsbCwgZGF0ZV9hcnJheSk7XG4gIHZhciB0aWNrX3RpbWUgPSB0aWNrX2RhdGUuZ2V0VGltZSgpO1xuICBpZiAoZ3JhbnVsYXJpdHkgPD0gR3JhbnVsYXJpdHkuSE9VUkxZKSB7XG4gICAgaWYgKHRpY2tfdGltZSA8IHN0YXJ0X3RpbWUpIHtcbiAgICAgIHRpY2tfdGltZSArPSBzcGFjaW5nO1xuICAgICAgdGlja19kYXRlID0gbmV3IERhdGUodGlja190aW1lKTtcbiAgICB9XG4gICAgd2hpbGUgKHRpY2tfdGltZSA8PSBlbmRfdGltZSkge1xuICAgICAgdGlja3MucHVzaCh7IHY6IHRpY2tfdGltZSxcbiAgICAgICAgICAgICAgICAgICBsYWJlbDogZm9ybWF0dGVyLmNhbGwoZGcsIHRpY2tfZGF0ZSwgZ3JhbnVsYXJpdHksIG9wdHMsIGRnKVxuICAgICAgICAgICAgICAgICB9KTtcbiAgICAgIHRpY2tfdGltZSArPSBzcGFjaW5nO1xuICAgICAgdGlja19kYXRlID0gbmV3IERhdGUodGlja190aW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRpY2tfdGltZSA8IHN0YXJ0X3RpbWUpIHtcbiAgICAgIGRhdGVfYXJyYXlbZGF0ZWZpZWxkXSArPSBzdGVwO1xuICAgICAgdGlja19kYXRlID0gYWNjZXNzb3JzLm1ha2VEYXRlLmFwcGx5KG51bGwsIGRhdGVfYXJyYXkpO1xuICAgICAgdGlja190aW1lID0gdGlja19kYXRlLmdldFRpbWUoKTtcbiAgICB9XG4gICAgd2hpbGUgKHRpY2tfdGltZSA8PSBlbmRfdGltZSkge1xuICAgICAgaWYgKGdyYW51bGFyaXR5ID49IEdyYW51bGFyaXR5LkRBSUxZIHx8XG4gICAgICAgICAgYWNjZXNzb3JzLmdldEhvdXJzKHRpY2tfZGF0ZSkgJSBzdGVwID09PSAwKSB7XG4gICAgICAgIHRpY2tzLnB1c2goeyB2OiB0aWNrX3RpbWUsXG4gICAgICAgICAgICAgICAgICAgICBsYWJlbDogZm9ybWF0dGVyLmNhbGwoZGcsIHRpY2tfZGF0ZSwgZ3JhbnVsYXJpdHksIG9wdHMsIGRnKVxuICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGF0ZV9hcnJheVtkYXRlZmllbGRdICs9IHN0ZXA7XG4gICAgICB0aWNrX2RhdGUgPSBhY2Nlc3NvcnMubWFrZURhdGUuYXBwbHkobnVsbCwgZGF0ZV9hcnJheSk7XG4gICAgICB0aWNrX3RpbWUgPSB0aWNrX2RhdGUuZ2V0VGltZSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGlja3M7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9keWdyYXBocy9zcmMvZHlncmFwaC10aWNrZXJzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_layout__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dygraph_canvas__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__dygraph_options__ = __webpack_require__(21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__dygraph_interaction_model__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__dygraph_default_attrs__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__dygraph_options_reference__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__iframe_tarp__ = __webpack_require__(13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__datahandler_default__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__datahandler_bars_error__ = __webpack_require__(17);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__datahandler_bars_custom__ = __webpack_require__(16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__datahandler_default_fractions__ = __webpack_require__(19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__datahandler_bars_fractions__ = __webpack_require__(18);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__datahandler_bars__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__plugins_annotations__ = __webpack_require__(22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__plugins_axes__ = __webpack_require__(23);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__plugins_chart_labels__ = __webpack_require__(24);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__plugins_grid__ = __webpack_require__(25);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__plugins_legend__ = __webpack_require__(26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__plugins_range_selector__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__dygraph_gviz__ = __webpack_require__(20);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * @license\n * Copyright 2006 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview Creates an interactive, zoomable graph based on a CSV file or\n * string. Dygraph can handle multiple series with or without error bars. The\n * date/value ranges will be automatically set. Dygraph uses the\n * &lt;canvas&gt; tag, so it only works in FF1.5+.\n * @author danvdk@gmail.com (Dan Vanderkam)\n\n  Usage:\n   <div id=\"graphdiv\" style=\"width:800px; height:500px;\"></div>\n   <script type=\"text/javascript\">\n     new Dygraph(document.getElementById(\"graphdiv\"),\n                 \"datafile.csv\",  // CSV file with headers\n                 { }); // options\n   </script>\n\n The CSV file is of the form\n\n   Date,SeriesA,SeriesB,SeriesC\n   YYYYMMDD,A1,B1,C1\n   YYYYMMDD,A2,B2,C2\n\n If the 'errorBars' option is set in the constructor, the input should be of\n the form\n   Date,SeriesA,SeriesB,...\n   YYYYMMDD,A1,sigmaA1,B1,sigmaB1,...\n   YYYYMMDD,A2,sigmaA2,B2,sigmaB2,...\n\n If the 'fractions' option is set, the input should be of the form:\n\n   Date,SeriesA,SeriesB,...\n   YYYYMMDD,A1/B1,A2/B2,...\n   YYYYMMDD,A1/B1,A2/B2,...\n\n And error bars will be calculated automatically using a binomial distribution.\n\n For further documentation and examples, see http://dygraphs.com/\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"use strict\";\n\n/**\n * Creates an interactive, zoomable chart.\n *\n * @constructor\n * @param {div | String} div A div or the id of a div into which to construct\n * the chart.\n * @param {String | Function} file A file containing CSV data or a function\n * that returns this data. The most basic expected format for each line is\n * \"YYYY/MM/DD,val1,val2,...\". For more information, see\n * http://dygraphs.com/data.html.\n * @param {Object} attrs Various other attributes, e.g. errorBars determines\n * whether the input data contains error ranges. For a complete list of\n * options, see http://dygraphs.com/options.html.\n */\nvar Dygraph = function Dygraph(div, data, opts) {\n  this.__init__(div, data, opts);\n};\n\nDygraph.NAME = \"Dygraph\";\nDygraph.VERSION = \"2.0.0\";\n\n// Various default values\nDygraph.DEFAULT_ROLL_PERIOD = 1;\nDygraph.DEFAULT_WIDTH = 480;\nDygraph.DEFAULT_HEIGHT = 320;\n\n// For max 60 Hz. animation:\nDygraph.ANIMATION_STEPS = 12;\nDygraph.ANIMATION_DURATION = 200;\n\n/**\n * Standard plotters. These may be used by clients.\n * Available plotters are:\n * - Dygraph.Plotters.linePlotter: draws central lines (most common)\n * - Dygraph.Plotters.errorPlotter: draws error bars\n * - Dygraph.Plotters.fillPlotter: draws fills under lines (used with fillGraph)\n *\n * By default, the plotter is [fillPlotter, errorPlotter, linePlotter].\n * This causes all the lines to be drawn over all the fills/error bars.\n */\nDygraph.Plotters = __WEBPACK_IMPORTED_MODULE_1__dygraph_canvas__[\"a\" /* default */]._Plotters;\n\n// Used for initializing annotation CSS rules only once.\nDygraph.addedAnnotationCSS = false;\n\n/**\n * Initializes the Dygraph. This creates a new DIV and constructs the PlotKit\n * and context &lt;canvas&gt; inside of it. See the constructor for details.\n * on the parameters.\n * @param {Element} div the Element to render the graph into.\n * @param {string | Function} file Source data\n * @param {Object} attrs Miscellaneous other options\n * @private\n */\nDygraph.prototype.__init__ = function (div, file, attrs) {\n  this.is_initial_draw_ = true;\n  this.readyFns_ = [];\n\n  // Support two-argument constructor\n  if (attrs === null || attrs === undefined) {\n    attrs = {};\n  }\n\n  attrs = Dygraph.copyUserAttrs_(attrs);\n\n  if (typeof div == 'string') {\n    div = document.getElementById(div);\n  }\n\n  if (!div) {\n    throw new Error('Constructing dygraph with a non-existent div!');\n  }\n\n  // Copy the important bits into the object\n  // TODO(danvk): most of these should just stay in the attrs_ dictionary.\n  this.maindiv_ = div;\n  this.file_ = file;\n  this.rollPeriod_ = attrs.rollPeriod || Dygraph.DEFAULT_ROLL_PERIOD;\n  this.previousVerticalX_ = -1;\n  this.fractions_ = attrs.fractions || false;\n  this.dateWindow_ = attrs.dateWindow || null;\n\n  this.annotations_ = [];\n\n  // Clear the div. This ensure that, if multiple dygraphs are passed the same\n  // div, then only one will be drawn.\n  div.innerHTML = \"\";\n\n  // For historical reasons, the 'width' and 'height' options trump all CSS\n  // rules _except_ for an explicit 'width' or 'height' on the div.\n  // As an added convenience, if the div has zero height (like <div></div> does\n  // without any styles), then we use a default height/width.\n  if (div.style.width === '' && attrs.width) {\n    div.style.width = attrs.width + \"px\";\n  }\n  if (div.style.height === '' && attrs.height) {\n    div.style.height = attrs.height + \"px\";\n  }\n  if (div.style.height === '' && div.clientHeight === 0) {\n    div.style.height = Dygraph.DEFAULT_HEIGHT + \"px\";\n    if (div.style.width === '') {\n      div.style.width = Dygraph.DEFAULT_WIDTH + \"px\";\n    }\n  }\n  // These will be zero if the dygraph's div is hidden. In that case,\n  // use the user-specified attributes if present. If not, use zero\n  // and assume the user will call resize to fix things later.\n  this.width_ = div.clientWidth || attrs.width || 0;\n  this.height_ = div.clientHeight || attrs.height || 0;\n\n  // TODO(danvk): set fillGraph to be part of attrs_ here, not user_attrs_.\n  if (attrs.stackedGraph) {\n    attrs.fillGraph = true;\n    // TODO(nikhilk): Add any other stackedGraph checks here.\n  }\n\n  // DEPRECATION WARNING: All option processing should be moved from\n  // attrs_ and user_attrs_ to options_, which holds all this information.\n  //\n  // Dygraphs has many options, some of which interact with one another.\n  // To keep track of everything, we maintain two sets of options:\n  //\n  //  this.user_attrs_   only options explicitly set by the user.\n  //  this.attrs_        defaults, options derived from user_attrs_, data.\n  //\n  // Options are then accessed this.attr_('attr'), which first looks at\n  // user_attrs_ and then computed attrs_. This way Dygraphs can set intelligent\n  // defaults without overriding behavior that the user specifically asks for.\n  this.user_attrs_ = {};\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"a\" /* update */](this.user_attrs_, attrs);\n\n  // This sequence ensures that Dygraph.DEFAULT_ATTRS is never modified.\n  this.attrs_ = {};\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"b\" /* updateDeep */](this.attrs_, __WEBPACK_IMPORTED_MODULE_6__dygraph_default_attrs__[\"a\" /* default */]);\n\n  this.boundaryIds_ = [];\n  this.setIndexByName_ = {};\n  this.datasetIndex_ = [];\n\n  this.registeredEvents_ = [];\n  this.eventListeners_ = {};\n\n  this.attributes_ = new __WEBPACK_IMPORTED_MODULE_2__dygraph_options__[\"a\" /* default */](this);\n\n  // Create the containing DIV and other interactive elements\n  this.createInterface_();\n\n  // Activate plugins.\n  this.plugins_ = [];\n  var plugins = Dygraph.PLUGINS.concat(this.getOption('plugins'));\n  for (var i = 0; i < plugins.length; i++) {\n    // the plugins option may contain either plugin classes or instances.\n    // Plugin instances contain an activate method.\n    var Plugin = plugins[i]; // either a constructor or an instance.\n    var pluginInstance;\n    if (typeof Plugin.activate !== 'undefined') {\n      pluginInstance = Plugin;\n    } else {\n      pluginInstance = new Plugin();\n    }\n\n    var pluginDict = {\n      plugin: pluginInstance,\n      events: {},\n      options: {},\n      pluginOptions: {}\n    };\n\n    var handlers = pluginInstance.activate(this);\n    for (var eventName in handlers) {\n      if (!handlers.hasOwnProperty(eventName)) continue;\n      // TODO(danvk): validate eventName.\n      pluginDict.events[eventName] = handlers[eventName];\n    }\n\n    this.plugins_.push(pluginDict);\n  }\n\n  // At this point, plugins can no longer register event handlers.\n  // Construct a map from event -> ordered list of [callback, plugin].\n  for (var i = 0; i < this.plugins_.length; i++) {\n    var plugin_dict = this.plugins_[i];\n    for (var eventName in plugin_dict.events) {\n      if (!plugin_dict.events.hasOwnProperty(eventName)) continue;\n      var callback = plugin_dict.events[eventName];\n\n      var pair = [plugin_dict.plugin, callback];\n      if (!(eventName in this.eventListeners_)) {\n        this.eventListeners_[eventName] = [pair];\n      } else {\n        this.eventListeners_[eventName].push(pair);\n      }\n    }\n  }\n\n  this.createDragInterface_();\n\n  this.start_();\n};\n\n/**\n * Triggers a cascade of events to the various plugins which are interested in them.\n * Returns true if the \"default behavior\" should be prevented, i.e. if one\n * of the event listeners called event.preventDefault().\n * @private\n */\nDygraph.prototype.cascadeEvents_ = function (name, extra_props) {\n  if (!(name in this.eventListeners_)) return false;\n\n  // QUESTION: can we use objects & prototypes to speed this up?\n  var e = {\n    dygraph: this,\n    cancelable: false,\n    defaultPrevented: false,\n    preventDefault: function preventDefault() {\n      if (!e.cancelable) throw \"Cannot call preventDefault on non-cancelable event.\";\n      e.defaultPrevented = true;\n    },\n    propagationStopped: false,\n    stopPropagation: function stopPropagation() {\n      e.propagationStopped = true;\n    }\n  };\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"a\" /* update */](e, extra_props);\n\n  var callback_plugin_pairs = this.eventListeners_[name];\n  if (callback_plugin_pairs) {\n    for (var i = callback_plugin_pairs.length - 1; i >= 0; i--) {\n      var plugin = callback_plugin_pairs[i][0];\n      var callback = callback_plugin_pairs[i][1];\n      callback.call(plugin, e);\n      if (e.propagationStopped) break;\n    }\n  }\n  return e.defaultPrevented;\n};\n\n/**\n * Fetch a plugin instance of a particular class. Only for testing.\n * @private\n * @param {!Class} type The type of the plugin.\n * @return {Object} Instance of the plugin, or null if there is none.\n */\nDygraph.prototype.getPluginInstance_ = function (type) {\n  for (var i = 0; i < this.plugins_.length; i++) {\n    var p = this.plugins_[i];\n    if (p.plugin instanceof type) {\n      return p.plugin;\n    }\n  }\n  return null;\n};\n\n/**\n * Returns the zoomed status of the chart for one or both axes.\n *\n * Axis is an optional parameter. Can be set to 'x' or 'y'.\n *\n * The zoomed status for an axis is set whenever a user zooms using the mouse\n * or when the dateWindow or valueRange are updated. Double-clicking or calling\n * resetZoom() resets the zoom status for the chart.\n */\nDygraph.prototype.isZoomed = function (axis) {\n  var isZoomedX = !!this.dateWindow_;\n  if (axis === 'x') return isZoomedX;\n\n  var isZoomedY = this.axes_.map(function (axis) {\n    return !!axis.valueRange;\n  }).indexOf(true) >= 0;\n  if (axis === null || axis === undefined) {\n    return isZoomedX || isZoomedY;\n  }\n  if (axis === 'y') return isZoomedY;\n\n  throw new Error('axis parameter is [' + axis + '] must be null, \\'x\\' or \\'y\\'.');\n};\n\n/**\n * Returns information about the Dygraph object, including its containing ID.\n */\nDygraph.prototype.toString = function () {\n  var maindiv = this.maindiv_;\n  var id = maindiv && maindiv.id ? maindiv.id : maindiv;\n  return \"[Dygraph \" + id + \"]\";\n};\n\n/**\n * @private\n * Returns the value of an option. This may be set by the user (either in the\n * constructor or by calling updateOptions) or by dygraphs, and may be set to a\n * per-series value.\n * @param {string} name The name of the option, e.g. 'rollPeriod'.\n * @param {string} [seriesName] The name of the series to which the option\n * will be applied. If no per-series value of this option is available, then\n * the global value is returned. This is optional.\n * @return { ... } The value of the option.\n */\nDygraph.prototype.attr_ = function (name, seriesName) {\n  // For \"production\" code, this gets removed by uglifyjs.\n  if (typeof process !== 'undefined') {\n    if (process.env.NODE_ENV != 'production') {\n      if (typeof __WEBPACK_IMPORTED_MODULE_7__dygraph_options_reference__[\"a\" /* default */] === 'undefined') {\n        console.error('Must include options reference JS for testing');\n      } else if (!__WEBPACK_IMPORTED_MODULE_7__dygraph_options_reference__[\"a\" /* default */].hasOwnProperty(name)) {\n        console.error('Dygraphs is using property ' + name + ', which has no ' + 'entry in the Dygraphs.OPTIONS_REFERENCE listing.');\n        // Only log this error once.\n        __WEBPACK_IMPORTED_MODULE_7__dygraph_options_reference__[\"a\" /* default */][name] = true;\n      }\n    }\n  }\n  return seriesName ? this.attributes_.getForSeries(name, seriesName) : this.attributes_.get(name);\n};\n\n/**\n * Returns the current value for an option, as set in the constructor or via\n * updateOptions. You may pass in an (optional) series name to get per-series\n * values for the option.\n *\n * All values returned by this method should be considered immutable. If you\n * modify them, there is no guarantee that the changes will be honored or that\n * dygraphs will remain in a consistent state. If you want to modify an option,\n * use updateOptions() instead.\n *\n * @param {string} name The name of the option (e.g. 'strokeWidth')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {*} The value of the option.\n */\nDygraph.prototype.getOption = function (name, opt_seriesName) {\n  return this.attr_(name, opt_seriesName);\n};\n\n/**\n * Like getOption(), but specifically returns a number.\n * This is a convenience function for working with the Closure Compiler.\n * @param {string} name The name of the option (e.g. 'strokeWidth')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {number} The value of the option.\n * @private\n */\nDygraph.prototype.getNumericOption = function (name, opt_seriesName) {\n  return (/** @type{number} */this.getOption(name, opt_seriesName)\n  );\n};\n\n/**\n * Like getOption(), but specifically returns a string.\n * This is a convenience function for working with the Closure Compiler.\n * @param {string} name The name of the option (e.g. 'strokeWidth')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {string} The value of the option.\n * @private\n */\nDygraph.prototype.getStringOption = function (name, opt_seriesName) {\n  return (/** @type{string} */this.getOption(name, opt_seriesName)\n  );\n};\n\n/**\n * Like getOption(), but specifically returns a boolean.\n * This is a convenience function for working with the Closure Compiler.\n * @param {string} name The name of the option (e.g. 'strokeWidth')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {boolean} The value of the option.\n * @private\n */\nDygraph.prototype.getBooleanOption = function (name, opt_seriesName) {\n  return (/** @type{boolean} */this.getOption(name, opt_seriesName)\n  );\n};\n\n/**\n * Like getOption(), but specifically returns a function.\n * This is a convenience function for working with the Closure Compiler.\n * @param {string} name The name of the option (e.g. 'strokeWidth')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {function(...)} The value of the option.\n * @private\n */\nDygraph.prototype.getFunctionOption = function (name, opt_seriesName) {\n  return (/** @type{function(...)} */this.getOption(name, opt_seriesName)\n  );\n};\n\nDygraph.prototype.getOptionForAxis = function (name, axis) {\n  return this.attributes_.getForAxis(name, axis);\n};\n\n/**\n * @private\n * @param {string} axis The name of the axis (i.e. 'x', 'y' or 'y2')\n * @return { ... } A function mapping string -> option value\n */\nDygraph.prototype.optionsViewForAxis_ = function (axis) {\n  var self = this;\n  return function (opt) {\n    var axis_opts = self.user_attrs_.axes;\n    if (axis_opts && axis_opts[axis] && axis_opts[axis].hasOwnProperty(opt)) {\n      return axis_opts[axis][opt];\n    }\n\n    // I don't like that this is in a second spot.\n    if (axis === 'x' && opt === 'logscale') {\n      // return the default value.\n      // TODO(konigsberg): pull the default from a global default.\n      return false;\n    }\n\n    // user-specified attributes always trump defaults, even if they're less\n    // specific.\n    if (typeof self.user_attrs_[opt] != 'undefined') {\n      return self.user_attrs_[opt];\n    }\n\n    axis_opts = self.attrs_.axes;\n    if (axis_opts && axis_opts[axis] && axis_opts[axis].hasOwnProperty(opt)) {\n      return axis_opts[axis][opt];\n    }\n    // check old-style axis options\n    // TODO(danvk): add a deprecation warning if either of these match.\n    if (axis == 'y' && self.axes_[0].hasOwnProperty(opt)) {\n      return self.axes_[0][opt];\n    } else if (axis == 'y2' && self.axes_[1].hasOwnProperty(opt)) {\n      return self.axes_[1][opt];\n    }\n    return self.attr_(opt);\n  };\n};\n\n/**\n * Returns the current rolling period, as set by the user or an option.\n * @return {number} The number of points in the rolling window\n */\nDygraph.prototype.rollPeriod = function () {\n  return this.rollPeriod_;\n};\n\n/**\n * Returns the currently-visible x-range. This can be affected by zooming,\n * panning or a call to updateOptions.\n * Returns a two-element array: [left, right].\n * If the Dygraph has dates on the x-axis, these will be millis since epoch.\n */\nDygraph.prototype.xAxisRange = function () {\n  return this.dateWindow_ ? this.dateWindow_ : this.xAxisExtremes();\n};\n\n/**\n * Returns the lower- and upper-bound x-axis values of the data set.\n */\nDygraph.prototype.xAxisExtremes = function () {\n  var pad = this.getNumericOption('xRangePad') / this.plotter_.area.w;\n  if (this.numRows() === 0) {\n    return [0 - pad, 1 + pad];\n  }\n  var left = this.rawData_[0][0];\n  var right = this.rawData_[this.rawData_.length - 1][0];\n  if (pad) {\n    // Must keep this in sync with dygraph-layout _evaluateLimits()\n    var range = right - left;\n    left -= range * pad;\n    right += range * pad;\n  }\n  return [left, right];\n};\n\n/**\n * Returns the lower- and upper-bound y-axis values for each axis. These are\n * the ranges you'll get if you double-click to zoom out or call resetZoom().\n * The return value is an array of [low, high] tuples, one for each y-axis.\n */\nDygraph.prototype.yAxisExtremes = function () {\n  // TODO(danvk): this is pretty inefficient\n  var packed = this.gatherDatasets_(this.rolledSeries_, null);\n  var extremes = packed.extremes;\n\n  var saveAxes = this.axes_;\n  this.computeYAxisRanges_(extremes);\n  var newAxes = this.axes_;\n  this.axes_ = saveAxes;\n  return newAxes.map(function (axis) {\n    return axis.extremeRange;\n  });\n};\n\n/**\n * Returns the currently-visible y-range for an axis. This can be affected by\n * zooming, panning or a call to updateOptions. Axis indices are zero-based. If\n * called with no arguments, returns the range of the first axis.\n * Returns a two-element array: [bottom, top].\n */\nDygraph.prototype.yAxisRange = function (idx) {\n  if (typeof idx == \"undefined\") idx = 0;\n  if (idx < 0 || idx >= this.axes_.length) {\n    return null;\n  }\n  var axis = this.axes_[idx];\n  return [axis.computedValueRange[0], axis.computedValueRange[1]];\n};\n\n/**\n * Returns the currently-visible y-ranges for each axis. This can be affected by\n * zooming, panning, calls to updateOptions, etc.\n * Returns an array of [bottom, top] pairs, one for each y-axis.\n */\nDygraph.prototype.yAxisRanges = function () {\n  var ret = [];\n  for (var i = 0; i < this.axes_.length; i++) {\n    ret.push(this.yAxisRange(i));\n  }\n  return ret;\n};\n\n// TODO(danvk): use these functions throughout dygraphs.\n/**\n * Convert from data coordinates to canvas/div X/Y coordinates.\n * If specified, do this conversion for the coordinate system of a particular\n * axis. Uses the first axis by default.\n * Returns a two-element array: [X, Y]\n *\n * Note: use toDomXCoord instead of toDomCoords(x, null) and use toDomYCoord\n * instead of toDomCoords(null, y, axis).\n */\nDygraph.prototype.toDomCoords = function (x, y, axis) {\n  return [this.toDomXCoord(x), this.toDomYCoord(y, axis)];\n};\n\n/**\n * Convert from data x coordinates to canvas/div X coordinate.\n * If specified, do this conversion for the coordinate system of a particular\n * axis.\n * Returns a single value or null if x is null.\n */\nDygraph.prototype.toDomXCoord = function (x) {\n  if (x === null) {\n    return null;\n  }\n\n  var area = this.plotter_.area;\n  var xRange = this.xAxisRange();\n  return area.x + (x - xRange[0]) / (xRange[1] - xRange[0]) * area.w;\n};\n\n/**\n * Convert from data x coordinates to canvas/div Y coordinate and optional\n * axis. Uses the first axis by default.\n *\n * returns a single value or null if y is null.\n */\nDygraph.prototype.toDomYCoord = function (y, axis) {\n  var pct = this.toPercentYCoord(y, axis);\n\n  if (pct === null) {\n    return null;\n  }\n  var area = this.plotter_.area;\n  return area.y + pct * area.h;\n};\n\n/**\n * Convert from canvas/div coords to data coordinates.\n * If specified, do this conversion for the coordinate system of a particular\n * axis. Uses the first axis by default.\n * Returns a two-element array: [X, Y].\n *\n * Note: use toDataXCoord instead of toDataCoords(x, null) and use toDataYCoord\n * instead of toDataCoords(null, y, axis).\n */\nDygraph.prototype.toDataCoords = function (x, y, axis) {\n  return [this.toDataXCoord(x), this.toDataYCoord(y, axis)];\n};\n\n/**\n * Convert from canvas/div x coordinate to data coordinate.\n *\n * If x is null, this returns null.\n */\nDygraph.prototype.toDataXCoord = function (x) {\n  if (x === null) {\n    return null;\n  }\n\n  var area = this.plotter_.area;\n  var xRange = this.xAxisRange();\n\n  if (!this.attributes_.getForAxis(\"logscale\", 'x')) {\n    return xRange[0] + (x - area.x) / area.w * (xRange[1] - xRange[0]);\n  } else {\n    var pct = (x - area.x) / area.w;\n    return __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"c\" /* logRangeFraction */](xRange[0], xRange[1], pct);\n  }\n};\n\n/**\n * Convert from canvas/div y coord to value.\n *\n * If y is null, this returns null.\n * if axis is null, this uses the first axis.\n */\nDygraph.prototype.toDataYCoord = function (y, axis) {\n  if (y === null) {\n    return null;\n  }\n\n  var area = this.plotter_.area;\n  var yRange = this.yAxisRange(axis);\n\n  if (typeof axis == \"undefined\") axis = 0;\n  if (!this.attributes_.getForAxis(\"logscale\", axis)) {\n    return yRange[0] + (area.y + area.h - y) / area.h * (yRange[1] - yRange[0]);\n  } else {\n    // Computing the inverse of toDomCoord.\n    var pct = (y - area.y) / area.h;\n    // Note reversed yRange, y1 is on top with pct==0.\n    return __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"c\" /* logRangeFraction */](yRange[1], yRange[0], pct);\n  }\n};\n\n/**\n * Converts a y for an axis to a percentage from the top to the\n * bottom of the drawing area.\n *\n * If the coordinate represents a value visible on the canvas, then\n * the value will be between 0 and 1, where 0 is the top of the canvas.\n * However, this method will return values outside the range, as\n * values can fall outside the canvas.\n *\n * If y is null, this returns null.\n * if axis is null, this uses the first axis.\n *\n * @param {number} y The data y-coordinate.\n * @param {number} [axis] The axis number on which the data coordinate lives.\n * @return {number} A fraction in [0, 1] where 0 = the top edge.\n */\nDygraph.prototype.toPercentYCoord = function (y, axis) {\n  if (y === null) {\n    return null;\n  }\n  if (typeof axis == \"undefined\") axis = 0;\n\n  var yRange = this.yAxisRange(axis);\n\n  var pct;\n  var logscale = this.attributes_.getForAxis(\"logscale\", axis);\n  if (logscale) {\n    var logr0 = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"d\" /* log10 */](yRange[0]);\n    var logr1 = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"d\" /* log10 */](yRange[1]);\n    pct = (logr1 - __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"d\" /* log10 */](y)) / (logr1 - logr0);\n  } else {\n    // yRange[1] - y is unit distance from the bottom.\n    // yRange[1] - yRange[0] is the scale of the range.\n    // (yRange[1] - y) / (yRange[1] - yRange[0]) is the % from the bottom.\n    pct = (yRange[1] - y) / (yRange[1] - yRange[0]);\n  }\n  return pct;\n};\n\n/**\n * Converts an x value to a percentage from the left to the right of\n * the drawing area.\n *\n * If the coordinate represents a value visible on the canvas, then\n * the value will be between 0 and 1, where 0 is the left of the canvas.\n * However, this method will return values outside the range, as\n * values can fall outside the canvas.\n *\n * If x is null, this returns null.\n * @param {number} x The data x-coordinate.\n * @return {number} A fraction in [0, 1] where 0 = the left edge.\n */\nDygraph.prototype.toPercentXCoord = function (x) {\n  if (x === null) {\n    return null;\n  }\n\n  var xRange = this.xAxisRange();\n  var pct;\n  var logscale = this.attributes_.getForAxis(\"logscale\", 'x');\n  if (logscale === true) {\n    // logscale can be null so we test for true explicitly.\n    var logr0 = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"d\" /* log10 */](xRange[0]);\n    var logr1 = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"d\" /* log10 */](xRange[1]);\n    pct = (__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"d\" /* log10 */](x) - logr0) / (logr1 - logr0);\n  } else {\n    // x - xRange[0] is unit distance from the left.\n    // xRange[1] - xRange[0] is the scale of the range.\n    // The full expression below is the % from the left.\n    pct = (x - xRange[0]) / (xRange[1] - xRange[0]);\n  }\n  return pct;\n};\n\n/**\n * Returns the number of columns (including the independent variable).\n * @return {number} The number of columns.\n */\nDygraph.prototype.numColumns = function () {\n  if (!this.rawData_) return 0;\n  return this.rawData_[0] ? this.rawData_[0].length : this.attr_(\"labels\").length;\n};\n\n/**\n * Returns the number of rows (excluding any header/label row).\n * @return {number} The number of rows, less any header.\n */\nDygraph.prototype.numRows = function () {\n  if (!this.rawData_) return 0;\n  return this.rawData_.length;\n};\n\n/**\n * Returns the value in the given row and column. If the row and column exceed\n * the bounds on the data, returns null. Also returns null if the value is\n * missing.\n * @param {number} row The row number of the data (0-based). Row 0 is the\n *     first row of data, not a header row.\n * @param {number} col The column number of the data (0-based)\n * @return {number} The value in the specified cell or null if the row/col\n *     were out of range.\n */\nDygraph.prototype.getValue = function (row, col) {\n  if (row < 0 || row > this.rawData_.length) return null;\n  if (col < 0 || col > this.rawData_[row].length) return null;\n\n  return this.rawData_[row][col];\n};\n\n/**\n * Generates interface elements for the Dygraph: a containing div, a div to\n * display the current point, and a textbox to adjust the rolling average\n * period. Also creates the Renderer/Layout elements.\n * @private\n */\nDygraph.prototype.createInterface_ = function () {\n  // Create the all-enclosing graph div\n  var enclosing = this.maindiv_;\n\n  this.graphDiv = document.createElement(\"div\");\n\n  // TODO(danvk): any other styles that are useful to set here?\n  this.graphDiv.style.textAlign = 'left'; // This is a CSS \"reset\"\n  this.graphDiv.style.position = 'relative';\n  enclosing.appendChild(this.graphDiv);\n\n  // Create the canvas for interactive parts of the chart.\n  this.canvas_ = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"e\" /* createCanvas */]();\n  this.canvas_.style.position = \"absolute\";\n\n  // ... and for static parts of the chart.\n  this.hidden_ = this.createPlotKitCanvas_(this.canvas_);\n\n  this.canvas_ctx_ = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"f\" /* getContext */](this.canvas_);\n  this.hidden_ctx_ = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"f\" /* getContext */](this.hidden_);\n\n  this.resizeElements_();\n\n  // The interactive parts of the graph are drawn on top of the chart.\n  this.graphDiv.appendChild(this.hidden_);\n  this.graphDiv.appendChild(this.canvas_);\n  this.mouseEventElement_ = this.createMouseEventElement_();\n\n  // Create the grapher\n  this.layout_ = new __WEBPACK_IMPORTED_MODULE_0__dygraph_layout__[\"a\" /* default */](this);\n\n  var dygraph = this;\n\n  this.mouseMoveHandler_ = function (e) {\n    dygraph.mouseMove_(e);\n  };\n\n  this.mouseOutHandler_ = function (e) {\n    // The mouse has left the chart if:\n    // 1. e.target is inside the chart\n    // 2. e.relatedTarget is outside the chart\n    var target = e.target || e.fromElement;\n    var relatedTarget = e.relatedTarget || e.toElement;\n    if (__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"g\" /* isNodeContainedBy */](target, dygraph.graphDiv) && !__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"g\" /* isNodeContainedBy */](relatedTarget, dygraph.graphDiv)) {\n      dygraph.mouseOut_(e);\n    }\n  };\n\n  this.addAndTrackEvent(window, 'mouseout', this.mouseOutHandler_);\n  this.addAndTrackEvent(this.mouseEventElement_, 'mousemove', this.mouseMoveHandler_);\n\n  // Don't recreate and register the resize handler on subsequent calls.\n  // This happens when the graph is resized.\n  if (!this.resizeHandler_) {\n    this.resizeHandler_ = function (e) {\n      dygraph.resize();\n    };\n\n    // Update when the window is resized.\n    // TODO(danvk): drop frames depending on complexity of the chart.\n    this.addAndTrackEvent(window, 'resize', this.resizeHandler_);\n  }\n};\n\nDygraph.prototype.resizeElements_ = function () {\n  this.graphDiv.style.width = this.width_ + \"px\";\n  this.graphDiv.style.height = this.height_ + \"px\";\n\n  var pixelRatioOption = this.getNumericOption('pixelRatio');\n\n  var canvasScale = pixelRatioOption || __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"h\" /* getContextPixelRatio */](this.canvas_ctx_);\n  this.canvas_.width = this.width_ * canvasScale;\n  this.canvas_.height = this.height_ * canvasScale;\n  this.canvas_.style.width = this.width_ + \"px\"; // for IE\n  this.canvas_.style.height = this.height_ + \"px\"; // for IE\n  if (canvasScale !== 1) {\n    this.canvas_ctx_.scale(canvasScale, canvasScale);\n  }\n\n  var hiddenScale = pixelRatioOption || __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"h\" /* getContextPixelRatio */](this.hidden_ctx_);\n  this.hidden_.width = this.width_ * hiddenScale;\n  this.hidden_.height = this.height_ * hiddenScale;\n  this.hidden_.style.width = this.width_ + \"px\"; // for IE\n  this.hidden_.style.height = this.height_ + \"px\"; // for IE\n  if (hiddenScale !== 1) {\n    this.hidden_ctx_.scale(hiddenScale, hiddenScale);\n  }\n};\n\n/**\n * Detach DOM elements in the dygraph and null out all data references.\n * Calling this when you're done with a dygraph can dramatically reduce memory\n * usage. See, e.g., the tests/perf.html example.\n */\nDygraph.prototype.destroy = function () {\n  this.canvas_ctx_.restore();\n  this.hidden_ctx_.restore();\n\n  // Destroy any plugins, in the reverse order that they were registered.\n  for (var i = this.plugins_.length - 1; i >= 0; i--) {\n    var p = this.plugins_.pop();\n    if (p.plugin.destroy) p.plugin.destroy();\n  }\n\n  var removeRecursive = function removeRecursive(node) {\n    while (node.hasChildNodes()) {\n      removeRecursive(node.firstChild);\n      node.removeChild(node.firstChild);\n    }\n  };\n\n  this.removeTrackedEvents_();\n\n  // remove mouse event handlers (This may not be necessary anymore)\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"i\" /* removeEvent */](window, 'mouseout', this.mouseOutHandler_);\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"i\" /* removeEvent */](this.mouseEventElement_, 'mousemove', this.mouseMoveHandler_);\n\n  // remove window handlers\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"i\" /* removeEvent */](window, 'resize', this.resizeHandler_);\n  this.resizeHandler_ = null;\n\n  removeRecursive(this.maindiv_);\n\n  var nullOut = function nullOut(obj) {\n    for (var n in obj) {\n      if (_typeof(obj[n]) === 'object') {\n        obj[n] = null;\n      }\n    }\n  };\n  // These may not all be necessary, but it can't hurt...\n  nullOut(this.layout_);\n  nullOut(this.plotter_);\n  nullOut(this);\n};\n\n/**\n * Creates the canvas on which the chart will be drawn. Only the Renderer ever\n * draws on this particular canvas. All Dygraph work (i.e. drawing hover dots\n * or the zoom rectangles) is done on this.canvas_.\n * @param {Object} canvas The Dygraph canvas over which to overlay the plot\n * @return {Object} The newly-created canvas\n * @private\n */\nDygraph.prototype.createPlotKitCanvas_ = function (canvas) {\n  var h = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"e\" /* createCanvas */]();\n  h.style.position = \"absolute\";\n  // TODO(danvk): h should be offset from canvas. canvas needs to include\n  // some extra area to make it easier to zoom in on the far left and far\n  // right. h needs to be precisely the plot area, so that clipping occurs.\n  h.style.top = canvas.style.top;\n  h.style.left = canvas.style.left;\n  h.width = this.width_;\n  h.height = this.height_;\n  h.style.width = this.width_ + \"px\"; // for IE\n  h.style.height = this.height_ + \"px\"; // for IE\n  return h;\n};\n\n/**\n * Creates an overlay element used to handle mouse events.\n * @return {Object} The mouse event element.\n * @private\n */\nDygraph.prototype.createMouseEventElement_ = function () {\n  return this.canvas_;\n};\n\n/**\n * Generate a set of distinct colors for the data series. This is done with a\n * color wheel. Saturation/Value are customizable, and the hue is\n * equally-spaced around the color wheel. If a custom set of colors is\n * specified, that is used instead.\n * @private\n */\nDygraph.prototype.setColors_ = function () {\n  var labels = this.getLabels();\n  var num = labels.length - 1;\n  this.colors_ = [];\n  this.colorsMap_ = {};\n\n  // These are used for when no custom colors are specified.\n  var sat = this.getNumericOption('colorSaturation') || 1.0;\n  var val = this.getNumericOption('colorValue') || 0.5;\n  var half = Math.ceil(num / 2);\n\n  var colors = this.getOption('colors');\n  var visibility = this.visibility();\n  for (var i = 0; i < num; i++) {\n    if (!visibility[i]) {\n      continue;\n    }\n    var label = labels[i + 1];\n    var colorStr = this.attributes_.getForSeries('color', label);\n    if (!colorStr) {\n      if (colors) {\n        colorStr = colors[i % colors.length];\n      } else {\n        // alternate colors for high contrast.\n        var idx = i % 2 ? half + (i + 1) / 2 : Math.ceil((i + 1) / 2);\n        var hue = 1.0 * idx / (1 + num);\n        colorStr = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"j\" /* hsvToRGB */](hue, sat, val);\n      }\n    }\n    this.colors_.push(colorStr);\n    this.colorsMap_[label] = colorStr;\n  }\n};\n\n/**\n * Return the list of colors. This is either the list of colors passed in the\n * attributes or the autogenerated list of rgb(r,g,b) strings.\n * This does not return colors for invisible series.\n * @return {Array.<string>} The list of colors.\n */\nDygraph.prototype.getColors = function () {\n  return this.colors_;\n};\n\n/**\n * Returns a few attributes of a series, i.e. its color, its visibility, which\n * axis it's assigned to, and its column in the original data.\n * Returns null if the series does not exist.\n * Otherwise, returns an object with column, visibility, color and axis properties.\n * The \"axis\" property will be set to 1 for y1 and 2 for y2.\n * The \"column\" property can be fed back into getValue(row, column) to get\n * values for this series.\n */\nDygraph.prototype.getPropertiesForSeries = function (series_name) {\n  var idx = -1;\n  var labels = this.getLabels();\n  for (var i = 1; i < labels.length; i++) {\n    if (labels[i] == series_name) {\n      idx = i;\n      break;\n    }\n  }\n  if (idx == -1) return null;\n\n  return {\n    name: series_name,\n    column: idx,\n    visible: this.visibility()[idx - 1],\n    color: this.colorsMap_[series_name],\n    axis: 1 + this.attributes_.axisForSeries(series_name)\n  };\n};\n\n/**\n * Create the text box to adjust the averaging period\n * @private\n */\nDygraph.prototype.createRollInterface_ = function () {\n  var _this = this;\n\n  // Create a roller if one doesn't exist already.\n  var roller = this.roller_;\n  if (!roller) {\n    this.roller_ = roller = document.createElement(\"input\");\n    roller.type = \"text\";\n    roller.style.display = \"none\";\n    roller.className = 'dygraph-roller';\n    this.graphDiv.appendChild(roller);\n  }\n\n  var display = this.getBooleanOption('showRoller') ? 'block' : 'none';\n\n  var area = this.getArea();\n  var textAttr = {\n    \"top\": area.y + area.h - 25 + \"px\",\n    \"left\": area.x + 1 + \"px\",\n    \"display\": display\n  };\n  roller.size = \"2\";\n  roller.value = this.rollPeriod_;\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"a\" /* update */](roller.style, textAttr);\n\n  roller.onchange = function () {\n    return _this.adjustRoll(roller.value);\n  };\n};\n\n/**\n * Set up all the mouse handlers needed to capture dragging behavior for zoom\n * events.\n * @private\n */\nDygraph.prototype.createDragInterface_ = function () {\n  var context = {\n    // Tracks whether the mouse is down right now\n    isZooming: false,\n    isPanning: false, // is this drag part of a pan?\n    is2DPan: false, // if so, is that pan 1- or 2-dimensional?\n    dragStartX: null, // pixel coordinates\n    dragStartY: null, // pixel coordinates\n    dragEndX: null, // pixel coordinates\n    dragEndY: null, // pixel coordinates\n    dragDirection: null,\n    prevEndX: null, // pixel coordinates\n    prevEndY: null, // pixel coordinates\n    prevDragDirection: null,\n    cancelNextDblclick: false, // see comment in dygraph-interaction-model.js\n\n    // The value on the left side of the graph when a pan operation starts.\n    initialLeftmostDate: null,\n\n    // The number of units each pixel spans. (This won't be valid for log\n    // scales)\n    xUnitsPerPixel: null,\n\n    // TODO(danvk): update this comment\n    // The range in second/value units that the viewport encompasses during a\n    // panning operation.\n    dateRange: null,\n\n    // Top-left corner of the canvas, in DOM coords\n    // TODO(konigsberg): Rename topLeftCanvasX, topLeftCanvasY.\n    px: 0,\n    py: 0,\n\n    // Values for use with panEdgeFraction, which limit how far outside the\n    // graph's data boundaries it can be panned.\n    boundedDates: null, // [minDate, maxDate]\n    boundedValues: null, // [[minValue, maxValue] ...]\n\n    // We cover iframes during mouse interactions. See comments in\n    // dygraph-utils.js for more info on why this is a good idea.\n    tarp: new __WEBPACK_IMPORTED_MODULE_8__iframe_tarp__[\"a\" /* default */](),\n\n    // contextB is the same thing as this context object but renamed.\n    initializeMouseDown: function initializeMouseDown(event, g, contextB) {\n      // prevents mouse drags from selecting page text.\n      if (event.preventDefault) {\n        event.preventDefault(); // Firefox, Chrome, etc.\n      } else {\n        event.returnValue = false; // IE\n        event.cancelBubble = true;\n      }\n\n      var canvasPos = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"k\" /* findPos */](g.canvas_);\n      contextB.px = canvasPos.x;\n      contextB.py = canvasPos.y;\n      contextB.dragStartX = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"l\" /* dragGetX_ */](event, contextB);\n      contextB.dragStartY = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"m\" /* dragGetY_ */](event, contextB);\n      contextB.cancelNextDblclick = false;\n      contextB.tarp.cover();\n    },\n    destroy: function destroy() {\n      var context = this;\n      if (context.isZooming || context.isPanning) {\n        context.isZooming = false;\n        context.dragStartX = null;\n        context.dragStartY = null;\n      }\n\n      if (context.isPanning) {\n        context.isPanning = false;\n        context.draggingDate = null;\n        context.dateRange = null;\n        for (var i = 0; i < self.axes_.length; i++) {\n          delete self.axes_[i].draggingValue;\n          delete self.axes_[i].dragValueRange;\n        }\n      }\n\n      context.tarp.uncover();\n    }\n  };\n\n  var interactionModel = this.getOption(\"interactionModel\");\n\n  // Self is the graph.\n  var self = this;\n\n  // Function that binds the graph and context to the handler.\n  var bindHandler = function bindHandler(handler) {\n    return function (event) {\n      handler(event, self, context);\n    };\n  };\n\n  for (var eventName in interactionModel) {\n    if (!interactionModel.hasOwnProperty(eventName)) continue;\n    this.addAndTrackEvent(this.mouseEventElement_, eventName, bindHandler(interactionModel[eventName]));\n  }\n\n  // If the user releases the mouse button during a drag, but not over the\n  // canvas, then it doesn't count as a zooming action.\n  if (!interactionModel.willDestroyContextMyself) {\n    var mouseUpHandler = function mouseUpHandler(event) {\n      context.destroy();\n    };\n\n    this.addAndTrackEvent(document, 'mouseup', mouseUpHandler);\n  }\n};\n\n/**\n * Draw a gray zoom rectangle over the desired area of the canvas. Also clears\n * up any previous zoom rectangles that were drawn. This could be optimized to\n * avoid extra redrawing, but it's tricky to avoid interactions with the status\n * dots.\n *\n * @param {number} direction the direction of the zoom rectangle. Acceptable\n *     values are utils.HORIZONTAL and utils.VERTICAL.\n * @param {number} startX The X position where the drag started, in canvas\n *     coordinates.\n * @param {number} endX The current X position of the drag, in canvas coords.\n * @param {number} startY The Y position where the drag started, in canvas\n *     coordinates.\n * @param {number} endY The current Y position of the drag, in canvas coords.\n * @param {number} prevDirection the value of direction on the previous call to\n *     this function. Used to avoid excess redrawing\n * @param {number} prevEndX The value of endX on the previous call to this\n *     function. Used to avoid excess redrawing\n * @param {number} prevEndY The value of endY on the previous call to this\n *     function. Used to avoid excess redrawing\n * @private\n */\nDygraph.prototype.drawZoomRect_ = function (direction, startX, endX, startY, endY, prevDirection, prevEndX, prevEndY) {\n  var ctx = this.canvas_ctx_;\n\n  // Clean up from the previous rect if necessary\n  if (prevDirection == __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"n\" /* HORIZONTAL */]) {\n    ctx.clearRect(Math.min(startX, prevEndX), this.layout_.getPlotArea().y, Math.abs(startX - prevEndX), this.layout_.getPlotArea().h);\n  } else if (prevDirection == __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"o\" /* VERTICAL */]) {\n    ctx.clearRect(this.layout_.getPlotArea().x, Math.min(startY, prevEndY), this.layout_.getPlotArea().w, Math.abs(startY - prevEndY));\n  }\n\n  // Draw a light-grey rectangle to show the new viewing area\n  if (direction == __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"n\" /* HORIZONTAL */]) {\n    if (endX && startX) {\n      ctx.fillStyle = \"rgba(128,128,128,0.33)\";\n      ctx.fillRect(Math.min(startX, endX), this.layout_.getPlotArea().y, Math.abs(endX - startX), this.layout_.getPlotArea().h);\n    }\n  } else if (direction == __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"o\" /* VERTICAL */]) {\n    if (endY && startY) {\n      ctx.fillStyle = \"rgba(128,128,128,0.33)\";\n      ctx.fillRect(this.layout_.getPlotArea().x, Math.min(startY, endY), this.layout_.getPlotArea().w, Math.abs(endY - startY));\n    }\n  }\n};\n\n/**\n * Clear the zoom rectangle (and perform no zoom).\n * @private\n */\nDygraph.prototype.clearZoomRect_ = function () {\n  this.currentZoomRectArgs_ = null;\n  this.canvas_ctx_.clearRect(0, 0, this.width_, this.height_);\n};\n\n/**\n * Zoom to something containing [lowX, highX]. These are pixel coordinates in\n * the canvas. The exact zoom window may be slightly larger if there are no data\n * points near lowX or highX. Don't confuse this function with doZoomXDates,\n * which accepts dates that match the raw data. This function redraws the graph.\n *\n * @param {number} lowX The leftmost pixel value that should be visible.\n * @param {number} highX The rightmost pixel value that should be visible.\n * @private\n */\nDygraph.prototype.doZoomX_ = function (lowX, highX) {\n  this.currentZoomRectArgs_ = null;\n  // Find the earliest and latest dates contained in this canvasx range.\n  // Convert the call to date ranges of the raw data.\n  var minDate = this.toDataXCoord(lowX);\n  var maxDate = this.toDataXCoord(highX);\n  this.doZoomXDates_(minDate, maxDate);\n};\n\n/**\n * Zoom to something containing [minDate, maxDate] values. Don't confuse this\n * method with doZoomX which accepts pixel coordinates. This function redraws\n * the graph.\n *\n * @param {number} minDate The minimum date that should be visible.\n * @param {number} maxDate The maximum date that should be visible.\n * @private\n */\nDygraph.prototype.doZoomXDates_ = function (minDate, maxDate) {\n  var _this2 = this;\n\n  // TODO(danvk): when xAxisRange is null (i.e. \"fit to data\", the animation\n  // can produce strange effects. Rather than the x-axis transitioning slowly\n  // between values, it can jerk around.)\n  var old_window = this.xAxisRange();\n  var new_window = [minDate, maxDate];\n  var zoomCallback = this.getFunctionOption('zoomCallback');\n  this.doAnimatedZoom(old_window, new_window, null, null, function () {\n    if (zoomCallback) {\n      zoomCallback.call(_this2, minDate, maxDate, _this2.yAxisRanges());\n    }\n  });\n};\n\n/**\n * Zoom to something containing [lowY, highY]. These are pixel coordinates in\n * the canvas. This function redraws the graph.\n *\n * @param {number} lowY The topmost pixel value that should be visible.\n * @param {number} highY The lowest pixel value that should be visible.\n * @private\n */\nDygraph.prototype.doZoomY_ = function (lowY, highY) {\n  var _this3 = this;\n\n  this.currentZoomRectArgs_ = null;\n  // Find the highest and lowest values in pixel range for each axis.\n  // Note that lowY (in pixels) corresponds to the max Value (in data coords).\n  // This is because pixels increase as you go down on the screen, whereas data\n  // coordinates increase as you go up the screen.\n  var oldValueRanges = this.yAxisRanges();\n  var newValueRanges = [];\n  for (var i = 0; i < this.axes_.length; i++) {\n    var hi = this.toDataYCoord(lowY, i);\n    var low = this.toDataYCoord(highY, i);\n    newValueRanges.push([low, hi]);\n  }\n\n  var zoomCallback = this.getFunctionOption('zoomCallback');\n  this.doAnimatedZoom(null, null, oldValueRanges, newValueRanges, function () {\n    if (zoomCallback) {\n      var _xAxisRange = _this3.xAxisRange(),\n          _xAxisRange2 = _slicedToArray(_xAxisRange, 2),\n          minX = _xAxisRange2[0],\n          maxX = _xAxisRange2[1];\n\n      zoomCallback.call(_this3, minX, maxX, _this3.yAxisRanges());\n    }\n  });\n};\n\n/**\n * Transition function to use in animations. Returns values between 0.0\n * (totally old values) and 1.0 (totally new values) for each frame.\n * @private\n */\nDygraph.zoomAnimationFunction = function (frame, numFrames) {\n  var k = 1.5;\n  return (1.0 - Math.pow(k, -frame)) / (1.0 - Math.pow(k, -numFrames));\n};\n\n/**\n * Reset the zoom to the original view coordinates. This is the same as\n * double-clicking on the graph.\n */\nDygraph.prototype.resetZoom = function () {\n  var _this4 = this;\n\n  var dirtyX = this.isZoomed('x');\n  var dirtyY = this.isZoomed('y');\n  var dirty = dirtyX || dirtyY;\n\n  // Clear any selection, since it's likely to be drawn in the wrong place.\n  this.clearSelection();\n\n  if (!dirty) return;\n\n  // Calculate extremes to avoid lack of padding on reset.\n\n  var _xAxisExtremes = this.xAxisExtremes(),\n      _xAxisExtremes2 = _slicedToArray(_xAxisExtremes, 2),\n      minDate = _xAxisExtremes2[0],\n      maxDate = _xAxisExtremes2[1];\n\n  var animatedZooms = this.getBooleanOption('animatedZooms');\n  var zoomCallback = this.getFunctionOption('zoomCallback');\n\n  // TODO(danvk): merge this block w/ the code below.\n  // TODO(danvk): factor out a generic, public zoomTo method.\n  if (!animatedZooms) {\n    this.dateWindow_ = null;\n    this.axes_.forEach(function (axis) {\n      if (axis.valueRange) delete axis.valueRange;\n    });\n\n    this.drawGraph_();\n    if (zoomCallback) {\n      zoomCallback.call(this, minDate, maxDate, this.yAxisRanges());\n    }\n    return;\n  }\n\n  var oldWindow = null,\n      newWindow = null,\n      oldValueRanges = null,\n      newValueRanges = null;\n  if (dirtyX) {\n    oldWindow = this.xAxisRange();\n    newWindow = [minDate, maxDate];\n  }\n\n  if (dirtyY) {\n    oldValueRanges = this.yAxisRanges();\n    newValueRanges = this.yAxisExtremes();\n  }\n\n  this.doAnimatedZoom(oldWindow, newWindow, oldValueRanges, newValueRanges, function () {\n    _this4.dateWindow_ = null;\n    _this4.axes_.forEach(function (axis) {\n      if (axis.valueRange) delete axis.valueRange;\n    });\n    if (zoomCallback) {\n      zoomCallback.call(_this4, minDate, maxDate, _this4.yAxisRanges());\n    }\n  });\n};\n\n/**\n * Combined animation logic for all zoom functions.\n * either the x parameters or y parameters may be null.\n * @private\n */\nDygraph.prototype.doAnimatedZoom = function (oldXRange, newXRange, oldYRanges, newYRanges, callback) {\n  var _this5 = this;\n\n  var steps = this.getBooleanOption(\"animatedZooms\") ? Dygraph.ANIMATION_STEPS : 1;\n\n  var windows = [];\n  var valueRanges = [];\n  var step, frac;\n\n  if (oldXRange !== null && newXRange !== null) {\n    for (step = 1; step <= steps; step++) {\n      frac = Dygraph.zoomAnimationFunction(step, steps);\n      windows[step - 1] = [oldXRange[0] * (1 - frac) + frac * newXRange[0], oldXRange[1] * (1 - frac) + frac * newXRange[1]];\n    }\n  }\n\n  if (oldYRanges !== null && newYRanges !== null) {\n    for (step = 1; step <= steps; step++) {\n      frac = Dygraph.zoomAnimationFunction(step, steps);\n      var thisRange = [];\n      for (var j = 0; j < this.axes_.length; j++) {\n        thisRange.push([oldYRanges[j][0] * (1 - frac) + frac * newYRanges[j][0], oldYRanges[j][1] * (1 - frac) + frac * newYRanges[j][1]]);\n      }\n      valueRanges[step - 1] = thisRange;\n    }\n  }\n\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"p\" /* repeatAndCleanup */](function (step) {\n    if (valueRanges.length) {\n      for (var i = 0; i < _this5.axes_.length; i++) {\n        var w = valueRanges[step][i];\n        _this5.axes_[i].valueRange = [w[0], w[1]];\n      }\n    }\n    if (windows.length) {\n      _this5.dateWindow_ = windows[step];\n    }\n    _this5.drawGraph_();\n  }, steps, Dygraph.ANIMATION_DURATION / steps, callback);\n};\n\n/**\n * Get the current graph's area object.\n *\n * Returns: {x, y, w, h}\n */\nDygraph.prototype.getArea = function () {\n  return this.plotter_.area;\n};\n\n/**\n * Convert a mouse event to DOM coordinates relative to the graph origin.\n *\n * Returns a two-element array: [X, Y].\n */\nDygraph.prototype.eventToDomCoords = function (event) {\n  if (event.offsetX && event.offsetY) {\n    return [event.offsetX, event.offsetY];\n  } else {\n    var eventElementPos = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"k\" /* findPos */](this.mouseEventElement_);\n    var canvasx = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"q\" /* pageX */](event) - eventElementPos.x;\n    var canvasy = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"r\" /* pageY */](event) - eventElementPos.y;\n    return [canvasx, canvasy];\n  }\n};\n\n/**\n * Given a canvas X coordinate, find the closest row.\n * @param {number} domX graph-relative DOM X coordinate\n * Returns {number} row number.\n * @private\n */\nDygraph.prototype.findClosestRow = function (domX) {\n  var minDistX = Infinity;\n  var closestRow = -1;\n  var sets = this.layout_.points;\n  for (var i = 0; i < sets.length; i++) {\n    var points = sets[i];\n    var len = points.length;\n    for (var j = 0; j < len; j++) {\n      var point = points[j];\n      if (!__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"s\" /* isValidPoint */](point, true)) continue;\n      var dist = Math.abs(point.canvasx - domX);\n      if (dist < minDistX) {\n        minDistX = dist;\n        closestRow = point.idx;\n      }\n    }\n  }\n\n  return closestRow;\n};\n\n/**\n * Given canvas X,Y coordinates, find the closest point.\n *\n * This finds the individual data point across all visible series\n * that's closest to the supplied DOM coordinates using the standard\n * Euclidean X,Y distance.\n *\n * @param {number} domX graph-relative DOM X coordinate\n * @param {number} domY graph-relative DOM Y coordinate\n * Returns: {row, seriesName, point}\n * @private\n */\nDygraph.prototype.findClosestPoint = function (domX, domY) {\n  var minDist = Infinity;\n  var dist, dx, dy, point, closestPoint, closestSeries, closestRow;\n  for (var setIdx = this.layout_.points.length - 1; setIdx >= 0; --setIdx) {\n    var points = this.layout_.points[setIdx];\n    for (var i = 0; i < points.length; ++i) {\n      point = points[i];\n      if (!__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"s\" /* isValidPoint */](point)) continue;\n      dx = point.canvasx - domX;\n      dy = point.canvasy - domY;\n      dist = dx * dx + dy * dy;\n      if (dist < minDist) {\n        minDist = dist;\n        closestPoint = point;\n        closestSeries = setIdx;\n        closestRow = point.idx;\n      }\n    }\n  }\n  var name = this.layout_.setNames[closestSeries];\n  return {\n    row: closestRow,\n    seriesName: name,\n    point: closestPoint\n  };\n};\n\n/**\n * Given canvas X,Y coordinates, find the touched area in a stacked graph.\n *\n * This first finds the X data point closest to the supplied DOM X coordinate,\n * then finds the series which puts the Y coordinate on top of its filled area,\n * using linear interpolation between adjacent point pairs.\n *\n * @param {number} domX graph-relative DOM X coordinate\n * @param {number} domY graph-relative DOM Y coordinate\n * Returns: {row, seriesName, point}\n * @private\n */\nDygraph.prototype.findStackedPoint = function (domX, domY) {\n  var row = this.findClosestRow(domX);\n  var closestPoint, closestSeries;\n  for (var setIdx = 0; setIdx < this.layout_.points.length; ++setIdx) {\n    var boundary = this.getLeftBoundary_(setIdx);\n    var rowIdx = row - boundary;\n    var points = this.layout_.points[setIdx];\n    if (rowIdx >= points.length) continue;\n    var p1 = points[rowIdx];\n    if (!__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"s\" /* isValidPoint */](p1)) continue;\n    var py = p1.canvasy;\n    if (domX > p1.canvasx && rowIdx + 1 < points.length) {\n      // interpolate series Y value using next point\n      var p2 = points[rowIdx + 1];\n      if (__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"s\" /* isValidPoint */](p2)) {\n        var dx = p2.canvasx - p1.canvasx;\n        if (dx > 0) {\n          var r = (domX - p1.canvasx) / dx;\n          py += r * (p2.canvasy - p1.canvasy);\n        }\n      }\n    } else if (domX < p1.canvasx && rowIdx > 0) {\n      // interpolate series Y value using previous point\n      var p0 = points[rowIdx - 1];\n      if (__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"s\" /* isValidPoint */](p0)) {\n        var dx = p1.canvasx - p0.canvasx;\n        if (dx > 0) {\n          var r = (p1.canvasx - domX) / dx;\n          py += r * (p0.canvasy - p1.canvasy);\n        }\n      }\n    }\n    // Stop if the point (domX, py) is above this series' upper edge\n    if (setIdx === 0 || py < domY) {\n      closestPoint = p1;\n      closestSeries = setIdx;\n    }\n  }\n  var name = this.layout_.setNames[closestSeries];\n  return {\n    row: row,\n    seriesName: name,\n    point: closestPoint\n  };\n};\n\n/**\n * When the mouse moves in the canvas, display information about a nearby data\n * point and draw dots over those points in the data series. This function\n * takes care of cleanup of previously-drawn dots.\n * @param {Object} event The mousemove event from the browser.\n * @private\n */\nDygraph.prototype.mouseMove_ = function (event) {\n  // This prevents JS errors when mousing over the canvas before data loads.\n  var points = this.layout_.points;\n  if (points === undefined || points === null) return;\n\n  var canvasCoords = this.eventToDomCoords(event);\n  var canvasx = canvasCoords[0];\n  var canvasy = canvasCoords[1];\n\n  var highlightSeriesOpts = this.getOption(\"highlightSeriesOpts\");\n  var selectionChanged = false;\n  if (highlightSeriesOpts && !this.isSeriesLocked()) {\n    var closest;\n    if (this.getBooleanOption(\"stackedGraph\")) {\n      closest = this.findStackedPoint(canvasx, canvasy);\n    } else {\n      closest = this.findClosestPoint(canvasx, canvasy);\n    }\n    selectionChanged = this.setSelection(closest.row, closest.seriesName);\n  } else {\n    var idx = this.findClosestRow(canvasx);\n    selectionChanged = this.setSelection(idx);\n  }\n\n  var callback = this.getFunctionOption(\"highlightCallback\");\n  if (callback && selectionChanged) {\n    callback.call(this, event, this.lastx_, this.selPoints_, this.lastRow_, this.highlightSet_);\n  }\n};\n\n/**\n * Fetch left offset from the specified set index or if not passed, the\n * first defined boundaryIds record (see bug #236).\n * @private\n */\nDygraph.prototype.getLeftBoundary_ = function (setIdx) {\n  if (this.boundaryIds_[setIdx]) {\n    return this.boundaryIds_[setIdx][0];\n  } else {\n    for (var i = 0; i < this.boundaryIds_.length; i++) {\n      if (this.boundaryIds_[i] !== undefined) {\n        return this.boundaryIds_[i][0];\n      }\n    }\n    return 0;\n  }\n};\n\nDygraph.prototype.animateSelection_ = function (direction) {\n  var totalSteps = 10;\n  var millis = 30;\n  if (this.fadeLevel === undefined) this.fadeLevel = 0;\n  if (this.animateId === undefined) this.animateId = 0;\n  var start = this.fadeLevel;\n  var steps = direction < 0 ? start : totalSteps - start;\n  if (steps <= 0) {\n    if (this.fadeLevel) {\n      this.updateSelection_(1.0);\n    }\n    return;\n  }\n\n  var thisId = ++this.animateId;\n  var that = this;\n  var cleanupIfClearing = function cleanupIfClearing() {\n    // if we haven't reached fadeLevel 0 in the max frame time,\n    // ensure that the clear happens and just go to 0\n    if (that.fadeLevel !== 0 && direction < 0) {\n      that.fadeLevel = 0;\n      that.clearSelection();\n    }\n  };\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"p\" /* repeatAndCleanup */](function (n) {\n    // ignore simultaneous animations\n    if (that.animateId != thisId) return;\n\n    that.fadeLevel += direction;\n    if (that.fadeLevel === 0) {\n      that.clearSelection();\n    } else {\n      that.updateSelection_(that.fadeLevel / totalSteps);\n    }\n  }, steps, millis, cleanupIfClearing);\n};\n\n/**\n * Draw dots over the selectied points in the data series. This function\n * takes care of cleanup of previously-drawn dots.\n * @private\n */\nDygraph.prototype.updateSelection_ = function (opt_animFraction) {\n  /*var defaultPrevented = */\n  this.cascadeEvents_('select', {\n    selectedRow: this.lastRow_ === -1 ? undefined : this.lastRow_,\n    selectedX: this.lastx_ === -1 ? undefined : this.lastx_,\n    selectedPoints: this.selPoints_\n  });\n  // TODO(danvk): use defaultPrevented here?\n\n  // Clear the previously drawn vertical, if there is one\n  var i;\n  var ctx = this.canvas_ctx_;\n  if (this.getOption('highlightSeriesOpts')) {\n    ctx.clearRect(0, 0, this.width_, this.height_);\n    var alpha = 1.0 - this.getNumericOption('highlightSeriesBackgroundAlpha');\n    var backgroundColor = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"t\" /* toRGB_ */](this.getOption('highlightSeriesBackgroundColor'));\n\n    if (alpha) {\n      // Activating background fade includes an animation effect for a gradual\n      // fade. TODO(klausw): make this independently configurable if it causes\n      // issues? Use a shared preference to control animations?\n      var animateBackgroundFade = true;\n      if (animateBackgroundFade) {\n        if (opt_animFraction === undefined) {\n          // start a new animation\n          this.animateSelection_(1);\n          return;\n        }\n        alpha *= opt_animFraction;\n      }\n      ctx.fillStyle = 'rgba(' + backgroundColor.r + ',' + backgroundColor.g + ',' + backgroundColor.b + ',' + alpha + ')';\n      ctx.fillRect(0, 0, this.width_, this.height_);\n    }\n\n    // Redraw only the highlighted series in the interactive canvas (not the\n    // static plot canvas, which is where series are usually drawn).\n    this.plotter_._renderLineChart(this.highlightSet_, ctx);\n  } else if (this.previousVerticalX_ >= 0) {\n    // Determine the maximum highlight circle size.\n    var maxCircleSize = 0;\n    var labels = this.attr_('labels');\n    for (i = 1; i < labels.length; i++) {\n      var r = this.getNumericOption('highlightCircleSize', labels[i]);\n      if (r > maxCircleSize) maxCircleSize = r;\n    }\n    var px = this.previousVerticalX_;\n    ctx.clearRect(px - maxCircleSize - 1, 0, 2 * maxCircleSize + 2, this.height_);\n  }\n\n  if (this.selPoints_.length > 0) {\n    // Draw colored circles over the center of each selected point\n    var canvasx = this.selPoints_[0].canvasx;\n    ctx.save();\n    for (i = 0; i < this.selPoints_.length; i++) {\n      var pt = this.selPoints_[i];\n      if (isNaN(pt.canvasy)) continue;\n\n      var circleSize = this.getNumericOption('highlightCircleSize', pt.name);\n      var callback = this.getFunctionOption(\"drawHighlightPointCallback\", pt.name);\n      var color = this.plotter_.colors[pt.name];\n      if (!callback) {\n        callback = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"u\" /* Circles */].DEFAULT;\n      }\n      ctx.lineWidth = this.getNumericOption('strokeWidth', pt.name);\n      ctx.strokeStyle = color;\n      ctx.fillStyle = color;\n      callback.call(this, this, pt.name, ctx, canvasx, pt.canvasy, color, circleSize, pt.idx);\n    }\n    ctx.restore();\n\n    this.previousVerticalX_ = canvasx;\n  }\n};\n\n/**\n * Manually set the selected points and display information about them in the\n * legend. The selection can be cleared using clearSelection() and queried\n * using getSelection().\n *\n * To set a selected series but not a selected point, call setSelection with\n * row=false and the selected series name.\n *\n * @param {number} row Row number that should be highlighted (i.e. appear with\n * hover dots on the chart).\n * @param {seriesName} optional series name to highlight that series with the\n * the highlightSeriesOpts setting.\n * @param { locked } optional If true, keep seriesName selected when mousing\n * over the graph, disabling closest-series highlighting. Call clearSelection()\n * to unlock it.\n */\nDygraph.prototype.setSelection = function (row, opt_seriesName, opt_locked) {\n  // Extract the points we've selected\n  this.selPoints_ = [];\n\n  var changed = false;\n  if (row !== false && row >= 0) {\n    if (row != this.lastRow_) changed = true;\n    this.lastRow_ = row;\n    for (var setIdx = 0; setIdx < this.layout_.points.length; ++setIdx) {\n      var points = this.layout_.points[setIdx];\n      // Check if the point at the appropriate index is the point we're looking\n      // for.  If it is, just use it, otherwise search the array for a point\n      // in the proper place.\n      var setRow = row - this.getLeftBoundary_(setIdx);\n      if (setRow >= 0 && setRow < points.length && points[setRow].idx == row) {\n        var point = points[setRow];\n        if (point.yval !== null) this.selPoints_.push(point);\n      } else {\n        for (var pointIdx = 0; pointIdx < points.length; ++pointIdx) {\n          var point = points[pointIdx];\n          if (point.idx == row) {\n            if (point.yval !== null) {\n              this.selPoints_.push(point);\n            }\n            break;\n          }\n        }\n      }\n    }\n  } else {\n    if (this.lastRow_ >= 0) changed = true;\n    this.lastRow_ = -1;\n  }\n\n  if (this.selPoints_.length) {\n    this.lastx_ = this.selPoints_[0].xval;\n  } else {\n    this.lastx_ = -1;\n  }\n\n  if (opt_seriesName !== undefined) {\n    if (this.highlightSet_ !== opt_seriesName) changed = true;\n    this.highlightSet_ = opt_seriesName;\n  }\n\n  if (opt_locked !== undefined) {\n    this.lockedSet_ = opt_locked;\n  }\n\n  if (changed) {\n    this.updateSelection_(undefined);\n  }\n  return changed;\n};\n\n/**\n * The mouse has left the canvas. Clear out whatever artifacts remain\n * @param {Object} event the mouseout event from the browser.\n * @private\n */\nDygraph.prototype.mouseOut_ = function (event) {\n  if (this.getFunctionOption(\"unhighlightCallback\")) {\n    this.getFunctionOption(\"unhighlightCallback\").call(this, event);\n  }\n\n  if (this.getBooleanOption(\"hideOverlayOnMouseOut\") && !this.lockedSet_) {\n    this.clearSelection();\n  }\n};\n\n/**\n * Clears the current selection (i.e. points that were highlighted by moving\n * the mouse over the chart).\n */\nDygraph.prototype.clearSelection = function () {\n  this.cascadeEvents_('deselect', {});\n\n  this.lockedSet_ = false;\n  // Get rid of the overlay data\n  if (this.fadeLevel) {\n    this.animateSelection_(-1);\n    return;\n  }\n  this.canvas_ctx_.clearRect(0, 0, this.width_, this.height_);\n  this.fadeLevel = 0;\n  this.selPoints_ = [];\n  this.lastx_ = -1;\n  this.lastRow_ = -1;\n  this.highlightSet_ = null;\n};\n\n/**\n * Returns the number of the currently selected row. To get data for this row,\n * you can use the getValue method.\n * @return {number} row number, or -1 if nothing is selected\n */\nDygraph.prototype.getSelection = function () {\n  if (!this.selPoints_ || this.selPoints_.length < 1) {\n    return -1;\n  }\n\n  for (var setIdx = 0; setIdx < this.layout_.points.length; setIdx++) {\n    var points = this.layout_.points[setIdx];\n    for (var row = 0; row < points.length; row++) {\n      if (points[row].x == this.selPoints_[0].x) {\n        return points[row].idx;\n      }\n    }\n  }\n  return -1;\n};\n\n/**\n * Returns the name of the currently-highlighted series.\n * Only available when the highlightSeriesOpts option is in use.\n */\nDygraph.prototype.getHighlightSeries = function () {\n  return this.highlightSet_;\n};\n\n/**\n * Returns true if the currently-highlighted series was locked\n * via setSelection(..., seriesName, true).\n */\nDygraph.prototype.isSeriesLocked = function () {\n  return this.lockedSet_;\n};\n\n/**\n * Fires when there's data available to be graphed.\n * @param {string} data Raw CSV data to be plotted\n * @private\n */\nDygraph.prototype.loadedEvent_ = function (data) {\n  this.rawData_ = this.parseCSV_(data);\n  this.cascadeDataDidUpdateEvent_();\n  this.predraw_();\n};\n\n/**\n * Add ticks on the x-axis representing years, months, quarters, weeks, or days\n * @private\n */\nDygraph.prototype.addXTicks_ = function () {\n  // Determine the correct ticks scale on the x-axis: quarterly, monthly, ...\n  var range;\n  if (this.dateWindow_) {\n    range = [this.dateWindow_[0], this.dateWindow_[1]];\n  } else {\n    range = this.xAxisExtremes();\n  }\n\n  var xAxisOptionsView = this.optionsViewForAxis_('x');\n  var xTicks = xAxisOptionsView('ticker')(range[0], range[1], this.plotter_.area.w, // TODO(danvk): should be area.width\n  xAxisOptionsView, this);\n  // var msg = 'ticker(' + range[0] + ', ' + range[1] + ', ' + this.width_ + ', ' + this.attr_('pixelsPerXLabel') + ') -> ' + JSON.stringify(xTicks);\n  // console.log(msg);\n  this.layout_.setXTicks(xTicks);\n};\n\n/**\n * Returns the correct handler class for the currently set options.\n * @private\n */\nDygraph.prototype.getHandlerClass_ = function () {\n  var handlerClass;\n  if (this.attr_('dataHandler')) {\n    handlerClass = this.attr_('dataHandler');\n  } else if (this.fractions_) {\n    if (this.getBooleanOption('errorBars')) {\n      handlerClass = __WEBPACK_IMPORTED_MODULE_13__datahandler_bars_fractions__[\"a\" /* default */];\n    } else {\n      handlerClass = __WEBPACK_IMPORTED_MODULE_12__datahandler_default_fractions__[\"a\" /* default */];\n    }\n  } else if (this.getBooleanOption('customBars')) {\n    handlerClass = __WEBPACK_IMPORTED_MODULE_11__datahandler_bars_custom__[\"a\" /* default */];\n  } else if (this.getBooleanOption('errorBars')) {\n    handlerClass = __WEBPACK_IMPORTED_MODULE_10__datahandler_bars_error__[\"a\" /* default */];\n  } else {\n    handlerClass = __WEBPACK_IMPORTED_MODULE_9__datahandler_default__[\"a\" /* default */];\n  }\n  return handlerClass;\n};\n\n/**\n * @private\n * This function is called once when the chart's data is changed or the options\n * dictionary is updated. It is _not_ called when the user pans or zooms. The\n * idea is that values derived from the chart's data can be computed here,\n * rather than every time the chart is drawn. This includes things like the\n * number of axes, rolling averages, etc.\n */\nDygraph.prototype.predraw_ = function () {\n  var start = new Date();\n\n  // Create the correct dataHandler\n  this.dataHandler_ = new (this.getHandlerClass_())();\n\n  this.layout_.computePlotArea();\n\n  // TODO(danvk): move more computations out of drawGraph_ and into here.\n  this.computeYAxes_();\n\n  if (!this.is_initial_draw_) {\n    this.canvas_ctx_.restore();\n    this.hidden_ctx_.restore();\n  }\n\n  this.canvas_ctx_.save();\n  this.hidden_ctx_.save();\n\n  // Create a new plotter.\n  this.plotter_ = new __WEBPACK_IMPORTED_MODULE_1__dygraph_canvas__[\"a\" /* default */](this, this.hidden_, this.hidden_ctx_, this.layout_);\n\n  // The roller sits in the bottom left corner of the chart. We don't know where\n  // this will be until the options are available, so it's positioned here.\n  this.createRollInterface_();\n\n  this.cascadeEvents_('predraw');\n\n  // Convert the raw data (a 2D array) into the internal format and compute\n  // rolling averages.\n  this.rolledSeries_ = [null]; // x-axis is the first series and it's special\n  for (var i = 1; i < this.numColumns(); i++) {\n    // var logScale = this.attr_('logscale', i); // TODO(klausw): this looks wrong // konigsberg thinks so too.\n    var series = this.dataHandler_.extractSeries(this.rawData_, i, this.attributes_);\n    if (this.rollPeriod_ > 1) {\n      series = this.dataHandler_.rollingAverage(series, this.rollPeriod_, this.attributes_);\n    }\n\n    this.rolledSeries_.push(series);\n  }\n\n  // If the data or options have changed, then we'd better redraw.\n  this.drawGraph_();\n\n  // This is used to determine whether to do various animations.\n  var end = new Date();\n  this.drawingTimeMs_ = end - start;\n};\n\n/**\n * Point structure.\n *\n * xval_* and yval_* are the original unscaled data values,\n * while x_* and y_* are scaled to the range (0.0-1.0) for plotting.\n * yval_stacked is the cumulative Y value used for stacking graphs,\n * and bottom/top/minus/plus are used for error bar graphs.\n *\n * @typedef {{\n *     idx: number,\n *     name: string,\n *     x: ?number,\n *     xval: ?number,\n *     y_bottom: ?number,\n *     y: ?number,\n *     y_stacked: ?number,\n *     y_top: ?number,\n *     yval_minus: ?number,\n *     yval: ?number,\n *     yval_plus: ?number,\n *     yval_stacked\n * }}\n */\nDygraph.PointType = undefined;\n\n/**\n * Calculates point stacking for stackedGraph=true.\n *\n * For stacking purposes, interpolate or extend neighboring data across\n * NaN values based on stackedGraphNaNFill settings. This is for display\n * only, the underlying data value as shown in the legend remains NaN.\n *\n * @param {Array.<Dygraph.PointType>} points Point array for a single series.\n *     Updates each Point's yval_stacked property.\n * @param {Array.<number>} cumulativeYval Accumulated top-of-graph stacked Y\n *     values for the series seen so far. Index is the row number. Updated\n *     based on the current series's values.\n * @param {Array.<number>} seriesExtremes Min and max values, updated\n *     to reflect the stacked values.\n * @param {string} fillMethod Interpolation method, one of 'all', 'inside', or\n *     'none'.\n * @private\n */\nDygraph.stackPoints_ = function (points, cumulativeYval, seriesExtremes, fillMethod) {\n  var lastXval = null;\n  var prevPoint = null;\n  var nextPoint = null;\n  var nextPointIdx = -1;\n\n  // Find the next stackable point starting from the given index.\n  var updateNextPoint = function updateNextPoint(idx) {\n    // If we've previously found a non-NaN point and haven't gone past it yet,\n    // just use that.\n    if (nextPointIdx >= idx) return;\n\n    // We haven't found a non-NaN point yet or have moved past it,\n    // look towards the right to find a non-NaN point.\n    for (var j = idx; j < points.length; ++j) {\n      // Clear out a previously-found point (if any) since it's no longer\n      // valid, we shouldn't use it for interpolation anymore.\n      nextPoint = null;\n      if (!isNaN(points[j].yval) && points[j].yval !== null) {\n        nextPointIdx = j;\n        nextPoint = points[j];\n        break;\n      }\n    }\n  };\n\n  for (var i = 0; i < points.length; ++i) {\n    var point = points[i];\n    var xval = point.xval;\n    if (cumulativeYval[xval] === undefined) {\n      cumulativeYval[xval] = 0;\n    }\n\n    var actualYval = point.yval;\n    if (isNaN(actualYval) || actualYval === null) {\n      if (fillMethod == 'none') {\n        actualYval = 0;\n      } else {\n        // Interpolate/extend for stacking purposes if possible.\n        updateNextPoint(i);\n        if (prevPoint && nextPoint && fillMethod != 'none') {\n          // Use linear interpolation between prevPoint and nextPoint.\n          actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) * ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n        } else if (prevPoint && fillMethod == 'all') {\n          actualYval = prevPoint.yval;\n        } else if (nextPoint && fillMethod == 'all') {\n          actualYval = nextPoint.yval;\n        } else {\n          actualYval = 0;\n        }\n      }\n    } else {\n      prevPoint = point;\n    }\n\n    var stackedYval = cumulativeYval[xval];\n    if (lastXval != xval) {\n      // If an x-value is repeated, we ignore the duplicates.\n      stackedYval += actualYval;\n      cumulativeYval[xval] = stackedYval;\n    }\n    lastXval = xval;\n\n    point.yval_stacked = stackedYval;\n\n    if (stackedYval > seriesExtremes[1]) {\n      seriesExtremes[1] = stackedYval;\n    }\n    if (stackedYval < seriesExtremes[0]) {\n      seriesExtremes[0] = stackedYval;\n    }\n  }\n};\n\n/**\n * Loop over all fields and create datasets, calculating extreme y-values for\n * each series and extreme x-indices as we go.\n *\n * dateWindow is passed in as an explicit parameter so that we can compute\n * extreme values \"speculatively\", i.e. without actually setting state on the\n * dygraph.\n *\n * @param {Array.<Array.<Array.<(number|Array<number>)>>} rolledSeries, where\n *     rolledSeries[seriesIndex][row] = raw point, where\n *     seriesIndex is the column number starting with 1, and\n *     rawPoint is [x,y] or [x, [y, err]] or [x, [y, yminus, yplus]].\n * @param {?Array.<number>} dateWindow [xmin, xmax] pair, or null.\n * @return {{\n *     points: Array.<Array.<Dygraph.PointType>>,\n *     seriesExtremes: Array.<Array.<number>>,\n *     boundaryIds: Array.<number>}}\n * @private\n */\nDygraph.prototype.gatherDatasets_ = function (rolledSeries, dateWindow) {\n  var boundaryIds = [];\n  var points = [];\n  var cumulativeYval = []; // For stacked series.\n  var extremes = {}; // series name -> [low, high]\n  var seriesIdx, sampleIdx;\n  var firstIdx, lastIdx;\n  var axisIdx;\n\n  // Loop over the fields (series).  Go from the last to the first,\n  // because if they're stacked that's how we accumulate the values.\n  var num_series = rolledSeries.length - 1;\n  var series;\n  for (seriesIdx = num_series; seriesIdx >= 1; seriesIdx--) {\n    if (!this.visibility()[seriesIdx - 1]) continue;\n\n    // Prune down to the desired range, if necessary (for zooming)\n    // Because there can be lines going to points outside of the visible area,\n    // we actually prune to visible points, plus one on either side.\n    if (dateWindow) {\n      series = rolledSeries[seriesIdx];\n      var low = dateWindow[0];\n      var high = dateWindow[1];\n\n      // TODO(danvk): do binary search instead of linear search.\n      // TODO(danvk): pass firstIdx and lastIdx directly to the renderer.\n      firstIdx = null;\n      lastIdx = null;\n      for (sampleIdx = 0; sampleIdx < series.length; sampleIdx++) {\n        if (series[sampleIdx][0] >= low && firstIdx === null) {\n          firstIdx = sampleIdx;\n        }\n        if (series[sampleIdx][0] <= high) {\n          lastIdx = sampleIdx;\n        }\n      }\n\n      if (firstIdx === null) firstIdx = 0;\n      var correctedFirstIdx = firstIdx;\n      var isInvalidValue = true;\n      while (isInvalidValue && correctedFirstIdx > 0) {\n        correctedFirstIdx--;\n        // check if the y value is null.\n        isInvalidValue = series[correctedFirstIdx][1] === null;\n      }\n\n      if (lastIdx === null) lastIdx = series.length - 1;\n      var correctedLastIdx = lastIdx;\n      isInvalidValue = true;\n      while (isInvalidValue && correctedLastIdx < series.length - 1) {\n        correctedLastIdx++;\n        isInvalidValue = series[correctedLastIdx][1] === null;\n      }\n\n      if (correctedFirstIdx !== firstIdx) {\n        firstIdx = correctedFirstIdx;\n      }\n      if (correctedLastIdx !== lastIdx) {\n        lastIdx = correctedLastIdx;\n      }\n\n      boundaryIds[seriesIdx - 1] = [firstIdx, lastIdx];\n\n      // .slice's end is exclusive, we want to include lastIdx.\n      series = series.slice(firstIdx, lastIdx + 1);\n    } else {\n      series = rolledSeries[seriesIdx];\n      boundaryIds[seriesIdx - 1] = [0, series.length - 1];\n    }\n\n    var seriesName = this.attr_(\"labels\")[seriesIdx];\n    var seriesExtremes = this.dataHandler_.getExtremeYValues(series, dateWindow, this.getBooleanOption(\"stepPlot\", seriesName));\n\n    var seriesPoints = this.dataHandler_.seriesToPoints(series, seriesName, boundaryIds[seriesIdx - 1][0]);\n\n    if (this.getBooleanOption(\"stackedGraph\")) {\n      axisIdx = this.attributes_.axisForSeries(seriesName);\n      if (cumulativeYval[axisIdx] === undefined) {\n        cumulativeYval[axisIdx] = [];\n      }\n      Dygraph.stackPoints_(seriesPoints, cumulativeYval[axisIdx], seriesExtremes, this.getBooleanOption(\"stackedGraphNaNFill\"));\n    }\n\n    extremes[seriesName] = seriesExtremes;\n    points[seriesIdx] = seriesPoints;\n  }\n\n  return { points: points, extremes: extremes, boundaryIds: boundaryIds };\n};\n\n/**\n * Update the graph with new data. This method is called when the viewing area\n * has changed. If the underlying data or options have changed, predraw_ will\n * be called before drawGraph_ is called.\n *\n * @private\n */\nDygraph.prototype.drawGraph_ = function () {\n  var start = new Date();\n\n  // This is used to set the second parameter to drawCallback, below.\n  var is_initial_draw = this.is_initial_draw_;\n  this.is_initial_draw_ = false;\n\n  this.layout_.removeAllDatasets();\n  this.setColors_();\n  this.attrs_.pointSize = 0.5 * this.getNumericOption('highlightCircleSize');\n\n  var packed = this.gatherDatasets_(this.rolledSeries_, this.dateWindow_);\n  var points = packed.points;\n  var extremes = packed.extremes;\n  this.boundaryIds_ = packed.boundaryIds;\n\n  this.setIndexByName_ = {};\n  var labels = this.attr_(\"labels\");\n  var dataIdx = 0;\n  for (var i = 1; i < points.length; i++) {\n    if (!this.visibility()[i - 1]) continue;\n    this.layout_.addDataset(labels[i], points[i]);\n    this.datasetIndex_[i] = dataIdx++;\n  }\n  for (var i = 0; i < labels.length; i++) {\n    this.setIndexByName_[labels[i]] = i;\n  }\n\n  this.computeYAxisRanges_(extremes);\n  this.layout_.setYAxes(this.axes_);\n\n  this.addXTicks_();\n\n  // Tell PlotKit to use this new data and render itself\n  this.layout_.evaluate();\n  this.renderGraph_(is_initial_draw);\n\n  if (this.getStringOption(\"timingName\")) {\n    var end = new Date();\n    console.log(this.getStringOption(\"timingName\") + \" - drawGraph: \" + (end - start) + \"ms\");\n  }\n};\n\n/**\n * This does the work of drawing the chart. It assumes that the layout and axis\n * scales have already been set (e.g. by predraw_).\n *\n * @private\n */\nDygraph.prototype.renderGraph_ = function (is_initial_draw) {\n  this.cascadeEvents_('clearChart');\n  this.plotter_.clear();\n\n  var underlayCallback = this.getFunctionOption('underlayCallback');\n  if (underlayCallback) {\n    // NOTE: we pass the dygraph object to this callback twice to avoid breaking\n    // users who expect a deprecated form of this callback.\n    underlayCallback.call(this, this.hidden_ctx_, this.layout_.getPlotArea(), this, this);\n  }\n\n  var e = {\n    canvas: this.hidden_,\n    drawingContext: this.hidden_ctx_\n  };\n  this.cascadeEvents_('willDrawChart', e);\n  this.plotter_.render();\n  this.cascadeEvents_('didDrawChart', e);\n  this.lastRow_ = -1; // because plugins/legend.js clears the legend\n\n  // TODO(danvk): is this a performance bottleneck when panning?\n  // The interaction canvas should already be empty in that situation.\n  this.canvas_.getContext('2d').clearRect(0, 0, this.width_, this.height_);\n\n  var drawCallback = this.getFunctionOption(\"drawCallback\");\n  if (drawCallback !== null) {\n    drawCallback.call(this, this, is_initial_draw);\n  }\n  if (is_initial_draw) {\n    this.readyFired_ = true;\n    while (this.readyFns_.length > 0) {\n      var fn = this.readyFns_.pop();\n      fn(this);\n    }\n  }\n};\n\n/**\n * @private\n * Determine properties of the y-axes which are independent of the data\n * currently being displayed. This includes things like the number of axes and\n * the style of the axes. It does not include the range of each axis and its\n * tick marks.\n * This fills in this.axes_.\n * axes_ = [ { options } ]\n *   indices are into the axes_ array.\n */\nDygraph.prototype.computeYAxes_ = function () {\n  var axis, index, opts, v;\n\n  // this.axes_ doesn't match this.attributes_.axes_.options. It's used for\n  // data computation as well as options storage.\n  // Go through once and add all the axes.\n  this.axes_ = [];\n\n  for (axis = 0; axis < this.attributes_.numAxes(); axis++) {\n    // Add a new axis, making a copy of its per-axis options.\n    opts = { g: this };\n    __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"a\" /* update */](opts, this.attributes_.axisOptions(axis));\n    this.axes_[axis] = opts;\n  }\n\n  for (axis = 0; axis < this.axes_.length; axis++) {\n    if (axis === 0) {\n      opts = this.optionsViewForAxis_('y' + (axis ? '2' : ''));\n      v = opts(\"valueRange\");\n      if (v) this.axes_[axis].valueRange = v;\n    } else {\n      // To keep old behavior\n      var axes = this.user_attrs_.axes;\n      if (axes && axes.y2) {\n        v = axes.y2.valueRange;\n        if (v) this.axes_[axis].valueRange = v;\n      }\n    }\n  }\n};\n\n/**\n * Returns the number of y-axes on the chart.\n * @return {number} the number of axes.\n */\nDygraph.prototype.numAxes = function () {\n  return this.attributes_.numAxes();\n};\n\n/**\n * @private\n * Returns axis properties for the given series.\n * @param {string} setName The name of the series for which to get axis\n * properties, e.g. 'Y1'.\n * @return {Object} The axis properties.\n */\nDygraph.prototype.axisPropertiesForSeries = function (series) {\n  // TODO(danvk): handle errors.\n  return this.axes_[this.attributes_.axisForSeries(series)];\n};\n\n/**\n * @private\n * Determine the value range and tick marks for each axis.\n * @param {Object} extremes A mapping from seriesName -> [low, high]\n * This fills in the valueRange and ticks fields in each entry of this.axes_.\n */\nDygraph.prototype.computeYAxisRanges_ = function (extremes) {\n  var isNullUndefinedOrNaN = function isNullUndefinedOrNaN(num) {\n    return isNaN(parseFloat(num));\n  };\n  var numAxes = this.attributes_.numAxes();\n  var ypadCompat, span, series, ypad;\n\n  var p_axis;\n\n  // Compute extreme values, a span and tick marks for each axis.\n  for (var i = 0; i < numAxes; i++) {\n    var axis = this.axes_[i];\n    var logscale = this.attributes_.getForAxis(\"logscale\", i);\n    var includeZero = this.attributes_.getForAxis(\"includeZero\", i);\n    var independentTicks = this.attributes_.getForAxis(\"independentTicks\", i);\n    series = this.attributes_.seriesForAxis(i);\n\n    // Add some padding. This supports two Y padding operation modes:\n    //\n    // - backwards compatible (yRangePad not set):\n    //   10% padding for automatic Y ranges, but not for user-supplied\n    //   ranges, and move a close-to-zero edge to zero, since drawing at the edge\n    //   results in invisible lines. Unfortunately lines drawn at the edge of a\n    //   user-supplied range will still be invisible. If logscale is\n    //   set, add a variable amount of padding at the top but\n    //   none at the bottom.\n    //\n    // - new-style (yRangePad set by the user):\n    //   always add the specified Y padding.\n    //\n    ypadCompat = true;\n    ypad = 0.1; // add 10%\n    var yRangePad = this.getNumericOption('yRangePad');\n    if (yRangePad !== null) {\n      ypadCompat = false;\n      // Convert pixel padding to ratio\n      ypad = yRangePad / this.plotter_.area.h;\n    }\n\n    if (series.length === 0) {\n      // If no series are defined or visible then use a reasonable default\n      axis.extremeRange = [0, 1];\n    } else {\n      // Calculate the extremes of extremes.\n      var minY = Infinity; // extremes[series[0]][0];\n      var maxY = -Infinity; // extremes[series[0]][1];\n      var extremeMinY, extremeMaxY;\n\n      for (var j = 0; j < series.length; j++) {\n        // this skips invisible series\n        if (!extremes.hasOwnProperty(series[j])) continue;\n\n        // Only use valid extremes to stop null data series' from corrupting the scale.\n        extremeMinY = extremes[series[j]][0];\n        if (extremeMinY !== null) {\n          minY = Math.min(extremeMinY, minY);\n        }\n        extremeMaxY = extremes[series[j]][1];\n        if (extremeMaxY !== null) {\n          maxY = Math.max(extremeMaxY, maxY);\n        }\n      }\n\n      // Include zero if requested by the user.\n      if (includeZero && !logscale) {\n        if (minY > 0) minY = 0;\n        if (maxY < 0) maxY = 0;\n      }\n\n      // Ensure we have a valid scale, otherwise default to [0, 1] for safety.\n      if (minY == Infinity) minY = 0;\n      if (maxY == -Infinity) maxY = 1;\n\n      span = maxY - minY;\n      // special case: if we have no sense of scale, center on the sole value.\n      if (span === 0) {\n        if (maxY !== 0) {\n          span = Math.abs(maxY);\n        } else {\n          // ... and if the sole value is zero, use range 0-1.\n          maxY = 1;\n          span = 1;\n        }\n      }\n\n      var maxAxisY = maxY,\n          minAxisY = minY;\n      if (ypadCompat) {\n        if (logscale) {\n          maxAxisY = maxY + ypad * span;\n          minAxisY = minY;\n        } else {\n          maxAxisY = maxY + ypad * span;\n          minAxisY = minY - ypad * span;\n\n          // Backwards-compatible behavior: Move the span to start or end at zero if it's\n          // close to zero.\n          if (minAxisY < 0 && minY >= 0) minAxisY = 0;\n          if (maxAxisY > 0 && maxY <= 0) maxAxisY = 0;\n        }\n      }\n      axis.extremeRange = [minAxisY, maxAxisY];\n    }\n    if (axis.valueRange) {\n      // This is a user-set value range for this axis.\n      var y0 = isNullUndefinedOrNaN(axis.valueRange[0]) ? axis.extremeRange[0] : axis.valueRange[0];\n      var y1 = isNullUndefinedOrNaN(axis.valueRange[1]) ? axis.extremeRange[1] : axis.valueRange[1];\n      axis.computedValueRange = [y0, y1];\n    } else {\n      axis.computedValueRange = axis.extremeRange;\n    }\n    if (!ypadCompat) {\n      // When using yRangePad, adjust the upper/lower bounds to add\n      // padding unless the user has zoomed/panned the Y axis range.\n      if (logscale) {\n        y0 = axis.computedValueRange[0];\n        y1 = axis.computedValueRange[1];\n        var y0pct = ypad / (2 * ypad - 1);\n        var y1pct = (ypad - 1) / (2 * ypad - 1);\n        axis.computedValueRange[0] = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"c\" /* logRangeFraction */](y0, y1, y0pct);\n        axis.computedValueRange[1] = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"c\" /* logRangeFraction */](y0, y1, y1pct);\n      } else {\n        y0 = axis.computedValueRange[0];\n        y1 = axis.computedValueRange[1];\n        span = y1 - y0;\n        axis.computedValueRange[0] = y0 - span * ypad;\n        axis.computedValueRange[1] = y1 + span * ypad;\n      }\n    }\n\n    if (independentTicks) {\n      axis.independentTicks = independentTicks;\n      var opts = this.optionsViewForAxis_('y' + (i ? '2' : ''));\n      var ticker = opts('ticker');\n      axis.ticks = ticker(axis.computedValueRange[0], axis.computedValueRange[1], this.plotter_.area.h, opts, this);\n      // Define the first independent axis as primary axis.\n      if (!p_axis) p_axis = axis;\n    }\n  }\n  if (p_axis === undefined) {\n    throw \"Configuration Error: At least one axis has to have the \\\"independentTicks\\\" option activated.\";\n  }\n  // Add ticks. By default, all axes inherit the tick positions of the\n  // primary axis. However, if an axis is specifically marked as having\n  // independent ticks, then that is permissible as well.\n  for (var i = 0; i < numAxes; i++) {\n    var axis = this.axes_[i];\n\n    if (!axis.independentTicks) {\n      var opts = this.optionsViewForAxis_('y' + (i ? '2' : ''));\n      var ticker = opts('ticker');\n      var p_ticks = p_axis.ticks;\n      var p_scale = p_axis.computedValueRange[1] - p_axis.computedValueRange[0];\n      var scale = axis.computedValueRange[1] - axis.computedValueRange[0];\n      var tick_values = [];\n      for (var k = 0; k < p_ticks.length; k++) {\n        var y_frac = (p_ticks[k].v - p_axis.computedValueRange[0]) / p_scale;\n        var y_val = axis.computedValueRange[0] + y_frac * scale;\n        tick_values.push(y_val);\n      }\n\n      axis.ticks = ticker(axis.computedValueRange[0], axis.computedValueRange[1], this.plotter_.area.h, opts, this, tick_values);\n    }\n  }\n};\n\n/**\n * Detects the type of the str (date or numeric) and sets the various\n * formatting attributes in this.attrs_ based on this type.\n * @param {string} str An x value.\n * @private\n */\nDygraph.prototype.detectTypeFromString_ = function (str) {\n  var isDate = false;\n  var dashPos = str.indexOf('-'); // could be 2006-01-01 _or_ 1.0e-2\n  if (dashPos > 0 && str[dashPos - 1] != 'e' && str[dashPos - 1] != 'E' || str.indexOf('/') >= 0 || isNaN(parseFloat(str))) {\n    isDate = true;\n  } else if (str.length == 8 && str > '19700101' && str < '20371231') {\n    // TODO(danvk): remove support for this format.\n    isDate = true;\n  }\n\n  this.setXAxisOptions_(isDate);\n};\n\nDygraph.prototype.setXAxisOptions_ = function (isDate) {\n  if (isDate) {\n    this.attrs_.xValueParser = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"v\" /* dateParser */];\n    this.attrs_.axes.x.valueFormatter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"w\" /* dateValueFormatter */];\n    this.attrs_.axes.x.ticker = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"a\" /* dateTicker */];\n    this.attrs_.axes.x.axisLabelFormatter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"x\" /* dateAxisLabelFormatter */];\n  } else {\n    /** @private (shut up, jsdoc!) */\n    this.attrs_.xValueParser = function (x) {\n      return parseFloat(x);\n    };\n    // TODO(danvk): use Dygraph.numberValueFormatter here?\n    /** @private (shut up, jsdoc!) */\n    this.attrs_.axes.x.valueFormatter = function (x) {\n      return x;\n    };\n    this.attrs_.axes.x.ticker = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"b\" /* numericTicks */];\n    this.attrs_.axes.x.axisLabelFormatter = this.attrs_.axes.x.valueFormatter;\n  }\n};\n\n/**\n * @private\n * Parses a string in a special csv format.  We expect a csv file where each\n * line is a date point, and the first field in each line is the date string.\n * We also expect that all remaining fields represent series.\n * if the errorBars attribute is set, then interpret the fields as:\n * date, series1, stddev1, series2, stddev2, ...\n * @param {[Object]} data See above.\n *\n * @return [Object] An array with one entry for each row. These entries\n * are an array of cells in that row. The first entry is the parsed x-value for\n * the row. The second, third, etc. are the y-values. These can take on one of\n * three forms, depending on the CSV and constructor parameters:\n * 1. numeric value\n * 2. [ value, stddev ]\n * 3. [ low value, center value, high value ]\n */\nDygraph.prototype.parseCSV_ = function (data) {\n  var ret = [];\n  var line_delimiter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"y\" /* detectLineDelimiter */](data);\n  var lines = data.split(line_delimiter || \"\\n\");\n  var vals, j;\n\n  // Use the default delimiter or fall back to a tab if that makes sense.\n  var delim = this.getStringOption('delimiter');\n  if (lines[0].indexOf(delim) == -1 && lines[0].indexOf('\\t') >= 0) {\n    delim = '\\t';\n  }\n\n  var start = 0;\n  if (!('labels' in this.user_attrs_)) {\n    // User hasn't explicitly set labels, so they're (presumably) in the CSV.\n    start = 1;\n    this.attrs_.labels = lines[0].split(delim); // NOTE: _not_ user_attrs_.\n    this.attributes_.reparseSeries();\n  }\n  var line_no = 0;\n\n  var xParser;\n  var defaultParserSet = false; // attempt to auto-detect x value type\n  var expectedCols = this.attr_(\"labels\").length;\n  var outOfOrder = false;\n  for (var i = start; i < lines.length; i++) {\n    var line = lines[i];\n    line_no = i;\n    if (line.length === 0) continue; // skip blank lines\n    if (line[0] == '#') continue; // skip comment lines\n    var inFields = line.split(delim);\n    if (inFields.length < 2) continue;\n\n    var fields = [];\n    if (!defaultParserSet) {\n      this.detectTypeFromString_(inFields[0]);\n      xParser = this.getFunctionOption(\"xValueParser\");\n      defaultParserSet = true;\n    }\n    fields[0] = xParser(inFields[0], this);\n\n    // If fractions are expected, parse the numbers as \"A/B\"\n    if (this.fractions_) {\n      for (j = 1; j < inFields.length; j++) {\n        // TODO(danvk): figure out an appropriate way to flag parse errors.\n        vals = inFields[j].split(\"/\");\n        if (vals.length != 2) {\n          console.error('Expected fractional \"num/den\" values in CSV data ' + \"but found a value '\" + inFields[j] + \"' on line \" + (1 + i) + \" ('\" + line + \"') which is not of this form.\");\n          fields[j] = [0, 0];\n        } else {\n          fields[j] = [__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"z\" /* parseFloat_ */](vals[0], i, line), __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"z\" /* parseFloat_ */](vals[1], i, line)];\n        }\n      }\n    } else if (this.getBooleanOption(\"errorBars\")) {\n      // If there are error bars, values are (value, stddev) pairs\n      if (inFields.length % 2 != 1) {\n        console.error('Expected alternating (value, stdev.) pairs in CSV data ' + 'but line ' + (1 + i) + ' has an odd number of values (' + (inFields.length - 1) + \"): '\" + line + \"'\");\n      }\n      for (j = 1; j < inFields.length; j += 2) {\n        fields[(j + 1) / 2] = [__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"z\" /* parseFloat_ */](inFields[j], i, line), __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"z\" /* parseFloat_ */](inFields[j + 1], i, line)];\n      }\n    } else if (this.getBooleanOption(\"customBars\")) {\n      // Bars are a low;center;high tuple\n      for (j = 1; j < inFields.length; j++) {\n        var val = inFields[j];\n        if (/^ *$/.test(val)) {\n          fields[j] = [null, null, null];\n        } else {\n          vals = val.split(\";\");\n          if (vals.length == 3) {\n            fields[j] = [__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"z\" /* parseFloat_ */](vals[0], i, line), __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"z\" /* parseFloat_ */](vals[1], i, line), __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"z\" /* parseFloat_ */](vals[2], i, line)];\n          } else {\n            console.warn('When using customBars, values must be either blank ' + 'or \"low;center;high\" tuples (got \"' + val + '\" on line ' + (1 + i));\n          }\n        }\n      }\n    } else {\n      // Values are just numbers\n      for (j = 1; j < inFields.length; j++) {\n        fields[j] = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"z\" /* parseFloat_ */](inFields[j], i, line);\n      }\n    }\n    if (ret.length > 0 && fields[0] < ret[ret.length - 1][0]) {\n      outOfOrder = true;\n    }\n\n    if (fields.length != expectedCols) {\n      console.error(\"Number of columns in line \" + i + \" (\" + fields.length + \") does not agree with number of labels (\" + expectedCols + \") \" + line);\n    }\n\n    // If the user specified the 'labels' option and none of the cells of the\n    // first row parsed correctly, then they probably double-specified the\n    // labels. We go with the values set in the option, discard this row and\n    // log a warning to the JS console.\n    if (i === 0 && this.attr_('labels')) {\n      var all_null = true;\n      for (j = 0; all_null && j < fields.length; j++) {\n        if (fields[j]) all_null = false;\n      }\n      if (all_null) {\n        console.warn(\"The dygraphs 'labels' option is set, but the first row \" + \"of CSV data ('\" + line + \"') appears to also contain \" + \"labels. Will drop the CSV labels and use the option \" + \"labels.\");\n        continue;\n      }\n    }\n    ret.push(fields);\n  }\n\n  if (outOfOrder) {\n    console.warn(\"CSV is out of order; order it correctly to speed loading.\");\n    ret.sort(function (a, b) {\n      return a[0] - b[0];\n    });\n  }\n\n  return ret;\n};\n\n// In native format, all values must be dates or numbers.\n// This check isn't perfect but will catch most mistaken uses of strings.\nfunction validateNativeFormat(data) {\n  var firstRow = data[0];\n  var firstX = firstRow[0];\n  if (typeof firstX !== 'number' && !__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"A\" /* isDateLike */](firstX)) {\n    throw new Error('Expected number or date but got ' + (typeof firstX === 'undefined' ? 'undefined' : _typeof(firstX)) + ': ' + firstX + '.');\n  }\n  for (var i = 1; i < firstRow.length; i++) {\n    var val = firstRow[i];\n    if (val === null || val === undefined) continue;\n    if (typeof val === 'number') continue;\n    if (__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"B\" /* isArrayLike */](val)) continue; // e.g. error bars or custom bars.\n    throw new Error('Expected number or array but got ' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)) + ': ' + val + '.');\n  }\n}\n\n/**\n * The user has provided their data as a pre-packaged JS array. If the x values\n * are numeric, this is the same as dygraphs' internal format. If the x values\n * are dates, we need to convert them from Date objects to ms since epoch.\n * @param {!Array} data\n * @return {Object} data with numeric x values.\n * @private\n */\nDygraph.prototype.parseArray_ = function (data) {\n  // Peek at the first x value to see if it's numeric.\n  if (data.length === 0) {\n    console.error(\"Can't plot empty data set\");\n    return null;\n  }\n  if (data[0].length === 0) {\n    console.error(\"Data set cannot contain an empty row\");\n    return null;\n  }\n\n  validateNativeFormat(data);\n\n  var i;\n  if (this.attr_(\"labels\") === null) {\n    console.warn(\"Using default labels. Set labels explicitly via 'labels' \" + \"in the options parameter\");\n    this.attrs_.labels = [\"X\"];\n    for (i = 1; i < data[0].length; i++) {\n      this.attrs_.labels.push(\"Y\" + i); // Not user_attrs_.\n    }\n    this.attributes_.reparseSeries();\n  } else {\n    var num_labels = this.attr_(\"labels\");\n    if (num_labels.length != data[0].length) {\n      console.error(\"Mismatch between number of labels (\" + num_labels + \")\" + \" and number of columns in array (\" + data[0].length + \")\");\n      return null;\n    }\n  }\n\n  if (__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"A\" /* isDateLike */](data[0][0])) {\n    // Some intelligent defaults for a date x-axis.\n    this.attrs_.axes.x.valueFormatter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"w\" /* dateValueFormatter */];\n    this.attrs_.axes.x.ticker = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"a\" /* dateTicker */];\n    this.attrs_.axes.x.axisLabelFormatter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"x\" /* dateAxisLabelFormatter */];\n\n    // Assume they're all dates.\n    var parsedData = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"C\" /* clone */](data);\n    for (i = 0; i < data.length; i++) {\n      if (parsedData[i].length === 0) {\n        console.error(\"Row \" + (1 + i) + \" of data is empty\");\n        return null;\n      }\n      if (parsedData[i][0] === null || typeof parsedData[i][0].getTime != 'function' || isNaN(parsedData[i][0].getTime())) {\n        console.error(\"x value in row \" + (1 + i) + \" is not a Date\");\n        return null;\n      }\n      parsedData[i][0] = parsedData[i][0].getTime();\n    }\n    return parsedData;\n  } else {\n    // Some intelligent defaults for a numeric x-axis.\n    /** @private (shut up, jsdoc!) */\n    this.attrs_.axes.x.valueFormatter = function (x) {\n      return x;\n    };\n    this.attrs_.axes.x.ticker = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"b\" /* numericTicks */];\n    this.attrs_.axes.x.axisLabelFormatter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"D\" /* numberAxisLabelFormatter */];\n    return data;\n  }\n};\n\n/**\n * Parses a DataTable object from gviz.\n * The data is expected to have a first column that is either a date or a\n * number. All subsequent columns must be numbers. If there is a clear mismatch\n * between this.xValueParser_ and the type of the first column, it will be\n * fixed. Fills out rawData_.\n * @param {!google.visualization.DataTable} data See above.\n * @private\n */\nDygraph.prototype.parseDataTable_ = function (data) {\n  var shortTextForAnnotationNum = function shortTextForAnnotationNum(num) {\n    // converts [0-9]+ [A-Z][a-z]*\n    // example: 0=A, 1=B, 25=Z, 26=Aa, 27=Ab\n    // and continues like.. Ba Bb .. Za .. Zz..Aaa...Zzz Aaaa Zzzz\n    var shortText = String.fromCharCode(65 /* A */ + num % 26);\n    num = Math.floor(num / 26);\n    while (num > 0) {\n      shortText = String.fromCharCode(65 /* A */ + (num - 1) % 26) + shortText.toLowerCase();\n      num = Math.floor((num - 1) / 26);\n    }\n    return shortText;\n  };\n\n  var cols = data.getNumberOfColumns();\n  var rows = data.getNumberOfRows();\n\n  var indepType = data.getColumnType(0);\n  if (indepType == 'date' || indepType == 'datetime') {\n    this.attrs_.xValueParser = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"v\" /* dateParser */];\n    this.attrs_.axes.x.valueFormatter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"w\" /* dateValueFormatter */];\n    this.attrs_.axes.x.ticker = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"a\" /* dateTicker */];\n    this.attrs_.axes.x.axisLabelFormatter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"x\" /* dateAxisLabelFormatter */];\n  } else if (indepType == 'number') {\n    this.attrs_.xValueParser = function (x) {\n      return parseFloat(x);\n    };\n    this.attrs_.axes.x.valueFormatter = function (x) {\n      return x;\n    };\n    this.attrs_.axes.x.ticker = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"b\" /* numericTicks */];\n    this.attrs_.axes.x.axisLabelFormatter = this.attrs_.axes.x.valueFormatter;\n  } else {\n    throw new Error(\"only 'date', 'datetime' and 'number' types are supported \" + \"for column 1 of DataTable input (Got '\" + indepType + \"')\");\n  }\n\n  // Array of the column indices which contain data (and not annotations).\n  var colIdx = [];\n  var annotationCols = {}; // data index -> [annotation cols]\n  var hasAnnotations = false;\n  var i, j;\n  for (i = 1; i < cols; i++) {\n    var type = data.getColumnType(i);\n    if (type == 'number') {\n      colIdx.push(i);\n    } else if (type == 'string' && this.getBooleanOption('displayAnnotations')) {\n      // This is OK -- it's an annotation column.\n      var dataIdx = colIdx[colIdx.length - 1];\n      if (!annotationCols.hasOwnProperty(dataIdx)) {\n        annotationCols[dataIdx] = [i];\n      } else {\n        annotationCols[dataIdx].push(i);\n      }\n      hasAnnotations = true;\n    } else {\n      throw new Error(\"Only 'number' is supported as a dependent type with Gviz.\" + \" 'string' is only supported if displayAnnotations is true\");\n    }\n  }\n\n  // Read column labels\n  // TODO(danvk): add support back for errorBars\n  var labels = [data.getColumnLabel(0)];\n  for (i = 0; i < colIdx.length; i++) {\n    labels.push(data.getColumnLabel(colIdx[i]));\n    if (this.getBooleanOption(\"errorBars\")) i += 1;\n  }\n  this.attrs_.labels = labels;\n  cols = labels.length;\n\n  var ret = [];\n  var outOfOrder = false;\n  var annotations = [];\n  for (i = 0; i < rows; i++) {\n    var row = [];\n    if (typeof data.getValue(i, 0) === 'undefined' || data.getValue(i, 0) === null) {\n      console.warn(\"Ignoring row \" + i + \" of DataTable because of undefined or null first column.\");\n      continue;\n    }\n\n    if (indepType == 'date' || indepType == 'datetime') {\n      row.push(data.getValue(i, 0).getTime());\n    } else {\n      row.push(data.getValue(i, 0));\n    }\n    if (!this.getBooleanOption(\"errorBars\")) {\n      for (j = 0; j < colIdx.length; j++) {\n        var col = colIdx[j];\n        row.push(data.getValue(i, col));\n        if (hasAnnotations && annotationCols.hasOwnProperty(col) && data.getValue(i, annotationCols[col][0]) !== null) {\n          var ann = {};\n          ann.series = data.getColumnLabel(col);\n          ann.xval = row[0];\n          ann.shortText = shortTextForAnnotationNum(annotations.length);\n          ann.text = '';\n          for (var k = 0; k < annotationCols[col].length; k++) {\n            if (k) ann.text += \"\\n\";\n            ann.text += data.getValue(i, annotationCols[col][k]);\n          }\n          annotations.push(ann);\n        }\n      }\n\n      // Strip out infinities, which give dygraphs problems later on.\n      for (j = 0; j < row.length; j++) {\n        if (!isFinite(row[j])) row[j] = null;\n      }\n    } else {\n      for (j = 0; j < cols - 1; j++) {\n        row.push([data.getValue(i, 1 + 2 * j), data.getValue(i, 2 + 2 * j)]);\n      }\n    }\n    if (ret.length > 0 && row[0] < ret[ret.length - 1][0]) {\n      outOfOrder = true;\n    }\n    ret.push(row);\n  }\n\n  if (outOfOrder) {\n    console.warn(\"DataTable is out of order; order it correctly to speed loading.\");\n    ret.sort(function (a, b) {\n      return a[0] - b[0];\n    });\n  }\n  this.rawData_ = ret;\n\n  if (annotations.length > 0) {\n    this.setAnnotations(annotations, true);\n  }\n  this.attributes_.reparseSeries();\n};\n\n/**\n * Signals to plugins that the chart data has updated.\n * This happens after the data has updated but before the chart has redrawn.\n * @private\n */\nDygraph.prototype.cascadeDataDidUpdateEvent_ = function () {\n  // TODO(danvk): there are some issues checking xAxisRange() and using\n  // toDomCoords from handlers of this event. The visible range should be set\n  // when the chart is drawn, not derived from the data.\n  this.cascadeEvents_('dataDidUpdate', {});\n};\n\n/**\n * Get the CSV data. If it's in a function, call that function. If it's in a\n * file, do an XMLHttpRequest to get it.\n * @private\n */\nDygraph.prototype.start_ = function () {\n  var data = this.file_;\n\n  // Functions can return references of all other types.\n  if (typeof data == 'function') {\n    data = data();\n  }\n\n  if (__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"B\" /* isArrayLike */](data)) {\n    this.rawData_ = this.parseArray_(data);\n    this.cascadeDataDidUpdateEvent_();\n    this.predraw_();\n  } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) == 'object' && typeof data.getColumnRange == 'function') {\n    // must be a DataTable from gviz.\n    this.parseDataTable_(data);\n    this.cascadeDataDidUpdateEvent_();\n    this.predraw_();\n  } else if (typeof data == 'string') {\n    // Heuristic: a newline means it's CSV data. Otherwise it's an URL.\n    var line_delimiter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"y\" /* detectLineDelimiter */](data);\n    if (line_delimiter) {\n      this.loadedEvent_(data);\n    } else {\n      // REMOVE_FOR_IE\n      var req;\n      if (window.XMLHttpRequest) {\n        // Firefox, Opera, IE7, and other browsers will use the native object\n        req = new XMLHttpRequest();\n      } else {\n        // IE 5 and 6 will use the ActiveX control\n        req = new ActiveXObject(\"Microsoft.XMLHTTP\");\n      }\n\n      var caller = this;\n      req.onreadystatechange = function () {\n        if (req.readyState == 4) {\n          if (req.status === 200 || // Normal http\n          req.status === 0) {\n            // Chrome w/ --allow-file-access-from-files\n            caller.loadedEvent_(req.responseText);\n          }\n        }\n      };\n\n      req.open(\"GET\", data, true);\n      req.send(null);\n    }\n  } else {\n    console.error(\"Unknown data format: \" + (typeof data === 'undefined' ? 'undefined' : _typeof(data)));\n  }\n};\n\n/**\n * Changes various properties of the graph. These can include:\n * <ul>\n * <li>file: changes the source data for the graph</li>\n * <li>errorBars: changes whether the data contains stddev</li>\n * </ul>\n *\n * There's a huge variety of options that can be passed to this method. For a\n * full list, see http://dygraphs.com/options.html.\n *\n * @param {Object} input_attrs The new properties and values\n * @param {boolean} block_redraw Usually the chart is redrawn after every\n *     call to updateOptions(). If you know better, you can pass true to\n *     explicitly block the redraw. This can be useful for chaining\n *     updateOptions() calls, avoiding the occasional infinite loop and\n *     preventing redraws when it's not necessary (e.g. when updating a\n *     callback).\n */\nDygraph.prototype.updateOptions = function (input_attrs, block_redraw) {\n  if (typeof block_redraw == 'undefined') block_redraw = false;\n\n  // copyUserAttrs_ drops the \"file\" parameter as a convenience to us.\n  var file = input_attrs.file;\n  var attrs = Dygraph.copyUserAttrs_(input_attrs);\n\n  // TODO(danvk): this is a mess. Move these options into attr_.\n  if ('rollPeriod' in attrs) {\n    this.rollPeriod_ = attrs.rollPeriod;\n  }\n  if ('dateWindow' in attrs) {\n    this.dateWindow_ = attrs.dateWindow;\n  }\n\n  // TODO(danvk): validate per-series options.\n  // Supported:\n  // strokeWidth\n  // pointSize\n  // drawPoints\n  // highlightCircleSize\n\n  // Check if this set options will require new points.\n  var requiresNewPoints = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"E\" /* isPixelChangingOptionList */](this.attr_(\"labels\"), attrs);\n\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"b\" /* updateDeep */](this.user_attrs_, attrs);\n\n  this.attributes_.reparseSeries();\n\n  if (file) {\n    // This event indicates that the data is about to change, but hasn't yet.\n    // TODO(danvk): support cancellation of the update via this event.\n    this.cascadeEvents_('dataWillUpdate', {});\n\n    this.file_ = file;\n    if (!block_redraw) this.start_();\n  } else {\n    if (!block_redraw) {\n      if (requiresNewPoints) {\n        this.predraw_();\n      } else {\n        this.renderGraph_(false);\n      }\n    }\n  }\n};\n\n/**\n * Make a copy of input attributes, removing file as a convenience.\n * @private\n */\nDygraph.copyUserAttrs_ = function (attrs) {\n  var my_attrs = {};\n  for (var k in attrs) {\n    if (!attrs.hasOwnProperty(k)) continue;\n    if (k == 'file') continue;\n    if (attrs.hasOwnProperty(k)) my_attrs[k] = attrs[k];\n  }\n  return my_attrs;\n};\n\n/**\n * Resizes the dygraph. If no parameters are specified, resizes to fill the\n * containing div (which has presumably changed size since the dygraph was\n * instantiated. If the width/height are specified, the div will be resized.\n *\n * This is far more efficient than destroying and re-instantiating a\n * Dygraph, since it doesn't have to reparse the underlying data.\n *\n * @param {number} width Width (in pixels)\n * @param {number} height Height (in pixels)\n */\nDygraph.prototype.resize = function (width, height) {\n  if (this.resize_lock) {\n    return;\n  }\n  this.resize_lock = true;\n\n  if (width === null != (height === null)) {\n    console.warn(\"Dygraph.resize() should be called with zero parameters or \" + \"two non-NULL parameters. Pretending it was zero.\");\n    width = height = null;\n  }\n\n  var old_width = this.width_;\n  var old_height = this.height_;\n\n  if (width) {\n    this.maindiv_.style.width = width + \"px\";\n    this.maindiv_.style.height = height + \"px\";\n    this.width_ = width;\n    this.height_ = height;\n  } else {\n    this.width_ = this.maindiv_.clientWidth;\n    this.height_ = this.maindiv_.clientHeight;\n  }\n\n  if (old_width != this.width_ || old_height != this.height_) {\n    // Resizing a canvas erases it, even when the size doesn't change, so\n    // any resize needs to be followed by a redraw.\n    this.resizeElements_();\n    this.predraw_();\n  }\n\n  this.resize_lock = false;\n};\n\n/**\n * Adjusts the number of points in the rolling average. Updates the graph to\n * reflect the new averaging period.\n * @param {number} length Number of points over which to average the data.\n */\nDygraph.prototype.adjustRoll = function (length) {\n  this.rollPeriod_ = length;\n  this.predraw_();\n};\n\n/**\n * Returns a boolean array of visibility statuses.\n */\nDygraph.prototype.visibility = function () {\n  // Do lazy-initialization, so that this happens after we know the number of\n  // data series.\n  if (!this.getOption(\"visibility\")) {\n    this.attrs_.visibility = [];\n  }\n  // TODO(danvk): it looks like this could go into an infinite loop w/ user_attrs.\n  while (this.getOption(\"visibility\").length < this.numColumns() - 1) {\n    this.attrs_.visibility.push(true);\n  }\n  return this.getOption(\"visibility\");\n};\n\n/**\n * Changes the visibility of one or more series.\n *\n * @param {number|number[]|object} num the series index or an array of series indices\n *                                     or a boolean array of visibility states by index\n *                                     or an object mapping series numbers, as keys, to\n *                                     visibility state (boolean values)\n * @param {boolean} value the visibility state expressed as a boolean\n */\nDygraph.prototype.setVisibility = function (num, value) {\n  var x = this.visibility();\n  var numIsObject = false;\n\n  if (!Array.isArray(num)) {\n    if (num !== null && (typeof num === 'undefined' ? 'undefined' : _typeof(num)) === 'object') {\n      numIsObject = true;\n    } else {\n      num = [num];\n    }\n  }\n\n  if (numIsObject) {\n    for (var i in num) {\n      if (num.hasOwnProperty(i)) {\n        if (i < 0 || i >= x.length) {\n          console.warn(\"Invalid series number in setVisibility: \" + i);\n        } else {\n          x[i] = num[i];\n        }\n      }\n    }\n  } else {\n    for (var i = 0; i < num.length; i++) {\n      if (typeof num[i] === 'boolean') {\n        if (i >= x.length) {\n          console.warn(\"Invalid series number in setVisibility: \" + i);\n        } else {\n          x[i] = num[i];\n        }\n      } else {\n        if (num[i] < 0 || num[i] >= x.length) {\n          console.warn(\"Invalid series number in setVisibility: \" + num[i]);\n        } else {\n          x[num[i]] = value;\n        }\n      }\n    }\n  }\n\n  this.predraw_();\n};\n\n/**\n * How large of an area will the dygraph render itself in?\n * This is used for testing.\n * @return A {width: w, height: h} object.\n * @private\n */\nDygraph.prototype.size = function () {\n  return { width: this.width_, height: this.height_ };\n};\n\n/**\n * Update the list of annotations and redraw the chart.\n * See dygraphs.com/annotations.html for more info on how to use annotations.\n * @param ann {Array} An array of annotation objects.\n * @param suppressDraw {Boolean} Set to \"true\" to block chart redraw (optional).\n */\nDygraph.prototype.setAnnotations = function (ann, suppressDraw) {\n  // Only add the annotation CSS rule once we know it will be used.\n  this.annotations_ = ann;\n  if (!this.layout_) {\n    console.warn(\"Tried to setAnnotations before dygraph was ready. \" + \"Try setting them in a ready() block. See \" + \"dygraphs.com/tests/annotation.html\");\n    return;\n  }\n\n  this.layout_.setAnnotations(this.annotations_);\n  if (!suppressDraw) {\n    this.predraw_();\n  }\n};\n\n/**\n * Return the list of annotations.\n */\nDygraph.prototype.annotations = function () {\n  return this.annotations_;\n};\n\n/**\n * Get the list of label names for this graph. The first column is the\n * x-axis, so the data series names start at index 1.\n *\n * Returns null when labels have not yet been defined.\n */\nDygraph.prototype.getLabels = function () {\n  var labels = this.attr_(\"labels\");\n  return labels ? labels.slice() : null;\n};\n\n/**\n * Get the index of a series (column) given its name. The first column is the\n * x-axis, so the data series start with index 1.\n */\nDygraph.prototype.indexFromSetName = function (name) {\n  return this.setIndexByName_[name];\n};\n\n/**\n * Find the row number corresponding to the given x-value.\n * Returns null if there is no such x-value in the data.\n * If there are multiple rows with the same x-value, this will return the\n * first one.\n * @param {number} xVal The x-value to look for (e.g. millis since epoch).\n * @return {?number} The row number, which you can pass to getValue(), or null.\n */\nDygraph.prototype.getRowForX = function (xVal) {\n  var low = 0,\n      high = this.numRows() - 1;\n\n  while (low <= high) {\n    var idx = high + low >> 1;\n    var x = this.getValue(idx, 0);\n    if (x < xVal) {\n      low = idx + 1;\n    } else if (x > xVal) {\n      high = idx - 1;\n    } else if (low != idx) {\n      // equal, but there may be an earlier match.\n      high = idx;\n    } else {\n      return idx;\n    }\n  }\n\n  return null;\n};\n\n/**\n * Trigger a callback when the dygraph has drawn itself and is ready to be\n * manipulated. This is primarily useful when dygraphs has to do an XHR for the\n * data (i.e. a URL is passed as the data source) and the chart is drawn\n * asynchronously. If the chart has already drawn, the callback will fire\n * immediately.\n *\n * This is a good place to call setAnnotation().\n *\n * @param {function(!Dygraph)} callback The callback to trigger when the chart\n *     is ready.\n */\nDygraph.prototype.ready = function (callback) {\n  if (this.is_initial_draw_) {\n    this.readyFns_.push(callback);\n  } else {\n    callback.call(this, this);\n  }\n};\n\n/**\n * Add an event handler. This event handler is kept until the graph is\n * destroyed with a call to graph.destroy().\n *\n * @param {!Node} elem The element to add the event to.\n * @param {string} type The type of the event, e.g. 'click' or 'mousemove'.\n * @param {function(Event):(boolean|undefined)} fn The function to call\n *     on the event. The function takes one parameter: the event object.\n * @private\n */\nDygraph.prototype.addAndTrackEvent = function (elem, type, fn) {\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"F\" /* addEvent */](elem, type, fn);\n  this.registeredEvents_.push({ elem: elem, type: type, fn: fn });\n};\n\nDygraph.prototype.removeTrackedEvents_ = function () {\n  if (this.registeredEvents_) {\n    for (var idx = 0; idx < this.registeredEvents_.length; idx++) {\n      var reg = this.registeredEvents_[idx];\n      __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"i\" /* removeEvent */](reg.elem, reg.type, reg.fn);\n    }\n  }\n\n  this.registeredEvents_ = [];\n};\n\n// Installed plugins, in order of precedence (most-general to most-specific).\nDygraph.PLUGINS = [__WEBPACK_IMPORTED_MODULE_19__plugins_legend__[\"a\" /* default */], __WEBPACK_IMPORTED_MODULE_16__plugins_axes__[\"a\" /* default */], __WEBPACK_IMPORTED_MODULE_20__plugins_range_selector__[\"a\" /* default */], // Has to be before ChartLabels so that its callbacks are called after ChartLabels' callbacks.\n__WEBPACK_IMPORTED_MODULE_17__plugins_chart_labels__[\"a\" /* default */], __WEBPACK_IMPORTED_MODULE_15__plugins_annotations__[\"a\" /* default */], __WEBPACK_IMPORTED_MODULE_18__plugins_grid__[\"a\" /* default */]];\n\n// There are many symbols which have historically been available through the\n// Dygraph class. These are exported here for backwards compatibility.\nDygraph.GVizChart = __WEBPACK_IMPORTED_MODULE_21__dygraph_gviz__[\"a\" /* default */];\nDygraph.DASHED_LINE = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"G\" /* DASHED_LINE */];\nDygraph.DOT_DASH_LINE = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"H\" /* DOT_DASH_LINE */];\nDygraph.dateAxisLabelFormatter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"x\" /* dateAxisLabelFormatter */];\nDygraph.toRGB_ = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"t\" /* toRGB_ */];\nDygraph.findPos = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"k\" /* findPos */];\nDygraph.pageX = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"q\" /* pageX */];\nDygraph.pageY = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"r\" /* pageY */];\nDygraph.dateString_ = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"I\" /* dateString_ */];\nDygraph.defaultInteractionModel = __WEBPACK_IMPORTED_MODULE_3__dygraph_interaction_model__[\"a\" /* default */].defaultModel;\nDygraph.nonInteractiveModel = Dygraph.nonInteractiveModel_ = __WEBPACK_IMPORTED_MODULE_3__dygraph_interaction_model__[\"a\" /* default */].nonInteractiveModel_;\nDygraph.Circles = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"u\" /* Circles */];\n\nDygraph.Plugins = {\n  Legend: __WEBPACK_IMPORTED_MODULE_19__plugins_legend__[\"a\" /* default */],\n  Axes: __WEBPACK_IMPORTED_MODULE_16__plugins_axes__[\"a\" /* default */],\n  Annotations: __WEBPACK_IMPORTED_MODULE_15__plugins_annotations__[\"a\" /* default */],\n  ChartLabels: __WEBPACK_IMPORTED_MODULE_17__plugins_chart_labels__[\"a\" /* default */],\n  Grid: __WEBPACK_IMPORTED_MODULE_18__plugins_grid__[\"a\" /* default */],\n  RangeSelector: __WEBPACK_IMPORTED_MODULE_20__plugins_range_selector__[\"a\" /* default */]\n};\n\nDygraph.DataHandlers = {\n  DefaultHandler: __WEBPACK_IMPORTED_MODULE_9__datahandler_default__[\"a\" /* default */],\n  BarsHandler: __WEBPACK_IMPORTED_MODULE_14__datahandler_bars__[\"a\" /* default */],\n  CustomBarsHandler: __WEBPACK_IMPORTED_MODULE_11__datahandler_bars_custom__[\"a\" /* default */],\n  DefaultFractionHandler: __WEBPACK_IMPORTED_MODULE_12__datahandler_default_fractions__[\"a\" /* default */],\n  ErrorBarsHandler: __WEBPACK_IMPORTED_MODULE_10__datahandler_bars_error__[\"a\" /* default */],\n  FractionsBarsHandler: __WEBPACK_IMPORTED_MODULE_13__datahandler_bars_fractions__[\"a\" /* default */]\n};\n\nDygraph.startPan = __WEBPACK_IMPORTED_MODULE_3__dygraph_interaction_model__[\"a\" /* default */].startPan;\nDygraph.startZoom = __WEBPACK_IMPORTED_MODULE_3__dygraph_interaction_model__[\"a\" /* default */].startZoom;\nDygraph.movePan = __WEBPACK_IMPORTED_MODULE_3__dygraph_interaction_model__[\"a\" /* default */].movePan;\nDygraph.moveZoom = __WEBPACK_IMPORTED_MODULE_3__dygraph_interaction_model__[\"a\" /* default */].moveZoom;\nDygraph.endPan = __WEBPACK_IMPORTED_MODULE_3__dygraph_interaction_model__[\"a\" /* default */].endPan;\nDygraph.endZoom = __WEBPACK_IMPORTED_MODULE_3__dygraph_interaction_model__[\"a\" /* default */].endZoom;\n\nDygraph.numericLinearTicks = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"c\" /* numericLinearTicks */];\nDygraph.numericTicks = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"b\" /* numericTicks */];\nDygraph.dateTicker = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"a\" /* dateTicker */];\nDygraph.Granularity = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"d\" /* Granularity */];\nDygraph.getDateAxis = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"e\" /* getDateAxis */];\nDygraph.floatFormat = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"J\" /* floatFormat */];\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Dygraph);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(6)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLmpzP2I0MDgiXSwibmFtZXMiOlsiRHlncmFwaCIsImRpdiIsImRhdGEiLCJvcHRzIiwiX19pbml0X18iLCJOQU1FIiwiVkVSU0lPTiIsIkRFRkFVTFRfUk9MTF9QRVJJT0QiLCJERUZBVUxUX1dJRFRIIiwiREVGQVVMVF9IRUlHSFQiLCJBTklNQVRJT05fU1RFUFMiLCJBTklNQVRJT05fRFVSQVRJT04iLCJQbG90dGVycyIsIkR5Z3JhcGhDYW52YXNSZW5kZXJlciIsIl9QbG90dGVycyIsImFkZGVkQW5ub3RhdGlvbkNTUyIsInByb3RvdHlwZSIsImZpbGUiLCJhdHRycyIsImlzX2luaXRpYWxfZHJhd18iLCJyZWFkeUZuc18iLCJ1bmRlZmluZWQiLCJjb3B5VXNlckF0dHJzXyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJFcnJvciIsIm1haW5kaXZfIiwiZmlsZV8iLCJyb2xsUGVyaW9kXyIsInJvbGxQZXJpb2QiLCJwcmV2aW91c1ZlcnRpY2FsWF8iLCJmcmFjdGlvbnNfIiwiZnJhY3Rpb25zIiwiZGF0ZVdpbmRvd18iLCJkYXRlV2luZG93IiwiYW5ub3RhdGlvbnNfIiwiaW5uZXJIVE1MIiwic3R5bGUiLCJ3aWR0aCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsIndpZHRoXyIsImNsaWVudFdpZHRoIiwiaGVpZ2h0XyIsInN0YWNrZWRHcmFwaCIsImZpbGxHcmFwaCIsInVzZXJfYXR0cnNfIiwidXRpbHMiLCJhdHRyc18iLCJib3VuZGFyeUlkc18iLCJzZXRJbmRleEJ5TmFtZV8iLCJkYXRhc2V0SW5kZXhfIiwicmVnaXN0ZXJlZEV2ZW50c18iLCJldmVudExpc3RlbmVyc18iLCJhdHRyaWJ1dGVzXyIsImNyZWF0ZUludGVyZmFjZV8iLCJwbHVnaW5zXyIsInBsdWdpbnMiLCJQTFVHSU5TIiwiY29uY2F0IiwiZ2V0T3B0aW9uIiwiaSIsImxlbmd0aCIsIlBsdWdpbiIsInBsdWdpbkluc3RhbmNlIiwiYWN0aXZhdGUiLCJwbHVnaW5EaWN0IiwicGx1Z2luIiwiZXZlbnRzIiwib3B0aW9ucyIsInBsdWdpbk9wdGlvbnMiLCJoYW5kbGVycyIsImV2ZW50TmFtZSIsImhhc093blByb3BlcnR5IiwicHVzaCIsInBsdWdpbl9kaWN0IiwiY2FsbGJhY2siLCJwYWlyIiwiY3JlYXRlRHJhZ0ludGVyZmFjZV8iLCJzdGFydF8iLCJjYXNjYWRlRXZlbnRzXyIsIm5hbWUiLCJleHRyYV9wcm9wcyIsImUiLCJkeWdyYXBoIiwiY2FuY2VsYWJsZSIsImRlZmF1bHRQcmV2ZW50ZWQiLCJwcmV2ZW50RGVmYXVsdCIsInByb3BhZ2F0aW9uU3RvcHBlZCIsInN0b3BQcm9wYWdhdGlvbiIsImNhbGxiYWNrX3BsdWdpbl9wYWlycyIsImNhbGwiLCJnZXRQbHVnaW5JbnN0YW5jZV8iLCJ0eXBlIiwicCIsImlzWm9vbWVkIiwiYXhpcyIsImlzWm9vbWVkWCIsImlzWm9vbWVkWSIsImF4ZXNfIiwibWFwIiwidmFsdWVSYW5nZSIsImluZGV4T2YiLCJ0b1N0cmluZyIsIm1haW5kaXYiLCJpZCIsImF0dHJfIiwic2VyaWVzTmFtZSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImNvbnNvbGUiLCJlcnJvciIsIk9QVElPTlNfUkVGRVJFTkNFIiwiZ2V0Rm9yU2VyaWVzIiwiZ2V0Iiwib3B0X3Nlcmllc05hbWUiLCJnZXROdW1lcmljT3B0aW9uIiwiZ2V0U3RyaW5nT3B0aW9uIiwiZ2V0Qm9vbGVhbk9wdGlvbiIsImdldEZ1bmN0aW9uT3B0aW9uIiwiZ2V0T3B0aW9uRm9yQXhpcyIsImdldEZvckF4aXMiLCJvcHRpb25zVmlld0ZvckF4aXNfIiwic2VsZiIsIm9wdCIsImF4aXNfb3B0cyIsImF4ZXMiLCJ4QXhpc1JhbmdlIiwieEF4aXNFeHRyZW1lcyIsInBhZCIsInBsb3R0ZXJfIiwiYXJlYSIsInciLCJudW1Sb3dzIiwibGVmdCIsInJhd0RhdGFfIiwicmlnaHQiLCJyYW5nZSIsInlBeGlzRXh0cmVtZXMiLCJwYWNrZWQiLCJnYXRoZXJEYXRhc2V0c18iLCJyb2xsZWRTZXJpZXNfIiwiZXh0cmVtZXMiLCJzYXZlQXhlcyIsImNvbXB1dGVZQXhpc1Jhbmdlc18iLCJuZXdBeGVzIiwiZXh0cmVtZVJhbmdlIiwieUF4aXNSYW5nZSIsImlkeCIsImNvbXB1dGVkVmFsdWVSYW5nZSIsInlBeGlzUmFuZ2VzIiwicmV0IiwidG9Eb21Db29yZHMiLCJ4IiwieSIsInRvRG9tWENvb3JkIiwidG9Eb21ZQ29vcmQiLCJ4UmFuZ2UiLCJwY3QiLCJ0b1BlcmNlbnRZQ29vcmQiLCJoIiwidG9EYXRhQ29vcmRzIiwidG9EYXRhWENvb3JkIiwidG9EYXRhWUNvb3JkIiwieVJhbmdlIiwibG9nc2NhbGUiLCJsb2dyMCIsImxvZ3IxIiwidG9QZXJjZW50WENvb3JkIiwibnVtQ29sdW1ucyIsImdldFZhbHVlIiwicm93IiwiY29sIiwiZW5jbG9zaW5nIiwiZ3JhcGhEaXYiLCJjcmVhdGVFbGVtZW50IiwidGV4dEFsaWduIiwicG9zaXRpb24iLCJhcHBlbmRDaGlsZCIsImNhbnZhc18iLCJoaWRkZW5fIiwiY3JlYXRlUGxvdEtpdENhbnZhc18iLCJjYW52YXNfY3R4XyIsImhpZGRlbl9jdHhfIiwicmVzaXplRWxlbWVudHNfIiwibW91c2VFdmVudEVsZW1lbnRfIiwiY3JlYXRlTW91c2VFdmVudEVsZW1lbnRfIiwibGF5b3V0XyIsIm1vdXNlTW92ZUhhbmRsZXJfIiwibW91c2VNb3ZlXyIsIm1vdXNlT3V0SGFuZGxlcl8iLCJ0YXJnZXQiLCJmcm9tRWxlbWVudCIsInJlbGF0ZWRUYXJnZXQiLCJ0b0VsZW1lbnQiLCJtb3VzZU91dF8iLCJhZGRBbmRUcmFja0V2ZW50Iiwid2luZG93IiwicmVzaXplSGFuZGxlcl8iLCJyZXNpemUiLCJwaXhlbFJhdGlvT3B0aW9uIiwiY2FudmFzU2NhbGUiLCJzY2FsZSIsImhpZGRlblNjYWxlIiwiZGVzdHJveSIsInJlc3RvcmUiLCJwb3AiLCJyZW1vdmVSZWN1cnNpdmUiLCJub2RlIiwiaGFzQ2hpbGROb2RlcyIsImZpcnN0Q2hpbGQiLCJyZW1vdmVDaGlsZCIsInJlbW92ZVRyYWNrZWRFdmVudHNfIiwibnVsbE91dCIsIm9iaiIsIm4iLCJjYW52YXMiLCJ0b3AiLCJzZXRDb2xvcnNfIiwibGFiZWxzIiwiZ2V0TGFiZWxzIiwibnVtIiwiY29sb3JzXyIsImNvbG9yc01hcF8iLCJzYXQiLCJ2YWwiLCJoYWxmIiwiTWF0aCIsImNlaWwiLCJjb2xvcnMiLCJ2aXNpYmlsaXR5IiwibGFiZWwiLCJjb2xvclN0ciIsImh1ZSIsImdldENvbG9ycyIsImdldFByb3BlcnRpZXNGb3JTZXJpZXMiLCJzZXJpZXNfbmFtZSIsImNvbHVtbiIsInZpc2libGUiLCJjb2xvciIsImF4aXNGb3JTZXJpZXMiLCJjcmVhdGVSb2xsSW50ZXJmYWNlXyIsInJvbGxlciIsInJvbGxlcl8iLCJkaXNwbGF5IiwiY2xhc3NOYW1lIiwiZ2V0QXJlYSIsInRleHRBdHRyIiwic2l6ZSIsInZhbHVlIiwib25jaGFuZ2UiLCJhZGp1c3RSb2xsIiwiY29udGV4dCIsImlzWm9vbWluZyIsImlzUGFubmluZyIsImlzMkRQYW4iLCJkcmFnU3RhcnRYIiwiZHJhZ1N0YXJ0WSIsImRyYWdFbmRYIiwiZHJhZ0VuZFkiLCJkcmFnRGlyZWN0aW9uIiwicHJldkVuZFgiLCJwcmV2RW5kWSIsInByZXZEcmFnRGlyZWN0aW9uIiwiY2FuY2VsTmV4dERibGNsaWNrIiwiaW5pdGlhbExlZnRtb3N0RGF0ZSIsInhVbml0c1BlclBpeGVsIiwiZGF0ZVJhbmdlIiwicHgiLCJweSIsImJvdW5kZWREYXRlcyIsImJvdW5kZWRWYWx1ZXMiLCJ0YXJwIiwiaW5pdGlhbGl6ZU1vdXNlRG93biIsImV2ZW50IiwiZyIsImNvbnRleHRCIiwicmV0dXJuVmFsdWUiLCJjYW5jZWxCdWJibGUiLCJjYW52YXNQb3MiLCJjb3ZlciIsImRyYWdnaW5nRGF0ZSIsImRyYWdnaW5nVmFsdWUiLCJkcmFnVmFsdWVSYW5nZSIsInVuY292ZXIiLCJpbnRlcmFjdGlvbk1vZGVsIiwiYmluZEhhbmRsZXIiLCJoYW5kbGVyIiwid2lsbERlc3Ryb3lDb250ZXh0TXlzZWxmIiwibW91c2VVcEhhbmRsZXIiLCJkcmF3Wm9vbVJlY3RfIiwiZGlyZWN0aW9uIiwic3RhcnRYIiwiZW5kWCIsInN0YXJ0WSIsImVuZFkiLCJwcmV2RGlyZWN0aW9uIiwiY3R4IiwiY2xlYXJSZWN0IiwibWluIiwiZ2V0UGxvdEFyZWEiLCJhYnMiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImNsZWFyWm9vbVJlY3RfIiwiY3VycmVudFpvb21SZWN0QXJnc18iLCJkb1pvb21YXyIsImxvd1giLCJoaWdoWCIsIm1pbkRhdGUiLCJtYXhEYXRlIiwiZG9ab29tWERhdGVzXyIsIm9sZF93aW5kb3ciLCJuZXdfd2luZG93Iiwiem9vbUNhbGxiYWNrIiwiZG9BbmltYXRlZFpvb20iLCJkb1pvb21ZXyIsImxvd1kiLCJoaWdoWSIsIm9sZFZhbHVlUmFuZ2VzIiwibmV3VmFsdWVSYW5nZXMiLCJoaSIsImxvdyIsIm1pblgiLCJtYXhYIiwiem9vbUFuaW1hdGlvbkZ1bmN0aW9uIiwiZnJhbWUiLCJudW1GcmFtZXMiLCJrIiwicG93IiwicmVzZXRab29tIiwiZGlydHlYIiwiZGlydHlZIiwiZGlydHkiLCJjbGVhclNlbGVjdGlvbiIsImFuaW1hdGVkWm9vbXMiLCJmb3JFYWNoIiwiZHJhd0dyYXBoXyIsIm9sZFdpbmRvdyIsIm5ld1dpbmRvdyIsIm9sZFhSYW5nZSIsIm5ld1hSYW5nZSIsIm9sZFlSYW5nZXMiLCJuZXdZUmFuZ2VzIiwic3RlcHMiLCJ3aW5kb3dzIiwidmFsdWVSYW5nZXMiLCJzdGVwIiwiZnJhYyIsInRoaXNSYW5nZSIsImoiLCJldmVudFRvRG9tQ29vcmRzIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJldmVudEVsZW1lbnRQb3MiLCJjYW52YXN4IiwiY2FudmFzeSIsImZpbmRDbG9zZXN0Um93IiwiZG9tWCIsIm1pbkRpc3RYIiwiSW5maW5pdHkiLCJjbG9zZXN0Um93Iiwic2V0cyIsInBvaW50cyIsImxlbiIsInBvaW50IiwiZGlzdCIsImZpbmRDbG9zZXN0UG9pbnQiLCJkb21ZIiwibWluRGlzdCIsImR4IiwiZHkiLCJjbG9zZXN0UG9pbnQiLCJjbG9zZXN0U2VyaWVzIiwic2V0SWR4Iiwic2V0TmFtZXMiLCJmaW5kU3RhY2tlZFBvaW50IiwiYm91bmRhcnkiLCJnZXRMZWZ0Qm91bmRhcnlfIiwicm93SWR4IiwicDEiLCJwMiIsInIiLCJwMCIsImNhbnZhc0Nvb3JkcyIsImhpZ2hsaWdodFNlcmllc09wdHMiLCJzZWxlY3Rpb25DaGFuZ2VkIiwiaXNTZXJpZXNMb2NrZWQiLCJjbG9zZXN0Iiwic2V0U2VsZWN0aW9uIiwibGFzdHhfIiwic2VsUG9pbnRzXyIsImxhc3RSb3dfIiwiaGlnaGxpZ2h0U2V0XyIsImFuaW1hdGVTZWxlY3Rpb25fIiwidG90YWxTdGVwcyIsIm1pbGxpcyIsImZhZGVMZXZlbCIsImFuaW1hdGVJZCIsInN0YXJ0IiwidXBkYXRlU2VsZWN0aW9uXyIsInRoaXNJZCIsInRoYXQiLCJjbGVhbnVwSWZDbGVhcmluZyIsIm9wdF9hbmltRnJhY3Rpb24iLCJzZWxlY3RlZFJvdyIsInNlbGVjdGVkWCIsInNlbGVjdGVkUG9pbnRzIiwiYWxwaGEiLCJiYWNrZ3JvdW5kQ29sb3IiLCJhbmltYXRlQmFja2dyb3VuZEZhZGUiLCJiIiwiX3JlbmRlckxpbmVDaGFydCIsIm1heENpcmNsZVNpemUiLCJzYXZlIiwicHQiLCJpc05hTiIsImNpcmNsZVNpemUiLCJERUZBVUxUIiwibGluZVdpZHRoIiwic3Ryb2tlU3R5bGUiLCJvcHRfbG9ja2VkIiwiY2hhbmdlZCIsInNldFJvdyIsInl2YWwiLCJwb2ludElkeCIsInh2YWwiLCJsb2NrZWRTZXRfIiwiZ2V0U2VsZWN0aW9uIiwiZ2V0SGlnaGxpZ2h0U2VyaWVzIiwibG9hZGVkRXZlbnRfIiwicGFyc2VDU1ZfIiwiY2FzY2FkZURhdGFEaWRVcGRhdGVFdmVudF8iLCJwcmVkcmF3XyIsImFkZFhUaWNrc18iLCJ4QXhpc09wdGlvbnNWaWV3IiwieFRpY2tzIiwic2V0WFRpY2tzIiwiZ2V0SGFuZGxlckNsYXNzXyIsImhhbmRsZXJDbGFzcyIsIkRhdGUiLCJkYXRhSGFuZGxlcl8iLCJjb21wdXRlUGxvdEFyZWEiLCJjb21wdXRlWUF4ZXNfIiwic2VyaWVzIiwiZXh0cmFjdFNlcmllcyIsInJvbGxpbmdBdmVyYWdlIiwiZW5kIiwiZHJhd2luZ1RpbWVNc18iLCJQb2ludFR5cGUiLCJzdGFja1BvaW50c18iLCJjdW11bGF0aXZlWXZhbCIsInNlcmllc0V4dHJlbWVzIiwiZmlsbE1ldGhvZCIsImxhc3RYdmFsIiwicHJldlBvaW50IiwibmV4dFBvaW50IiwibmV4dFBvaW50SWR4IiwidXBkYXRlTmV4dFBvaW50IiwiYWN0dWFsWXZhbCIsInN0YWNrZWRZdmFsIiwieXZhbF9zdGFja2VkIiwicm9sbGVkU2VyaWVzIiwiYm91bmRhcnlJZHMiLCJzZXJpZXNJZHgiLCJzYW1wbGVJZHgiLCJmaXJzdElkeCIsImxhc3RJZHgiLCJheGlzSWR4IiwibnVtX3NlcmllcyIsImhpZ2giLCJjb3JyZWN0ZWRGaXJzdElkeCIsImlzSW52YWxpZFZhbHVlIiwiY29ycmVjdGVkTGFzdElkeCIsInNsaWNlIiwiZ2V0RXh0cmVtZVlWYWx1ZXMiLCJzZXJpZXNQb2ludHMiLCJzZXJpZXNUb1BvaW50cyIsImlzX2luaXRpYWxfZHJhdyIsInJlbW92ZUFsbERhdGFzZXRzIiwicG9pbnRTaXplIiwiZGF0YUlkeCIsImFkZERhdGFzZXQiLCJzZXRZQXhlcyIsImV2YWx1YXRlIiwicmVuZGVyR3JhcGhfIiwibG9nIiwiY2xlYXIiLCJ1bmRlcmxheUNhbGxiYWNrIiwiZHJhd2luZ0NvbnRleHQiLCJyZW5kZXIiLCJnZXRDb250ZXh0IiwiZHJhd0NhbGxiYWNrIiwicmVhZHlGaXJlZF8iLCJmbiIsImluZGV4IiwidiIsIm51bUF4ZXMiLCJheGlzT3B0aW9ucyIsInkyIiwiYXhpc1Byb3BlcnRpZXNGb3JTZXJpZXMiLCJpc051bGxVbmRlZmluZWRPck5hTiIsInBhcnNlRmxvYXQiLCJ5cGFkQ29tcGF0Iiwic3BhbiIsInlwYWQiLCJwX2F4aXMiLCJpbmNsdWRlWmVybyIsImluZGVwZW5kZW50VGlja3MiLCJzZXJpZXNGb3JBeGlzIiwieVJhbmdlUGFkIiwibWluWSIsIm1heFkiLCJleHRyZW1lTWluWSIsImV4dHJlbWVNYXhZIiwibWF4IiwibWF4QXhpc1kiLCJtaW5BeGlzWSIsInkwIiwieTEiLCJ5MHBjdCIsInkxcGN0IiwidGlja2VyIiwidGlja3MiLCJwX3RpY2tzIiwicF9zY2FsZSIsInRpY2tfdmFsdWVzIiwieV9mcmFjIiwieV92YWwiLCJkZXRlY3RUeXBlRnJvbVN0cmluZ18iLCJzdHIiLCJpc0RhdGUiLCJkYXNoUG9zIiwic2V0WEF4aXNPcHRpb25zXyIsInhWYWx1ZVBhcnNlciIsInZhbHVlRm9ybWF0dGVyIiwiYXhpc0xhYmVsRm9ybWF0dGVyIiwibGluZV9kZWxpbWl0ZXIiLCJsaW5lcyIsInNwbGl0IiwidmFscyIsImRlbGltIiwicmVwYXJzZVNlcmllcyIsImxpbmVfbm8iLCJ4UGFyc2VyIiwiZGVmYXVsdFBhcnNlclNldCIsImV4cGVjdGVkQ29scyIsIm91dE9mT3JkZXIiLCJsaW5lIiwiaW5GaWVsZHMiLCJmaWVsZHMiLCJ0ZXN0Iiwid2FybiIsImFsbF9udWxsIiwic29ydCIsImEiLCJ2YWxpZGF0ZU5hdGl2ZUZvcm1hdCIsImZpcnN0Um93IiwiZmlyc3RYIiwicGFyc2VBcnJheV8iLCJudW1fbGFiZWxzIiwicGFyc2VkRGF0YSIsImdldFRpbWUiLCJwYXJzZURhdGFUYWJsZV8iLCJzaG9ydFRleHRGb3JBbm5vdGF0aW9uTnVtIiwic2hvcnRUZXh0IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZmxvb3IiLCJ0b0xvd2VyQ2FzZSIsImNvbHMiLCJnZXROdW1iZXJPZkNvbHVtbnMiLCJyb3dzIiwiZ2V0TnVtYmVyT2ZSb3dzIiwiaW5kZXBUeXBlIiwiZ2V0Q29sdW1uVHlwZSIsImNvbElkeCIsImFubm90YXRpb25Db2xzIiwiaGFzQW5ub3RhdGlvbnMiLCJnZXRDb2x1bW5MYWJlbCIsImFubm90YXRpb25zIiwiYW5uIiwidGV4dCIsImlzRmluaXRlIiwic2V0QW5ub3RhdGlvbnMiLCJnZXRDb2x1bW5SYW5nZSIsInJlcSIsIlhNTEh0dHBSZXF1ZXN0IiwiQWN0aXZlWE9iamVjdCIsImNhbGxlciIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJzdGF0dXMiLCJyZXNwb25zZVRleHQiLCJvcGVuIiwic2VuZCIsInVwZGF0ZU9wdGlvbnMiLCJpbnB1dF9hdHRycyIsImJsb2NrX3JlZHJhdyIsInJlcXVpcmVzTmV3UG9pbnRzIiwibXlfYXR0cnMiLCJyZXNpemVfbG9jayIsIm9sZF93aWR0aCIsIm9sZF9oZWlnaHQiLCJzZXRWaXNpYmlsaXR5IiwibnVtSXNPYmplY3QiLCJBcnJheSIsImlzQXJyYXkiLCJzdXBwcmVzc0RyYXciLCJpbmRleEZyb21TZXROYW1lIiwiZ2V0Um93Rm9yWCIsInhWYWwiLCJyZWFkeSIsImVsZW0iLCJyZWciLCJHVml6Q2hhcnQiLCJEQVNIRURfTElORSIsIkRPVF9EQVNIX0xJTkUiLCJkYXRlQXhpc0xhYmVsRm9ybWF0dGVyIiwidG9SR0JfIiwiZmluZFBvcyIsInBhZ2VYIiwicGFnZVkiLCJkYXRlU3RyaW5nXyIsImRlZmF1bHRJbnRlcmFjdGlvbk1vZGVsIiwiRHlncmFwaEludGVyYWN0aW9uIiwiZGVmYXVsdE1vZGVsIiwibm9uSW50ZXJhY3RpdmVNb2RlbCIsIm5vbkludGVyYWN0aXZlTW9kZWxfIiwiQ2lyY2xlcyIsIlBsdWdpbnMiLCJMZWdlbmQiLCJBeGVzIiwiQW5ub3RhdGlvbnMiLCJDaGFydExhYmVscyIsIkdyaWQiLCJSYW5nZVNlbGVjdG9yIiwiUmFuZ2VTZWxlY3RvclBsdWdpbiIsIkRhdGFIYW5kbGVycyIsIkRlZmF1bHRIYW5kbGVyIiwiQmFyc0hhbmRsZXIiLCJDdXN0b21CYXJzSGFuZGxlciIsIkRlZmF1bHRGcmFjdGlvbkhhbmRsZXIiLCJFcnJvckJhcnNIYW5kbGVyIiwiRnJhY3Rpb25zQmFyc0hhbmRsZXIiLCJzdGFydFBhbiIsInN0YXJ0Wm9vbSIsIm1vdmVQYW4iLCJtb3ZlWm9vbSIsImVuZFBhbiIsImVuZFpvb20iLCJudW1lcmljTGluZWFyVGlja3MiLCJudW1lcmljVGlja3MiLCJkYXRlVGlja2VyIiwiR3JhbnVsYXJpdHkiLCJnZXREYXRlQXhpcyIsImZsb2F0Rm9ybWF0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7QUFNQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBY0EsSUFBSUEsVUFBVSxTQUFWQSxPQUFVLENBQVNDLEdBQVQsRUFBY0MsSUFBZCxFQUFvQkMsSUFBcEIsRUFBMEI7QUFDdEMsT0FBS0MsUUFBTCxDQUFjSCxHQUFkLEVBQW1CQyxJQUFuQixFQUF5QkMsSUFBekI7QUFDRCxDQUZEOztBQUlBSCxRQUFRSyxJQUFSLEdBQWUsU0FBZjtBQUNBTCxRQUFRTSxPQUFSLEdBQWtCLE9BQWxCOztBQUVBO0FBQ0FOLFFBQVFPLG1CQUFSLEdBQThCLENBQTlCO0FBQ0FQLFFBQVFRLGFBQVIsR0FBd0IsR0FBeEI7QUFDQVIsUUFBUVMsY0FBUixHQUF5QixHQUF6Qjs7QUFFQTtBQUNBVCxRQUFRVSxlQUFSLEdBQTBCLEVBQTFCO0FBQ0FWLFFBQVFXLGtCQUFSLEdBQTZCLEdBQTdCOztBQUVBOzs7Ozs7Ozs7O0FBVUFYLFFBQVFZLFFBQVIsR0FBbUIsZ0VBQUFDLENBQXNCQyxTQUF6Qzs7QUFHQTtBQUNBZCxRQUFRZSxrQkFBUixHQUE2QixLQUE3Qjs7QUFFQTs7Ozs7Ozs7O0FBU0FmLFFBQVFnQixTQUFSLENBQWtCWixRQUFsQixHQUE2QixVQUFTSCxHQUFULEVBQWNnQixJQUFkLEVBQW9CQyxL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YSx1RUFKRztBQUtoQkMsUUFBTSwrREFMVTtBQU1oQkMsaUJBQWUseUVBQUFDO0FBTkMsQ0FBbEI7O0FBU0E5bkIsUUFBUStuQixZQUFSLEdBQXVCO0FBQ3JCQyxrQkFBQSxxRUFEcUI7QUFFckJDLGVBQUEsbUVBRnFCO0FBR3JCQyxxQkFBQSwwRUFIcUI7QUFJckJDLDBCQUFBLGdGQUpxQjtBQUtyQkMsb0JBQUEseUVBTHFCO0FBTXJCQyx3QkFBQSw2RUFBQUE7QUFOcUIsQ0FBdkI7O0FBU0Fyb0IsUUFBUXNvQixRQUFSLEdBQW1CLDJFQUFBcEIsQ0FBbUJvQixRQUF0QztBQUNBdG9CLFFBQVF1b0IsU0FBUixHQUFvQiwyRUFBQXJCLENBQW1CcUIsU0FBdkM7QUFDQXZvQixRQUFRd29CLE9BQVIsR0FBa0IsMkVBQUF0QixDQUFtQnNCLE9BQXJDO0FBQ0F4b0IsUUFBUXlvQixRQUFSLEdBQW1CLDJFQUFBdkIsQ0FBbUJ1QixRQUF0QztBQUNBem9CLFFBQVEwb0IsTUFBUixHQUFpQiwyRUFBQXhCLENBQW1Cd0IsTUFBcEM7QUFDQTFvQixRQUFRMm9CLE9BQVIsR0FBa0IsMkVBQUF6QixDQUFtQnlCLE9BQXJDOztBQUVBM29CLFFBQVE0b0Isa0JBQVIsR0FBNkIsNEVBQTdCO0FBQ0E1b0IsUUFBUTZvQixZQUFSLEdBQXVCLHNFQUF2QjtBQUNBN29CLFFBQVE4b0IsVUFBUixHQUFxQixvRUFBckI7QUFDQTlvQixRQUFRK29CLFdBQVIsR0FBc0IscUVBQXRCO0FBQ0Evb0IsUUFBUWdwQixXQUFSLEdBQXNCLHFFQUF0QjtBQUNBaHBCLFFBQVFpcEIsV0FBUixHQUFzQixtRUFBdEI7O0FBRUEseURBQWVqcEIsT0FBZixFIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAwNiBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDcmVhdGVzIGFuIGludGVyYWN0aXZlLCB6b29tYWJsZSBncmFwaCBiYXNlZCBvbiBhIENTViBmaWxlIG9yXG4gKiBzdHJpbmcuIER5Z3JhcGggY2FuIGhhbmRsZSBtdWx0aXBsZSBzZXJpZXMgd2l0aCBvciB3aXRob3V0IGVycm9yIGJhcnMuIFRoZVxuICogZGF0ZS92YWx1ZSByYW5nZXMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNldC4gRHlncmFwaCB1c2VzIHRoZVxuICogJmx0O2NhbnZhcyZndDsgdGFnLCBzbyBpdCBvbmx5IHdvcmtzIGluIEZGMS41Ky5cbiAqIEBhdXRob3IgZGFudmRrQGdtYWlsLmNvbSAoRGFuIFZhbmRlcmthbSlcblxuICBVc2FnZTpcbiAgIDxkaXYgaWQ9XCJncmFwaGRpdlwiIHN0eWxlPVwid2lkdGg6ODAwcHg7IGhlaWdodDo1MDBweDtcIj48L2Rpdj5cbiAgIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiPlxuICAgICBuZXcgRHlncmFwaChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdyYXBoZGl2XCIpLFxuICAgICAgICAgICAgICAgICBcImRhdGFmaWxlLmNzdlwiLCAgLy8gQ1NWIGZpbGUgd2l0aCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgIHsgfSk7IC8vIG9wdGlvbnNcbiAgIDwvc2NyaXB0PlxuXG4gVGhlIENTViBmaWxlIGlzIG9mIHRoZSBmb3JtXG5cbiAgIERhdGUsU2VyaWVzQSxTZXJpZXNCLFNlcmllc0NcbiAgIFlZWVlNTURELEExLEIxLEMxXG4gICBZWVlZTU1ERCxBMixCMixDMlxuXG4gSWYgdGhlICdlcnJvckJhcnMnIG9wdGlvbiBpcyBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yLCB0aGUgaW5wdXQgc2hvdWxkIGJlIG9mXG4gdGhlIGZvcm1cbiAgIERhdGUsU2VyaWVzQSxTZXJpZXNCLC4uLlxuICAgWVlZWU1NREQsQTEsc2lnbWFBMSxCMSxzaWdtYUIxLC4uLlxuICAgWVlZWU1NREQsQTIsc2lnbWFBMixCMixzaWdtYUIyLC4uLlxuXG4gSWYgdGhlICdmcmFjdGlvbnMnIG9wdGlvbiBpcyBzZXQsIHRoZSBpbnB1dCBzaG91bGQgYmUgb2YgdGhlIGZvcm06XG5cbiAgIERhdGUsU2VyaWVzQSxTZXJpZXNCLC4uLlxuICAgWVlZWU1NREQsQTEvQjEsQTIvQjIsLi4uXG4gICBZWVlZTU1ERCxBMS9CMSxBMi9CMiwuLi5cblxuIEFuZCBlcnJvciBiYXJzIHdpbGwgYmUgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IHVzaW5nIGEgYmlub21pYWwgZGlzdHJpYnV0aW9uLlxuXG4gRm9yIGZ1cnRoZXIgZG9jdW1lbnRhdGlvbiBhbmQgZXhhbXBsZXMsIHNlZSBodHRwOi8vZHlncmFwaHMuY29tL1xuICovXG5cbmltcG9ydCBEeWdyYXBoTGF5b3V0IGZyb20gJy4vZHlncmFwaC1sYXlvdXQnO1xuaW1wb3J0IER5Z3JhcGhDYW52YXNSZW5kZXJlciBmcm9tICcuL2R5Z3JhcGgtY2FudmFzJztcbmltcG9ydCBEeWdyYXBoT3B0aW9ucyBmcm9tICcuL2R5Z3JhcGgtb3B0aW9ucyc7XG5pbXBvcnQgRHlncmFwaEludGVyYWN0aW9uIGZyb20gJy4vZHlncmFwaC1pbnRlcmFjdGlvbi1tb2RlbCc7XG5pbXBvcnQgKiBhcyBEeWdyYXBoVGlja2VycyBmcm9tICcuL2R5Z3JhcGgtdGlja2Vycyc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2R5Z3JhcGgtdXRpbHMnO1xuaW1wb3J0IERFRkFVTFRfQVRUUlMgZnJvbSAnLi9keWdyYXBoLWRlZmF1bHQtYXR0cnMnO1xuaW1wb3J0IE9QVElPTlNfUkVGRVJFTkNFIGZyb20gJy4vZHlncmFwaC1vcHRpb25zLXJlZmVyZW5jZSc7XG5pbXBvcnQgSUZyYW1lVGFycCBmcm9tICcuL2lmcmFtZS10YXJwJztcblxuaW1wb3J0IERlZmF1bHRIYW5kbGVyIGZyb20gJy4vZGF0YWhhbmRsZXIvZGVmYXVsdCc7XG5pbXBvcnQgRXJyb3JCYXJzSGFuZGxlciBmcm9tICcuL2RhdGFoYW5kbGVyL2JhcnMtZXJyb3InO1xuaW1wb3J0IEN1c3RvbUJhcnNIYW5kbGVyIGZyb20gJy4vZGF0YWhhbmRsZXIvYmFycy1jdXN0b20nO1xuaW1wb3J0IERlZmF1bHRGcmFjdGlvbkhhbmRsZXIgZnJvbSAnLi9kYXRhaGFuZGxlci9kZWZhdWx0LWZyYWN0aW9ucyc7XG5pbXBvcnQgRnJhY3Rpb25zQmFyc0hhbmRsZXIgZnJvbSAnLi9kYXRhaGFuZGxlci9iYXJzLWZyYWN0aW9ucyc7XG5pbXBvcnQgQmFyc0hhbmRsZXIgZnJvbSAnLi9kYXRhaGFuZGxlci9iYXJzJztcblxuaW1wb3J0IEFubm90YXRpb25zUGx1Z2luIGZyb20gJy4vcGx1Z2lucy9hbm5vdGF0aW9ucyc7XG5pbXBvcnQgQXhlc1BsdWdpbiBmcm9tICcuL3BsdWdpbnMvYXhlcyc7XG5pbXBvcnQgQ2hhcnRMYWJlbHNQbHVnaW4gZnJvbSAnLi9wbHVnaW5zL2NoYXJ0LWxhYmVscyc7XG5pbXBvcnQgR3JpZFBsdWdpbiBmcm9tICcuL3BsdWdpbnMvZ3JpZCc7XG5pbXBvcnQgTGVnZW5kUGx1Z2luIGZyb20gJy4vcGx1Z2lucy9sZWdlbmQnO1xuaW1wb3J0IFJhbmdlU2VsZWN0b3JQbHVnaW4gZnJvbSAnLi9wbHVnaW5zL3JhbmdlLXNlbGVjdG9yJztcblxuaW1wb3J0IEdWaXpDaGFydCBmcm9tICcuL2R5Z3JhcGgtZ3Zpeic7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gaW50ZXJhY3RpdmUsIHpvb21hYmxlIGNoYXJ0LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtkaXYgfCBTdHJpbmd9IGRpdiBBIGRpdiBvciB0aGUgaWQgb2YgYSBkaXYgaW50byB3aGljaCB0byBjb25zdHJ1Y3RcbiAqIHRoZSBjaGFydC5cbiAqIEBwYXJhbSB7U3RyaW5nIHwgRnVuY3Rpb259IGZpbGUgQSBmaWxlIGNvbnRhaW5pbmcgQ1NWIGRhdGEgb3IgYSBmdW5jdGlvblxuICogdGhhdCByZXR1cm5zIHRoaXMgZGF0YS4gVGhlIG1vc3QgYmFzaWMgZXhwZWN0ZWQgZm9ybWF0IGZvciBlYWNoIGxpbmUgaXNcbiAqIFwiWVlZWS9NTS9ERCx2YWwxLHZhbDIsLi4uXCIuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbiAqIGh0dHA6Ly9keWdyYXBocy5jb20vZGF0YS5odG1sLlxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIFZhcmlvdXMgb3RoZXIgYXR0cmlidXRlcywgZS5nLiBlcnJvckJhcnMgZGV0ZXJtaW5lc1xuICogd2hldGhlciB0aGUgaW5wdXQgZGF0YSBjb250YWlucyBlcnJvciByYW5nZXMuIEZvciBhIGNvbXBsZXRlIGxpc3Qgb2ZcbiAqIG9wdGlvbnMsIHNlZSBodHRwOi8vZHlncmFwaHMuY29tL29wdGlvbnMuaHRtbC5cbiAqL1xudmFyIER5Z3JhcGggPSBmdW5jdGlvbihkaXYsIGRhdGEsIG9wdHMpIHtcbiAgdGhpcy5fX2luaXRfXyhkaXYsIGRhdGEsIG9wdHMpO1xufTtcblxuRHlncmFwaC5OQU1FID0gXCJEeWdyYXBoXCI7XG5EeWdyYXBoLlZFUlNJT04gPSBcIjIuMC4wXCI7XG5cbi8vIFZhcmlvdXMgZGVmYXVsdCB2YWx1ZXNcbkR5Z3JhcGguREVGQVVMVF9ST0xMX1BFUklPRCA9IDE7XG5EeWdyYXBoLkRFRkFVTFRfV0lEVEggPSA0ODA7XG5EeWdyYXBoLkRFRkFVTFRfSEVJR0hUID0gMzIwO1xuXG4vLyBGb3IgbWF4IDYwIEh6LiBhbmltYXRpb246XG5EeWdyYXBoLkFOSU1BVElPTl9TVEVQUyA9IDEyO1xuRHlncmFwaC5BTklNQVRJT05fRFVSQVRJT04gPSAyMDA7XG5cbi8qKlxuICogU3RhbmRhcmQgcGxvdHRlcnMuIFRoZXNlIG1heSBiZSB1c2VkIGJ5IGNsaWVudHMuXG4gKiBBdmFpbGFibGUgcGxvdHRlcnMgYXJlOlxuICogLSBEeWdyYXBoLlBsb3R0ZXJzLmxpbmVQbG90dGVyOiBkcmF3cyBjZW50cmFsIGxpbmVzIChtb3N0IGNvbW1vbilcbiAqIC0gRHlncmFwaC5QbG90dGVycy5lcnJvclBsb3R0ZXI6IGRyYXdzIGVycm9yIGJhcnNcbiAqIC0gRHlncmFwaC5QbG90dGVycy5maWxsUGxvdHRlcjogZHJhd3MgZmlsbHMgdW5kZXIgbGluZXMgKHVzZWQgd2l0aCBmaWxsR3JhcGgpXG4gKlxuICogQnkgZGVmYXVsdCwgdGhlIHBsb3R0ZXIgaXMgW2ZpbGxQbG90dGVyLCBlcnJvclBsb3R0ZXIsIGxpbmVQbG90dGVyXS5cbiAqIFRoaXMgY2F1c2VzIGFsbCB0aGUgbGluZXMgdG8gYmUgZHJhd24gb3ZlciBhbGwgdGhlIGZpbGxzL2Vycm9yIGJhcnMuXG4gKi9cbkR5Z3JhcGguUGxvdHRlcnMgPSBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX1Bsb3R0ZXJzO1xuXG5cbi8vIFVzZWQgZm9yIGluaXRpYWxpemluZyBhbm5vdGF0aW9uIENTUyBydWxlcyBvbmx5IG9uY2UuXG5EeWdyYXBoLmFkZGVkQW5ub3RhdGlvbkNTUyA9IGZhbHNlO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBEeWdyYXBoLiBUaGlzIGNyZWF0ZXMgYSBuZXcgRElWIGFuZCBjb25zdHJ1Y3RzIHRoZSBQbG90S2l0XG4gKiBhbmQgY29udGV4dCAmbHQ7Y2FudmFzJmd0OyBpbnNpZGUgb2YgaXQuIFNlZSB0aGUgY29uc3RydWN0b3IgZm9yIGRldGFpbHMuXG4gKiBvbiB0aGUgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZGl2IHRoZSBFbGVtZW50IHRvIHJlbmRlciB0aGUgZ3JhcGggaW50by5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgRnVuY3Rpb259IGZpbGUgU291cmNlIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRycyBNaXNjZWxsYW5lb3VzIG90aGVyIG9wdGlvbnNcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLl9faW5pdF9fID0gZnVuY3Rpb24oZGl2LCBmaWxlLCBhdHRycykge1xuICB0aGlzLmlzX2luaXRpYWxfZHJhd18gPSB0cnVlO1xuICB0aGlzLnJlYWR5Rm5zXyA9IFtdO1xuXG4gIC8vIFN1cHBvcnQgdHdvLWFyZ3VtZW50IGNvbnN0cnVjdG9yXG4gIGlmIChhdHRycyA9PT0gbnVsbCB8fCBhdHRycyA9PT0gdW5kZWZpbmVkKSB7IGF0dHJzID0ge307IH1cblxuICBhdHRycyA9IER5Z3JhcGguY29weVVzZXJBdHRyc18oYXR0cnMpO1xuXG4gIGlmICh0eXBlb2YoZGl2KSA9PSAnc3RyaW5nJykge1xuICAgIGRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRpdik7XG4gIH1cblxuICBpZiAoIWRpdikge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29uc3RydWN0aW5nIGR5Z3JhcGggd2l0aCBhIG5vbi1leGlzdGVudCBkaXYhJyk7XG4gIH1cblxuICAvLyBDb3B5IHRoZSBpbXBvcnRhbnQgYml0cyBpbnRvIHRoZSBvYmplY3RcbiAgLy8gVE9ETyhkYW52ayk6IG1vc3Qgb2YgdGhlc2Ugc2hvdWxkIGp1c3Qgc3RheSBpbiB0aGUgYXR0cnNfIGRpY3Rpb25hcnkuXG4gIHRoaXMubWFpbmRpdl8gPSBkaXY7XG4gIHRoaXMuZmlsZV8gPSBmaWxlO1xuICB0aGlzLnJvbGxQZXJpb2RfID0gYXR0cnMucm9sbFBlcmlvZCB8fCBEeWdyYXBoLkRFRkFVTFRfUk9MTF9QRVJJT0Q7XG4gIHRoaXMucHJldmlvdXNWZXJ0aWNhbFhfID0gLTE7XG4gIHRoaXMuZnJhY3Rpb25zXyA9IGF0dHJzLmZyYWN0aW9ucyB8fCBmYWxzZTtcbiAgdGhpcy5kYXRlV2luZG93XyA9IGF0dHJzLmRhdGVXaW5kb3cgfHwgbnVsbDtcblxuICB0aGlzLmFubm90YXRpb25zXyA9IFtdO1xuXG4gIC8vIENsZWFyIHRoZSBkaXYuIFRoaXMgZW5zdXJlIHRoYXQsIGlmIG11bHRpcGxlIGR5Z3JhcGhzIGFyZSBwYXNzZWQgdGhlIHNhbWVcbiAgLy8gZGl2LCB0aGVuIG9ubHkgb25lIHdpbGwgYmUgZHJhd24uXG4gIGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuXG4gIC8vIEZvciBoaXN0b3JpY2FsIHJlYXNvbnMsIHRoZSAnd2lkdGgnIGFuZCAnaGVpZ2h0JyBvcHRpb25zIHRydW1wIGFsbCBDU1NcbiAgLy8gcnVsZXMgX2V4Y2VwdF8gZm9yIGFuIGV4cGxpY2l0ICd3aWR0aCcgb3IgJ2hlaWdodCcgb24gdGhlIGRpdi5cbiAgLy8gQXMgYW4gYWRkZWQgY29udmVuaWVuY2UsIGlmIHRoZSBkaXYgaGFzIHplcm8gaGVpZ2h0IChsaWtlIDxkaXY+PC9kaXY+IGRvZXNcbiAgLy8gd2l0aG91dCBhbnkgc3R5bGVzKSwgdGhlbiB3ZSB1c2UgYSBkZWZhdWx0IGhlaWdodC93aWR0aC5cbiAgaWYgKGRpdi5zdHlsZS53aWR0aCA9PT0gJycgJiYgYXR0cnMud2lkdGgpIHtcbiAgICBkaXYuc3R5bGUud2lkdGggPSBhdHRycy53aWR0aCArIFwicHhcIjtcbiAgfVxuICBpZiAoZGl2LnN0eWxlLmhlaWdodCA9PT0gJycgJiYgYXR0cnMuaGVpZ2h0KSB7XG4gICAgZGl2LnN0eWxlLmhlaWdodCA9IGF0dHJzLmhlaWdodCArIFwicHhcIjtcbiAgfVxuICBpZiAoZGl2LnN0eWxlLmhlaWdodCA9PT0gJycgJiYgZGl2LmNsaWVudEhlaWdodCA9PT0gMCkge1xuICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBEeWdyYXBoLkRFRkFVTFRfSEVJR0hUICsgXCJweFwiO1xuICAgIGlmIChkaXYuc3R5bGUud2lkdGggPT09ICcnKSB7XG4gICAgICBkaXYuc3R5bGUud2lkdGggPSBEeWdyYXBoLkRFRkFVTFRfV0lEVEggKyBcInB4XCI7XG4gICAgfVxuICB9XG4gIC8vIFRoZXNlIHdpbGwgYmUgemVybyBpZiB0aGUgZHlncmFwaCdzIGRpdiBpcyBoaWRkZW4uIEluIHRoYXQgY2FzZSxcbiAgLy8gdXNlIHRoZSB1c2VyLXNwZWNpZmllZCBhdHRyaWJ1dGVzIGlmIHByZXNlbnQuIElmIG5vdCwgdXNlIHplcm9cbiAgLy8gYW5kIGFzc3VtZSB0aGUgdXNlciB3aWxsIGNhbGwgcmVzaXplIHRvIGZpeCB0aGluZ3MgbGF0ZXIuXG4gIHRoaXMud2lkdGhfID0gZGl2LmNsaWVudFdpZHRoIHx8IGF0dHJzLndpZHRoIHx8IDA7XG4gIHRoaXMuaGVpZ2h0XyA9IGRpdi5jbGllbnRIZWlnaHQgfHwgYXR0cnMuaGVpZ2h0IHx8IDA7XG5cbiAgLy8gVE9ETyhkYW52ayk6IHNldCBmaWxsR3JhcGggdG8gYmUgcGFydCBvZiBhdHRyc18gaGVyZSwgbm90IHVzZXJfYXR0cnNfLlxuICBpZiAoYXR0cnMuc3RhY2tlZEdyYXBoKSB7XG4gICAgYXR0cnMuZmlsbEdyYXBoID0gdHJ1ZTtcbiAgICAvLyBUT0RPKG5pa2hpbGspOiBBZGQgYW55IG90aGVyIHN0YWNrZWRHcmFwaCBjaGVja3MgaGVyZS5cbiAgfVxuXG4gIC8vIERFUFJFQ0FUSU9OIFdBUk5JTkc6IEFsbCBvcHRpb24gcHJvY2Vzc2luZyBzaG91bGQgYmUgbW92ZWQgZnJvbVxuICAvLyBhdHRyc18gYW5kIHVzZXJfYXR0cnNfIHRvIG9wdGlvbnNfLCB3aGljaCBob2xkcyBhbGwgdGhpcyBpbmZvcm1hdGlvbi5cbiAgLy9cbiAgLy8gRHlncmFwaHMgaGFzIG1hbnkgb3B0aW9ucywgc29tZSBvZiB3aGljaCBpbnRlcmFjdCB3aXRoIG9uZSBhbm90aGVyLlxuICAvLyBUbyBrZWVwIHRyYWNrIG9mIGV2ZXJ5dGhpbmcsIHdlIG1haW50YWluIHR3byBzZXRzIG9mIG9wdGlvbnM6XG4gIC8vXG4gIC8vICB0aGlzLnVzZXJfYXR0cnNfICAgb25seSBvcHRpb25zIGV4cGxpY2l0bHkgc2V0IGJ5IHRoZSB1c2VyLlxuICAvLyAgdGhpcy5hdHRyc18gICAgICAgIGRlZmF1bHRzLCBvcHRpb25zIGRlcml2ZWQgZnJvbSB1c2VyX2F0dHJzXywgZGF0YS5cbiAgLy9cbiAgLy8gT3B0aW9ucyBhcmUgdGhlbiBhY2Nlc3NlZCB0aGlzLmF0dHJfKCdhdHRyJyksIHdoaWNoIGZpcnN0IGxvb2tzIGF0XG4gIC8vIHVzZXJfYXR0cnNfIGFuZCB0aGVuIGNvbXB1dGVkIGF0dHJzXy4gVGhpcyB3YXkgRHlncmFwaHMgY2FuIHNldCBpbnRlbGxpZ2VudFxuICAvLyBkZWZhdWx0cyB3aXRob3V0IG92ZXJyaWRpbmcgYmVoYXZpb3IgdGhhdCB0aGUgdXNlciBzcGVjaWZpY2FsbHkgYXNrcyBmb3IuXG4gIHRoaXMudXNlcl9hdHRyc18gPSB7fTtcbiAgdXRpbHMudXBkYXRlKHRoaXMudXNlcl9hdHRyc18sIGF0dHJzKTtcblxuICAvLyBUaGlzIHNlcXVlbmNlIGVuc3VyZXMgdGhhdCBEeWdyYXBoLkRFRkFVTFRfQVRUUlMgaXMgbmV2ZXIgbW9kaWZpZWQuXG4gIHRoaXMuYXR0cnNfID0ge307XG4gIHV0aWxzLnVwZGF0ZURlZXAodGhpcy5hdHRyc18sIERFRkFVTFRfQVRUUlMpO1xuXG4gIHRoaXMuYm91bmRhcnlJZHNfID0gW107XG4gIHRoaXMuc2V0SW5kZXhCeU5hbWVfID0ge307XG4gIHRoaXMuZGF0YXNldEluZGV4XyA9IFtdO1xuXG4gIHRoaXMucmVnaXN0ZXJlZEV2ZW50c18gPSBbXTtcbiAgdGhpcy5ldmVudExpc3RlbmVyc18gPSB7fTtcblxuICB0aGlzLmF0dHJpYnV0ZXNfID0gbmV3IER5Z3JhcGhPcHRpb25zKHRoaXMpO1xuXG4gIC8vIENyZWF0ZSB0aGUgY29udGFpbmluZyBESVYgYW5kIG90aGVyIGludGVyYWN0aXZlIGVsZW1lbnRzXG4gIHRoaXMuY3JlYXRlSW50ZXJmYWNlXygpO1xuXG4gIC8vIEFjdGl2YXRlIHBsdWdpbnMuXG4gIHRoaXMucGx1Z2luc18gPSBbXTtcbiAgdmFyIHBsdWdpbnMgPSBEeWdyYXBoLlBMVUdJTlMuY29uY2F0KHRoaXMuZ2V0T3B0aW9uKCdwbHVnaW5zJykpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyB0aGUgcGx1Z2lucyBvcHRpb24gbWF5IGNvbnRhaW4gZWl0aGVyIHBsdWdpbiBjbGFzc2VzIG9yIGluc3RhbmNlcy5cbiAgICAvLyBQbHVnaW4gaW5zdGFuY2VzIGNvbnRhaW4gYW4gYWN0aXZhdGUgbWV0aG9kLlxuICAgIHZhciBQbHVnaW4gPSBwbHVnaW5zW2ldOyAgLy8gZWl0aGVyIGEgY29uc3RydWN0b3Igb3IgYW4gaW5zdGFuY2UuXG4gICAgdmFyIHBsdWdpbkluc3RhbmNlO1xuICAgIGlmICh0eXBlb2YoUGx1Z2luLmFjdGl2YXRlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHBsdWdpbkluc3RhbmNlID0gUGx1Z2luO1xuICAgIH0gZWxzZSB7XG4gICAgICBwbHVnaW5JbnN0YW5jZSA9IG5ldyBQbHVnaW4oKTtcbiAgICB9XG5cbiAgICB2YXIgcGx1Z2luRGljdCA9IHtcbiAgICAgIHBsdWdpbjogcGx1Z2luSW5zdGFuY2UsXG4gICAgICBldmVudHM6IHt9LFxuICAgICAgb3B0aW9uczoge30sXG4gICAgICBwbHVnaW5PcHRpb25zOiB7fVxuICAgIH07XG5cbiAgICB2YXIgaGFuZGxlcnMgPSBwbHVnaW5JbnN0YW5jZS5hY3RpdmF0ZSh0aGlzKTtcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gaGFuZGxlcnMpIHtcbiAgICAgIGlmICghaGFuZGxlcnMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkgY29udGludWU7XG4gICAgICAvLyBUT0RPKGRhbnZrKTogdmFsaWRhdGUgZXZlbnROYW1lLlxuICAgICAgcGx1Z2luRGljdC5ldmVudHNbZXZlbnROYW1lXSA9IGhhbmRsZXJzW2V2ZW50TmFtZV07XG4gICAgfVxuXG4gICAgdGhpcy5wbHVnaW5zXy5wdXNoKHBsdWdpbkRpY3QpO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCwgcGx1Z2lucyBjYW4gbm8gbG9uZ2VyIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzLlxuICAvLyBDb25zdHJ1Y3QgYSBtYXAgZnJvbSBldmVudCAtPiBvcmRlcmVkIGxpc3Qgb2YgW2NhbGxiYWNrLCBwbHVnaW5dLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGx1Z2luc18ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGx1Z2luX2RpY3QgPSB0aGlzLnBsdWdpbnNfW2ldO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwbHVnaW5fZGljdC5ldmVudHMpIHtcbiAgICAgIGlmICghcGx1Z2luX2RpY3QuZXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIGNvbnRpbnVlO1xuICAgICAgdmFyIGNhbGxiYWNrID0gcGx1Z2luX2RpY3QuZXZlbnRzW2V2ZW50TmFtZV07XG5cbiAgICAgIHZhciBwYWlyID0gW3BsdWdpbl9kaWN0LnBsdWdpbiwgY2FsbGJhY2tdO1xuICAgICAgaWYgKCEoZXZlbnROYW1lIGluIHRoaXMuZXZlbnRMaXN0ZW5lcnNfKSkge1xuICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzX1tldmVudE5hbWVdID0gW3BhaXJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyc19bZXZlbnROYW1lXS5wdXNoKHBhaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuY3JlYXRlRHJhZ0ludGVyZmFjZV8oKTtcblxuICB0aGlzLnN0YXJ0XygpO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VycyBhIGNhc2NhZGUgb2YgZXZlbnRzIHRvIHRoZSB2YXJpb3VzIHBsdWdpbnMgd2hpY2ggYXJlIGludGVyZXN0ZWQgaW4gdGhlbS5cbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgXCJkZWZhdWx0IGJlaGF2aW9yXCIgc2hvdWxkIGJlIHByZXZlbnRlZCwgaS5lLiBpZiBvbmVcbiAqIG9mIHRoZSBldmVudCBsaXN0ZW5lcnMgY2FsbGVkIGV2ZW50LnByZXZlbnREZWZhdWx0KCkuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5jYXNjYWRlRXZlbnRzXyA9IGZ1bmN0aW9uKG5hbWUsIGV4dHJhX3Byb3BzKSB7XG4gIGlmICghKG5hbWUgaW4gdGhpcy5ldmVudExpc3RlbmVyc18pKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gUVVFU1RJT046IGNhbiB3ZSB1c2Ugb2JqZWN0cyAmIHByb3RvdHlwZXMgdG8gc3BlZWQgdGhpcyB1cD9cbiAgdmFyIGUgPSB7XG4gICAgZHlncmFwaDogdGhpcyxcbiAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICBkZWZhdWx0UHJldmVudGVkOiBmYWxzZSxcbiAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWUuY2FuY2VsYWJsZSkgdGhyb3cgXCJDYW5ub3QgY2FsbCBwcmV2ZW50RGVmYXVsdCBvbiBub24tY2FuY2VsYWJsZSBldmVudC5cIjtcbiAgICAgIGUuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgfSxcbiAgICBwcm9wYWdhdGlvblN0b3BwZWQ6IGZhbHNlLFxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBlLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuICB1dGlscy51cGRhdGUoZSwgZXh0cmFfcHJvcHMpO1xuXG4gIHZhciBjYWxsYmFja19wbHVnaW5fcGFpcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzX1tuYW1lXTtcbiAgaWYgKGNhbGxiYWNrX3BsdWdpbl9wYWlycykge1xuICAgIGZvciAodmFyIGkgPSBjYWxsYmFja19wbHVnaW5fcGFpcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBwbHVnaW4gPSBjYWxsYmFja19wbHVnaW5fcGFpcnNbaV1bMF07XG4gICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja19wbHVnaW5fcGFpcnNbaV1bMV07XG4gICAgICBjYWxsYmFjay5jYWxsKHBsdWdpbiwgZSk7XG4gICAgICBpZiAoZS5wcm9wYWdhdGlvblN0b3BwZWQpIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZS5kZWZhdWx0UHJldmVudGVkO1xufTtcblxuLyoqXG4gKiBGZXRjaCBhIHBsdWdpbiBpbnN0YW5jZSBvZiBhIHBhcnRpY3VsYXIgY2xhc3MuIE9ubHkgZm9yIHRlc3RpbmcuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHshQ2xhc3N9IHR5cGUgVGhlIHR5cGUgb2YgdGhlIHBsdWdpbi5cbiAqIEByZXR1cm4ge09iamVjdH0gSW5zdGFuY2Ugb2YgdGhlIHBsdWdpbiwgb3IgbnVsbCBpZiB0aGVyZSBpcyBub25lLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRQbHVnaW5JbnN0YW5jZV8gPSBmdW5jdGlvbih0eXBlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5zXy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gdGhpcy5wbHVnaW5zX1tpXTtcbiAgICBpZiAocC5wbHVnaW4gaW5zdGFuY2VvZiB0eXBlKSB7XG4gICAgICByZXR1cm4gcC5wbHVnaW47XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB6b29tZWQgc3RhdHVzIG9mIHRoZSBjaGFydCBmb3Igb25lIG9yIGJvdGggYXhlcy5cbiAqXG4gKiBBeGlzIGlzIGFuIG9wdGlvbmFsIHBhcmFtZXRlci4gQ2FuIGJlIHNldCB0byAneCcgb3IgJ3knLlxuICpcbiAqIFRoZSB6b29tZWQgc3RhdHVzIGZvciBhbiBheGlzIGlzIHNldCB3aGVuZXZlciBhIHVzZXIgem9vbXMgdXNpbmcgdGhlIG1vdXNlXG4gKiBvciB3aGVuIHRoZSBkYXRlV2luZG93IG9yIHZhbHVlUmFuZ2UgYXJlIHVwZGF0ZWQuIERvdWJsZS1jbGlja2luZyBvciBjYWxsaW5nXG4gKiByZXNldFpvb20oKSByZXNldHMgdGhlIHpvb20gc3RhdHVzIGZvciB0aGUgY2hhcnQuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmlzWm9vbWVkID0gZnVuY3Rpb24oYXhpcykge1xuICBjb25zdCBpc1pvb21lZFggPSAhIXRoaXMuZGF0ZVdpbmRvd187XG4gIGlmIChheGlzID09PSAneCcpIHJldHVybiBpc1pvb21lZFg7XG5cbiAgY29uc3QgaXNab29tZWRZID0gdGhpcy5heGVzXy5tYXAoYXhpcyA9PiAhIWF4aXMudmFsdWVSYW5nZSkuaW5kZXhPZih0cnVlKSA+PSAwO1xuICBpZiAoYXhpcyA9PT0gbnVsbCB8fCBheGlzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaXNab29tZWRYIHx8IGlzWm9vbWVkWTtcbiAgfVxuICBpZiAoYXhpcyA9PT0gJ3knKSByZXR1cm4gaXNab29tZWRZO1xuXG4gIHRocm93IG5ldyBFcnJvcihgYXhpcyBwYXJhbWV0ZXIgaXMgWyR7YXhpc31dIG11c3QgYmUgbnVsbCwgJ3gnIG9yICd5Jy5gKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgRHlncmFwaCBvYmplY3QsIGluY2x1ZGluZyBpdHMgY29udGFpbmluZyBJRC5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG1haW5kaXYgPSB0aGlzLm1haW5kaXZfO1xuICB2YXIgaWQgPSAobWFpbmRpdiAmJiBtYWluZGl2LmlkKSA/IG1haW5kaXYuaWQgOiBtYWluZGl2O1xuICByZXR1cm4gXCJbRHlncmFwaCBcIiArIGlkICsgXCJdXCI7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhbiBvcHRpb24uIFRoaXMgbWF5IGJlIHNldCBieSB0aGUgdXNlciAoZWl0aGVyIGluIHRoZVxuICogY29uc3RydWN0b3Igb3IgYnkgY2FsbGluZyB1cGRhdGVPcHRpb25zKSBvciBieSBkeWdyYXBocywgYW5kIG1heSBiZSBzZXQgdG8gYVxuICogcGVyLXNlcmllcyB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBvcHRpb24sIGUuZy4gJ3JvbGxQZXJpb2QnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzZXJpZXNOYW1lXSBUaGUgbmFtZSBvZiB0aGUgc2VyaWVzIHRvIHdoaWNoIHRoZSBvcHRpb25cbiAqIHdpbGwgYmUgYXBwbGllZC4gSWYgbm8gcGVyLXNlcmllcyB2YWx1ZSBvZiB0aGlzIG9wdGlvbiBpcyBhdmFpbGFibGUsIHRoZW5cbiAqIHRoZSBnbG9iYWwgdmFsdWUgaXMgcmV0dXJuZWQuIFRoaXMgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJuIHsgLi4uIH0gVGhlIHZhbHVlIG9mIHRoZSBvcHRpb24uXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmF0dHJfID0gZnVuY3Rpb24obmFtZSwgc2VyaWVzTmFtZSkge1xuICAvLyBGb3IgXCJwcm9kdWN0aW9uXCIgY29kZSwgdGhpcyBnZXRzIHJlbW92ZWQgYnkgdWdsaWZ5anMuXG4gIGlmICh0eXBlb2YocHJvY2VzcykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZihPUFRJT05TX1JFRkVSRU5DRSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ011c3QgaW5jbHVkZSBvcHRpb25zIHJlZmVyZW5jZSBKUyBmb3IgdGVzdGluZycpO1xuICAgICAgfSBlbHNlIGlmICghT1BUSU9OU19SRUZFUkVOQ0UuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRHlncmFwaHMgaXMgdXNpbmcgcHJvcGVydHkgJyArIG5hbWUgKyAnLCB3aGljaCBoYXMgbm8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ2VudHJ5IGluIHRoZSBEeWdyYXBocy5PUFRJT05TX1JFRkVSRU5DRSBsaXN0aW5nLicpO1xuICAgICAgICAvLyBPbmx5IGxvZyB0aGlzIGVycm9yIG9uY2UuXG4gICAgICAgIE9QVElPTlNfUkVGRVJFTkNFW25hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmllc05hbWUgPyB0aGlzLmF0dHJpYnV0ZXNfLmdldEZvclNlcmllcyhuYW1lLCBzZXJpZXNOYW1lKSA6IHRoaXMuYXR0cmlidXRlc18uZ2V0KG5hbWUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIGZvciBhbiBvcHRpb24sIGFzIHNldCBpbiB0aGUgY29uc3RydWN0b3Igb3IgdmlhXG4gKiB1cGRhdGVPcHRpb25zLiBZb3UgbWF5IHBhc3MgaW4gYW4gKG9wdGlvbmFsKSBzZXJpZXMgbmFtZSB0byBnZXQgcGVyLXNlcmllc1xuICogdmFsdWVzIGZvciB0aGUgb3B0aW9uLlxuICpcbiAqIEFsbCB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW1tdXRhYmxlLiBJZiB5b3VcbiAqIG1vZGlmeSB0aGVtLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgY2hhbmdlcyB3aWxsIGJlIGhvbm9yZWQgb3IgdGhhdFxuICogZHlncmFwaHMgd2lsbCByZW1haW4gaW4gYSBjb25zaXN0ZW50IHN0YXRlLiBJZiB5b3Ugd2FudCB0byBtb2RpZnkgYW4gb3B0aW9uLFxuICogdXNlIHVwZGF0ZU9wdGlvbnMoKSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBvcHRpb24gKGUuZy4gJ3N0cm9rZVdpZHRoJylcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Nlcmllc05hbWUgU2VyaWVzIG5hbWUgdG8gZ2V0IHBlci1zZXJpZXMgdmFsdWVzLlxuICogQHJldHVybiB7Kn0gVGhlIHZhbHVlIG9mIHRoZSBvcHRpb24uXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldE9wdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIG9wdF9zZXJpZXNOYW1lKSB7XG4gIHJldHVybiB0aGlzLmF0dHJfKG5hbWUsIG9wdF9zZXJpZXNOYW1lKTtcbn07XG5cbi8qKlxuICogTGlrZSBnZXRPcHRpb24oKSwgYnV0IHNwZWNpZmljYWxseSByZXR1cm5zIGEgbnVtYmVyLlxuICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciB3b3JraW5nIHdpdGggdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgb3B0aW9uIChlLmcuICdzdHJva2VXaWR0aCcpXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zZXJpZXNOYW1lIFNlcmllcyBuYW1lIHRvIGdldCBwZXItc2VyaWVzIHZhbHVlcy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZhbHVlIG9mIHRoZSBvcHRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXROdW1lcmljT3B0aW9uID0gZnVuY3Rpb24obmFtZSwgb3B0X3Nlcmllc05hbWUpIHtcbiAgcmV0dXJuIC8qKiBAdHlwZXtudW1iZXJ9ICovKHRoaXMuZ2V0T3B0aW9uKG5hbWUsIG9wdF9zZXJpZXNOYW1lKSk7XG59O1xuXG4vKipcbiAqIExpa2UgZ2V0T3B0aW9uKCksIGJ1dCBzcGVjaWZpY2FsbHkgcmV0dXJucyBhIHN0cmluZy5cbiAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3Igd29ya2luZyB3aXRoIHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIG9wdGlvbiAoZS5nLiAnc3Ryb2tlV2lkdGgnKVxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfc2VyaWVzTmFtZSBTZXJpZXMgbmFtZSB0byBnZXQgcGVyLXNlcmllcyB2YWx1ZXMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0U3RyaW5nT3B0aW9uID0gZnVuY3Rpb24obmFtZSwgb3B0X3Nlcmllc05hbWUpIHtcbiAgcmV0dXJuIC8qKiBAdHlwZXtzdHJpbmd9ICovKHRoaXMuZ2V0T3B0aW9uKG5hbWUsIG9wdF9zZXJpZXNOYW1lKSk7XG59O1xuXG4vKipcbiAqIExpa2UgZ2V0T3B0aW9uKCksIGJ1dCBzcGVjaWZpY2FsbHkgcmV0dXJucyBhIGJvb2xlYW4uXG4gKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIHdvcmtpbmcgd2l0aCB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBvcHRpb24gKGUuZy4gJ3N0cm9rZVdpZHRoJylcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Nlcmllc05hbWUgU2VyaWVzIG5hbWUgdG8gZ2V0IHBlci1zZXJpZXMgdmFsdWVzLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHZhbHVlIG9mIHRoZSBvcHRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRCb29sZWFuT3B0aW9uID0gZnVuY3Rpb24obmFtZSwgb3B0X3Nlcmllc05hbWUpIHtcbiAgcmV0dXJuIC8qKiBAdHlwZXtib29sZWFufSAqLyh0aGlzLmdldE9wdGlvbihuYW1lLCBvcHRfc2VyaWVzTmFtZSkpO1xufTtcblxuLyoqXG4gKiBMaWtlIGdldE9wdGlvbigpLCBidXQgc3BlY2lmaWNhbGx5IHJldHVybnMgYSBmdW5jdGlvbi5cbiAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3Igd29ya2luZyB3aXRoIHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIG9wdGlvbiAoZS5nLiAnc3Ryb2tlV2lkdGgnKVxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfc2VyaWVzTmFtZSBTZXJpZXMgbmFtZSB0byBnZXQgcGVyLXNlcmllcyB2YWx1ZXMuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbiguLi4pfSBUaGUgdmFsdWUgb2YgdGhlIG9wdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldEZ1bmN0aW9uT3B0aW9uID0gZnVuY3Rpb24obmFtZSwgb3B0X3Nlcmllc05hbWUpIHtcbiAgcmV0dXJuIC8qKiBAdHlwZXtmdW5jdGlvbiguLi4pfSAqLyh0aGlzLmdldE9wdGlvbihuYW1lLCBvcHRfc2VyaWVzTmFtZSkpO1xufTtcblxuRHlncmFwaC5wcm90b3R5cGUuZ2V0T3B0aW9uRm9yQXhpcyA9IGZ1bmN0aW9uKG5hbWUsIGF4aXMpIHtcbiAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc18uZ2V0Rm9yQXhpcyhuYW1lLCBheGlzKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIFRoZSBuYW1lIG9mIHRoZSBheGlzIChpLmUuICd4JywgJ3knIG9yICd5MicpXG4gKiBAcmV0dXJuIHsgLi4uIH0gQSBmdW5jdGlvbiBtYXBwaW5nIHN0cmluZyAtPiBvcHRpb24gdmFsdWVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUub3B0aW9uc1ZpZXdGb3JBeGlzXyA9IGZ1bmN0aW9uKGF4aXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24ob3B0KSB7XG4gICAgdmFyIGF4aXNfb3B0cyA9IHNlbGYudXNlcl9hdHRyc18uYXhlcztcbiAgICBpZiAoYXhpc19vcHRzICYmIGF4aXNfb3B0c1theGlzXSAmJiBheGlzX29wdHNbYXhpc10uaGFzT3duUHJvcGVydHkob3B0KSkge1xuICAgICAgcmV0dXJuIGF4aXNfb3B0c1theGlzXVtvcHRdO1xuICAgIH1cblxuICAgIC8vIEkgZG9uJ3QgbGlrZSB0aGF0IHRoaXMgaXMgaW4gYSBzZWNvbmQgc3BvdC5cbiAgICBpZiAoYXhpcyA9PT0gJ3gnICYmIG9wdCA9PT0gJ2xvZ3NjYWxlJykge1xuICAgICAgLy8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAgLy8gVE9ETyhrb25pZ3NiZXJnKTogcHVsbCB0aGUgZGVmYXVsdCBmcm9tIGEgZ2xvYmFsIGRlZmF1bHQuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gdXNlci1zcGVjaWZpZWQgYXR0cmlidXRlcyBhbHdheXMgdHJ1bXAgZGVmYXVsdHMsIGV2ZW4gaWYgdGhleSdyZSBsZXNzXG4gICAgLy8gc3BlY2lmaWMuXG4gICAgaWYgKHR5cGVvZihzZWxmLnVzZXJfYXR0cnNfW29wdF0pICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gc2VsZi51c2VyX2F0dHJzX1tvcHRdO1xuICAgIH1cblxuICAgIGF4aXNfb3B0cyA9IHNlbGYuYXR0cnNfLmF4ZXM7XG4gICAgaWYgKGF4aXNfb3B0cyAmJiBheGlzX29wdHNbYXhpc10gJiYgYXhpc19vcHRzW2F4aXNdLmhhc093blByb3BlcnR5KG9wdCkpIHtcbiAgICAgIHJldHVybiBheGlzX29wdHNbYXhpc11bb3B0XTtcbiAgICB9XG4gICAgLy8gY2hlY2sgb2xkLXN0eWxlIGF4aXMgb3B0aW9uc1xuICAgIC8vIFRPRE8oZGFudmspOiBhZGQgYSBkZXByZWNhdGlvbiB3YXJuaW5nIGlmIGVpdGhlciBvZiB0aGVzZSBtYXRjaC5cbiAgICBpZiAoYXhpcyA9PSAneScgJiYgc2VsZi5heGVzX1swXS5oYXNPd25Qcm9wZXJ0eShvcHQpKSB7XG4gICAgICByZXR1cm4gc2VsZi5heGVzX1swXVtvcHRdO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PSAneTInICYmIHNlbGYuYXhlc19bMV0uaGFzT3duUHJvcGVydHkob3B0KSkge1xuICAgICAgcmV0dXJuIHNlbGYuYXhlc19bMV1bb3B0XTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGYuYXR0cl8ob3B0KTtcbiAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCByb2xsaW5nIHBlcmlvZCwgYXMgc2V0IGJ5IHRoZSB1c2VyIG9yIGFuIG9wdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBwb2ludHMgaW4gdGhlIHJvbGxpbmcgd2luZG93XG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnJvbGxQZXJpb2QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucm9sbFBlcmlvZF87XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnRseS12aXNpYmxlIHgtcmFuZ2UuIFRoaXMgY2FuIGJlIGFmZmVjdGVkIGJ5IHpvb21pbmcsXG4gKiBwYW5uaW5nIG9yIGEgY2FsbCB0byB1cGRhdGVPcHRpb25zLlxuICogUmV0dXJucyBhIHR3by1lbGVtZW50IGFycmF5OiBbbGVmdCwgcmlnaHRdLlxuICogSWYgdGhlIER5Z3JhcGggaGFzIGRhdGVzIG9uIHRoZSB4LWF4aXMsIHRoZXNlIHdpbGwgYmUgbWlsbGlzIHNpbmNlIGVwb2NoLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS54QXhpc1JhbmdlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGVXaW5kb3dfID8gdGhpcy5kYXRlV2luZG93XyA6IHRoaXMueEF4aXNFeHRyZW1lcygpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsb3dlci0gYW5kIHVwcGVyLWJvdW5kIHgtYXhpcyB2YWx1ZXMgb2YgdGhlIGRhdGEgc2V0LlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS54QXhpc0V4dHJlbWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYWQgPSB0aGlzLmdldE51bWVyaWNPcHRpb24oJ3hSYW5nZVBhZCcpIC8gdGhpcy5wbG90dGVyXy5hcmVhLnc7XG4gIGlmICh0aGlzLm51bVJvd3MoKSA9PT0gMCkge1xuICAgIHJldHVybiBbMCAtIHBhZCwgMSArIHBhZF07XG4gIH1cbiAgdmFyIGxlZnQgPSB0aGlzLnJhd0RhdGFfWzBdWzBdO1xuICB2YXIgcmlnaHQgPSB0aGlzLnJhd0RhdGFfW3RoaXMucmF3RGF0YV8ubGVuZ3RoIC0gMV1bMF07XG4gIGlmIChwYWQpIHtcbiAgICAvLyBNdXN0IGtlZXAgdGhpcyBpbiBzeW5jIHdpdGggZHlncmFwaC1sYXlvdXQgX2V2YWx1YXRlTGltaXRzKClcbiAgICB2YXIgcmFuZ2UgPSByaWdodCAtIGxlZnQ7XG4gICAgbGVmdCAtPSByYW5nZSAqIHBhZDtcbiAgICByaWdodCArPSByYW5nZSAqIHBhZDtcbiAgfVxuICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbG93ZXItIGFuZCB1cHBlci1ib3VuZCB5LWF4aXMgdmFsdWVzIGZvciBlYWNoIGF4aXMuIFRoZXNlIGFyZVxuICogdGhlIHJhbmdlcyB5b3UnbGwgZ2V0IGlmIHlvdSBkb3VibGUtY2xpY2sgdG8gem9vbSBvdXQgb3IgY2FsbCByZXNldFpvb20oKS5cbiAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gYXJyYXkgb2YgW2xvdywgaGlnaF0gdHVwbGVzLCBvbmUgZm9yIGVhY2ggeS1heGlzLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS55QXhpc0V4dHJlbWVzID0gZnVuY3Rpb24oKSB7XG4gIC8vIFRPRE8oZGFudmspOiB0aGlzIGlzIHByZXR0eSBpbmVmZmljaWVudFxuICBjb25zdCBwYWNrZWQgPSB0aGlzLmdhdGhlckRhdGFzZXRzXyh0aGlzLnJvbGxlZFNlcmllc18sIG51bGwpO1xuICBjb25zdCB7IGV4dHJlbWVzIH0gPSBwYWNrZWQ7XG4gIGNvbnN0IHNhdmVBeGVzID0gdGhpcy5heGVzXztcbiAgdGhpcy5jb21wdXRlWUF4aXNSYW5nZXNfKGV4dHJlbWVzKTtcbiAgY29uc3QgbmV3QXhlcyA9IHRoaXMuYXhlc187XG4gIHRoaXMuYXhlc18gPSBzYXZlQXhlcztcbiAgcmV0dXJuIG5ld0F4ZXMubWFwKGF4aXMgPT4gYXhpcy5leHRyZW1lUmFuZ2UpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnRseS12aXNpYmxlIHktcmFuZ2UgZm9yIGFuIGF4aXMuIFRoaXMgY2FuIGJlIGFmZmVjdGVkIGJ5XG4gKiB6b29taW5nLCBwYW5uaW5nIG9yIGEgY2FsbCB0byB1cGRhdGVPcHRpb25zLiBBeGlzIGluZGljZXMgYXJlIHplcm8tYmFzZWQuIElmXG4gKiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIHJldHVybnMgdGhlIHJhbmdlIG9mIHRoZSBmaXJzdCBheGlzLlxuICogUmV0dXJucyBhIHR3by1lbGVtZW50IGFycmF5OiBbYm90dG9tLCB0b3BdLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS55QXhpc1JhbmdlID0gZnVuY3Rpb24oaWR4KSB7XG4gIGlmICh0eXBlb2YoaWR4KSA9PSBcInVuZGVmaW5lZFwiKSBpZHggPSAwO1xuICBpZiAoaWR4IDwgMCB8fCBpZHggPj0gdGhpcy5heGVzXy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgYXhpcyA9IHRoaXMuYXhlc19baWR4XTtcbiAgcmV0dXJuIFsgYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMF0sIGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzFdIF07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnRseS12aXNpYmxlIHktcmFuZ2VzIGZvciBlYWNoIGF4aXMuIFRoaXMgY2FuIGJlIGFmZmVjdGVkIGJ5XG4gKiB6b29taW5nLCBwYW5uaW5nLCBjYWxscyB0byB1cGRhdGVPcHRpb25zLCBldGMuXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIFtib3R0b20sIHRvcF0gcGFpcnMsIG9uZSBmb3IgZWFjaCB5LWF4aXMuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnlBeGlzUmFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmF4ZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgcmV0LnB1c2godGhpcy55QXhpc1JhbmdlKGkpKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuLy8gVE9ETyhkYW52ayk6IHVzZSB0aGVzZSBmdW5jdGlvbnMgdGhyb3VnaG91dCBkeWdyYXBocy5cbi8qKlxuICogQ29udmVydCBmcm9tIGRhdGEgY29vcmRpbmF0ZXMgdG8gY2FudmFzL2RpdiBYL1kgY29vcmRpbmF0ZXMuXG4gKiBJZiBzcGVjaWZpZWQsIGRvIHRoaXMgY29udmVyc2lvbiBmb3IgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIG9mIGEgcGFydGljdWxhclxuICogYXhpcy4gVXNlcyB0aGUgZmlyc3QgYXhpcyBieSBkZWZhdWx0LlxuICogUmV0dXJucyBhIHR3by1lbGVtZW50IGFycmF5OiBbWCwgWV1cbiAqXG4gKiBOb3RlOiB1c2UgdG9Eb21YQ29vcmQgaW5zdGVhZCBvZiB0b0RvbUNvb3Jkcyh4LCBudWxsKSBhbmQgdXNlIHRvRG9tWUNvb3JkXG4gKiBpbnN0ZWFkIG9mIHRvRG9tQ29vcmRzKG51bGwsIHksIGF4aXMpLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS50b0RvbUNvb3JkcyA9IGZ1bmN0aW9uKHgsIHksIGF4aXMpIHtcbiAgcmV0dXJuIFsgdGhpcy50b0RvbVhDb29yZCh4KSwgdGhpcy50b0RvbVlDb29yZCh5LCBheGlzKSBdO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGZyb20gZGF0YSB4IGNvb3JkaW5hdGVzIHRvIGNhbnZhcy9kaXYgWCBjb29yZGluYXRlLlxuICogSWYgc3BlY2lmaWVkLCBkbyB0aGlzIGNvbnZlcnNpb24gZm9yIHRoZSBjb29yZGluYXRlIHN5c3RlbSBvZiBhIHBhcnRpY3VsYXJcbiAqIGF4aXMuXG4gKiBSZXR1cm5zIGEgc2luZ2xlIHZhbHVlIG9yIG51bGwgaWYgeCBpcyBudWxsLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS50b0RvbVhDb29yZCA9IGZ1bmN0aW9uKHgpIHtcbiAgaWYgKHggPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhcmVhID0gdGhpcy5wbG90dGVyXy5hcmVhO1xuICB2YXIgeFJhbmdlID0gdGhpcy54QXhpc1JhbmdlKCk7XG4gIHJldHVybiBhcmVhLnggKyAoeCAtIHhSYW5nZVswXSkgLyAoeFJhbmdlWzFdIC0geFJhbmdlWzBdKSAqIGFyZWEudztcbn07XG5cbi8qKlxuICogQ29udmVydCBmcm9tIGRhdGEgeCBjb29yZGluYXRlcyB0byBjYW52YXMvZGl2IFkgY29vcmRpbmF0ZSBhbmQgb3B0aW9uYWxcbiAqIGF4aXMuIFVzZXMgdGhlIGZpcnN0IGF4aXMgYnkgZGVmYXVsdC5cbiAqXG4gKiByZXR1cm5zIGEgc2luZ2xlIHZhbHVlIG9yIG51bGwgaWYgeSBpcyBudWxsLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS50b0RvbVlDb29yZCA9IGZ1bmN0aW9uKHksIGF4aXMpIHtcbiAgdmFyIHBjdCA9IHRoaXMudG9QZXJjZW50WUNvb3JkKHksIGF4aXMpO1xuXG4gIGlmIChwY3QgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgYXJlYSA9IHRoaXMucGxvdHRlcl8uYXJlYTtcbiAgcmV0dXJuIGFyZWEueSArIHBjdCAqIGFyZWEuaDtcbn07XG5cbi8qKlxuICogQ29udmVydCBmcm9tIGNhbnZhcy9kaXYgY29vcmRzIHRvIGRhdGEgY29vcmRpbmF0ZXMuXG4gKiBJZiBzcGVjaWZpZWQsIGRvIHRoaXMgY29udmVyc2lvbiBmb3IgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIG9mIGEgcGFydGljdWxhclxuICogYXhpcy4gVXNlcyB0aGUgZmlyc3QgYXhpcyBieSBkZWZhdWx0LlxuICogUmV0dXJucyBhIHR3by1lbGVtZW50IGFycmF5OiBbWCwgWV0uXG4gKlxuICogTm90ZTogdXNlIHRvRGF0YVhDb29yZCBpbnN0ZWFkIG9mIHRvRGF0YUNvb3Jkcyh4LCBudWxsKSBhbmQgdXNlIHRvRGF0YVlDb29yZFxuICogaW5zdGVhZCBvZiB0b0RhdGFDb29yZHMobnVsbCwgeSwgYXhpcykuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnRvRGF0YUNvb3JkcyA9IGZ1bmN0aW9uKHgsIHksIGF4aXMpIHtcbiAgcmV0dXJuIFsgdGhpcy50b0RhdGFYQ29vcmQoeCksIHRoaXMudG9EYXRhWUNvb3JkKHksIGF4aXMpIF07XG59O1xuXG4vKipcbiAqIENvbnZlcnQgZnJvbSBjYW52YXMvZGl2IHggY29vcmRpbmF0ZSB0byBkYXRhIGNvb3JkaW5hdGUuXG4gKlxuICogSWYgeCBpcyBudWxsLCB0aGlzIHJldHVybnMgbnVsbC5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUudG9EYXRhWENvb3JkID0gZnVuY3Rpb24oeCkge1xuICBpZiAoeCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFyZWEgPSB0aGlzLnBsb3R0ZXJfLmFyZWE7XG4gIHZhciB4UmFuZ2UgPSB0aGlzLnhBeGlzUmFuZ2UoKTtcblxuICBpZiAoIXRoaXMuYXR0cmlidXRlc18uZ2V0Rm9yQXhpcyhcImxvZ3NjYWxlXCIsICd4JykpIHtcbiAgICByZXR1cm4geFJhbmdlWzBdICsgKHggLSBhcmVhLngpIC8gYXJlYS53ICogKHhSYW5nZVsxXSAtIHhSYW5nZVswXSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBjdCA9ICh4IC0gYXJlYS54KSAvIGFyZWEudztcbiAgICByZXR1cm4gdXRpbHMubG9nUmFuZ2VGcmFjdGlvbih4UmFuZ2VbMF0sIHhSYW5nZVsxXSwgcGN0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0IGZyb20gY2FudmFzL2RpdiB5IGNvb3JkIHRvIHZhbHVlLlxuICpcbiAqIElmIHkgaXMgbnVsbCwgdGhpcyByZXR1cm5zIG51bGwuXG4gKiBpZiBheGlzIGlzIG51bGwsIHRoaXMgdXNlcyB0aGUgZmlyc3QgYXhpcy5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUudG9EYXRhWUNvb3JkID0gZnVuY3Rpb24oeSwgYXhpcykge1xuICBpZiAoeSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFyZWEgPSB0aGlzLnBsb3R0ZXJfLmFyZWE7XG4gIHZhciB5UmFuZ2UgPSB0aGlzLnlBeGlzUmFuZ2UoYXhpcyk7XG5cbiAgaWYgKHR5cGVvZihheGlzKSA9PSBcInVuZGVmaW5lZFwiKSBheGlzID0gMDtcbiAgaWYgKCF0aGlzLmF0dHJpYnV0ZXNfLmdldEZvckF4aXMoXCJsb2dzY2FsZVwiLCBheGlzKSkge1xuICAgIHJldHVybiB5UmFuZ2VbMF0gKyAoYXJlYS55ICsgYXJlYS5oIC0geSkgLyBhcmVhLmggKiAoeVJhbmdlWzFdIC0geVJhbmdlWzBdKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb21wdXRpbmcgdGhlIGludmVyc2Ugb2YgdG9Eb21Db29yZC5cbiAgICB2YXIgcGN0ID0gKHkgLSBhcmVhLnkpIC8gYXJlYS5oO1xuICAgIC8vIE5vdGUgcmV2ZXJzZWQgeVJhbmdlLCB5MSBpcyBvbiB0b3Agd2l0aCBwY3Q9PTAuXG4gICAgcmV0dXJuIHV0aWxzLmxvZ1JhbmdlRnJhY3Rpb24oeVJhbmdlWzFdLCB5UmFuZ2VbMF0sIHBjdCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ29udmVydHMgYSB5IGZvciBhbiBheGlzIHRvIGEgcGVyY2VudGFnZSBmcm9tIHRoZSB0b3AgdG8gdGhlXG4gKiBib3R0b20gb2YgdGhlIGRyYXdpbmcgYXJlYS5cbiAqXG4gKiBJZiB0aGUgY29vcmRpbmF0ZSByZXByZXNlbnRzIGEgdmFsdWUgdmlzaWJsZSBvbiB0aGUgY2FudmFzLCB0aGVuXG4gKiB0aGUgdmFsdWUgd2lsbCBiZSBiZXR3ZWVuIDAgYW5kIDEsIHdoZXJlIDAgaXMgdGhlIHRvcCBvZiB0aGUgY2FudmFzLlxuICogSG93ZXZlciwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdmFsdWVzIG91dHNpZGUgdGhlIHJhbmdlLCBhc1xuICogdmFsdWVzIGNhbiBmYWxsIG91dHNpZGUgdGhlIGNhbnZhcy5cbiAqXG4gKiBJZiB5IGlzIG51bGwsIHRoaXMgcmV0dXJucyBudWxsLlxuICogaWYgYXhpcyBpcyBudWxsLCB0aGlzIHVzZXMgdGhlIGZpcnN0IGF4aXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIGRhdGEgeS1jb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtheGlzXSBUaGUgYXhpcyBudW1iZXIgb24gd2hpY2ggdGhlIGRhdGEgY29vcmRpbmF0ZSBsaXZlcy5cbiAqIEByZXR1cm4ge251bWJlcn0gQSBmcmFjdGlvbiBpbiBbMCwgMV0gd2hlcmUgMCA9IHRoZSB0b3AgZWRnZS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUudG9QZXJjZW50WUNvb3JkID0gZnVuY3Rpb24oeSwgYXhpcykge1xuICBpZiAoeSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YoYXhpcykgPT0gXCJ1bmRlZmluZWRcIikgYXhpcyA9IDA7XG5cbiAgdmFyIHlSYW5nZSA9IHRoaXMueUF4aXNSYW5nZShheGlzKTtcblxuICB2YXIgcGN0O1xuICB2YXIgbG9nc2NhbGUgPSB0aGlzLmF0dHJpYnV0ZXNfLmdldEZvckF4aXMoXCJsb2dzY2FsZVwiLCBheGlzKTtcbiAgaWYgKGxvZ3NjYWxlKSB7XG4gICAgdmFyIGxvZ3IwID0gdXRpbHMubG9nMTAoeVJhbmdlWzBdKTtcbiAgICB2YXIgbG9ncjEgPSB1dGlscy5sb2cxMCh5UmFuZ2VbMV0pO1xuICAgIHBjdCA9IChsb2dyMSAtIHV0aWxzLmxvZzEwKHkpKSAvIChsb2dyMSAtIGxvZ3IwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB5UmFuZ2VbMV0gLSB5IGlzIHVuaXQgZGlzdGFuY2UgZnJvbSB0aGUgYm90dG9tLlxuICAgIC8vIHlSYW5nZVsxXSAtIHlSYW5nZVswXSBpcyB0aGUgc2NhbGUgb2YgdGhlIHJhbmdlLlxuICAgIC8vICh5UmFuZ2VbMV0gLSB5KSAvICh5UmFuZ2VbMV0gLSB5UmFuZ2VbMF0pIGlzIHRoZSAlIGZyb20gdGhlIGJvdHRvbS5cbiAgICBwY3QgPSAoeVJhbmdlWzFdIC0geSkgLyAoeVJhbmdlWzFdIC0geVJhbmdlWzBdKTtcbiAgfVxuICByZXR1cm4gcGN0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiB4IHZhbHVlIHRvIGEgcGVyY2VudGFnZSBmcm9tIHRoZSBsZWZ0IHRvIHRoZSByaWdodCBvZlxuICogdGhlIGRyYXdpbmcgYXJlYS5cbiAqXG4gKiBJZiB0aGUgY29vcmRpbmF0ZSByZXByZXNlbnRzIGEgdmFsdWUgdmlzaWJsZSBvbiB0aGUgY2FudmFzLCB0aGVuXG4gKiB0aGUgdmFsdWUgd2lsbCBiZSBiZXR3ZWVuIDAgYW5kIDEsIHdoZXJlIDAgaXMgdGhlIGxlZnQgb2YgdGhlIGNhbnZhcy5cbiAqIEhvd2V2ZXIsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHZhbHVlcyBvdXRzaWRlIHRoZSByYW5nZSwgYXNcbiAqIHZhbHVlcyBjYW4gZmFsbCBvdXRzaWRlIHRoZSBjYW52YXMuXG4gKlxuICogSWYgeCBpcyBudWxsLCB0aGlzIHJldHVybnMgbnVsbC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBkYXRhIHgtY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge251bWJlcn0gQSBmcmFjdGlvbiBpbiBbMCwgMV0gd2hlcmUgMCA9IHRoZSBsZWZ0IGVkZ2UuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnRvUGVyY2VudFhDb29yZCA9IGZ1bmN0aW9uKHgpIHtcbiAgaWYgKHggPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciB4UmFuZ2UgPSB0aGlzLnhBeGlzUmFuZ2UoKTtcbiAgdmFyIHBjdDtcbiAgdmFyIGxvZ3NjYWxlID0gdGhpcy5hdHRyaWJ1dGVzXy5nZXRGb3JBeGlzKFwibG9nc2NhbGVcIiwgJ3gnKSA7XG4gIGlmIChsb2dzY2FsZSA9PT0gdHJ1ZSkgeyAgLy8gbG9nc2NhbGUgY2FuIGJlIG51bGwgc28gd2UgdGVzdCBmb3IgdHJ1ZSBleHBsaWNpdGx5LlxuICAgIHZhciBsb2dyMCA9IHV0aWxzLmxvZzEwKHhSYW5nZVswXSk7XG4gICAgdmFyIGxvZ3IxID0gdXRpbHMubG9nMTAoeFJhbmdlWzFdKTtcbiAgICBwY3QgPSAodXRpbHMubG9nMTAoeCkgLSBsb2dyMCkgLyAobG9ncjEgLSBsb2dyMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8geCAtIHhSYW5nZVswXSBpcyB1bml0IGRpc3RhbmNlIGZyb20gdGhlIGxlZnQuXG4gICAgLy8geFJhbmdlWzFdIC0geFJhbmdlWzBdIGlzIHRoZSBzY2FsZSBvZiB0aGUgcmFuZ2UuXG4gICAgLy8gVGhlIGZ1bGwgZXhwcmVzc2lvbiBiZWxvdyBpcyB0aGUgJSBmcm9tIHRoZSBsZWZ0LlxuICAgIHBjdCA9ICh4IC0geFJhbmdlWzBdKSAvICh4UmFuZ2VbMV0gLSB4UmFuZ2VbMF0pO1xuICB9XG4gIHJldHVybiBwY3Q7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBjb2x1bW5zIChpbmNsdWRpbmcgdGhlIGluZGVwZW5kZW50IHZhcmlhYmxlKS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjb2x1bW5zLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5udW1Db2x1bW5zID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5yYXdEYXRhXykgcmV0dXJuIDA7XG4gIHJldHVybiB0aGlzLnJhd0RhdGFfWzBdID8gdGhpcy5yYXdEYXRhX1swXS5sZW5ndGggOiB0aGlzLmF0dHJfKFwibGFiZWxzXCIpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJvd3MgKGV4Y2x1ZGluZyBhbnkgaGVhZGVyL2xhYmVsIHJvdykuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygcm93cywgbGVzcyBhbnkgaGVhZGVyLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5udW1Sb3dzID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5yYXdEYXRhXykgcmV0dXJuIDA7XG4gIHJldHVybiB0aGlzLnJhd0RhdGFfLmxlbmd0aDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgaW4gdGhlIGdpdmVuIHJvdyBhbmQgY29sdW1uLiBJZiB0aGUgcm93IGFuZCBjb2x1bW4gZXhjZWVkXG4gKiB0aGUgYm91bmRzIG9uIHRoZSBkYXRhLCByZXR1cm5zIG51bGwuIEFsc28gcmV0dXJucyBudWxsIGlmIHRoZSB2YWx1ZSBpc1xuICogbWlzc2luZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3cgVGhlIHJvdyBudW1iZXIgb2YgdGhlIGRhdGEgKDAtYmFzZWQpLiBSb3cgMCBpcyB0aGVcbiAqICAgICBmaXJzdCByb3cgb2YgZGF0YSwgbm90IGEgaGVhZGVyIHJvdy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2wgVGhlIGNvbHVtbiBudW1iZXIgb2YgdGhlIGRhdGEgKDAtYmFzZWQpXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB2YWx1ZSBpbiB0aGUgc3BlY2lmaWVkIGNlbGwgb3IgbnVsbCBpZiB0aGUgcm93L2NvbFxuICogICAgIHdlcmUgb3V0IG9mIHJhbmdlLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKHJvdywgY29sKSB7XG4gIGlmIChyb3cgPCAwIHx8IHJvdyA+IHRoaXMucmF3RGF0YV8ubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgaWYgKGNvbCA8IDAgfHwgY29sID4gdGhpcy5yYXdEYXRhX1tyb3ddLmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIHRoaXMucmF3RGF0YV9bcm93XVtjb2xdO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgaW50ZXJmYWNlIGVsZW1lbnRzIGZvciB0aGUgRHlncmFwaDogYSBjb250YWluaW5nIGRpdiwgYSBkaXYgdG9cbiAqIGRpc3BsYXkgdGhlIGN1cnJlbnQgcG9pbnQsIGFuZCBhIHRleHRib3ggdG8gYWRqdXN0IHRoZSByb2xsaW5nIGF2ZXJhZ2VcbiAqIHBlcmlvZC4gQWxzbyBjcmVhdGVzIHRoZSBSZW5kZXJlci9MYXlvdXQgZWxlbWVudHMuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5jcmVhdGVJbnRlcmZhY2VfID0gZnVuY3Rpb24oKSB7XG4gIC8vIENyZWF0ZSB0aGUgYWxsLWVuY2xvc2luZyBncmFwaCBkaXZcbiAgdmFyIGVuY2xvc2luZyA9IHRoaXMubWFpbmRpdl87XG5cbiAgdGhpcy5ncmFwaERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgLy8gVE9ETyhkYW52ayk6IGFueSBvdGhlciBzdHlsZXMgdGhhdCBhcmUgdXNlZnVsIHRvIHNldCBoZXJlP1xuICB0aGlzLmdyYXBoRGl2LnN0eWxlLnRleHRBbGlnbiA9ICdsZWZ0JzsgIC8vIFRoaXMgaXMgYSBDU1MgXCJyZXNldFwiXG4gIHRoaXMuZ3JhcGhEaXYuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICBlbmNsb3NpbmcuYXBwZW5kQ2hpbGQodGhpcy5ncmFwaERpdik7XG5cbiAgLy8gQ3JlYXRlIHRoZSBjYW52YXMgZm9yIGludGVyYWN0aXZlIHBhcnRzIG9mIHRoZSBjaGFydC5cbiAgdGhpcy5jYW52YXNfID0gdXRpbHMuY3JlYXRlQ2FudmFzKCk7XG4gIHRoaXMuY2FudmFzXy5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblxuICAvLyAuLi4gYW5kIGZvciBzdGF0aWMgcGFydHMgb2YgdGhlIGNoYXJ0LlxuICB0aGlzLmhpZGRlbl8gPSB0aGlzLmNyZWF0ZVBsb3RLaXRDYW52YXNfKHRoaXMuY2FudmFzXyk7XG5cbiAgdGhpcy5jYW52YXNfY3R4XyA9IHV0aWxzLmdldENvbnRleHQodGhpcy5jYW52YXNfKTtcbiAgdGhpcy5oaWRkZW5fY3R4XyA9IHV0aWxzLmdldENvbnRleHQodGhpcy5oaWRkZW5fKTtcblxuICB0aGlzLnJlc2l6ZUVsZW1lbnRzXygpO1xuXG4gIC8vIFRoZSBpbnRlcmFjdGl2ZSBwYXJ0cyBvZiB0aGUgZ3JhcGggYXJlIGRyYXduIG9uIHRvcCBvZiB0aGUgY2hhcnQuXG4gIHRoaXMuZ3JhcGhEaXYuYXBwZW5kQ2hpbGQodGhpcy5oaWRkZW5fKTtcbiAgdGhpcy5ncmFwaERpdi5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhc18pO1xuICB0aGlzLm1vdXNlRXZlbnRFbGVtZW50XyA9IHRoaXMuY3JlYXRlTW91c2VFdmVudEVsZW1lbnRfKCk7XG5cbiAgLy8gQ3JlYXRlIHRoZSBncmFwaGVyXG4gIHRoaXMubGF5b3V0XyA9IG5ldyBEeWdyYXBoTGF5b3V0KHRoaXMpO1xuXG4gIHZhciBkeWdyYXBoID0gdGhpcztcblxuICB0aGlzLm1vdXNlTW92ZUhhbmRsZXJfID0gZnVuY3Rpb24oZSkge1xuICAgIGR5Z3JhcGgubW91c2VNb3ZlXyhlKTtcbiAgfTtcblxuICB0aGlzLm1vdXNlT3V0SGFuZGxlcl8gPSBmdW5jdGlvbihlKSB7XG4gICAgLy8gVGhlIG1vdXNlIGhhcyBsZWZ0IHRoZSBjaGFydCBpZjpcbiAgICAvLyAxLiBlLnRhcmdldCBpcyBpbnNpZGUgdGhlIGNoYXJ0XG4gICAgLy8gMi4gZS5yZWxhdGVkVGFyZ2V0IGlzIG91dHNpZGUgdGhlIGNoYXJ0XG4gICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuZnJvbUVsZW1lbnQ7XG4gICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSBlLnJlbGF0ZWRUYXJnZXQgfHwgZS50b0VsZW1lbnQ7XG4gICAgaWYgKHV0aWxzLmlzTm9kZUNvbnRhaW5lZEJ5KHRhcmdldCwgZHlncmFwaC5ncmFwaERpdikgJiZcbiAgICAgICAgIXV0aWxzLmlzTm9kZUNvbnRhaW5lZEJ5KHJlbGF0ZWRUYXJnZXQsIGR5Z3JhcGguZ3JhcGhEaXYpKSB7XG4gICAgICBkeWdyYXBoLm1vdXNlT3V0XyhlKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5hZGRBbmRUcmFja0V2ZW50KHdpbmRvdywgJ21vdXNlb3V0JywgdGhpcy5tb3VzZU91dEhhbmRsZXJfKTtcbiAgdGhpcy5hZGRBbmRUcmFja0V2ZW50KHRoaXMubW91c2VFdmVudEVsZW1lbnRfLCAnbW91c2Vtb3ZlJywgdGhpcy5tb3VzZU1vdmVIYW5kbGVyXyk7XG5cbiAgLy8gRG9uJ3QgcmVjcmVhdGUgYW5kIHJlZ2lzdGVyIHRoZSByZXNpemUgaGFuZGxlciBvbiBzdWJzZXF1ZW50IGNhbGxzLlxuICAvLyBUaGlzIGhhcHBlbnMgd2hlbiB0aGUgZ3JhcGggaXMgcmVzaXplZC5cbiAgaWYgKCF0aGlzLnJlc2l6ZUhhbmRsZXJfKSB7XG4gICAgdGhpcy5yZXNpemVIYW5kbGVyXyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGR5Z3JhcGgucmVzaXplKCk7XG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSB3aGVuIHRoZSB3aW5kb3cgaXMgcmVzaXplZC5cbiAgICAvLyBUT0RPKGRhbnZrKTogZHJvcCBmcmFtZXMgZGVwZW5kaW5nIG9uIGNvbXBsZXhpdHkgb2YgdGhlIGNoYXJ0LlxuICAgIHRoaXMuYWRkQW5kVHJhY2tFdmVudCh3aW5kb3csICdyZXNpemUnLCB0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgfVxufTtcblxuRHlncmFwaC5wcm90b3R5cGUucmVzaXplRWxlbWVudHNfID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZ3JhcGhEaXYuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoXyArIFwicHhcIjtcbiAgdGhpcy5ncmFwaERpdi5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodF8gKyBcInB4XCI7XG5cbiAgdmFyIHBpeGVsUmF0aW9PcHRpb24gPSB0aGlzLmdldE51bWVyaWNPcHRpb24oJ3BpeGVsUmF0aW8nKVxuXG4gIHZhciBjYW52YXNTY2FsZSA9IHBpeGVsUmF0aW9PcHRpb24gfHwgdXRpbHMuZ2V0Q29udGV4dFBpeGVsUmF0aW8odGhpcy5jYW52YXNfY3R4Xyk7XG4gIHRoaXMuY2FudmFzXy53aWR0aCA9IHRoaXMud2lkdGhfICogY2FudmFzU2NhbGU7XG4gIHRoaXMuY2FudmFzXy5oZWlnaHQgPSB0aGlzLmhlaWdodF8gKiBjYW52YXNTY2FsZTtcbiAgdGhpcy5jYW52YXNfLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aF8gKyBcInB4XCI7ICAgIC8vIGZvciBJRVxuICB0aGlzLmNhbnZhc18uc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHRfICsgXCJweFwiOyAgLy8gZm9yIElFXG4gIGlmIChjYW52YXNTY2FsZSAhPT0gMSkge1xuICAgIHRoaXMuY2FudmFzX2N0eF8uc2NhbGUoY2FudmFzU2NhbGUsIGNhbnZhc1NjYWxlKTtcbiAgfVxuXG4gIHZhciBoaWRkZW5TY2FsZSA9IHBpeGVsUmF0aW9PcHRpb24gfHwgdXRpbHMuZ2V0Q29udGV4dFBpeGVsUmF0aW8odGhpcy5oaWRkZW5fY3R4Xyk7XG4gIHRoaXMuaGlkZGVuXy53aWR0aCA9IHRoaXMud2lkdGhfICogaGlkZGVuU2NhbGU7XG4gIHRoaXMuaGlkZGVuXy5oZWlnaHQgPSB0aGlzLmhlaWdodF8gKiBoaWRkZW5TY2FsZTtcbiAgdGhpcy5oaWRkZW5fLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aF8gKyBcInB4XCI7ICAgIC8vIGZvciBJRVxuICB0aGlzLmhpZGRlbl8uc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHRfICsgXCJweFwiOyAgLy8gZm9yIElFXG4gIGlmIChoaWRkZW5TY2FsZSAhPT0gMSkge1xuICAgIHRoaXMuaGlkZGVuX2N0eF8uc2NhbGUoaGlkZGVuU2NhbGUsIGhpZGRlblNjYWxlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXRhY2ggRE9NIGVsZW1lbnRzIGluIHRoZSBkeWdyYXBoIGFuZCBudWxsIG91dCBhbGwgZGF0YSByZWZlcmVuY2VzLlxuICogQ2FsbGluZyB0aGlzIHdoZW4geW91J3JlIGRvbmUgd2l0aCBhIGR5Z3JhcGggY2FuIGRyYW1hdGljYWxseSByZWR1Y2UgbWVtb3J5XG4gKiB1c2FnZS4gU2VlLCBlLmcuLCB0aGUgdGVzdHMvcGVyZi5odG1sIGV4YW1wbGUuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jYW52YXNfY3R4Xy5yZXN0b3JlKCk7XG4gIHRoaXMuaGlkZGVuX2N0eF8ucmVzdG9yZSgpO1xuXG4gIC8vIERlc3Ryb3kgYW55IHBsdWdpbnMsIGluIHRoZSByZXZlcnNlIG9yZGVyIHRoYXQgdGhleSB3ZXJlIHJlZ2lzdGVyZWQuXG4gIGZvciAodmFyIGkgPSB0aGlzLnBsdWdpbnNfLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBsdWdpbnNfLnBvcCgpO1xuICAgIGlmIChwLnBsdWdpbi5kZXN0cm95KSBwLnBsdWdpbi5kZXN0cm95KCk7XG4gIH1cblxuICB2YXIgcmVtb3ZlUmVjdXJzaXZlID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHdoaWxlIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgcmVtb3ZlUmVjdXJzaXZlKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMucmVtb3ZlVHJhY2tlZEV2ZW50c18oKTtcblxuICAvLyByZW1vdmUgbW91c2UgZXZlbnQgaGFuZGxlcnMgKFRoaXMgbWF5IG5vdCBiZSBuZWNlc3NhcnkgYW55bW9yZSlcbiAgdXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAnbW91c2VvdXQnLCB0aGlzLm1vdXNlT3V0SGFuZGxlcl8pO1xuICB1dGlscy5yZW1vdmVFdmVudCh0aGlzLm1vdXNlRXZlbnRFbGVtZW50XywgJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlSGFuZGxlcl8pO1xuXG4gIC8vIHJlbW92ZSB3aW5kb3cgaGFuZGxlcnNcbiAgdXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCdyZXNpemUnLCB0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgdGhpcy5yZXNpemVIYW5kbGVyXyA9IG51bGw7XG5cbiAgcmVtb3ZlUmVjdXJzaXZlKHRoaXMubWFpbmRpdl8pO1xuXG4gIHZhciBudWxsT3V0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgZm9yICh2YXIgbiBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Yob2JqW25dKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb2JqW25dID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFRoZXNlIG1heSBub3QgYWxsIGJlIG5lY2Vzc2FyeSwgYnV0IGl0IGNhbid0IGh1cnQuLi5cbiAgbnVsbE91dCh0aGlzLmxheW91dF8pO1xuICBudWxsT3V0KHRoaXMucGxvdHRlcl8pO1xuICBudWxsT3V0KHRoaXMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBjYW52YXMgb24gd2hpY2ggdGhlIGNoYXJ0IHdpbGwgYmUgZHJhd24uIE9ubHkgdGhlIFJlbmRlcmVyIGV2ZXJcbiAqIGRyYXdzIG9uIHRoaXMgcGFydGljdWxhciBjYW52YXMuIEFsbCBEeWdyYXBoIHdvcmsgKGkuZS4gZHJhd2luZyBob3ZlciBkb3RzXG4gKiBvciB0aGUgem9vbSByZWN0YW5nbGVzKSBpcyBkb25lIG9uIHRoaXMuY2FudmFzXy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXMgVGhlIER5Z3JhcGggY2FudmFzIG92ZXIgd2hpY2ggdG8gb3ZlcmxheSB0aGUgcGxvdFxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3bHktY3JlYXRlZCBjYW52YXNcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmNyZWF0ZVBsb3RLaXRDYW52YXNfID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gIHZhciBoID0gdXRpbHMuY3JlYXRlQ2FudmFzKCk7XG4gIGguc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gIC8vIFRPRE8oZGFudmspOiBoIHNob3VsZCBiZSBvZmZzZXQgZnJvbSBjYW52YXMuIGNhbnZhcyBuZWVkcyB0byBpbmNsdWRlXG4gIC8vIHNvbWUgZXh0cmEgYXJlYSB0byBtYWtlIGl0IGVhc2llciB0byB6b29tIGluIG9uIHRoZSBmYXIgbGVmdCBhbmQgZmFyXG4gIC8vIHJpZ2h0LiBoIG5lZWRzIHRvIGJlIHByZWNpc2VseSB0aGUgcGxvdCBhcmVhLCBzbyB0aGF0IGNsaXBwaW5nIG9jY3Vycy5cbiAgaC5zdHlsZS50b3AgPSBjYW52YXMuc3R5bGUudG9wO1xuICBoLnN0eWxlLmxlZnQgPSBjYW52YXMuc3R5bGUubGVmdDtcbiAgaC53aWR0aCA9IHRoaXMud2lkdGhfO1xuICBoLmhlaWdodCA9IHRoaXMuaGVpZ2h0XztcbiAgaC5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGhfICsgXCJweFwiOyAgICAvLyBmb3IgSUVcbiAgaC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodF8gKyBcInB4XCI7ICAvLyBmb3IgSUVcbiAgcmV0dXJuIGg7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb3ZlcmxheSBlbGVtZW50IHVzZWQgdG8gaGFuZGxlIG1vdXNlIGV2ZW50cy5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1vdXNlIGV2ZW50IGVsZW1lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5jcmVhdGVNb3VzZUV2ZW50RWxlbWVudF8gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY2FudmFzXztcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgZGlzdGluY3QgY29sb3JzIGZvciB0aGUgZGF0YSBzZXJpZXMuIFRoaXMgaXMgZG9uZSB3aXRoIGFcbiAqIGNvbG9yIHdoZWVsLiBTYXR1cmF0aW9uL1ZhbHVlIGFyZSBjdXN0b21pemFibGUsIGFuZCB0aGUgaHVlIGlzXG4gKiBlcXVhbGx5LXNwYWNlZCBhcm91bmQgdGhlIGNvbG9yIHdoZWVsLiBJZiBhIGN1c3RvbSBzZXQgb2YgY29sb3JzIGlzXG4gKiBzcGVjaWZpZWQsIHRoYXQgaXMgdXNlZCBpbnN0ZWFkLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuc2V0Q29sb3JzXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgdmFyIG51bSA9IGxhYmVscy5sZW5ndGggLSAxO1xuICB0aGlzLmNvbG9yc18gPSBbXTtcbiAgdGhpcy5jb2xvcnNNYXBfID0ge307XG5cbiAgLy8gVGhlc2UgYXJlIHVzZWQgZm9yIHdoZW4gbm8gY3VzdG9tIGNvbG9ycyBhcmUgc3BlY2lmaWVkLlxuICB2YXIgc2F0ID0gdGhpcy5nZXROdW1lcmljT3B0aW9uKCdjb2xvclNhdHVyYXRpb24nKSB8fCAxLjA7XG4gIHZhciB2YWwgPSB0aGlzLmdldE51bWVyaWNPcHRpb24oJ2NvbG9yVmFsdWUnKSB8fCAwLjU7XG4gIHZhciBoYWxmID0gTWF0aC5jZWlsKG51bSAvIDIpO1xuXG4gIHZhciBjb2xvcnMgPSB0aGlzLmdldE9wdGlvbignY29sb3JzJyk7XG4gIHZhciB2aXNpYmlsaXR5ID0gdGhpcy52aXNpYmlsaXR5KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICBpZiAoIXZpc2liaWxpdHlbaV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbGFiZWwgPSBsYWJlbHNbaSArIDFdO1xuICAgIHZhciBjb2xvclN0ciA9IHRoaXMuYXR0cmlidXRlc18uZ2V0Rm9yU2VyaWVzKCdjb2xvcicsIGxhYmVsKTtcbiAgICBpZiAoIWNvbG9yU3RyKSB7XG4gICAgICBpZiAoY29sb3JzKSB7XG4gICAgICAgIGNvbG9yU3RyID0gY29sb3JzW2kgJSBjb2xvcnMubGVuZ3RoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFsdGVybmF0ZSBjb2xvcnMgZm9yIGhpZ2ggY29udHJhc3QuXG4gICAgICAgIHZhciBpZHggPSBpICUgMiA/IChoYWxmICsgKGkgKyAxKS8gMikgOiBNYXRoLmNlaWwoKGkgKyAxKSAvIDIpO1xuICAgICAgICB2YXIgaHVlID0gKDEuMCAqIGlkeCAvICgxICsgbnVtKSk7XG4gICAgICAgIGNvbG9yU3RyID0gdXRpbHMuaHN2VG9SR0IoaHVlLCBzYXQsIHZhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29sb3JzXy5wdXNoKGNvbG9yU3RyKTtcbiAgICB0aGlzLmNvbG9yc01hcF9bbGFiZWxdID0gY29sb3JTdHI7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0IG9mIGNvbG9ycy4gVGhpcyBpcyBlaXRoZXIgdGhlIGxpc3Qgb2YgY29sb3JzIHBhc3NlZCBpbiB0aGVcbiAqIGF0dHJpYnV0ZXMgb3IgdGhlIGF1dG9nZW5lcmF0ZWQgbGlzdCBvZiByZ2IocixnLGIpIHN0cmluZ3MuXG4gKiBUaGlzIGRvZXMgbm90IHJldHVybiBjb2xvcnMgZm9yIGludmlzaWJsZSBzZXJpZXMuXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gVGhlIGxpc3Qgb2YgY29sb3JzLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRDb2xvcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY29sb3JzXztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZldyBhdHRyaWJ1dGVzIG9mIGEgc2VyaWVzLCBpLmUuIGl0cyBjb2xvciwgaXRzIHZpc2liaWxpdHksIHdoaWNoXG4gKiBheGlzIGl0J3MgYXNzaWduZWQgdG8sIGFuZCBpdHMgY29sdW1uIGluIHRoZSBvcmlnaW5hbCBkYXRhLlxuICogUmV0dXJucyBudWxsIGlmIHRoZSBzZXJpZXMgZG9lcyBub3QgZXhpc3QuXG4gKiBPdGhlcndpc2UsIHJldHVybnMgYW4gb2JqZWN0IHdpdGggY29sdW1uLCB2aXNpYmlsaXR5LCBjb2xvciBhbmQgYXhpcyBwcm9wZXJ0aWVzLlxuICogVGhlIFwiYXhpc1wiIHByb3BlcnR5IHdpbGwgYmUgc2V0IHRvIDEgZm9yIHkxIGFuZCAyIGZvciB5Mi5cbiAqIFRoZSBcImNvbHVtblwiIHByb3BlcnR5IGNhbiBiZSBmZWQgYmFjayBpbnRvIGdldFZhbHVlKHJvdywgY29sdW1uKSB0byBnZXRcbiAqIHZhbHVlcyBmb3IgdGhpcyBzZXJpZXMuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldFByb3BlcnRpZXNGb3JTZXJpZXMgPSBmdW5jdGlvbihzZXJpZXNfbmFtZSkge1xuICB2YXIgaWR4ID0gLTE7XG4gIHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsYWJlbHNbaV0gPT0gc2VyaWVzX25hbWUpIHtcbiAgICAgIGlkeCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGlkeCA9PSAtMSkgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBzZXJpZXNfbmFtZSxcbiAgICBjb2x1bW46IGlkeCxcbiAgICB2aXNpYmxlOiB0aGlzLnZpc2liaWxpdHkoKVtpZHggLSAxXSxcbiAgICBjb2xvcjogdGhpcy5jb2xvcnNNYXBfW3Nlcmllc19uYW1lXSxcbiAgICBheGlzOiAxICsgdGhpcy5hdHRyaWJ1dGVzXy5heGlzRm9yU2VyaWVzKHNlcmllc19uYW1lKVxuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIHRleHQgYm94IHRvIGFkanVzdCB0aGUgYXZlcmFnaW5nIHBlcmlvZFxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuY3JlYXRlUm9sbEludGVyZmFjZV8gPSBmdW5jdGlvbigpIHtcbiAgLy8gQ3JlYXRlIGEgcm9sbGVyIGlmIG9uZSBkb2Vzbid0IGV4aXN0IGFscmVhZHkuXG4gIHZhciByb2xsZXIgPSB0aGlzLnJvbGxlcl87XG4gIGlmICghcm9sbGVyKSB7XG4gICAgdGhpcy5yb2xsZXJfID0gcm9sbGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIHJvbGxlci50eXBlID0gXCJ0ZXh0XCI7XG4gICAgcm9sbGVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICByb2xsZXIuY2xhc3NOYW1lID0gJ2R5Z3JhcGgtcm9sbGVyJztcbiAgICB0aGlzLmdyYXBoRGl2LmFwcGVuZENoaWxkKHJvbGxlcik7XG4gIH1cblxuICB2YXIgZGlzcGxheSA9IHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbignc2hvd1JvbGxlcicpID8gJ2Jsb2NrJyA6ICdub25lJztcblxuICB2YXIgYXJlYSA9IHRoaXMuZ2V0QXJlYSgpO1xuICB2YXIgdGV4dEF0dHIgPSB7XG4gICAgICAgICAgICAgICAgICAgXCJ0b3BcIjogKGFyZWEueSArIGFyZWEuaCAtIDI1KSArIFwicHhcIixcbiAgICAgICAgICAgICAgICAgICBcImxlZnRcIjogKGFyZWEueCArIDEpICsgXCJweFwiLFxuICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBkaXNwbGF5XG4gICAgICAgICAgICAgICAgIH07XG4gIHJvbGxlci5zaXplID0gXCIyXCI7XG4gIHJvbGxlci52YWx1ZSA9IHRoaXMucm9sbFBlcmlvZF87XG4gIHV0aWxzLnVwZGF0ZShyb2xsZXIuc3R5bGUsIHRleHRBdHRyKTtcblxuICByb2xsZXIub25jaGFuZ2UgPSAoKSA9PiB0aGlzLmFkanVzdFJvbGwocm9sbGVyLnZhbHVlKTtcbn07XG5cbi8qKlxuICogU2V0IHVwIGFsbCB0aGUgbW91c2UgaGFuZGxlcnMgbmVlZGVkIHRvIGNhcHR1cmUgZHJhZ2dpbmcgYmVoYXZpb3IgZm9yIHpvb21cbiAqIGV2ZW50cy5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmNyZWF0ZURyYWdJbnRlcmZhY2VfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb250ZXh0ID0ge1xuICAgIC8vIFRyYWNrcyB3aGV0aGVyIHRoZSBtb3VzZSBpcyBkb3duIHJpZ2h0IG5vd1xuICAgIGlzWm9vbWluZzogZmFsc2UsXG4gICAgaXNQYW5uaW5nOiBmYWxzZSwgIC8vIGlzIHRoaXMgZHJhZyBwYXJ0IG9mIGEgcGFuP1xuICAgIGlzMkRQYW46IGZhbHNlLCAgICAvLyBpZiBzbywgaXMgdGhhdCBwYW4gMS0gb3IgMi1kaW1lbnNpb25hbD9cbiAgICBkcmFnU3RhcnRYOiBudWxsLCAvLyBwaXhlbCBjb29yZGluYXRlc1xuICAgIGRyYWdTdGFydFk6IG51bGwsIC8vIHBpeGVsIGNvb3JkaW5hdGVzXG4gICAgZHJhZ0VuZFg6IG51bGwsIC8vIHBpeGVsIGNvb3JkaW5hdGVzXG4gICAgZHJhZ0VuZFk6IG51bGwsIC8vIHBpeGVsIGNvb3JkaW5hdGVzXG4gICAgZHJhZ0RpcmVjdGlvbjogbnVsbCxcbiAgICBwcmV2RW5kWDogbnVsbCwgLy8gcGl4ZWwgY29vcmRpbmF0ZXNcbiAgICBwcmV2RW5kWTogbnVsbCwgLy8gcGl4ZWwgY29vcmRpbmF0ZXNcbiAgICBwcmV2RHJhZ0RpcmVjdGlvbjogbnVsbCxcbiAgICBjYW5jZWxOZXh0RGJsY2xpY2s6IGZhbHNlLCAgLy8gc2VlIGNvbW1lbnQgaW4gZHlncmFwaC1pbnRlcmFjdGlvbi1tb2RlbC5qc1xuXG4gICAgLy8gVGhlIHZhbHVlIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGdyYXBoIHdoZW4gYSBwYW4gb3BlcmF0aW9uIHN0YXJ0cy5cbiAgICBpbml0aWFsTGVmdG1vc3REYXRlOiBudWxsLFxuXG4gICAgLy8gVGhlIG51bWJlciBvZiB1bml0cyBlYWNoIHBpeGVsIHNwYW5zLiAoVGhpcyB3b24ndCBiZSB2YWxpZCBmb3IgbG9nXG4gICAgLy8gc2NhbGVzKVxuICAgIHhVbml0c1BlclBpeGVsOiBudWxsLFxuXG4gICAgLy8gVE9ETyhkYW52ayk6IHVwZGF0ZSB0aGlzIGNvbW1lbnRcbiAgICAvLyBUaGUgcmFuZ2UgaW4gc2Vjb25kL3ZhbHVlIHVuaXRzIHRoYXQgdGhlIHZpZXdwb3J0IGVuY29tcGFzc2VzIGR1cmluZyBhXG4gICAgLy8gcGFubmluZyBvcGVyYXRpb24uXG4gICAgZGF0ZVJhbmdlOiBudWxsLFxuXG4gICAgLy8gVG9wLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXMsIGluIERPTSBjb29yZHNcbiAgICAvLyBUT0RPKGtvbmlnc2JlcmcpOiBSZW5hbWUgdG9wTGVmdENhbnZhc1gsIHRvcExlZnRDYW52YXNZLlxuICAgIHB4OiAwLFxuICAgIHB5OiAwLFxuXG4gICAgLy8gVmFsdWVzIGZvciB1c2Ugd2l0aCBwYW5FZGdlRnJhY3Rpb24sIHdoaWNoIGxpbWl0IGhvdyBmYXIgb3V0c2lkZSB0aGVcbiAgICAvLyBncmFwaCdzIGRhdGEgYm91bmRhcmllcyBpdCBjYW4gYmUgcGFubmVkLlxuICAgIGJvdW5kZWREYXRlczogbnVsbCwgLy8gW21pbkRhdGUsIG1heERhdGVdXG4gICAgYm91bmRlZFZhbHVlczogbnVsbCwgLy8gW1ttaW5WYWx1ZSwgbWF4VmFsdWVdIC4uLl1cblxuICAgIC8vIFdlIGNvdmVyIGlmcmFtZXMgZHVyaW5nIG1vdXNlIGludGVyYWN0aW9ucy4gU2VlIGNvbW1lbnRzIGluXG4gICAgLy8gZHlncmFwaC11dGlscy5qcyBmb3IgbW9yZSBpbmZvIG9uIHdoeSB0aGlzIGlzIGEgZ29vZCBpZGVhLlxuICAgIHRhcnA6IG5ldyBJRnJhbWVUYXJwKCksXG5cbiAgICAvLyBjb250ZXh0QiBpcyB0aGUgc2FtZSB0aGluZyBhcyB0aGlzIGNvbnRleHQgb2JqZWN0IGJ1dCByZW5hbWVkLlxuICAgIGluaXRpYWxpemVNb3VzZURvd246IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0Qikge1xuICAgICAgLy8gcHJldmVudHMgbW91c2UgZHJhZ3MgZnJvbSBzZWxlY3RpbmcgcGFnZSB0ZXh0LlxuICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7ICAvLyBGaXJlZm94LCBDaHJvbWUsIGV0Yy5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7ICAvLyBJRVxuICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FudmFzUG9zID0gdXRpbHMuZmluZFBvcyhnLmNhbnZhc18pO1xuICAgICAgY29udGV4dEIucHggPSBjYW52YXNQb3MueDtcbiAgICAgIGNvbnRleHRCLnB5ID0gY2FudmFzUG9zLnk7XG4gICAgICBjb250ZXh0Qi5kcmFnU3RhcnRYID0gdXRpbHMuZHJhZ0dldFhfKGV2ZW50LCBjb250ZXh0Qik7XG4gICAgICBjb250ZXh0Qi5kcmFnU3RhcnRZID0gdXRpbHMuZHJhZ0dldFlfKGV2ZW50LCBjb250ZXh0Qik7XG4gICAgICBjb250ZXh0Qi5jYW5jZWxOZXh0RGJsY2xpY2sgPSBmYWxzZTtcbiAgICAgIGNvbnRleHRCLnRhcnAuY292ZXIoKTtcbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgaWYgKGNvbnRleHQuaXNab29taW5nIHx8IGNvbnRleHQuaXNQYW5uaW5nKSB7XG4gICAgICAgIGNvbnRleHQuaXNab29taW5nID0gZmFsc2U7XG4gICAgICAgIGNvbnRleHQuZHJhZ1N0YXJ0WCA9IG51bGw7XG4gICAgICAgIGNvbnRleHQuZHJhZ1N0YXJ0WSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb250ZXh0LmlzUGFubmluZykge1xuICAgICAgICBjb250ZXh0LmlzUGFubmluZyA9IGZhbHNlO1xuICAgICAgICBjb250ZXh0LmRyYWdnaW5nRGF0ZSA9IG51bGw7XG4gICAgICAgIGNvbnRleHQuZGF0ZVJhbmdlID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmF4ZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZGVsZXRlIHNlbGYuYXhlc19baV0uZHJhZ2dpbmdWYWx1ZTtcbiAgICAgICAgICBkZWxldGUgc2VsZi5heGVzX1tpXS5kcmFnVmFsdWVSYW5nZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnRhcnAudW5jb3ZlcigpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaW50ZXJhY3Rpb25Nb2RlbCA9IHRoaXMuZ2V0T3B0aW9uKFwiaW50ZXJhY3Rpb25Nb2RlbFwiKTtcblxuICAvLyBTZWxmIGlzIHRoZSBncmFwaC5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIEZ1bmN0aW9uIHRoYXQgYmluZHMgdGhlIGdyYXBoIGFuZCBjb250ZXh0IHRvIHRoZSBoYW5kbGVyLlxuICB2YXIgYmluZEhhbmRsZXIgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBoYW5kbGVyKGV2ZW50LCBzZWxmLCBjb250ZXh0KTtcbiAgICB9O1xuICB9O1xuXG4gIGZvciAodmFyIGV2ZW50TmFtZSBpbiBpbnRlcmFjdGlvbk1vZGVsKSB7XG4gICAgaWYgKCFpbnRlcmFjdGlvbk1vZGVsLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIGNvbnRpbnVlO1xuICAgIHRoaXMuYWRkQW5kVHJhY2tFdmVudCh0aGlzLm1vdXNlRXZlbnRFbGVtZW50XywgZXZlbnROYW1lLFxuICAgICAgICBiaW5kSGFuZGxlcihpbnRlcmFjdGlvbk1vZGVsW2V2ZW50TmFtZV0pKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBtb3VzZSBidXR0b24gZHVyaW5nIGEgZHJhZywgYnV0IG5vdCBvdmVyIHRoZVxuICAvLyBjYW52YXMsIHRoZW4gaXQgZG9lc24ndCBjb3VudCBhcyBhIHpvb21pbmcgYWN0aW9uLlxuICBpZiAoIWludGVyYWN0aW9uTW9kZWwud2lsbERlc3Ryb3lDb250ZXh0TXlzZWxmKSB7XG4gICAgdmFyIG1vdXNlVXBIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGNvbnRleHQuZGVzdHJveSgpO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZEFuZFRyYWNrRXZlbnQoZG9jdW1lbnQsICdtb3VzZXVwJywgbW91c2VVcEhhbmRsZXIpO1xuICB9XG59O1xuXG4vKipcbiAqIERyYXcgYSBncmF5IHpvb20gcmVjdGFuZ2xlIG92ZXIgdGhlIGRlc2lyZWQgYXJlYSBvZiB0aGUgY2FudmFzLiBBbHNvIGNsZWFyc1xuICogdXAgYW55IHByZXZpb3VzIHpvb20gcmVjdGFuZ2xlcyB0aGF0IHdlcmUgZHJhd24uIFRoaXMgY291bGQgYmUgb3B0aW1pemVkIHRvXG4gKiBhdm9pZCBleHRyYSByZWRyYXdpbmcsIGJ1dCBpdCdzIHRyaWNreSB0byBhdm9pZCBpbnRlcmFjdGlvbnMgd2l0aCB0aGUgc3RhdHVzXG4gKiBkb3RzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gdGhlIGRpcmVjdGlvbiBvZiB0aGUgem9vbSByZWN0YW5nbGUuIEFjY2VwdGFibGVcbiAqICAgICB2YWx1ZXMgYXJlIHV0aWxzLkhPUklaT05UQUwgYW5kIHV0aWxzLlZFUlRJQ0FMLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0WCBUaGUgWCBwb3NpdGlvbiB3aGVyZSB0aGUgZHJhZyBzdGFydGVkLCBpbiBjYW52YXNcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRYIFRoZSBjdXJyZW50IFggcG9zaXRpb24gb2YgdGhlIGRyYWcsIGluIGNhbnZhcyBjb29yZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRZIFRoZSBZIHBvc2l0aW9uIHdoZXJlIHRoZSBkcmFnIHN0YXJ0ZWQsIGluIGNhbnZhc1xuICogICAgIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZFkgVGhlIGN1cnJlbnQgWSBwb3NpdGlvbiBvZiB0aGUgZHJhZywgaW4gY2FudmFzIGNvb3Jkcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwcmV2RGlyZWN0aW9uIHRoZSB2YWx1ZSBvZiBkaXJlY3Rpb24gb24gdGhlIHByZXZpb3VzIGNhbGwgdG9cbiAqICAgICB0aGlzIGZ1bmN0aW9uLiBVc2VkIHRvIGF2b2lkIGV4Y2VzcyByZWRyYXdpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcmV2RW5kWCBUaGUgdmFsdWUgb2YgZW5kWCBvbiB0aGUgcHJldmlvdXMgY2FsbCB0byB0aGlzXG4gKiAgICAgZnVuY3Rpb24uIFVzZWQgdG8gYXZvaWQgZXhjZXNzIHJlZHJhd2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHByZXZFbmRZIFRoZSB2YWx1ZSBvZiBlbmRZIG9uIHRoZSBwcmV2aW91cyBjYWxsIHRvIHRoaXNcbiAqICAgICBmdW5jdGlvbi4gVXNlZCB0byBhdm9pZCBleGNlc3MgcmVkcmF3aW5nXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5kcmF3Wm9vbVJlY3RfID0gZnVuY3Rpb24oZGlyZWN0aW9uLCBzdGFydFgsIGVuZFgsIHN0YXJ0WSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRZLCBwcmV2RGlyZWN0aW9uLCBwcmV2RW5kWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2RW5kWSkge1xuICB2YXIgY3R4ID0gdGhpcy5jYW52YXNfY3R4XztcblxuICAvLyBDbGVhbiB1cCBmcm9tIHRoZSBwcmV2aW91cyByZWN0IGlmIG5lY2Vzc2FyeVxuICBpZiAocHJldkRpcmVjdGlvbiA9PSB1dGlscy5IT1JJWk9OVEFMKSB7XG4gICAgY3R4LmNsZWFyUmVjdChNYXRoLm1pbihzdGFydFgsIHByZXZFbmRYKSwgdGhpcy5sYXlvdXRfLmdldFBsb3RBcmVhKCkueSxcbiAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHN0YXJ0WCAtIHByZXZFbmRYKSwgdGhpcy5sYXlvdXRfLmdldFBsb3RBcmVhKCkuaCk7XG4gIH0gZWxzZSBpZiAocHJldkRpcmVjdGlvbiA9PSB1dGlscy5WRVJUSUNBTCkge1xuICAgIGN0eC5jbGVhclJlY3QodGhpcy5sYXlvdXRfLmdldFBsb3RBcmVhKCkueCwgTWF0aC5taW4oc3RhcnRZLCBwcmV2RW5kWSksXG4gICAgICAgICAgICAgICAgICB0aGlzLmxheW91dF8uZ2V0UGxvdEFyZWEoKS53LCBNYXRoLmFicyhzdGFydFkgLSBwcmV2RW5kWSkpO1xuICB9XG5cbiAgLy8gRHJhdyBhIGxpZ2h0LWdyZXkgcmVjdGFuZ2xlIHRvIHNob3cgdGhlIG5ldyB2aWV3aW5nIGFyZWFcbiAgaWYgKGRpcmVjdGlvbiA9PSB1dGlscy5IT1JJWk9OVEFMKSB7XG4gICAgaWYgKGVuZFggJiYgc3RhcnRYKSB7XG4gICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDEyOCwxMjgsMTI4LDAuMzMpXCI7XG4gICAgICBjdHguZmlsbFJlY3QoTWF0aC5taW4oc3RhcnRYLCBlbmRYKSwgdGhpcy5sYXlvdXRfLmdldFBsb3RBcmVhKCkueSxcbiAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhlbmRYIC0gc3RhcnRYKSwgdGhpcy5sYXlvdXRfLmdldFBsb3RBcmVhKCkuaCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSB1dGlscy5WRVJUSUNBTCkge1xuICAgIGlmIChlbmRZICYmIHN0YXJ0WSkge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYSgxMjgsMTI4LDEyOCwwLjMzKVwiO1xuICAgICAgY3R4LmZpbGxSZWN0KHRoaXMubGF5b3V0Xy5nZXRQbG90QXJlYSgpLngsIE1hdGgubWluKHN0YXJ0WSwgZW5kWSksXG4gICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXRfLmdldFBsb3RBcmVhKCkudywgTWF0aC5hYnMoZW5kWSAtIHN0YXJ0WSkpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhciB0aGUgem9vbSByZWN0YW5nbGUgKGFuZCBwZXJmb3JtIG5vIHpvb20pLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuY2xlYXJab29tUmVjdF8gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jdXJyZW50Wm9vbVJlY3RBcmdzXyA9IG51bGw7XG4gIHRoaXMuY2FudmFzX2N0eF8uY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGhfLCB0aGlzLmhlaWdodF8pO1xufTtcblxuLyoqXG4gKiBab29tIHRvIHNvbWV0aGluZyBjb250YWluaW5nIFtsb3dYLCBoaWdoWF0uIFRoZXNlIGFyZSBwaXhlbCBjb29yZGluYXRlcyBpblxuICogdGhlIGNhbnZhcy4gVGhlIGV4YWN0IHpvb20gd2luZG93IG1heSBiZSBzbGlnaHRseSBsYXJnZXIgaWYgdGhlcmUgYXJlIG5vIGRhdGFcbiAqIHBvaW50cyBuZWFyIGxvd1ggb3IgaGlnaFguIERvbid0IGNvbmZ1c2UgdGhpcyBmdW5jdGlvbiB3aXRoIGRvWm9vbVhEYXRlcyxcbiAqIHdoaWNoIGFjY2VwdHMgZGF0ZXMgdGhhdCBtYXRjaCB0aGUgcmF3IGRhdGEuIFRoaXMgZnVuY3Rpb24gcmVkcmF3cyB0aGUgZ3JhcGguXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGxvd1ggVGhlIGxlZnRtb3N0IHBpeGVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHZpc2libGUuXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaFggVGhlIHJpZ2h0bW9zdCBwaXhlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB2aXNpYmxlLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZG9ab29tWF8gPSBmdW5jdGlvbihsb3dYLCBoaWdoWCkge1xuICB0aGlzLmN1cnJlbnRab29tUmVjdEFyZ3NfID0gbnVsbDtcbiAgLy8gRmluZCB0aGUgZWFybGllc3QgYW5kIGxhdGVzdCBkYXRlcyBjb250YWluZWQgaW4gdGhpcyBjYW52YXN4IHJhbmdlLlxuICAvLyBDb252ZXJ0IHRoZSBjYWxsIHRvIGRhdGUgcmFuZ2VzIG9mIHRoZSByYXcgZGF0YS5cbiAgdmFyIG1pbkRhdGUgPSB0aGlzLnRvRGF0YVhDb29yZChsb3dYKTtcbiAgdmFyIG1heERhdGUgPSB0aGlzLnRvRGF0YVhDb29yZChoaWdoWCk7XG4gIHRoaXMuZG9ab29tWERhdGVzXyhtaW5EYXRlLCBtYXhEYXRlKTtcbn07XG5cbi8qKlxuICogWm9vbSB0byBzb21ldGhpbmcgY29udGFpbmluZyBbbWluRGF0ZSwgbWF4RGF0ZV0gdmFsdWVzLiBEb24ndCBjb25mdXNlIHRoaXNcbiAqIG1ldGhvZCB3aXRoIGRvWm9vbVggd2hpY2ggYWNjZXB0cyBwaXhlbCBjb29yZGluYXRlcy4gVGhpcyBmdW5jdGlvbiByZWRyYXdzXG4gKiB0aGUgZ3JhcGguXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG1pbkRhdGUgVGhlIG1pbmltdW0gZGF0ZSB0aGF0IHNob3VsZCBiZSB2aXNpYmxlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heERhdGUgVGhlIG1heGltdW0gZGF0ZSB0aGF0IHNob3VsZCBiZSB2aXNpYmxlLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZG9ab29tWERhdGVzXyA9IGZ1bmN0aW9uKG1pbkRhdGUsIG1heERhdGUpIHtcbiAgLy8gVE9ETyhkYW52ayk6IHdoZW4geEF4aXNSYW5nZSBpcyBudWxsIChpLmUuIFwiZml0IHRvIGRhdGFcIiwgdGhlIGFuaW1hdGlvblxuICAvLyBjYW4gcHJvZHVjZSBzdHJhbmdlIGVmZmVjdHMuIFJhdGhlciB0aGFuIHRoZSB4LWF4aXMgdHJhbnNpdGlvbmluZyBzbG93bHlcbiAgLy8gYmV0d2VlbiB2YWx1ZXMsIGl0IGNhbiBqZXJrIGFyb3VuZC4pXG4gIHZhciBvbGRfd2luZG93ID0gdGhpcy54QXhpc1JhbmdlKCk7XG4gIHZhciBuZXdfd2luZG93ID0gW21pbkRhdGUsIG1heERhdGVdO1xuICBjb25zdCB6b29tQ2FsbGJhY2sgPSB0aGlzLmdldEZ1bmN0aW9uT3B0aW9uKCd6b29tQ2FsbGJhY2snKTtcbiAgdGhpcy5kb0FuaW1hdGVkWm9vbShvbGRfd2luZG93LCBuZXdfd2luZG93LCBudWxsLCBudWxsLCAoKSA9PiB7XG4gICAgaWYgKHpvb21DYWxsYmFjaykge1xuICAgICAgem9vbUNhbGxiYWNrLmNhbGwodGhpcywgbWluRGF0ZSwgbWF4RGF0ZSwgdGhpcy55QXhpc1JhbmdlcygpKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBab29tIHRvIHNvbWV0aGluZyBjb250YWluaW5nIFtsb3dZLCBoaWdoWV0uIFRoZXNlIGFyZSBwaXhlbCBjb29yZGluYXRlcyBpblxuICogdGhlIGNhbnZhcy4gVGhpcyBmdW5jdGlvbiByZWRyYXdzIHRoZSBncmFwaC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93WSBUaGUgdG9wbW9zdCBwaXhlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB2aXNpYmxlLlxuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hZIFRoZSBsb3dlc3QgcGl4ZWwgdmFsdWUgdGhhdCBzaG91bGQgYmUgdmlzaWJsZS5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmRvWm9vbVlfID0gZnVuY3Rpb24obG93WSwgaGlnaFkpIHtcbiAgdGhpcy5jdXJyZW50Wm9vbVJlY3RBcmdzXyA9IG51bGw7XG4gIC8vIEZpbmQgdGhlIGhpZ2hlc3QgYW5kIGxvd2VzdCB2YWx1ZXMgaW4gcGl4ZWwgcmFuZ2UgZm9yIGVhY2ggYXhpcy5cbiAgLy8gTm90ZSB0aGF0IGxvd1kgKGluIHBpeGVscykgY29ycmVzcG9uZHMgdG8gdGhlIG1heCBWYWx1ZSAoaW4gZGF0YSBjb29yZHMpLlxuICAvLyBUaGlzIGlzIGJlY2F1c2UgcGl4ZWxzIGluY3JlYXNlIGFzIHlvdSBnbyBkb3duIG9uIHRoZSBzY3JlZW4sIHdoZXJlYXMgZGF0YVxuICAvLyBjb29yZGluYXRlcyBpbmNyZWFzZSBhcyB5b3UgZ28gdXAgdGhlIHNjcmVlbi5cbiAgdmFyIG9sZFZhbHVlUmFuZ2VzID0gdGhpcy55QXhpc1JhbmdlcygpO1xuICB2YXIgbmV3VmFsdWVSYW5nZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmF4ZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGhpID0gdGhpcy50b0RhdGFZQ29vcmQobG93WSwgaSk7XG4gICAgdmFyIGxvdyA9IHRoaXMudG9EYXRhWUNvb3JkKGhpZ2hZLCBpKTtcbiAgICBuZXdWYWx1ZVJhbmdlcy5wdXNoKFtsb3csIGhpXSk7XG4gIH1cblxuICBjb25zdCB6b29tQ2FsbGJhY2sgPSB0aGlzLmdldEZ1bmN0aW9uT3B0aW9uKCd6b29tQ2FsbGJhY2snKTtcbiAgdGhpcy5kb0FuaW1hdGVkWm9vbShudWxsLCBudWxsLCBvbGRWYWx1ZVJhbmdlcywgbmV3VmFsdWVSYW5nZXMsICgpID0+IHtcbiAgICBpZiAoem9vbUNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBbbWluWCwgbWF4WF0gPSB0aGlzLnhBeGlzUmFuZ2UoKTtcbiAgICAgIHpvb21DYWxsYmFjay5jYWxsKHRoaXMsIG1pblgsIG1heFgsIHRoaXMueUF4aXNSYW5nZXMoKSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogVHJhbnNpdGlvbiBmdW5jdGlvbiB0byB1c2UgaW4gYW5pbWF0aW9ucy4gUmV0dXJucyB2YWx1ZXMgYmV0d2VlbiAwLjBcbiAqICh0b3RhbGx5IG9sZCB2YWx1ZXMpIGFuZCAxLjAgKHRvdGFsbHkgbmV3IHZhbHVlcykgZm9yIGVhY2ggZnJhbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnpvb21BbmltYXRpb25GdW5jdGlvbiA9IGZ1bmN0aW9uKGZyYW1lLCBudW1GcmFtZXMpIHtcbiAgdmFyIGsgPSAxLjU7XG4gIHJldHVybiAoMS4wIC0gTWF0aC5wb3coaywgLWZyYW1lKSkgLyAoMS4wIC0gTWF0aC5wb3coaywgLW51bUZyYW1lcykpO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgem9vbSB0byB0aGUgb3JpZ2luYWwgdmlldyBjb29yZGluYXRlcy4gVGhpcyBpcyB0aGUgc2FtZSBhc1xuICogZG91YmxlLWNsaWNraW5nIG9uIHRoZSBncmFwaC5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUucmVzZXRab29tID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGRpcnR5WCA9IHRoaXMuaXNab29tZWQoJ3gnKTtcbiAgY29uc3QgZGlydHlZID0gdGhpcy5pc1pvb21lZCgneScpO1xuICBjb25zdCBkaXJ0eSA9IGRpcnR5WCB8fCBkaXJ0eVk7XG5cbiAgLy8gQ2xlYXIgYW55IHNlbGVjdGlvbiwgc2luY2UgaXQncyBsaWtlbHkgdG8gYmUgZHJhd24gaW4gdGhlIHdyb25nIHBsYWNlLlxuICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFkaXJ0eSkgcmV0dXJuO1xuXG4gIC8vIENhbGN1bGF0ZSBleHRyZW1lcyB0byBhdm9pZCBsYWNrIG9mIHBhZGRpbmcgb24gcmVzZXQuXG4gIGNvbnN0IFttaW5EYXRlLCBtYXhEYXRlXSA9IHRoaXMueEF4aXNFeHRyZW1lcygpO1xuXG4gIGNvbnN0IGFuaW1hdGVkWm9vbXMgPSB0aGlzLmdldEJvb2xlYW5PcHRpb24oJ2FuaW1hdGVkWm9vbXMnKTtcbiAgY29uc3Qgem9vbUNhbGxiYWNrID0gdGhpcy5nZXRGdW5jdGlvbk9wdGlvbignem9vbUNhbGxiYWNrJyk7XG5cbiAgLy8gVE9ETyhkYW52ayk6IG1lcmdlIHRoaXMgYmxvY2sgdy8gdGhlIGNvZGUgYmVsb3cuXG4gIC8vIFRPRE8oZGFudmspOiBmYWN0b3Igb3V0IGEgZ2VuZXJpYywgcHVibGljIHpvb21UbyBtZXRob2QuXG4gIGlmICghYW5pbWF0ZWRab29tcykge1xuICAgIHRoaXMuZGF0ZVdpbmRvd18gPSBudWxsO1xuICAgIHRoaXMuYXhlc18uZm9yRWFjaChheGlzID0+IHtcbiAgICAgIGlmIChheGlzLnZhbHVlUmFuZ2UpIGRlbGV0ZSBheGlzLnZhbHVlUmFuZ2U7XG4gICAgfSk7XG5cbiAgICB0aGlzLmRyYXdHcmFwaF8oKTtcbiAgICBpZiAoem9vbUNhbGxiYWNrKSB7XG4gICAgICB6b29tQ2FsbGJhY2suY2FsbCh0aGlzLCBtaW5EYXRlLCBtYXhEYXRlLCB0aGlzLnlBeGlzUmFuZ2VzKCkpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb2xkV2luZG93PW51bGwsIG5ld1dpbmRvdz1udWxsLCBvbGRWYWx1ZVJhbmdlcz1udWxsLCBuZXdWYWx1ZVJhbmdlcz1udWxsO1xuICBpZiAoZGlydHlYKSB7XG4gICAgb2xkV2luZG93ID0gdGhpcy54QXhpc1JhbmdlKCk7XG4gICAgbmV3V2luZG93ID0gW21pbkRhdGUsIG1heERhdGVdO1xuICB9XG5cbiAgaWYgKGRpcnR5WSkge1xuICAgIG9sZFZhbHVlUmFuZ2VzID0gdGhpcy55QXhpc1JhbmdlcygpO1xuICAgIG5ld1ZhbHVlUmFuZ2VzID0gdGhpcy55QXhpc0V4dHJlbWVzKCk7XG4gIH1cblxuICB0aGlzLmRvQW5pbWF0ZWRab29tKG9sZFdpbmRvdywgbmV3V2luZG93LCBvbGRWYWx1ZVJhbmdlcywgbmV3VmFsdWVSYW5nZXMsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuZGF0ZVdpbmRvd18gPSBudWxsO1xuICAgICAgICB0aGlzLmF4ZXNfLmZvckVhY2goYXhpcyA9PiB7XG4gICAgICAgICAgaWYgKGF4aXMudmFsdWVSYW5nZSkgZGVsZXRlIGF4aXMudmFsdWVSYW5nZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh6b29tQ2FsbGJhY2spIHtcbiAgICAgICAgICB6b29tQ2FsbGJhY2suY2FsbCh0aGlzLCBtaW5EYXRlLCBtYXhEYXRlLCB0aGlzLnlBeGlzUmFuZ2VzKCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbn07XG5cbi8qKlxuICogQ29tYmluZWQgYW5pbWF0aW9uIGxvZ2ljIGZvciBhbGwgem9vbSBmdW5jdGlvbnMuXG4gKiBlaXRoZXIgdGhlIHggcGFyYW1ldGVycyBvciB5IHBhcmFtZXRlcnMgbWF5IGJlIG51bGwuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5kb0FuaW1hdGVkWm9vbSA9IGZ1bmN0aW9uKG9sZFhSYW5nZSwgbmV3WFJhbmdlLCBvbGRZUmFuZ2VzLCBuZXdZUmFuZ2VzLCBjYWxsYmFjaykge1xuICB2YXIgc3RlcHMgPSB0aGlzLmdldEJvb2xlYW5PcHRpb24oXCJhbmltYXRlZFpvb21zXCIpID9cbiAgICAgIER5Z3JhcGguQU5JTUFUSU9OX1NURVBTIDogMTtcblxuICB2YXIgd2luZG93cyA9IFtdO1xuICB2YXIgdmFsdWVSYW5nZXMgPSBbXTtcbiAgdmFyIHN0ZXAsIGZyYWM7XG5cbiAgaWYgKG9sZFhSYW5nZSAhPT0gbnVsbCAmJiBuZXdYUmFuZ2UgIT09IG51bGwpIHtcbiAgICBmb3IgKHN0ZXAgPSAxOyBzdGVwIDw9IHN0ZXBzOyBzdGVwKyspIHtcbiAgICAgIGZyYWMgPSBEeWdyYXBoLnpvb21BbmltYXRpb25GdW5jdGlvbihzdGVwLCBzdGVwcyk7XG4gICAgICB3aW5kb3dzW3N0ZXAtMV0gPSBbb2xkWFJhbmdlWzBdKigxLWZyYWMpICsgZnJhYypuZXdYUmFuZ2VbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgb2xkWFJhbmdlWzFdKigxLWZyYWMpICsgZnJhYypuZXdYUmFuZ2VbMV1dO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvbGRZUmFuZ2VzICE9PSBudWxsICYmIG5ld1lSYW5nZXMgIT09IG51bGwpIHtcbiAgICBmb3IgKHN0ZXAgPSAxOyBzdGVwIDw9IHN0ZXBzOyBzdGVwKyspIHtcbiAgICAgIGZyYWMgPSBEeWdyYXBoLnpvb21BbmltYXRpb25GdW5jdGlvbihzdGVwLCBzdGVwcyk7XG4gICAgICB2YXIgdGhpc1JhbmdlID0gW107XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuYXhlc18ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdGhpc1JhbmdlLnB1c2goW29sZFlSYW5nZXNbal1bMF0qKDEtZnJhYykgKyBmcmFjKm5ld1lSYW5nZXNbal1bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRZUmFuZ2VzW2pdWzFdKigxLWZyYWMpICsgZnJhYypuZXdZUmFuZ2VzW2pdWzFdXSk7XG4gICAgICB9XG4gICAgICB2YWx1ZVJhbmdlc1tzdGVwLTFdID0gdGhpc1JhbmdlO1xuICAgIH1cbiAgfVxuXG4gIHV0aWxzLnJlcGVhdEFuZENsZWFudXAoc3RlcCA9PiB7XG4gICAgaWYgKHZhbHVlUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmF4ZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gdmFsdWVSYW5nZXNbc3RlcF1baV07XG4gICAgICAgIHRoaXMuYXhlc19baV0udmFsdWVSYW5nZSA9IFt3WzBdLCB3WzFdXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdpbmRvd3MubGVuZ3RoKSB7XG4gICAgICB0aGlzLmRhdGVXaW5kb3dfID0gd2luZG93c1tzdGVwXTtcbiAgICB9XG4gICAgdGhpcy5kcmF3R3JhcGhfKCk7XG4gIH0sIHN0ZXBzLCBEeWdyYXBoLkFOSU1BVElPTl9EVVJBVElPTiAvIHN0ZXBzLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBncmFwaCdzIGFyZWEgb2JqZWN0LlxuICpcbiAqIFJldHVybnM6IHt4LCB5LCB3LCBofVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRBcmVhID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnBsb3R0ZXJfLmFyZWE7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBtb3VzZSBldmVudCB0byBET00gY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlIGdyYXBoIG9yaWdpbi5cbiAqXG4gKiBSZXR1cm5zIGEgdHdvLWVsZW1lbnQgYXJyYXk6IFtYLCBZXS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZXZlbnRUb0RvbUNvb3JkcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGlmIChldmVudC5vZmZzZXRYICYmIGV2ZW50Lm9mZnNldFkpIHtcbiAgICByZXR1cm4gWyBldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZIF07XG4gIH0gZWxzZSB7XG4gICAgdmFyIGV2ZW50RWxlbWVudFBvcyA9IHV0aWxzLmZpbmRQb3ModGhpcy5tb3VzZUV2ZW50RWxlbWVudF8pO1xuICAgIHZhciBjYW52YXN4ID0gdXRpbHMucGFnZVgoZXZlbnQpIC0gZXZlbnRFbGVtZW50UG9zLng7XG4gICAgdmFyIGNhbnZhc3kgPSB1dGlscy5wYWdlWShldmVudCkgLSBldmVudEVsZW1lbnRQb3MueTtcbiAgICByZXR1cm4gW2NhbnZhc3gsIGNhbnZhc3ldO1xuICB9XG59O1xuXG4vKipcbiAqIEdpdmVuIGEgY2FudmFzIFggY29vcmRpbmF0ZSwgZmluZCB0aGUgY2xvc2VzdCByb3cuXG4gKiBAcGFyYW0ge251bWJlcn0gZG9tWCBncmFwaC1yZWxhdGl2ZSBET00gWCBjb29yZGluYXRlXG4gKiBSZXR1cm5zIHtudW1iZXJ9IHJvdyBudW1iZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5maW5kQ2xvc2VzdFJvdyA9IGZ1bmN0aW9uKGRvbVgpIHtcbiAgdmFyIG1pbkRpc3RYID0gSW5maW5pdHk7XG4gIHZhciBjbG9zZXN0Um93ID0gLTE7XG4gIHZhciBzZXRzID0gdGhpcy5sYXlvdXRfLnBvaW50cztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBvaW50cyA9IHNldHNbaV07XG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2pdO1xuICAgICAgaWYgKCF1dGlscy5pc1ZhbGlkUG9pbnQocG9pbnQsIHRydWUpKSBjb250aW51ZTtcbiAgICAgIHZhciBkaXN0ID0gTWF0aC5hYnMocG9pbnQuY2FudmFzeCAtIGRvbVgpO1xuICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0WCkge1xuICAgICAgICBtaW5EaXN0WCA9IGRpc3Q7XG4gICAgICAgIGNsb3Nlc3RSb3cgPSBwb2ludC5pZHg7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsb3Nlc3RSb3c7XG59O1xuXG4vKipcbiAqIEdpdmVuIGNhbnZhcyBYLFkgY29vcmRpbmF0ZXMsIGZpbmQgdGhlIGNsb3Nlc3QgcG9pbnQuXG4gKlxuICogVGhpcyBmaW5kcyB0aGUgaW5kaXZpZHVhbCBkYXRhIHBvaW50IGFjcm9zcyBhbGwgdmlzaWJsZSBzZXJpZXNcbiAqIHRoYXQncyBjbG9zZXN0IHRvIHRoZSBzdXBwbGllZCBET00gY29vcmRpbmF0ZXMgdXNpbmcgdGhlIHN0YW5kYXJkXG4gKiBFdWNsaWRlYW4gWCxZIGRpc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkb21YIGdyYXBoLXJlbGF0aXZlIERPTSBYIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkb21ZIGdyYXBoLXJlbGF0aXZlIERPTSBZIGNvb3JkaW5hdGVcbiAqIFJldHVybnM6IHtyb3csIHNlcmllc05hbWUsIHBvaW50fVxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZmluZENsb3Nlc3RQb2ludCA9IGZ1bmN0aW9uKGRvbVgsIGRvbVkpIHtcbiAgdmFyIG1pbkRpc3QgPSBJbmZpbml0eTtcbiAgdmFyIGRpc3QsIGR4LCBkeSwgcG9pbnQsIGNsb3Nlc3RQb2ludCwgY2xvc2VzdFNlcmllcywgY2xvc2VzdFJvdztcbiAgZm9yICggdmFyIHNldElkeCA9IHRoaXMubGF5b3V0Xy5wb2ludHMubGVuZ3RoIC0gMSA7IHNldElkeCA+PSAwIDsgLS1zZXRJZHggKSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMubGF5b3V0Xy5wb2ludHNbc2V0SWR4XTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBpZiAoIXV0aWxzLmlzVmFsaWRQb2ludChwb2ludCkpIGNvbnRpbnVlO1xuICAgICAgZHggPSBwb2ludC5jYW52YXN4IC0gZG9tWDtcbiAgICAgIGR5ID0gcG9pbnQuY2FudmFzeSAtIGRvbVk7XG4gICAgICBkaXN0ID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgIGNsb3Nlc3RQb2ludCA9IHBvaW50O1xuICAgICAgICBjbG9zZXN0U2VyaWVzID0gc2V0SWR4O1xuICAgICAgICBjbG9zZXN0Um93ID0gcG9pbnQuaWR4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgbmFtZSA9IHRoaXMubGF5b3V0Xy5zZXROYW1lc1tjbG9zZXN0U2VyaWVzXTtcbiAgcmV0dXJuIHtcbiAgICByb3c6IGNsb3Nlc3RSb3csXG4gICAgc2VyaWVzTmFtZTogbmFtZSxcbiAgICBwb2ludDogY2xvc2VzdFBvaW50XG4gIH07XG59O1xuXG4vKipcbiAqIEdpdmVuIGNhbnZhcyBYLFkgY29vcmRpbmF0ZXMsIGZpbmQgdGhlIHRvdWNoZWQgYXJlYSBpbiBhIHN0YWNrZWQgZ3JhcGguXG4gKlxuICogVGhpcyBmaXJzdCBmaW5kcyB0aGUgWCBkYXRhIHBvaW50IGNsb3Nlc3QgdG8gdGhlIHN1cHBsaWVkIERPTSBYIGNvb3JkaW5hdGUsXG4gKiB0aGVuIGZpbmRzIHRoZSBzZXJpZXMgd2hpY2ggcHV0cyB0aGUgWSBjb29yZGluYXRlIG9uIHRvcCBvZiBpdHMgZmlsbGVkIGFyZWEsXG4gKiB1c2luZyBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGFkamFjZW50IHBvaW50IHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkb21YIGdyYXBoLXJlbGF0aXZlIERPTSBYIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkb21ZIGdyYXBoLXJlbGF0aXZlIERPTSBZIGNvb3JkaW5hdGVcbiAqIFJldHVybnM6IHtyb3csIHNlcmllc05hbWUsIHBvaW50fVxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZmluZFN0YWNrZWRQb2ludCA9IGZ1bmN0aW9uKGRvbVgsIGRvbVkpIHtcbiAgdmFyIHJvdyA9IHRoaXMuZmluZENsb3Nlc3RSb3coZG9tWCk7XG4gIHZhciBjbG9zZXN0UG9pbnQsIGNsb3Nlc3RTZXJpZXM7XG4gIGZvciAodmFyIHNldElkeCA9IDA7IHNldElkeCA8IHRoaXMubGF5b3V0Xy5wb2ludHMubGVuZ3RoOyArK3NldElkeCkge1xuICAgIHZhciBib3VuZGFyeSA9IHRoaXMuZ2V0TGVmdEJvdW5kYXJ5XyhzZXRJZHgpO1xuICAgIHZhciByb3dJZHggPSByb3cgLSBib3VuZGFyeTtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5sYXlvdXRfLnBvaW50c1tzZXRJZHhdO1xuICAgIGlmIChyb3dJZHggPj0gcG9pbnRzLmxlbmd0aCkgY29udGludWU7XG4gICAgdmFyIHAxID0gcG9pbnRzW3Jvd0lkeF07XG4gICAgaWYgKCF1dGlscy5pc1ZhbGlkUG9pbnQocDEpKSBjb250aW51ZTtcbiAgICB2YXIgcHkgPSBwMS5jYW52YXN5O1xuICAgIGlmIChkb21YID4gcDEuY2FudmFzeCAmJiByb3dJZHggKyAxIDwgcG9pbnRzLmxlbmd0aCkge1xuICAgICAgLy8gaW50ZXJwb2xhdGUgc2VyaWVzIFkgdmFsdWUgdXNpbmcgbmV4dCBwb2ludFxuICAgICAgdmFyIHAyID0gcG9pbnRzW3Jvd0lkeCArIDFdO1xuICAgICAgaWYgKHV0aWxzLmlzVmFsaWRQb2ludChwMikpIHtcbiAgICAgICAgdmFyIGR4ID0gcDIuY2FudmFzeCAtIHAxLmNhbnZhc3g7XG4gICAgICAgIGlmIChkeCA+IDApIHtcbiAgICAgICAgICB2YXIgciA9IChkb21YIC0gcDEuY2FudmFzeCkgLyBkeDtcbiAgICAgICAgICBweSArPSByICogKHAyLmNhbnZhc3kgLSBwMS5jYW52YXN5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZG9tWCA8IHAxLmNhbnZhc3ggJiYgcm93SWR4ID4gMCkge1xuICAgICAgLy8gaW50ZXJwb2xhdGUgc2VyaWVzIFkgdmFsdWUgdXNpbmcgcHJldmlvdXMgcG9pbnRcbiAgICAgIHZhciBwMCA9IHBvaW50c1tyb3dJZHggLSAxXTtcbiAgICAgIGlmICh1dGlscy5pc1ZhbGlkUG9pbnQocDApKSB7XG4gICAgICAgIHZhciBkeCA9IHAxLmNhbnZhc3ggLSBwMC5jYW52YXN4O1xuICAgICAgICBpZiAoZHggPiAwKSB7XG4gICAgICAgICAgdmFyIHIgPSAocDEuY2FudmFzeCAtIGRvbVgpIC8gZHg7XG4gICAgICAgICAgcHkgKz0gciAqIChwMC5jYW52YXN5IC0gcDEuY2FudmFzeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gU3RvcCBpZiB0aGUgcG9pbnQgKGRvbVgsIHB5KSBpcyBhYm92ZSB0aGlzIHNlcmllcycgdXBwZXIgZWRnZVxuICAgIGlmIChzZXRJZHggPT09IDAgfHwgcHkgPCBkb21ZKSB7XG4gICAgICBjbG9zZXN0UG9pbnQgPSBwMTtcbiAgICAgIGNsb3Nlc3RTZXJpZXMgPSBzZXRJZHg7XG4gICAgfVxuICB9XG4gIHZhciBuYW1lID0gdGhpcy5sYXlvdXRfLnNldE5hbWVzW2Nsb3Nlc3RTZXJpZXNdO1xuICByZXR1cm4ge1xuICAgIHJvdzogcm93LFxuICAgIHNlcmllc05hbWU6IG5hbWUsXG4gICAgcG9pbnQ6IGNsb3Nlc3RQb2ludFxuICB9O1xufTtcblxuLyoqXG4gKiBXaGVuIHRoZSBtb3VzZSBtb3ZlcyBpbiB0aGUgY2FudmFzLCBkaXNwbGF5IGluZm9ybWF0aW9uIGFib3V0IGEgbmVhcmJ5IGRhdGFcbiAqIHBvaW50IGFuZCBkcmF3IGRvdHMgb3ZlciB0aG9zZSBwb2ludHMgaW4gdGhlIGRhdGEgc2VyaWVzLiBUaGlzIGZ1bmN0aW9uXG4gKiB0YWtlcyBjYXJlIG9mIGNsZWFudXAgb2YgcHJldmlvdXNseS1kcmF3biBkb3RzLlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBtb3VzZW1vdmUgZXZlbnQgZnJvbSB0aGUgYnJvd3Nlci5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLm1vdXNlTW92ZV8gPSBmdW5jdGlvbihldmVudCkge1xuICAvLyBUaGlzIHByZXZlbnRzIEpTIGVycm9ycyB3aGVuIG1vdXNpbmcgb3ZlciB0aGUgY2FudmFzIGJlZm9yZSBkYXRhIGxvYWRzLlxuICB2YXIgcG9pbnRzID0gdGhpcy5sYXlvdXRfLnBvaW50cztcbiAgaWYgKHBvaW50cyA9PT0gdW5kZWZpbmVkIHx8IHBvaW50cyA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gIHZhciBjYW52YXNDb29yZHMgPSB0aGlzLmV2ZW50VG9Eb21Db29yZHMoZXZlbnQpO1xuICB2YXIgY2FudmFzeCA9IGNhbnZhc0Nvb3Jkc1swXTtcbiAgdmFyIGNhbnZhc3kgPSBjYW52YXNDb29yZHNbMV07XG5cbiAgdmFyIGhpZ2hsaWdodFNlcmllc09wdHMgPSB0aGlzLmdldE9wdGlvbihcImhpZ2hsaWdodFNlcmllc09wdHNcIik7XG4gIHZhciBzZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gIGlmIChoaWdobGlnaHRTZXJpZXNPcHRzICYmICF0aGlzLmlzU2VyaWVzTG9ja2VkKCkpIHtcbiAgICB2YXIgY2xvc2VzdDtcbiAgICBpZiAodGhpcy5nZXRCb29sZWFuT3B0aW9uKFwic3RhY2tlZEdyYXBoXCIpKSB7XG4gICAgICBjbG9zZXN0ID0gdGhpcy5maW5kU3RhY2tlZFBvaW50KGNhbnZhc3gsIGNhbnZhc3kpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZXN0ID0gdGhpcy5maW5kQ2xvc2VzdFBvaW50KGNhbnZhc3gsIGNhbnZhc3kpO1xuICAgIH1cbiAgICBzZWxlY3Rpb25DaGFuZ2VkID0gdGhpcy5zZXRTZWxlY3Rpb24oY2xvc2VzdC5yb3csIGNsb3Nlc3Quc2VyaWVzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuZmluZENsb3Nlc3RSb3coY2FudmFzeCk7XG4gICAgc2VsZWN0aW9uQ2hhbmdlZCA9IHRoaXMuc2V0U2VsZWN0aW9uKGlkeCk7XG4gIH1cblxuICB2YXIgY2FsbGJhY2sgPSB0aGlzLmdldEZ1bmN0aW9uT3B0aW9uKFwiaGlnaGxpZ2h0Q2FsbGJhY2tcIik7XG4gIGlmIChjYWxsYmFjayAmJiBzZWxlY3Rpb25DaGFuZ2VkKSB7XG4gICAgY2FsbGJhY2suY2FsbCh0aGlzLCBldmVudCxcbiAgICAgICAgdGhpcy5sYXN0eF8sXG4gICAgICAgIHRoaXMuc2VsUG9pbnRzXyxcbiAgICAgICAgdGhpcy5sYXN0Um93XyxcbiAgICAgICAgdGhpcy5oaWdobGlnaHRTZXRfKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGZXRjaCBsZWZ0IG9mZnNldCBmcm9tIHRoZSBzcGVjaWZpZWQgc2V0IGluZGV4IG9yIGlmIG5vdCBwYXNzZWQsIHRoZVxuICogZmlyc3QgZGVmaW5lZCBib3VuZGFyeUlkcyByZWNvcmQgKHNlZSBidWcgIzIzNikuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRMZWZ0Qm91bmRhcnlfID0gZnVuY3Rpb24oc2V0SWR4KSB7XG4gIGlmICh0aGlzLmJvdW5kYXJ5SWRzX1tzZXRJZHhdKSB7XG4gICAgICByZXR1cm4gdGhpcy5ib3VuZGFyeUlkc19bc2V0SWR4XVswXTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm91bmRhcnlJZHNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5ib3VuZGFyeUlkc19baV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZGFyeUlkc19baV1bMF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG5EeWdyYXBoLnByb3RvdHlwZS5hbmltYXRlU2VsZWN0aW9uXyA9IGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuICB2YXIgdG90YWxTdGVwcyA9IDEwO1xuICB2YXIgbWlsbGlzID0gMzA7XG4gIGlmICh0aGlzLmZhZGVMZXZlbCA9PT0gdW5kZWZpbmVkKSB0aGlzLmZhZGVMZXZlbCA9IDA7XG4gIGlmICh0aGlzLmFuaW1hdGVJZCA9PT0gdW5kZWZpbmVkKSB0aGlzLmFuaW1hdGVJZCA9IDA7XG4gIHZhciBzdGFydCA9IHRoaXMuZmFkZUxldmVsO1xuICB2YXIgc3RlcHMgPSBkaXJlY3Rpb24gPCAwID8gc3RhcnQgOiB0b3RhbFN0ZXBzIC0gc3RhcnQ7XG4gIGlmIChzdGVwcyA8PSAwKSB7XG4gICAgaWYgKHRoaXMuZmFkZUxldmVsKSB7XG4gICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbl8oMS4wKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRoaXNJZCA9ICsrdGhpcy5hbmltYXRlSWQ7XG4gIHZhciB0aGF0ID0gdGhpcztcbiAgdmFyIGNsZWFudXBJZkNsZWFyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gaWYgd2UgaGF2ZW4ndCByZWFjaGVkIGZhZGVMZXZlbCAwIGluIHRoZSBtYXggZnJhbWUgdGltZSxcbiAgICAvLyBlbnN1cmUgdGhhdCB0aGUgY2xlYXIgaGFwcGVucyBhbmQganVzdCBnbyB0byAwXG4gICAgaWYgKHRoYXQuZmFkZUxldmVsICE9PSAwICYmIGRpcmVjdGlvbiA8IDApIHtcbiAgICAgIHRoYXQuZmFkZUxldmVsID0gMDtcbiAgICAgIHRoYXQuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICB9XG4gIH07XG4gIHV0aWxzLnJlcGVhdEFuZENsZWFudXAoXG4gICAgZnVuY3Rpb24obikge1xuICAgICAgLy8gaWdub3JlIHNpbXVsdGFuZW91cyBhbmltYXRpb25zXG4gICAgICBpZiAodGhhdC5hbmltYXRlSWQgIT0gdGhpc0lkKSByZXR1cm47XG5cbiAgICAgIHRoYXQuZmFkZUxldmVsICs9IGRpcmVjdGlvbjtcbiAgICAgIGlmICh0aGF0LmZhZGVMZXZlbCA9PT0gMCkge1xuICAgICAgICB0aGF0LmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGF0LnVwZGF0ZVNlbGVjdGlvbl8odGhhdC5mYWRlTGV2ZWwgLyB0b3RhbFN0ZXBzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0ZXBzLCBtaWxsaXMsIGNsZWFudXBJZkNsZWFyaW5nKTtcbn07XG5cbi8qKlxuICogRHJhdyBkb3RzIG92ZXIgdGhlIHNlbGVjdGllZCBwb2ludHMgaW4gdGhlIGRhdGEgc2VyaWVzLiBUaGlzIGZ1bmN0aW9uXG4gKiB0YWtlcyBjYXJlIG9mIGNsZWFudXAgb2YgcHJldmlvdXNseS1kcmF3biBkb3RzLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUudXBkYXRlU2VsZWN0aW9uXyA9IGZ1bmN0aW9uKG9wdF9hbmltRnJhY3Rpb24pIHtcbiAgLyp2YXIgZGVmYXVsdFByZXZlbnRlZCA9ICovXG4gIHRoaXMuY2FzY2FkZUV2ZW50c18oJ3NlbGVjdCcsIHtcbiAgICBzZWxlY3RlZFJvdzogdGhpcy5sYXN0Um93XyA9PT0gLTEgPyB1bmRlZmluZWQgOiB0aGlzLmxhc3RSb3dfLFxuICAgIHNlbGVjdGVkWDogdGhpcy5sYXN0eF8gPT09IC0xID8gdW5kZWZpbmVkIDogdGhpcy5sYXN0eF8sXG4gICAgc2VsZWN0ZWRQb2ludHM6IHRoaXMuc2VsUG9pbnRzX1xuICB9KTtcbiAgLy8gVE9ETyhkYW52ayk6IHVzZSBkZWZhdWx0UHJldmVudGVkIGhlcmU/XG5cbiAgLy8gQ2xlYXIgdGhlIHByZXZpb3VzbHkgZHJhd24gdmVydGljYWwsIGlmIHRoZXJlIGlzIG9uZVxuICB2YXIgaTtcbiAgdmFyIGN0eCA9IHRoaXMuY2FudmFzX2N0eF87XG4gIGlmICh0aGlzLmdldE9wdGlvbignaGlnaGxpZ2h0U2VyaWVzT3B0cycpKSB7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoXywgdGhpcy5oZWlnaHRfKTtcbiAgICB2YXIgYWxwaGEgPSAxLjAgLSB0aGlzLmdldE51bWVyaWNPcHRpb24oJ2hpZ2hsaWdodFNlcmllc0JhY2tncm91bmRBbHBoYScpO1xuICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSB1dGlscy50b1JHQl8odGhpcy5nZXRPcHRpb24oJ2hpZ2hsaWdodFNlcmllc0JhY2tncm91bmRDb2xvcicpKTtcblxuICAgIGlmIChhbHBoYSkge1xuICAgICAgLy8gQWN0aXZhdGluZyBiYWNrZ3JvdW5kIGZhZGUgaW5jbHVkZXMgYW4gYW5pbWF0aW9uIGVmZmVjdCBmb3IgYSBncmFkdWFsXG4gICAgICAvLyBmYWRlLiBUT0RPKGtsYXVzdyk6IG1ha2UgdGhpcyBpbmRlcGVuZGVudGx5IGNvbmZpZ3VyYWJsZSBpZiBpdCBjYXVzZXNcbiAgICAgIC8vIGlzc3Vlcz8gVXNlIGEgc2hhcmVkIHByZWZlcmVuY2UgdG8gY29udHJvbCBhbmltYXRpb25zP1xuICAgICAgdmFyIGFuaW1hdGVCYWNrZ3JvdW5kRmFkZSA9IHRydWU7XG4gICAgICBpZiAoYW5pbWF0ZUJhY2tncm91bmRGYWRlKSB7XG4gICAgICAgIGlmIChvcHRfYW5pbUZyYWN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBzdGFydCBhIG5ldyBhbmltYXRpb25cbiAgICAgICAgICB0aGlzLmFuaW1hdGVTZWxlY3Rpb25fKDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhbHBoYSAqPSBvcHRfYW5pbUZyYWN0aW9uO1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyBiYWNrZ3JvdW5kQ29sb3IuciArICcsJyArIGJhY2tncm91bmRDb2xvci5nICsgJywnICsgYmFja2dyb3VuZENvbG9yLmIgKyAnLCcgKyBhbHBoYSArICcpJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLndpZHRoXywgdGhpcy5oZWlnaHRfKTtcbiAgICB9XG5cbiAgICAvLyBSZWRyYXcgb25seSB0aGUgaGlnaGxpZ2h0ZWQgc2VyaWVzIGluIHRoZSBpbnRlcmFjdGl2ZSBjYW52YXMgKG5vdCB0aGVcbiAgICAvLyBzdGF0aWMgcGxvdCBjYW52YXMsIHdoaWNoIGlzIHdoZXJlIHNlcmllcyBhcmUgdXN1YWxseSBkcmF3bikuXG4gICAgdGhpcy5wbG90dGVyXy5fcmVuZGVyTGluZUNoYXJ0KHRoaXMuaGlnaGxpZ2h0U2V0XywgY3R4KTtcbiAgfSBlbHNlIGlmICh0aGlzLnByZXZpb3VzVmVydGljYWxYXyA+PSAwKSB7XG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBtYXhpbXVtIGhpZ2hsaWdodCBjaXJjbGUgc2l6ZS5cbiAgICB2YXIgbWF4Q2lyY2xlU2l6ZSA9IDA7XG4gICAgdmFyIGxhYmVscyA9IHRoaXMuYXR0cl8oJ2xhYmVscycpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByID0gdGhpcy5nZXROdW1lcmljT3B0aW9uKCdoaWdobGlnaHRDaXJjbGVTaXplJywgbGFiZWxzW2ldKTtcbiAgICAgIGlmIChyID4gbWF4Q2lyY2xlU2l6ZSkgbWF4Q2lyY2xlU2l6ZSA9IHI7XG4gICAgfVxuICAgIHZhciBweCA9IHRoaXMucHJldmlvdXNWZXJ0aWNhbFhfO1xuICAgIGN0eC5jbGVhclJlY3QocHggLSBtYXhDaXJjbGVTaXplIC0gMSwgMCxcbiAgICAgICAgICAgICAgICAgIDIgKiBtYXhDaXJjbGVTaXplICsgMiwgdGhpcy5oZWlnaHRfKTtcbiAgfVxuXG4gIGlmICh0aGlzLnNlbFBvaW50c18ubGVuZ3RoID4gMCkge1xuICAgIC8vIERyYXcgY29sb3JlZCBjaXJjbGVzIG92ZXIgdGhlIGNlbnRlciBvZiBlYWNoIHNlbGVjdGVkIHBvaW50XG4gICAgdmFyIGNhbnZhc3ggPSB0aGlzLnNlbFBvaW50c19bMF0uY2FudmFzeDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlbFBvaW50c18ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwdCA9IHRoaXMuc2VsUG9pbnRzX1tpXTtcbiAgICAgIGlmIChpc05hTihwdC5jYW52YXN5KSkgY29udGludWU7XG5cbiAgICAgIHZhciBjaXJjbGVTaXplID0gdGhpcy5nZXROdW1lcmljT3B0aW9uKCdoaWdobGlnaHRDaXJjbGVTaXplJywgcHQubmFtZSk7XG4gICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLmdldEZ1bmN0aW9uT3B0aW9uKFwiZHJhd0hpZ2hsaWdodFBvaW50Q2FsbGJhY2tcIiwgcHQubmFtZSk7XG4gICAgICB2YXIgY29sb3IgPSB0aGlzLnBsb3R0ZXJfLmNvbG9yc1twdC5uYW1lXTtcbiAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSB1dGlscy5DaXJjbGVzLkRFRkFVTFQ7XG4gICAgICB9XG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5nZXROdW1lcmljT3B0aW9uKCdzdHJva2VXaWR0aCcsIHB0Lm5hbWUpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMsIHB0Lm5hbWUsIGN0eCwgY2FudmFzeCwgcHQuY2FudmFzeSxcbiAgICAgICAgICBjb2xvciwgY2lyY2xlU2l6ZSwgcHQuaWR4KTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcblxuICAgIHRoaXMucHJldmlvdXNWZXJ0aWNhbFhfID0gY2FudmFzeDtcbiAgfVxufTtcblxuLyoqXG4gKiBNYW51YWxseSBzZXQgdGhlIHNlbGVjdGVkIHBvaW50cyBhbmQgZGlzcGxheSBpbmZvcm1hdGlvbiBhYm91dCB0aGVtIGluIHRoZVxuICogbGVnZW5kLiBUaGUgc2VsZWN0aW9uIGNhbiBiZSBjbGVhcmVkIHVzaW5nIGNsZWFyU2VsZWN0aW9uKCkgYW5kIHF1ZXJpZWRcbiAqIHVzaW5nIGdldFNlbGVjdGlvbigpLlxuICpcbiAqIFRvIHNldCBhIHNlbGVjdGVkIHNlcmllcyBidXQgbm90IGEgc2VsZWN0ZWQgcG9pbnQsIGNhbGwgc2V0U2VsZWN0aW9uIHdpdGhcbiAqIHJvdz1mYWxzZSBhbmQgdGhlIHNlbGVjdGVkIHNlcmllcyBuYW1lLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSByb3cgUm93IG51bWJlciB0aGF0IHNob3VsZCBiZSBoaWdobGlnaHRlZCAoaS5lLiBhcHBlYXIgd2l0aFxuICogaG92ZXIgZG90cyBvbiB0aGUgY2hhcnQpLlxuICogQHBhcmFtIHtzZXJpZXNOYW1lfSBvcHRpb25hbCBzZXJpZXMgbmFtZSB0byBoaWdobGlnaHQgdGhhdCBzZXJpZXMgd2l0aCB0aGVcbiAqIHRoZSBoaWdobGlnaHRTZXJpZXNPcHRzIHNldHRpbmcuXG4gKiBAcGFyYW0geyBsb2NrZWQgfSBvcHRpb25hbCBJZiB0cnVlLCBrZWVwIHNlcmllc05hbWUgc2VsZWN0ZWQgd2hlbiBtb3VzaW5nXG4gKiBvdmVyIHRoZSBncmFwaCwgZGlzYWJsaW5nIGNsb3Nlc3Qtc2VyaWVzIGhpZ2hsaWdodGluZy4gQ2FsbCBjbGVhclNlbGVjdGlvbigpXG4gKiB0byB1bmxvY2sgaXQuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKHJvdywgb3B0X3Nlcmllc05hbWUsIG9wdF9sb2NrZWQpIHtcbiAgLy8gRXh0cmFjdCB0aGUgcG9pbnRzIHdlJ3ZlIHNlbGVjdGVkXG4gIHRoaXMuc2VsUG9pbnRzXyA9IFtdO1xuXG4gIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gIGlmIChyb3cgIT09IGZhbHNlICYmIHJvdyA+PSAwKSB7XG4gICAgaWYgKHJvdyAhPSB0aGlzLmxhc3RSb3dfKSBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLmxhc3RSb3dfID0gcm93O1xuICAgIGZvciAodmFyIHNldElkeCA9IDA7IHNldElkeCA8IHRoaXMubGF5b3V0Xy5wb2ludHMubGVuZ3RoOyArK3NldElkeCkge1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMubGF5b3V0Xy5wb2ludHNbc2V0SWR4XTtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBwb2ludCBhdCB0aGUgYXBwcm9wcmlhdGUgaW5kZXggaXMgdGhlIHBvaW50IHdlJ3JlIGxvb2tpbmdcbiAgICAgIC8vIGZvci4gIElmIGl0IGlzLCBqdXN0IHVzZSBpdCwgb3RoZXJ3aXNlIHNlYXJjaCB0aGUgYXJyYXkgZm9yIGEgcG9pbnRcbiAgICAgIC8vIGluIHRoZSBwcm9wZXIgcGxhY2UuXG4gICAgICB2YXIgc2V0Um93ID0gcm93IC0gdGhpcy5nZXRMZWZ0Qm91bmRhcnlfKHNldElkeCk7XG4gICAgICBpZiAoc2V0Um93ID49IDAgJiYgc2V0Um93IDwgcG9pbnRzLmxlbmd0aCAmJiBwb2ludHNbc2V0Um93XS5pZHggPT0gcm93KSB7XG4gICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tzZXRSb3ddO1xuICAgICAgICBpZiAocG9pbnQueXZhbCAhPT0gbnVsbCkgdGhpcy5zZWxQb2ludHNfLnB1c2gocG9pbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgcG9pbnRJZHggPSAwOyBwb2ludElkeCA8IHBvaW50cy5sZW5ndGg7ICsrcG9pbnRJZHgpIHtcbiAgICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbcG9pbnRJZHhdO1xuICAgICAgICAgIGlmIChwb2ludC5pZHggPT0gcm93KSB7XG4gICAgICAgICAgICBpZiAocG9pbnQueXZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLnNlbFBvaW50c18ucHVzaChwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMubGFzdFJvd18gPj0gMCkgY2hhbmdlZCA9IHRydWU7XG4gICAgdGhpcy5sYXN0Um93XyA9IC0xO1xuICB9XG5cbiAgaWYgKHRoaXMuc2VsUG9pbnRzXy5sZW5ndGgpIHtcbiAgICB0aGlzLmxhc3R4XyA9IHRoaXMuc2VsUG9pbnRzX1swXS54dmFsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdHhfID0gLTE7XG4gIH1cblxuICBpZiAob3B0X3Nlcmllc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLmhpZ2hsaWdodFNldF8gIT09IG9wdF9zZXJpZXNOYW1lKSBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLmhpZ2hsaWdodFNldF8gPSBvcHRfc2VyaWVzTmFtZTtcbiAgfVxuXG4gIGlmIChvcHRfbG9ja2VkICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmxvY2tlZFNldF8gPSBvcHRfbG9ja2VkO1xuICB9XG5cbiAgaWYgKGNoYW5nZWQpIHtcbiAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbl8odW5kZWZpbmVkKTtcbiAgfVxuICByZXR1cm4gY2hhbmdlZDtcbn07XG5cbi8qKlxuICogVGhlIG1vdXNlIGhhcyBsZWZ0IHRoZSBjYW52YXMuIENsZWFyIG91dCB3aGF0ZXZlciBhcnRpZmFjdHMgcmVtYWluXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIG1vdXNlb3V0IGV2ZW50IGZyb20gdGhlIGJyb3dzZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5tb3VzZU91dF8gPSBmdW5jdGlvbihldmVudCkge1xuICBpZiAodGhpcy5nZXRGdW5jdGlvbk9wdGlvbihcInVuaGlnaGxpZ2h0Q2FsbGJhY2tcIikpIHtcbiAgICB0aGlzLmdldEZ1bmN0aW9uT3B0aW9uKFwidW5oaWdobGlnaHRDYWxsYmFja1wiKS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfVxuXG4gIGlmICh0aGlzLmdldEJvb2xlYW5PcHRpb24oXCJoaWRlT3ZlcmxheU9uTW91c2VPdXRcIikgJiYgIXRoaXMubG9ja2VkU2V0Xykge1xuICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIChpLmUuIHBvaW50cyB0aGF0IHdlcmUgaGlnaGxpZ2h0ZWQgYnkgbW92aW5nXG4gKiB0aGUgbW91c2Ugb3ZlciB0aGUgY2hhcnQpLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5jbGVhclNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNhc2NhZGVFdmVudHNfKCdkZXNlbGVjdCcsIHt9KTtcblxuICB0aGlzLmxvY2tlZFNldF8gPSBmYWxzZTtcbiAgLy8gR2V0IHJpZCBvZiB0aGUgb3ZlcmxheSBkYXRhXG4gIGlmICh0aGlzLmZhZGVMZXZlbCkge1xuICAgIHRoaXMuYW5pbWF0ZVNlbGVjdGlvbl8oLTEpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmNhbnZhc19jdHhfLmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoXywgdGhpcy5oZWlnaHRfKTtcbiAgdGhpcy5mYWRlTGV2ZWwgPSAwO1xuICB0aGlzLnNlbFBvaW50c18gPSBbXTtcbiAgdGhpcy5sYXN0eF8gPSAtMTtcbiAgdGhpcy5sYXN0Um93XyA9IC0xO1xuICB0aGlzLmhpZ2hsaWdodFNldF8gPSBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCByb3cuIFRvIGdldCBkYXRhIGZvciB0aGlzIHJvdyxcbiAqIHlvdSBjYW4gdXNlIHRoZSBnZXRWYWx1ZSBtZXRob2QuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHJvdyBudW1iZXIsIG9yIC0xIGlmIG5vdGhpbmcgaXMgc2VsZWN0ZWRcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5zZWxQb2ludHNfIHx8IHRoaXMuc2VsUG9pbnRzXy5sZW5ndGggPCAxKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZm9yICh2YXIgc2V0SWR4ID0gMDsgc2V0SWR4IDwgdGhpcy5sYXlvdXRfLnBvaW50cy5sZW5ndGg7IHNldElkeCsrKSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMubGF5b3V0Xy5wb2ludHNbc2V0SWR4XTtcbiAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBwb2ludHMubGVuZ3RoOyByb3crKykge1xuICAgICAgaWYgKHBvaW50c1tyb3ddLnggPT0gdGhpcy5zZWxQb2ludHNfWzBdLngpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50c1tyb3ddLmlkeDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHktaGlnaGxpZ2h0ZWQgc2VyaWVzLlxuICogT25seSBhdmFpbGFibGUgd2hlbiB0aGUgaGlnaGxpZ2h0U2VyaWVzT3B0cyBvcHRpb24gaXMgaW4gdXNlLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRIaWdobGlnaHRTZXJpZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaGlnaGxpZ2h0U2V0Xztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50bHktaGlnaGxpZ2h0ZWQgc2VyaWVzIHdhcyBsb2NrZWRcbiAqIHZpYSBzZXRTZWxlY3Rpb24oLi4uLCBzZXJpZXNOYW1lLCB0cnVlKS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuaXNTZXJpZXNMb2NrZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubG9ja2VkU2V0Xztcbn07XG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGVyZSdzIGRhdGEgYXZhaWxhYmxlIHRvIGJlIGdyYXBoZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSBSYXcgQ1NWIGRhdGEgdG8gYmUgcGxvdHRlZFxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUubG9hZGVkRXZlbnRfID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLnJhd0RhdGFfID0gdGhpcy5wYXJzZUNTVl8oZGF0YSk7XG4gIHRoaXMuY2FzY2FkZURhdGFEaWRVcGRhdGVFdmVudF8oKTtcbiAgdGhpcy5wcmVkcmF3XygpO1xufTtcblxuLyoqXG4gKiBBZGQgdGlja3Mgb24gdGhlIHgtYXhpcyByZXByZXNlbnRpbmcgeWVhcnMsIG1vbnRocywgcXVhcnRlcnMsIHdlZWtzLCBvciBkYXlzXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5hZGRYVGlja3NfID0gZnVuY3Rpb24oKSB7XG4gIC8vIERldGVybWluZSB0aGUgY29ycmVjdCB0aWNrcyBzY2FsZSBvbiB0aGUgeC1heGlzOiBxdWFydGVybHksIG1vbnRobHksIC4uLlxuICB2YXIgcmFuZ2U7XG4gIGlmICh0aGlzLmRhdGVXaW5kb3dfKSB7XG4gICAgcmFuZ2UgPSBbdGhpcy5kYXRlV2luZG93X1swXSwgdGhpcy5kYXRlV2luZG93X1sxXV07XG4gIH0gZWxzZSB7XG4gICAgcmFuZ2UgPSB0aGlzLnhBeGlzRXh0cmVtZXMoKTtcbiAgfVxuXG4gIHZhciB4QXhpc09wdGlvbnNWaWV3ID0gdGhpcy5vcHRpb25zVmlld0ZvckF4aXNfKCd4Jyk7XG4gIHZhciB4VGlja3MgPSB4QXhpc09wdGlvbnNWaWV3KCd0aWNrZXInKShcbiAgICAgIHJhbmdlWzBdLFxuICAgICAgcmFuZ2VbMV0sXG4gICAgICB0aGlzLnBsb3R0ZXJfLmFyZWEudywgIC8vIFRPRE8oZGFudmspOiBzaG91bGQgYmUgYXJlYS53aWR0aFxuICAgICAgeEF4aXNPcHRpb25zVmlldyxcbiAgICAgIHRoaXMpO1xuICAvLyB2YXIgbXNnID0gJ3RpY2tlcignICsgcmFuZ2VbMF0gKyAnLCAnICsgcmFuZ2VbMV0gKyAnLCAnICsgdGhpcy53aWR0aF8gKyAnLCAnICsgdGhpcy5hdHRyXygncGl4ZWxzUGVyWExhYmVsJykgKyAnKSAtPiAnICsgSlNPTi5zdHJpbmdpZnkoeFRpY2tzKTtcbiAgLy8gY29uc29sZS5sb2cobXNnKTtcbiAgdGhpcy5sYXlvdXRfLnNldFhUaWNrcyh4VGlja3MpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb3JyZWN0IGhhbmRsZXIgY2xhc3MgZm9yIHRoZSBjdXJyZW50bHkgc2V0IG9wdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRIYW5kbGVyQ2xhc3NfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYW5kbGVyQ2xhc3M7XG4gIGlmICh0aGlzLmF0dHJfKCdkYXRhSGFuZGxlcicpKSB7XG4gICAgaGFuZGxlckNsYXNzID0gIHRoaXMuYXR0cl8oJ2RhdGFIYW5kbGVyJyk7XG4gIH0gZWxzZSBpZiAodGhpcy5mcmFjdGlvbnNfKSB7XG4gICAgaWYgKHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbignZXJyb3JCYXJzJykpIHtcbiAgICAgIGhhbmRsZXJDbGFzcyA9IEZyYWN0aW9uc0JhcnNIYW5kbGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVyQ2xhc3MgPSBEZWZhdWx0RnJhY3Rpb25IYW5kbGVyO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLmdldEJvb2xlYW5PcHRpb24oJ2N1c3RvbUJhcnMnKSkge1xuICAgIGhhbmRsZXJDbGFzcyA9IEN1c3RvbUJhcnNIYW5kbGVyO1xuICB9IGVsc2UgaWYgKHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbignZXJyb3JCYXJzJykpIHtcbiAgICBoYW5kbGVyQ2xhc3MgPSBFcnJvckJhcnNIYW5kbGVyO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZXJDbGFzcyA9IERlZmF1bHRIYW5kbGVyO1xuICB9XG4gIHJldHVybiBoYW5kbGVyQ2xhc3M7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmNlIHdoZW4gdGhlIGNoYXJ0J3MgZGF0YSBpcyBjaGFuZ2VkIG9yIHRoZSBvcHRpb25zXG4gKiBkaWN0aW9uYXJ5IGlzIHVwZGF0ZWQuIEl0IGlzIF9ub3RfIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHBhbnMgb3Igem9vbXMuIFRoZVxuICogaWRlYSBpcyB0aGF0IHZhbHVlcyBkZXJpdmVkIGZyb20gdGhlIGNoYXJ0J3MgZGF0YSBjYW4gYmUgY29tcHV0ZWQgaGVyZSxcbiAqIHJhdGhlciB0aGFuIGV2ZXJ5IHRpbWUgdGhlIGNoYXJ0IGlzIGRyYXduLiBUaGlzIGluY2x1ZGVzIHRoaW5ncyBsaWtlIHRoZVxuICogbnVtYmVyIG9mIGF4ZXMsIHJvbGxpbmcgYXZlcmFnZXMsIGV0Yy5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUucHJlZHJhd18gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoKTtcblxuICAvLyBDcmVhdGUgdGhlIGNvcnJlY3QgZGF0YUhhbmRsZXJcbiAgdGhpcy5kYXRhSGFuZGxlcl8gPSBuZXcgKHRoaXMuZ2V0SGFuZGxlckNsYXNzXygpKSgpO1xuXG4gIHRoaXMubGF5b3V0Xy5jb21wdXRlUGxvdEFyZWEoKTtcblxuICAvLyBUT0RPKGRhbnZrKTogbW92ZSBtb3JlIGNvbXB1dGF0aW9ucyBvdXQgb2YgZHJhd0dyYXBoXyBhbmQgaW50byBoZXJlLlxuICB0aGlzLmNvbXB1dGVZQXhlc18oKTtcblxuICBpZiAoIXRoaXMuaXNfaW5pdGlhbF9kcmF3Xykge1xuICAgIHRoaXMuY2FudmFzX2N0eF8ucmVzdG9yZSgpO1xuICAgIHRoaXMuaGlkZGVuX2N0eF8ucmVzdG9yZSgpO1xuICB9XG5cbiAgdGhpcy5jYW52YXNfY3R4Xy5zYXZlKCk7XG4gIHRoaXMuaGlkZGVuX2N0eF8uc2F2ZSgpO1xuXG4gIC8vIENyZWF0ZSBhIG5ldyBwbG90dGVyLlxuICB0aGlzLnBsb3R0ZXJfID0gbmV3IER5Z3JhcGhDYW52YXNSZW5kZXJlcih0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGRlbl8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuX2N0eF8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0Xyk7XG5cbiAgLy8gVGhlIHJvbGxlciBzaXRzIGluIHRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIGNoYXJ0LiBXZSBkb24ndCBrbm93IHdoZXJlXG4gIC8vIHRoaXMgd2lsbCBiZSB1bnRpbCB0aGUgb3B0aW9ucyBhcmUgYXZhaWxhYmxlLCBzbyBpdCdzIHBvc2l0aW9uZWQgaGVyZS5cbiAgdGhpcy5jcmVhdGVSb2xsSW50ZXJmYWNlXygpO1xuXG4gIHRoaXMuY2FzY2FkZUV2ZW50c18oJ3ByZWRyYXcnKTtcblxuICAvLyBDb252ZXJ0IHRoZSByYXcgZGF0YSAoYSAyRCBhcnJheSkgaW50byB0aGUgaW50ZXJuYWwgZm9ybWF0IGFuZCBjb21wdXRlXG4gIC8vIHJvbGxpbmcgYXZlcmFnZXMuXG4gIHRoaXMucm9sbGVkU2VyaWVzXyA9IFtudWxsXTsgIC8vIHgtYXhpcyBpcyB0aGUgZmlyc3Qgc2VyaWVzIGFuZCBpdCdzIHNwZWNpYWxcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLm51bUNvbHVtbnMoKTsgaSsrKSB7XG4gICAgLy8gdmFyIGxvZ1NjYWxlID0gdGhpcy5hdHRyXygnbG9nc2NhbGUnLCBpKTsgLy8gVE9ETyhrbGF1c3cpOiB0aGlzIGxvb2tzIHdyb25nIC8vIGtvbmlnc2JlcmcgdGhpbmtzIHNvIHRvby5cbiAgICB2YXIgc2VyaWVzID0gdGhpcy5kYXRhSGFuZGxlcl8uZXh0cmFjdFNlcmllcyh0aGlzLnJhd0RhdGFfLCBpLCB0aGlzLmF0dHJpYnV0ZXNfKTtcbiAgICBpZiAodGhpcy5yb2xsUGVyaW9kXyA+IDEpIHtcbiAgICAgIHNlcmllcyA9IHRoaXMuZGF0YUhhbmRsZXJfLnJvbGxpbmdBdmVyYWdlKHNlcmllcywgdGhpcy5yb2xsUGVyaW9kXywgdGhpcy5hdHRyaWJ1dGVzXyk7XG4gICAgfVxuXG4gICAgdGhpcy5yb2xsZWRTZXJpZXNfLnB1c2goc2VyaWVzKTtcbiAgfVxuXG4gIC8vIElmIHRoZSBkYXRhIG9yIG9wdGlvbnMgaGF2ZSBjaGFuZ2VkLCB0aGVuIHdlJ2QgYmV0dGVyIHJlZHJhdy5cbiAgdGhpcy5kcmF3R3JhcGhfKCk7XG5cbiAgLy8gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIGRvIHZhcmlvdXMgYW5pbWF0aW9ucy5cbiAgdmFyIGVuZCA9IG5ldyBEYXRlKCk7XG4gIHRoaXMuZHJhd2luZ1RpbWVNc18gPSAoZW5kIC0gc3RhcnQpO1xufTtcblxuLyoqXG4gKiBQb2ludCBzdHJ1Y3R1cmUuXG4gKlxuICogeHZhbF8qIGFuZCB5dmFsXyogYXJlIHRoZSBvcmlnaW5hbCB1bnNjYWxlZCBkYXRhIHZhbHVlcyxcbiAqIHdoaWxlIHhfKiBhbmQgeV8qIGFyZSBzY2FsZWQgdG8gdGhlIHJhbmdlICgwLjAtMS4wKSBmb3IgcGxvdHRpbmcuXG4gKiB5dmFsX3N0YWNrZWQgaXMgdGhlIGN1bXVsYXRpdmUgWSB2YWx1ZSB1c2VkIGZvciBzdGFja2luZyBncmFwaHMsXG4gKiBhbmQgYm90dG9tL3RvcC9taW51cy9wbHVzIGFyZSB1c2VkIGZvciBlcnJvciBiYXIgZ3JhcGhzLlxuICpcbiAqIEB0eXBlZGVmIHt7XG4gKiAgICAgaWR4OiBudW1iZXIsXG4gKiAgICAgbmFtZTogc3RyaW5nLFxuICogICAgIHg6ID9udW1iZXIsXG4gKiAgICAgeHZhbDogP251bWJlcixcbiAqICAgICB5X2JvdHRvbTogP251bWJlcixcbiAqICAgICB5OiA/bnVtYmVyLFxuICogICAgIHlfc3RhY2tlZDogP251bWJlcixcbiAqICAgICB5X3RvcDogP251bWJlcixcbiAqICAgICB5dmFsX21pbnVzOiA/bnVtYmVyLFxuICogICAgIHl2YWw6ID9udW1iZXIsXG4gKiAgICAgeXZhbF9wbHVzOiA/bnVtYmVyLFxuICogICAgIHl2YWxfc3RhY2tlZFxuICogfX1cbiAqL1xuRHlncmFwaC5Qb2ludFR5cGUgPSB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBwb2ludCBzdGFja2luZyBmb3Igc3RhY2tlZEdyYXBoPXRydWUuXG4gKlxuICogRm9yIHN0YWNraW5nIHB1cnBvc2VzLCBpbnRlcnBvbGF0ZSBvciBleHRlbmQgbmVpZ2hib3JpbmcgZGF0YSBhY3Jvc3NcbiAqIE5hTiB2YWx1ZXMgYmFzZWQgb24gc3RhY2tlZEdyYXBoTmFORmlsbCBzZXR0aW5ncy4gVGhpcyBpcyBmb3IgZGlzcGxheVxuICogb25seSwgdGhlIHVuZGVybHlpbmcgZGF0YSB2YWx1ZSBhcyBzaG93biBpbiB0aGUgbGVnZW5kIHJlbWFpbnMgTmFOLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPER5Z3JhcGguUG9pbnRUeXBlPn0gcG9pbnRzIFBvaW50IGFycmF5IGZvciBhIHNpbmdsZSBzZXJpZXMuXG4gKiAgICAgVXBkYXRlcyBlYWNoIFBvaW50J3MgeXZhbF9zdGFja2VkIHByb3BlcnR5LlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gY3VtdWxhdGl2ZVl2YWwgQWNjdW11bGF0ZWQgdG9wLW9mLWdyYXBoIHN0YWNrZWQgWVxuICogICAgIHZhbHVlcyBmb3IgdGhlIHNlcmllcyBzZWVuIHNvIGZhci4gSW5kZXggaXMgdGhlIHJvdyBudW1iZXIuIFVwZGF0ZWRcbiAqICAgICBiYXNlZCBvbiB0aGUgY3VycmVudCBzZXJpZXMncyB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBzZXJpZXNFeHRyZW1lcyBNaW4gYW5kIG1heCB2YWx1ZXMsIHVwZGF0ZWRcbiAqICAgICB0byByZWZsZWN0IHRoZSBzdGFja2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxsTWV0aG9kIEludGVycG9sYXRpb24gbWV0aG9kLCBvbmUgb2YgJ2FsbCcsICdpbnNpZGUnLCBvclxuICogICAgICdub25lJy5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGguc3RhY2tQb2ludHNfID0gZnVuY3Rpb24oXG4gICAgcG9pbnRzLCBjdW11bGF0aXZlWXZhbCwgc2VyaWVzRXh0cmVtZXMsIGZpbGxNZXRob2QpIHtcbiAgdmFyIGxhc3RYdmFsID0gbnVsbDtcbiAgdmFyIHByZXZQb2ludCA9IG51bGw7XG4gIHZhciBuZXh0UG9pbnQgPSBudWxsO1xuICB2YXIgbmV4dFBvaW50SWR4ID0gLTE7XG5cbiAgLy8gRmluZCB0aGUgbmV4dCBzdGFja2FibGUgcG9pbnQgc3RhcnRpbmcgZnJvbSB0aGUgZ2l2ZW4gaW5kZXguXG4gIHZhciB1cGRhdGVOZXh0UG9pbnQgPSBmdW5jdGlvbihpZHgpIHtcbiAgICAvLyBJZiB3ZSd2ZSBwcmV2aW91c2x5IGZvdW5kIGEgbm9uLU5hTiBwb2ludCBhbmQgaGF2ZW4ndCBnb25lIHBhc3QgaXQgeWV0LFxuICAgIC8vIGp1c3QgdXNlIHRoYXQuXG4gICAgaWYgKG5leHRQb2ludElkeCA+PSBpZHgpIHJldHVybjtcblxuICAgIC8vIFdlIGhhdmVuJ3QgZm91bmQgYSBub24tTmFOIHBvaW50IHlldCBvciBoYXZlIG1vdmVkIHBhc3QgaXQsXG4gICAgLy8gbG9vayB0b3dhcmRzIHRoZSByaWdodCB0byBmaW5kIGEgbm9uLU5hTiBwb2ludC5cbiAgICBmb3IgKHZhciBqID0gaWR4OyBqIDwgcG9pbnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAvLyBDbGVhciBvdXQgYSBwcmV2aW91c2x5LWZvdW5kIHBvaW50IChpZiBhbnkpIHNpbmNlIGl0J3Mgbm8gbG9uZ2VyXG4gICAgICAvLyB2YWxpZCwgd2Ugc2hvdWxkbid0IHVzZSBpdCBmb3IgaW50ZXJwb2xhdGlvbiBhbnltb3JlLlxuICAgICAgbmV4dFBvaW50ID0gbnVsbDtcbiAgICAgIGlmICghaXNOYU4ocG9pbnRzW2pdLnl2YWwpICYmIHBvaW50c1tqXS55dmFsICE9PSBudWxsKSB7XG4gICAgICAgIG5leHRQb2ludElkeCA9IGo7XG4gICAgICAgIG5leHRQb2ludCA9IHBvaW50c1tqXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgIHZhciB4dmFsID0gcG9pbnQueHZhbDtcbiAgICBpZiAoY3VtdWxhdGl2ZVl2YWxbeHZhbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3VtdWxhdGl2ZVl2YWxbeHZhbF0gPSAwO1xuICAgIH1cblxuICAgIHZhciBhY3R1YWxZdmFsID0gcG9pbnQueXZhbDtcbiAgICBpZiAoaXNOYU4oYWN0dWFsWXZhbCkgfHwgYWN0dWFsWXZhbCA9PT0gbnVsbCkge1xuICAgICAgaWYoZmlsbE1ldGhvZCA9PSAnbm9uZScpIHtcbiAgICAgICAgYWN0dWFsWXZhbCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbnRlcnBvbGF0ZS9leHRlbmQgZm9yIHN0YWNraW5nIHB1cnBvc2VzIGlmIHBvc3NpYmxlLlxuICAgICAgICB1cGRhdGVOZXh0UG9pbnQoaSk7XG4gICAgICAgIGlmIChwcmV2UG9pbnQgJiYgbmV4dFBvaW50ICYmIGZpbGxNZXRob2QgIT0gJ25vbmUnKSB7XG4gICAgICAgICAgLy8gVXNlIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gcHJldlBvaW50IGFuZCBuZXh0UG9pbnQuXG4gICAgICAgICAgYWN0dWFsWXZhbCA9IHByZXZQb2ludC55dmFsICsgKG5leHRQb2ludC55dmFsIC0gcHJldlBvaW50Lnl2YWwpICpcbiAgICAgICAgICAgICAgKCh4dmFsIC0gcHJldlBvaW50Lnh2YWwpIC8gKG5leHRQb2ludC54dmFsIC0gcHJldlBvaW50Lnh2YWwpKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2UG9pbnQgJiYgZmlsbE1ldGhvZCA9PSAnYWxsJykge1xuICAgICAgICAgIGFjdHVhbFl2YWwgPSBwcmV2UG9pbnQueXZhbDtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0UG9pbnQgJiYgZmlsbE1ldGhvZCA9PSAnYWxsJykge1xuICAgICAgICAgIGFjdHVhbFl2YWwgPSBuZXh0UG9pbnQueXZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY3R1YWxZdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2UG9pbnQgPSBwb2ludDtcbiAgICB9XG5cbiAgICB2YXIgc3RhY2tlZFl2YWwgPSBjdW11bGF0aXZlWXZhbFt4dmFsXTtcbiAgICBpZiAobGFzdFh2YWwgIT0geHZhbCkge1xuICAgICAgLy8gSWYgYW4geC12YWx1ZSBpcyByZXBlYXRlZCwgd2UgaWdub3JlIHRoZSBkdXBsaWNhdGVzLlxuICAgICAgc3RhY2tlZFl2YWwgKz0gYWN0dWFsWXZhbDtcbiAgICAgIGN1bXVsYXRpdmVZdmFsW3h2YWxdID0gc3RhY2tlZFl2YWw7XG4gICAgfVxuICAgIGxhc3RYdmFsID0geHZhbDtcblxuICAgIHBvaW50Lnl2YWxfc3RhY2tlZCA9IHN0YWNrZWRZdmFsO1xuXG4gICAgaWYgKHN0YWNrZWRZdmFsID4gc2VyaWVzRXh0cmVtZXNbMV0pIHtcbiAgICAgIHNlcmllc0V4dHJlbWVzWzFdID0gc3RhY2tlZFl2YWw7XG4gICAgfVxuICAgIGlmIChzdGFja2VkWXZhbCA8IHNlcmllc0V4dHJlbWVzWzBdKSB7XG4gICAgICBzZXJpZXNFeHRyZW1lc1swXSA9IHN0YWNrZWRZdmFsO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIExvb3Agb3ZlciBhbGwgZmllbGRzIGFuZCBjcmVhdGUgZGF0YXNldHMsIGNhbGN1bGF0aW5nIGV4dHJlbWUgeS12YWx1ZXMgZm9yXG4gKiBlYWNoIHNlcmllcyBhbmQgZXh0cmVtZSB4LWluZGljZXMgYXMgd2UgZ28uXG4gKlxuICogZGF0ZVdpbmRvdyBpcyBwYXNzZWQgaW4gYXMgYW4gZXhwbGljaXQgcGFyYW1ldGVyIHNvIHRoYXQgd2UgY2FuIGNvbXB1dGVcbiAqIGV4dHJlbWUgdmFsdWVzIFwic3BlY3VsYXRpdmVseVwiLCBpLmUuIHdpdGhvdXQgYWN0dWFsbHkgc2V0dGluZyBzdGF0ZSBvbiB0aGVcbiAqIGR5Z3JhcGguXG4gKlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPEFycmF5LjwobnVtYmVyfEFycmF5PG51bWJlcj4pPj59IHJvbGxlZFNlcmllcywgd2hlcmVcbiAqICAgICByb2xsZWRTZXJpZXNbc2VyaWVzSW5kZXhdW3Jvd10gPSByYXcgcG9pbnQsIHdoZXJlXG4gKiAgICAgc2VyaWVzSW5kZXggaXMgdGhlIGNvbHVtbiBudW1iZXIgc3RhcnRpbmcgd2l0aCAxLCBhbmRcbiAqICAgICByYXdQb2ludCBpcyBbeCx5XSBvciBbeCwgW3ksIGVycl1dIG9yIFt4LCBbeSwgeW1pbnVzLCB5cGx1c11dLlxuICogQHBhcmFtIHs/QXJyYXkuPG51bWJlcj59IGRhdGVXaW5kb3cgW3htaW4sIHhtYXhdIHBhaXIsIG9yIG51bGwuXG4gKiBAcmV0dXJuIHt7XG4gKiAgICAgcG9pbnRzOiBBcnJheS48QXJyYXkuPER5Z3JhcGguUG9pbnRUeXBlPj4sXG4gKiAgICAgc2VyaWVzRXh0cmVtZXM6IEFycmF5LjxBcnJheS48bnVtYmVyPj4sXG4gKiAgICAgYm91bmRhcnlJZHM6IEFycmF5LjxudW1iZXI+fX1cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdhdGhlckRhdGFzZXRzXyA9IGZ1bmN0aW9uKHJvbGxlZFNlcmllcywgZGF0ZVdpbmRvdykge1xuICB2YXIgYm91bmRhcnlJZHMgPSBbXTtcbiAgdmFyIHBvaW50cyA9IFtdO1xuICB2YXIgY3VtdWxhdGl2ZVl2YWwgPSBbXTsgIC8vIEZvciBzdGFja2VkIHNlcmllcy5cbiAgdmFyIGV4dHJlbWVzID0ge307ICAvLyBzZXJpZXMgbmFtZSAtPiBbbG93LCBoaWdoXVxuICB2YXIgc2VyaWVzSWR4LCBzYW1wbGVJZHg7XG4gIHZhciBmaXJzdElkeCwgbGFzdElkeDtcbiAgdmFyIGF4aXNJZHg7XG5cbiAgLy8gTG9vcCBvdmVyIHRoZSBmaWVsZHMgKHNlcmllcykuICBHbyBmcm9tIHRoZSBsYXN0IHRvIHRoZSBmaXJzdCxcbiAgLy8gYmVjYXVzZSBpZiB0aGV5J3JlIHN0YWNrZWQgdGhhdCdzIGhvdyB3ZSBhY2N1bXVsYXRlIHRoZSB2YWx1ZXMuXG4gIHZhciBudW1fc2VyaWVzID0gcm9sbGVkU2VyaWVzLmxlbmd0aCAtIDE7XG4gIHZhciBzZXJpZXM7XG4gIGZvciAoc2VyaWVzSWR4ID0gbnVtX3Nlcmllczsgc2VyaWVzSWR4ID49IDE7IHNlcmllc0lkeC0tKSB7XG4gICAgaWYgKCF0aGlzLnZpc2liaWxpdHkoKVtzZXJpZXNJZHggLSAxXSkgY29udGludWU7XG5cbiAgICAvLyBQcnVuZSBkb3duIHRvIHRoZSBkZXNpcmVkIHJhbmdlLCBpZiBuZWNlc3NhcnkgKGZvciB6b29taW5nKVxuICAgIC8vIEJlY2F1c2UgdGhlcmUgY2FuIGJlIGxpbmVzIGdvaW5nIHRvIHBvaW50cyBvdXRzaWRlIG9mIHRoZSB2aXNpYmxlIGFyZWEsXG4gICAgLy8gd2UgYWN0dWFsbHkgcHJ1bmUgdG8gdmlzaWJsZSBwb2ludHMsIHBsdXMgb25lIG9uIGVpdGhlciBzaWRlLlxuICAgIGlmIChkYXRlV2luZG93KSB7XG4gICAgICBzZXJpZXMgPSByb2xsZWRTZXJpZXNbc2VyaWVzSWR4XTtcbiAgICAgIHZhciBsb3cgPSBkYXRlV2luZG93WzBdO1xuICAgICAgdmFyIGhpZ2ggPSBkYXRlV2luZG93WzFdO1xuXG4gICAgICAvLyBUT0RPKGRhbnZrKTogZG8gYmluYXJ5IHNlYXJjaCBpbnN0ZWFkIG9mIGxpbmVhciBzZWFyY2guXG4gICAgICAvLyBUT0RPKGRhbnZrKTogcGFzcyBmaXJzdElkeCBhbmQgbGFzdElkeCBkaXJlY3RseSB0byB0aGUgcmVuZGVyZXIuXG4gICAgICBmaXJzdElkeCA9IG51bGw7XG4gICAgICBsYXN0SWR4ID0gbnVsbDtcbiAgICAgIGZvciAoc2FtcGxlSWR4ID0gMDsgc2FtcGxlSWR4IDwgc2VyaWVzLmxlbmd0aDsgc2FtcGxlSWR4KyspIHtcbiAgICAgICAgaWYgKHNlcmllc1tzYW1wbGVJZHhdWzBdID49IGxvdyAmJiBmaXJzdElkeCA9PT0gbnVsbCkge1xuICAgICAgICAgIGZpcnN0SWR4ID0gc2FtcGxlSWR4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXJpZXNbc2FtcGxlSWR4XVswXSA8PSBoaWdoKSB7XG4gICAgICAgICAgbGFzdElkeCA9IHNhbXBsZUlkeDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3RJZHggPT09IG51bGwpIGZpcnN0SWR4ID0gMDtcbiAgICAgIHZhciBjb3JyZWN0ZWRGaXJzdElkeCA9IGZpcnN0SWR4O1xuICAgICAgdmFyIGlzSW52YWxpZFZhbHVlID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChpc0ludmFsaWRWYWx1ZSAmJiBjb3JyZWN0ZWRGaXJzdElkeCA+IDApIHtcbiAgICAgICAgY29ycmVjdGVkRmlyc3RJZHgtLTtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHkgdmFsdWUgaXMgbnVsbC5cbiAgICAgICAgaXNJbnZhbGlkVmFsdWUgPSBzZXJpZXNbY29ycmVjdGVkRmlyc3RJZHhdWzFdID09PSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAobGFzdElkeCA9PT0gbnVsbCkgbGFzdElkeCA9IHNlcmllcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGNvcnJlY3RlZExhc3RJZHggPSBsYXN0SWR4O1xuICAgICAgaXNJbnZhbGlkVmFsdWUgPSB0cnVlO1xuICAgICAgd2hpbGUgKGlzSW52YWxpZFZhbHVlICYmIGNvcnJlY3RlZExhc3RJZHggPCBzZXJpZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb3JyZWN0ZWRMYXN0SWR4Kys7XG4gICAgICAgIGlzSW52YWxpZFZhbHVlID0gc2VyaWVzW2NvcnJlY3RlZExhc3RJZHhdWzFdID09PSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29ycmVjdGVkRmlyc3RJZHghPT1maXJzdElkeCkge1xuICAgICAgICBmaXJzdElkeCA9IGNvcnJlY3RlZEZpcnN0SWR4O1xuICAgICAgfVxuICAgICAgaWYgKGNvcnJlY3RlZExhc3RJZHggIT09IGxhc3RJZHgpIHtcbiAgICAgICAgbGFzdElkeCA9IGNvcnJlY3RlZExhc3RJZHg7XG4gICAgICB9XG5cbiAgICAgIGJvdW5kYXJ5SWRzW3Nlcmllc0lkeC0xXSA9IFtmaXJzdElkeCwgbGFzdElkeF07XG5cbiAgICAgIC8vIC5zbGljZSdzIGVuZCBpcyBleGNsdXNpdmUsIHdlIHdhbnQgdG8gaW5jbHVkZSBsYXN0SWR4LlxuICAgICAgc2VyaWVzID0gc2VyaWVzLnNsaWNlKGZpcnN0SWR4LCBsYXN0SWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmllcyA9IHJvbGxlZFNlcmllc1tzZXJpZXNJZHhdO1xuICAgICAgYm91bmRhcnlJZHNbc2VyaWVzSWR4LTFdID0gWzAsIHNlcmllcy5sZW5ndGgtMV07XG4gICAgfVxuXG4gICAgdmFyIHNlcmllc05hbWUgPSB0aGlzLmF0dHJfKFwibGFiZWxzXCIpW3Nlcmllc0lkeF07XG4gICAgdmFyIHNlcmllc0V4dHJlbWVzID0gdGhpcy5kYXRhSGFuZGxlcl8uZ2V0RXh0cmVtZVlWYWx1ZXMoc2VyaWVzLFxuICAgICAgICBkYXRlV2luZG93LCB0aGlzLmdldEJvb2xlYW5PcHRpb24oXCJzdGVwUGxvdFwiLHNlcmllc05hbWUpKTtcblxuICAgIHZhciBzZXJpZXNQb2ludHMgPSB0aGlzLmRhdGFIYW5kbGVyXy5zZXJpZXNUb1BvaW50cyhzZXJpZXMsXG4gICAgICAgIHNlcmllc05hbWUsIGJvdW5kYXJ5SWRzW3Nlcmllc0lkeC0xXVswXSk7XG5cbiAgICBpZiAodGhpcy5nZXRCb29sZWFuT3B0aW9uKFwic3RhY2tlZEdyYXBoXCIpKSB7XG4gICAgICBheGlzSWR4ID0gdGhpcy5hdHRyaWJ1dGVzXy5heGlzRm9yU2VyaWVzKHNlcmllc05hbWUpO1xuICAgICAgaWYgKGN1bXVsYXRpdmVZdmFsW2F4aXNJZHhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3VtdWxhdGl2ZVl2YWxbYXhpc0lkeF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIER5Z3JhcGguc3RhY2tQb2ludHNfKHNlcmllc1BvaW50cywgY3VtdWxhdGl2ZVl2YWxbYXhpc0lkeF0sIHNlcmllc0V4dHJlbWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRCb29sZWFuT3B0aW9uKFwic3RhY2tlZEdyYXBoTmFORmlsbFwiKSk7XG4gICAgfVxuXG4gICAgZXh0cmVtZXNbc2VyaWVzTmFtZV0gPSBzZXJpZXNFeHRyZW1lcztcbiAgICBwb2ludHNbc2VyaWVzSWR4XSA9IHNlcmllc1BvaW50cztcbiAgfVxuXG4gIHJldHVybiB7IHBvaW50czogcG9pbnRzLCBleHRyZW1lczogZXh0cmVtZXMsIGJvdW5kYXJ5SWRzOiBib3VuZGFyeUlkcyB9O1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGdyYXBoIHdpdGggbmV3IGRhdGEuIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZSB2aWV3aW5nIGFyZWFcbiAqIGhhcyBjaGFuZ2VkLiBJZiB0aGUgdW5kZXJseWluZyBkYXRhIG9yIG9wdGlvbnMgaGF2ZSBjaGFuZ2VkLCBwcmVkcmF3XyB3aWxsXG4gKiBiZSBjYWxsZWQgYmVmb3JlIGRyYXdHcmFwaF8gaXMgY2FsbGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmRyYXdHcmFwaF8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoKTtcblxuICAvLyBUaGlzIGlzIHVzZWQgdG8gc2V0IHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGRyYXdDYWxsYmFjaywgYmVsb3cuXG4gIHZhciBpc19pbml0aWFsX2RyYXcgPSB0aGlzLmlzX2luaXRpYWxfZHJhd187XG4gIHRoaXMuaXNfaW5pdGlhbF9kcmF3XyA9IGZhbHNlO1xuXG4gIHRoaXMubGF5b3V0Xy5yZW1vdmVBbGxEYXRhc2V0cygpO1xuICB0aGlzLnNldENvbG9yc18oKTtcbiAgdGhpcy5hdHRyc18ucG9pbnRTaXplID0gMC41ICogdGhpcy5nZXROdW1lcmljT3B0aW9uKCdoaWdobGlnaHRDaXJjbGVTaXplJyk7XG5cbiAgdmFyIHBhY2tlZCA9IHRoaXMuZ2F0aGVyRGF0YXNldHNfKHRoaXMucm9sbGVkU2VyaWVzXywgdGhpcy5kYXRlV2luZG93Xyk7XG4gIHZhciBwb2ludHMgPSBwYWNrZWQucG9pbnRzO1xuICB2YXIgZXh0cmVtZXMgPSBwYWNrZWQuZXh0cmVtZXM7XG4gIHRoaXMuYm91bmRhcnlJZHNfID0gcGFja2VkLmJvdW5kYXJ5SWRzO1xuXG4gIHRoaXMuc2V0SW5kZXhCeU5hbWVfID0ge307XG4gIHZhciBsYWJlbHMgPSB0aGlzLmF0dHJfKFwibGFiZWxzXCIpO1xuICB2YXIgZGF0YUlkeCA9IDA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCF0aGlzLnZpc2liaWxpdHkoKVtpIC0gMV0pIGNvbnRpbnVlO1xuICAgIHRoaXMubGF5b3V0Xy5hZGREYXRhc2V0KGxhYmVsc1tpXSwgcG9pbnRzW2ldKTtcbiAgICB0aGlzLmRhdGFzZXRJbmRleF9baV0gPSBkYXRhSWR4Kys7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnNldEluZGV4QnlOYW1lX1tsYWJlbHNbaV1dID0gaTtcbiAgfVxuXG4gIHRoaXMuY29tcHV0ZVlBeGlzUmFuZ2VzXyhleHRyZW1lcyk7XG4gIHRoaXMubGF5b3V0Xy5zZXRZQXhlcyh0aGlzLmF4ZXNfKTtcblxuICB0aGlzLmFkZFhUaWNrc18oKTtcblxuICAvLyBUZWxsIFBsb3RLaXQgdG8gdXNlIHRoaXMgbmV3IGRhdGEgYW5kIHJlbmRlciBpdHNlbGZcbiAgdGhpcy5sYXlvdXRfLmV2YWx1YXRlKCk7XG4gIHRoaXMucmVuZGVyR3JhcGhfKGlzX2luaXRpYWxfZHJhdyk7XG5cbiAgaWYgKHRoaXMuZ2V0U3RyaW5nT3B0aW9uKFwidGltaW5nTmFtZVwiKSkge1xuICAgIHZhciBlbmQgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnNvbGUubG9nKHRoaXMuZ2V0U3RyaW5nT3B0aW9uKFwidGltaW5nTmFtZVwiKSArIFwiIC0gZHJhd0dyYXBoOiBcIiArIChlbmQgLSBzdGFydCkgKyBcIm1zXCIpO1xuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgZG9lcyB0aGUgd29yayBvZiBkcmF3aW5nIHRoZSBjaGFydC4gSXQgYXNzdW1lcyB0aGF0IHRoZSBsYXlvdXQgYW5kIGF4aXNcbiAqIHNjYWxlcyBoYXZlIGFscmVhZHkgYmVlbiBzZXQgKGUuZy4gYnkgcHJlZHJhd18pLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnJlbmRlckdyYXBoXyA9IGZ1bmN0aW9uKGlzX2luaXRpYWxfZHJhdykge1xuICB0aGlzLmNhc2NhZGVFdmVudHNfKCdjbGVhckNoYXJ0Jyk7XG4gIHRoaXMucGxvdHRlcl8uY2xlYXIoKTtcblxuICBjb25zdCB1bmRlcmxheUNhbGxiYWNrID0gdGhpcy5nZXRGdW5jdGlvbk9wdGlvbigndW5kZXJsYXlDYWxsYmFjaycpO1xuICBpZiAodW5kZXJsYXlDYWxsYmFjaykge1xuICAgIC8vIE5PVEU6IHdlIHBhc3MgdGhlIGR5Z3JhcGggb2JqZWN0IHRvIHRoaXMgY2FsbGJhY2sgdHdpY2UgdG8gYXZvaWQgYnJlYWtpbmdcbiAgICAvLyB1c2VycyB3aG8gZXhwZWN0IGEgZGVwcmVjYXRlZCBmb3JtIG9mIHRoaXMgY2FsbGJhY2suXG4gICAgdW5kZXJsYXlDYWxsYmFjay5jYWxsKHRoaXMsXG4gICAgICAgIHRoaXMuaGlkZGVuX2N0eF8sIHRoaXMubGF5b3V0Xy5nZXRQbG90QXJlYSgpLCB0aGlzLCB0aGlzKTtcbiAgfVxuXG4gIHZhciBlID0ge1xuICAgIGNhbnZhczogdGhpcy5oaWRkZW5fLFxuICAgIGRyYXdpbmdDb250ZXh0OiB0aGlzLmhpZGRlbl9jdHhfXG4gIH07XG4gIHRoaXMuY2FzY2FkZUV2ZW50c18oJ3dpbGxEcmF3Q2hhcnQnLCBlKTtcbiAgdGhpcy5wbG90dGVyXy5yZW5kZXIoKTtcbiAgdGhpcy5jYXNjYWRlRXZlbnRzXygnZGlkRHJhd0NoYXJ0JywgZSk7XG4gIHRoaXMubGFzdFJvd18gPSAtMTsgIC8vIGJlY2F1c2UgcGx1Z2lucy9sZWdlbmQuanMgY2xlYXJzIHRoZSBsZWdlbmRcblxuICAvLyBUT0RPKGRhbnZrKTogaXMgdGhpcyBhIHBlcmZvcm1hbmNlIGJvdHRsZW5lY2sgd2hlbiBwYW5uaW5nP1xuICAvLyBUaGUgaW50ZXJhY3Rpb24gY2FudmFzIHNob3VsZCBhbHJlYWR5IGJlIGVtcHR5IGluIHRoYXQgc2l0dWF0aW9uLlxuICB0aGlzLmNhbnZhc18uZ2V0Q29udGV4dCgnMmQnKS5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aF8sIHRoaXMuaGVpZ2h0Xyk7XG5cbiAgY29uc3QgZHJhd0NhbGxiYWNrID0gdGhpcy5nZXRGdW5jdGlvbk9wdGlvbihcImRyYXdDYWxsYmFja1wiKTtcbiAgaWYgKGRyYXdDYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIGRyYXdDYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMsIGlzX2luaXRpYWxfZHJhdyk7XG4gIH1cbiAgaWYgKGlzX2luaXRpYWxfZHJhdykge1xuICAgIHRoaXMucmVhZHlGaXJlZF8gPSB0cnVlO1xuICAgIHdoaWxlICh0aGlzLnJlYWR5Rm5zXy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgZm4gPSB0aGlzLnJlYWR5Rm5zXy5wb3AoKTtcbiAgICAgIGZuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogRGV0ZXJtaW5lIHByb3BlcnRpZXMgb2YgdGhlIHktYXhlcyB3aGljaCBhcmUgaW5kZXBlbmRlbnQgb2YgdGhlIGRhdGFcbiAqIGN1cnJlbnRseSBiZWluZyBkaXNwbGF5ZWQuIFRoaXMgaW5jbHVkZXMgdGhpbmdzIGxpa2UgdGhlIG51bWJlciBvZiBheGVzIGFuZFxuICogdGhlIHN0eWxlIG9mIHRoZSBheGVzLiBJdCBkb2VzIG5vdCBpbmNsdWRlIHRoZSByYW5nZSBvZiBlYWNoIGF4aXMgYW5kIGl0c1xuICogdGljayBtYXJrcy5cbiAqIFRoaXMgZmlsbHMgaW4gdGhpcy5heGVzXy5cbiAqIGF4ZXNfID0gWyB7IG9wdGlvbnMgfSBdXG4gKiAgIGluZGljZXMgYXJlIGludG8gdGhlIGF4ZXNfIGFycmF5LlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5jb21wdXRlWUF4ZXNfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBheGlzLCBpbmRleCwgb3B0cywgdjtcblxuICAvLyB0aGlzLmF4ZXNfIGRvZXNuJ3QgbWF0Y2ggdGhpcy5hdHRyaWJ1dGVzXy5heGVzXy5vcHRpb25zLiBJdCdzIHVzZWQgZm9yXG4gIC8vIGRhdGEgY29tcHV0YXRpb24gYXMgd2VsbCBhcyBvcHRpb25zIHN0b3JhZ2UuXG4gIC8vIEdvIHRocm91Z2ggb25jZSBhbmQgYWRkIGFsbCB0aGUgYXhlcy5cbiAgdGhpcy5heGVzXyA9IFtdO1xuXG4gIGZvciAoYXhpcyA9IDA7IGF4aXMgPCB0aGlzLmF0dHJpYnV0ZXNfLm51bUF4ZXMoKTsgYXhpcysrKSB7XG4gICAgLy8gQWRkIGEgbmV3IGF4aXMsIG1ha2luZyBhIGNvcHkgb2YgaXRzIHBlci1heGlzIG9wdGlvbnMuXG4gICAgb3B0cyA9IHsgZyA6IHRoaXMgfTtcbiAgICB1dGlscy51cGRhdGUob3B0cywgdGhpcy5hdHRyaWJ1dGVzXy5heGlzT3B0aW9ucyhheGlzKSk7XG4gICAgdGhpcy5heGVzX1theGlzXSA9IG9wdHM7XG4gIH1cblxuICBmb3IgKGF4aXMgPSAwOyBheGlzIDwgdGhpcy5heGVzXy5sZW5ndGg7IGF4aXMrKykge1xuICAgIGlmIChheGlzID09PSAwKSB7XG4gICAgICBvcHRzID0gdGhpcy5vcHRpb25zVmlld0ZvckF4aXNfKCd5JyArIChheGlzID8gJzInIDogJycpKTtcbiAgICAgIHYgPSBvcHRzKFwidmFsdWVSYW5nZVwiKTtcbiAgICAgIGlmICh2KSB0aGlzLmF4ZXNfW2F4aXNdLnZhbHVlUmFuZ2UgPSB2O1xuICAgIH0gZWxzZSB7ICAvLyBUbyBrZWVwIG9sZCBiZWhhdmlvclxuICAgICAgdmFyIGF4ZXMgPSB0aGlzLnVzZXJfYXR0cnNfLmF4ZXM7XG4gICAgICBpZiAoYXhlcyAmJiBheGVzLnkyKSB7XG4gICAgICAgIHYgPSBheGVzLnkyLnZhbHVlUmFuZ2U7XG4gICAgICAgIGlmICh2KSB0aGlzLmF4ZXNfW2F4aXNdLnZhbHVlUmFuZ2UgPSB2O1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgeS1heGVzIG9uIHRoZSBjaGFydC5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIG51bWJlciBvZiBheGVzLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5udW1BeGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNfLm51bUF4ZXMoKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJldHVybnMgYXhpcyBwcm9wZXJ0aWVzIGZvciB0aGUgZ2l2ZW4gc2VyaWVzLlxuICogQHBhcmFtIHtzdHJpbmd9IHNldE5hbWUgVGhlIG5hbWUgb2YgdGhlIHNlcmllcyBmb3Igd2hpY2ggdG8gZ2V0IGF4aXNcbiAqIHByb3BlcnRpZXMsIGUuZy4gJ1kxJy5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGF4aXMgcHJvcGVydGllcy5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuYXhpc1Byb3BlcnRpZXNGb3JTZXJpZXMgPSBmdW5jdGlvbihzZXJpZXMpIHtcbiAgLy8gVE9ETyhkYW52ayk6IGhhbmRsZSBlcnJvcnMuXG4gIHJldHVybiB0aGlzLmF4ZXNfW3RoaXMuYXR0cmlidXRlc18uYXhpc0ZvclNlcmllcyhzZXJpZXMpXTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIERldGVybWluZSB0aGUgdmFsdWUgcmFuZ2UgYW5kIHRpY2sgbWFya3MgZm9yIGVhY2ggYXhpcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRyZW1lcyBBIG1hcHBpbmcgZnJvbSBzZXJpZXNOYW1lIC0+IFtsb3csIGhpZ2hdXG4gKiBUaGlzIGZpbGxzIGluIHRoZSB2YWx1ZVJhbmdlIGFuZCB0aWNrcyBmaWVsZHMgaW4gZWFjaCBlbnRyeSBvZiB0aGlzLmF4ZXNfLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5jb21wdXRlWUF4aXNSYW5nZXNfID0gZnVuY3Rpb24oZXh0cmVtZXMpIHtcbiAgdmFyIGlzTnVsbFVuZGVmaW5lZE9yTmFOID0gZnVuY3Rpb24obnVtKSB7XG4gICAgcmV0dXJuIGlzTmFOKHBhcnNlRmxvYXQobnVtKSk7XG4gIH07XG4gIHZhciBudW1BeGVzID0gdGhpcy5hdHRyaWJ1dGVzXy5udW1BeGVzKCk7XG4gIHZhciB5cGFkQ29tcGF0LCBzcGFuLCBzZXJpZXMsIHlwYWQ7XG5cbiAgdmFyIHBfYXhpcztcblxuICAvLyBDb21wdXRlIGV4dHJlbWUgdmFsdWVzLCBhIHNwYW4gYW5kIHRpY2sgbWFya3MgZm9yIGVhY2ggYXhpcy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1BeGVzOyBpKyspIHtcbiAgICB2YXIgYXhpcyA9IHRoaXMuYXhlc19baV07XG4gICAgdmFyIGxvZ3NjYWxlID0gdGhpcy5hdHRyaWJ1dGVzXy5nZXRGb3JBeGlzKFwibG9nc2NhbGVcIiwgaSk7XG4gICAgdmFyIGluY2x1ZGVaZXJvID0gdGhpcy5hdHRyaWJ1dGVzXy5nZXRGb3JBeGlzKFwiaW5jbHVkZVplcm9cIiwgaSk7XG4gICAgdmFyIGluZGVwZW5kZW50VGlja3MgPSB0aGlzLmF0dHJpYnV0ZXNfLmdldEZvckF4aXMoXCJpbmRlcGVuZGVudFRpY2tzXCIsIGkpO1xuICAgIHNlcmllcyA9IHRoaXMuYXR0cmlidXRlc18uc2VyaWVzRm9yQXhpcyhpKTtcblxuICAgIC8vIEFkZCBzb21lIHBhZGRpbmcuIFRoaXMgc3VwcG9ydHMgdHdvIFkgcGFkZGluZyBvcGVyYXRpb24gbW9kZXM6XG4gICAgLy9cbiAgICAvLyAtIGJhY2t3YXJkcyBjb21wYXRpYmxlICh5UmFuZ2VQYWQgbm90IHNldCk6XG4gICAgLy8gICAxMCUgcGFkZGluZyBmb3IgYXV0b21hdGljIFkgcmFuZ2VzLCBidXQgbm90IGZvciB1c2VyLXN1cHBsaWVkXG4gICAgLy8gICByYW5nZXMsIGFuZCBtb3ZlIGEgY2xvc2UtdG8temVybyBlZGdlIHRvIHplcm8sIHNpbmNlIGRyYXdpbmcgYXQgdGhlIGVkZ2VcbiAgICAvLyAgIHJlc3VsdHMgaW4gaW52aXNpYmxlIGxpbmVzLiBVbmZvcnR1bmF0ZWx5IGxpbmVzIGRyYXduIGF0IHRoZSBlZGdlIG9mIGFcbiAgICAvLyAgIHVzZXItc3VwcGxpZWQgcmFuZ2Ugd2lsbCBzdGlsbCBiZSBpbnZpc2libGUuIElmIGxvZ3NjYWxlIGlzXG4gICAgLy8gICBzZXQsIGFkZCBhIHZhcmlhYmxlIGFtb3VudCBvZiBwYWRkaW5nIGF0IHRoZSB0b3AgYnV0XG4gICAgLy8gICBub25lIGF0IHRoZSBib3R0b20uXG4gICAgLy9cbiAgICAvLyAtIG5ldy1zdHlsZSAoeVJhbmdlUGFkIHNldCBieSB0aGUgdXNlcik6XG4gICAgLy8gICBhbHdheXMgYWRkIHRoZSBzcGVjaWZpZWQgWSBwYWRkaW5nLlxuICAgIC8vXG4gICAgeXBhZENvbXBhdCA9IHRydWU7XG4gICAgeXBhZCA9IDAuMTsgLy8gYWRkIDEwJVxuICAgIGNvbnN0IHlSYW5nZVBhZCA9IHRoaXMuZ2V0TnVtZXJpY09wdGlvbigneVJhbmdlUGFkJyk7XG4gICAgaWYgKHlSYW5nZVBhZCAhPT0gbnVsbCkge1xuICAgICAgeXBhZENvbXBhdCA9IGZhbHNlO1xuICAgICAgLy8gQ29udmVydCBwaXhlbCBwYWRkaW5nIHRvIHJhdGlvXG4gICAgICB5cGFkID0geVJhbmdlUGFkIC8gdGhpcy5wbG90dGVyXy5hcmVhLmg7XG4gICAgfVxuXG4gICAgaWYgKHNlcmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIElmIG5vIHNlcmllcyBhcmUgZGVmaW5lZCBvciB2aXNpYmxlIHRoZW4gdXNlIGEgcmVhc29uYWJsZSBkZWZhdWx0XG4gICAgICBheGlzLmV4dHJlbWVSYW5nZSA9IFswLCAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBleHRyZW1lcyBvZiBleHRyZW1lcy5cbiAgICAgIHZhciBtaW5ZID0gSW5maW5pdHk7ICAvLyBleHRyZW1lc1tzZXJpZXNbMF1dWzBdO1xuICAgICAgdmFyIG1heFkgPSAtSW5maW5pdHk7ICAvLyBleHRyZW1lc1tzZXJpZXNbMF1dWzFdO1xuICAgICAgdmFyIGV4dHJlbWVNaW5ZLCBleHRyZW1lTWF4WTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXJpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgLy8gdGhpcyBza2lwcyBpbnZpc2libGUgc2VyaWVzXG4gICAgICAgIGlmICghZXh0cmVtZXMuaGFzT3duUHJvcGVydHkoc2VyaWVzW2pdKSkgY29udGludWU7XG5cbiAgICAgICAgLy8gT25seSB1c2UgdmFsaWQgZXh0cmVtZXMgdG8gc3RvcCBudWxsIGRhdGEgc2VyaWVzJyBmcm9tIGNvcnJ1cHRpbmcgdGhlIHNjYWxlLlxuICAgICAgICBleHRyZW1lTWluWSA9IGV4dHJlbWVzW3Nlcmllc1tqXV1bMF07XG4gICAgICAgIGlmIChleHRyZW1lTWluWSAhPT0gbnVsbCkge1xuICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihleHRyZW1lTWluWSwgbWluWSk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0cmVtZU1heFkgPSBleHRyZW1lc1tzZXJpZXNbal1dWzFdO1xuICAgICAgICBpZiAoZXh0cmVtZU1heFkgIT09IG51bGwpIHtcbiAgICAgICAgICBtYXhZID0gTWF0aC5tYXgoZXh0cmVtZU1heFksIG1heFkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEluY2x1ZGUgemVybyBpZiByZXF1ZXN0ZWQgYnkgdGhlIHVzZXIuXG4gICAgICBpZiAoaW5jbHVkZVplcm8gJiYgIWxvZ3NjYWxlKSB7XG4gICAgICAgIGlmIChtaW5ZID4gMCkgbWluWSA9IDA7XG4gICAgICAgIGlmIChtYXhZIDwgMCkgbWF4WSA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGEgdmFsaWQgc2NhbGUsIG90aGVyd2lzZSBkZWZhdWx0IHRvIFswLCAxXSBmb3Igc2FmZXR5LlxuICAgICAgaWYgKG1pblkgPT0gSW5maW5pdHkpIG1pblkgPSAwO1xuICAgICAgaWYgKG1heFkgPT0gLUluZmluaXR5KSBtYXhZID0gMTtcblxuICAgICAgc3BhbiA9IG1heFkgLSBtaW5ZO1xuICAgICAgLy8gc3BlY2lhbCBjYXNlOiBpZiB3ZSBoYXZlIG5vIHNlbnNlIG9mIHNjYWxlLCBjZW50ZXIgb24gdGhlIHNvbGUgdmFsdWUuXG4gICAgICBpZiAoc3BhbiA9PT0gMCkge1xuICAgICAgICBpZiAobWF4WSAhPT0gMCkge1xuICAgICAgICAgIHNwYW4gPSBNYXRoLmFicyhtYXhZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAuLi4gYW5kIGlmIHRoZSBzb2xlIHZhbHVlIGlzIHplcm8sIHVzZSByYW5nZSAwLTEuXG4gICAgICAgICAgbWF4WSA9IDE7XG4gICAgICAgICAgc3BhbiA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG1heEF4aXNZID0gbWF4WSwgbWluQXhpc1kgPSBtaW5ZO1xuICAgICAgaWYgKHlwYWRDb21wYXQpIHtcbiAgICAgICAgaWYgKGxvZ3NjYWxlKSB7XG4gICAgICAgICAgbWF4QXhpc1kgPSBtYXhZICsgeXBhZCAqIHNwYW47XG4gICAgICAgICAgbWluQXhpc1kgPSBtaW5ZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1heEF4aXNZID0gbWF4WSArIHlwYWQgKiBzcGFuO1xuICAgICAgICAgIG1pbkF4aXNZID0gbWluWSAtIHlwYWQgKiBzcGFuO1xuXG4gICAgICAgICAgLy8gQmFja3dhcmRzLWNvbXBhdGlibGUgYmVoYXZpb3I6IE1vdmUgdGhlIHNwYW4gdG8gc3RhcnQgb3IgZW5kIGF0IHplcm8gaWYgaXQnc1xuICAgICAgICAgIC8vIGNsb3NlIHRvIHplcm8uXG4gICAgICAgICAgaWYgKG1pbkF4aXNZIDwgMCAmJiBtaW5ZID49IDApIG1pbkF4aXNZID0gMDtcbiAgICAgICAgICBpZiAobWF4QXhpc1kgPiAwICYmIG1heFkgPD0gMCkgbWF4QXhpc1kgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBheGlzLmV4dHJlbWVSYW5nZSA9IFttaW5BeGlzWSwgbWF4QXhpc1ldO1xuICAgIH1cbiAgICBpZiAoYXhpcy52YWx1ZVJhbmdlKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdXNlci1zZXQgdmFsdWUgcmFuZ2UgZm9yIHRoaXMgYXhpcy5cbiAgICAgIHZhciB5MCA9IGlzTnVsbFVuZGVmaW5lZE9yTmFOKGF4aXMudmFsdWVSYW5nZVswXSkgPyBheGlzLmV4dHJlbWVSYW5nZVswXSA6IGF4aXMudmFsdWVSYW5nZVswXTtcbiAgICAgIHZhciB5MSA9IGlzTnVsbFVuZGVmaW5lZE9yTmFOKGF4aXMudmFsdWVSYW5nZVsxXSkgPyBheGlzLmV4dHJlbWVSYW5nZVsxXSA6IGF4aXMudmFsdWVSYW5nZVsxXTtcbiAgICAgIGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlID0gW3kwLCB5MV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlID0gYXhpcy5leHRyZW1lUmFuZ2U7XG4gICAgfVxuICAgIGlmICgheXBhZENvbXBhdCkge1xuICAgICAgLy8gV2hlbiB1c2luZyB5UmFuZ2VQYWQsIGFkanVzdCB0aGUgdXBwZXIvbG93ZXIgYm91bmRzIHRvIGFkZFxuICAgICAgLy8gcGFkZGluZyB1bmxlc3MgdGhlIHVzZXIgaGFzIHpvb21lZC9wYW5uZWQgdGhlIFkgYXhpcyByYW5nZS5cbiAgICAgIGlmIChsb2dzY2FsZSkge1xuICAgICAgICB5MCA9IGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdO1xuICAgICAgICB5MSA9IGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzFdO1xuICAgICAgICB2YXIgeTBwY3QgPSB5cGFkIC8gKDIgKiB5cGFkIC0gMSk7XG4gICAgICAgIHZhciB5MXBjdCA9ICh5cGFkIC0gMSkgLyAoMiAqIHlwYWQgLSAxKTtcbiAgICAgICAgYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMF0gPSB1dGlscy5sb2dSYW5nZUZyYWN0aW9uKHkwLCB5MSwgeTBwY3QpO1xuICAgICAgICBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVsxXSA9IHV0aWxzLmxvZ1JhbmdlRnJhY3Rpb24oeTAsIHkxLCB5MXBjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5MCA9IGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdO1xuICAgICAgICB5MSA9IGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzFdO1xuICAgICAgICBzcGFuID0geTEgLSB5MDtcbiAgICAgICAgYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMF0gPSB5MCAtIHNwYW4gKiB5cGFkO1xuICAgICAgICBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVsxXSA9IHkxICsgc3BhbiAqIHlwYWQ7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICBpZiAoaW5kZXBlbmRlbnRUaWNrcykge1xuICAgICAgYXhpcy5pbmRlcGVuZGVudFRpY2tzID0gaW5kZXBlbmRlbnRUaWNrcztcbiAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zVmlld0ZvckF4aXNfKCd5JyArIChpID8gJzInIDogJycpKTtcbiAgICAgIHZhciB0aWNrZXIgPSBvcHRzKCd0aWNrZXInKTtcbiAgICAgIGF4aXMudGlja3MgPSB0aWNrZXIoYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMF0sXG4gICAgICAgICAgICAgIGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzFdLFxuICAgICAgICAgICAgICB0aGlzLnBsb3R0ZXJfLmFyZWEuaCxcbiAgICAgICAgICAgICAgb3B0cyxcbiAgICAgICAgICAgICAgdGhpcyk7XG4gICAgICAvLyBEZWZpbmUgdGhlIGZpcnN0IGluZGVwZW5kZW50IGF4aXMgYXMgcHJpbWFyeSBheGlzLlxuICAgICAgaWYgKCFwX2F4aXMpIHBfYXhpcyA9IGF4aXM7XG4gICAgfVxuICB9XG4gIGlmIChwX2F4aXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IChcIkNvbmZpZ3VyYXRpb24gRXJyb3I6IEF0IGxlYXN0IG9uZSBheGlzIGhhcyB0byBoYXZlIHRoZSBcXFwiaW5kZXBlbmRlbnRUaWNrc1xcXCIgb3B0aW9uIGFjdGl2YXRlZC5cIik7XG4gIH1cbiAgLy8gQWRkIHRpY2tzLiBCeSBkZWZhdWx0LCBhbGwgYXhlcyBpbmhlcml0IHRoZSB0aWNrIHBvc2l0aW9ucyBvZiB0aGVcbiAgLy8gcHJpbWFyeSBheGlzLiBIb3dldmVyLCBpZiBhbiBheGlzIGlzIHNwZWNpZmljYWxseSBtYXJrZWQgYXMgaGF2aW5nXG4gIC8vIGluZGVwZW5kZW50IHRpY2tzLCB0aGVuIHRoYXQgaXMgcGVybWlzc2libGUgYXMgd2VsbC5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1BeGVzOyBpKyspIHtcbiAgICB2YXIgYXhpcyA9IHRoaXMuYXhlc19baV07XG5cbiAgICBpZiAoIWF4aXMuaW5kZXBlbmRlbnRUaWNrcykge1xuICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnNWaWV3Rm9yQXhpc18oJ3knICsgKGkgPyAnMicgOiAnJykpO1xuICAgICAgdmFyIHRpY2tlciA9IG9wdHMoJ3RpY2tlcicpO1xuICAgICAgdmFyIHBfdGlja3MgPSBwX2F4aXMudGlja3M7XG4gICAgICB2YXIgcF9zY2FsZSA9IHBfYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMV0gLSBwX2F4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdO1xuICAgICAgdmFyIHNjYWxlID0gYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMV0gLSBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVswXTtcbiAgICAgIHZhciB0aWNrX3ZhbHVlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBwX3RpY2tzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciB5X2ZyYWMgPSAocF90aWNrc1trXS52IC0gcF9heGlzLmNvbXB1dGVkVmFsdWVSYW5nZVswXSkgLyBwX3NjYWxlO1xuICAgICAgICB2YXIgeV92YWwgPSBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVswXSArIHlfZnJhYyAqIHNjYWxlO1xuICAgICAgICB0aWNrX3ZhbHVlcy5wdXNoKHlfdmFsKTtcbiAgICAgIH1cblxuICAgICAgYXhpcy50aWNrcyA9IHRpY2tlcihheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGxvdHRlcl8uYXJlYS5oLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aWNrX3ZhbHVlcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIERldGVjdHMgdGhlIHR5cGUgb2YgdGhlIHN0ciAoZGF0ZSBvciBudW1lcmljKSBhbmQgc2V0cyB0aGUgdmFyaW91c1xuICogZm9ybWF0dGluZyBhdHRyaWJ1dGVzIGluIHRoaXMuYXR0cnNfIGJhc2VkIG9uIHRoaXMgdHlwZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgQW4geCB2YWx1ZS5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmRldGVjdFR5cGVGcm9tU3RyaW5nXyA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgaXNEYXRlID0gZmFsc2U7XG4gIHZhciBkYXNoUG9zID0gc3RyLmluZGV4T2YoJy0nKTsgIC8vIGNvdWxkIGJlIDIwMDYtMDEtMDEgX29yXyAxLjBlLTJcbiAgaWYgKChkYXNoUG9zID4gMCAmJiAoc3RyW2Rhc2hQb3MtMV0gIT0gJ2UnICYmIHN0cltkYXNoUG9zLTFdICE9ICdFJykpIHx8XG4gICAgICBzdHIuaW5kZXhPZignLycpID49IDAgfHxcbiAgICAgIGlzTmFOKHBhcnNlRmxvYXQoc3RyKSkpIHtcbiAgICBpc0RhdGUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggPT0gOCAmJiBzdHIgPiAnMTk3MDAxMDEnICYmIHN0ciA8ICcyMDM3MTIzMScpIHtcbiAgICAvLyBUT0RPKGRhbnZrKTogcmVtb3ZlIHN1cHBvcnQgZm9yIHRoaXMgZm9ybWF0LlxuICAgIGlzRGF0ZSA9IHRydWU7XG4gIH1cblxuICB0aGlzLnNldFhBeGlzT3B0aW9uc18oaXNEYXRlKTtcbn07XG5cbkR5Z3JhcGgucHJvdG90eXBlLnNldFhBeGlzT3B0aW9uc18gPSBmdW5jdGlvbihpc0RhdGUpIHtcbiAgaWYgKGlzRGF0ZSkge1xuICAgIHRoaXMuYXR0cnNfLnhWYWx1ZVBhcnNlciA9IHV0aWxzLmRhdGVQYXJzZXI7XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LnZhbHVlRm9ybWF0dGVyID0gdXRpbHMuZGF0ZVZhbHVlRm9ybWF0dGVyO1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC50aWNrZXIgPSBEeWdyYXBoVGlja2Vycy5kYXRlVGlja2VyO1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC5heGlzTGFiZWxGb3JtYXR0ZXIgPSB1dGlscy5kYXRlQXhpc0xhYmVsRm9ybWF0dGVyO1xuICB9IGVsc2Uge1xuICAgIC8qKiBAcHJpdmF0ZSAoc2h1dCB1cCwganNkb2MhKSAqL1xuICAgIHRoaXMuYXR0cnNfLnhWYWx1ZVBhcnNlciA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHBhcnNlRmxvYXQoeCk7IH07XG4gICAgLy8gVE9ETyhkYW52ayk6IHVzZSBEeWdyYXBoLm51bWJlclZhbHVlRm9ybWF0dGVyIGhlcmU/XG4gICAgLyoqIEBwcml2YXRlIChzaHV0IHVwLCBqc2RvYyEpICovXG4gICAgdGhpcy5hdHRyc18uYXhlcy54LnZhbHVlRm9ybWF0dGVyID0gZnVuY3Rpb24oeCkgeyByZXR1cm4geDsgfTtcbiAgICB0aGlzLmF0dHJzXy5heGVzLngudGlja2VyID0gRHlncmFwaFRpY2tlcnMubnVtZXJpY1RpY2tzO1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC5heGlzTGFiZWxGb3JtYXR0ZXIgPSB0aGlzLmF0dHJzXy5heGVzLngudmFsdWVGb3JtYXR0ZXI7XG4gIH1cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFBhcnNlcyBhIHN0cmluZyBpbiBhIHNwZWNpYWwgY3N2IGZvcm1hdC4gIFdlIGV4cGVjdCBhIGNzdiBmaWxlIHdoZXJlIGVhY2hcbiAqIGxpbmUgaXMgYSBkYXRlIHBvaW50LCBhbmQgdGhlIGZpcnN0IGZpZWxkIGluIGVhY2ggbGluZSBpcyB0aGUgZGF0ZSBzdHJpbmcuXG4gKiBXZSBhbHNvIGV4cGVjdCB0aGF0IGFsbCByZW1haW5pbmcgZmllbGRzIHJlcHJlc2VudCBzZXJpZXMuXG4gKiBpZiB0aGUgZXJyb3JCYXJzIGF0dHJpYnV0ZSBpcyBzZXQsIHRoZW4gaW50ZXJwcmV0IHRoZSBmaWVsZHMgYXM6XG4gKiBkYXRlLCBzZXJpZXMxLCBzdGRkZXYxLCBzZXJpZXMyLCBzdGRkZXYyLCAuLi5cbiAqIEBwYXJhbSB7W09iamVjdF19IGRhdGEgU2VlIGFib3ZlLlxuICpcbiAqIEByZXR1cm4gW09iamVjdF0gQW4gYXJyYXkgd2l0aCBvbmUgZW50cnkgZm9yIGVhY2ggcm93LiBUaGVzZSBlbnRyaWVzXG4gKiBhcmUgYW4gYXJyYXkgb2YgY2VsbHMgaW4gdGhhdCByb3cuIFRoZSBmaXJzdCBlbnRyeSBpcyB0aGUgcGFyc2VkIHgtdmFsdWUgZm9yXG4gKiB0aGUgcm93LiBUaGUgc2Vjb25kLCB0aGlyZCwgZXRjLiBhcmUgdGhlIHktdmFsdWVzLiBUaGVzZSBjYW4gdGFrZSBvbiBvbmUgb2ZcbiAqIHRocmVlIGZvcm1zLCBkZXBlbmRpbmcgb24gdGhlIENTViBhbmQgY29uc3RydWN0b3IgcGFyYW1ldGVyczpcbiAqIDEuIG51bWVyaWMgdmFsdWVcbiAqIDIuIFsgdmFsdWUsIHN0ZGRldiBdXG4gKiAzLiBbIGxvdyB2YWx1ZSwgY2VudGVyIHZhbHVlLCBoaWdoIHZhbHVlIF1cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUucGFyc2VDU1ZfID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgcmV0ID0gW107XG4gIHZhciBsaW5lX2RlbGltaXRlciA9IHV0aWxzLmRldGVjdExpbmVEZWxpbWl0ZXIoZGF0YSk7XG4gIHZhciBsaW5lcyA9IGRhdGEuc3BsaXQobGluZV9kZWxpbWl0ZXIgfHwgXCJcXG5cIik7XG4gIHZhciB2YWxzLCBqO1xuXG4gIC8vIFVzZSB0aGUgZGVmYXVsdCBkZWxpbWl0ZXIgb3IgZmFsbCBiYWNrIHRvIGEgdGFiIGlmIHRoYXQgbWFrZXMgc2Vuc2UuXG4gIHZhciBkZWxpbSA9IHRoaXMuZ2V0U3RyaW5nT3B0aW9uKCdkZWxpbWl0ZXInKTtcbiAgaWYgKGxpbmVzWzBdLmluZGV4T2YoZGVsaW0pID09IC0xICYmIGxpbmVzWzBdLmluZGV4T2YoJ1xcdCcpID49IDApIHtcbiAgICBkZWxpbSA9ICdcXHQnO1xuICB9XG5cbiAgdmFyIHN0YXJ0ID0gMDtcbiAgaWYgKCEoJ2xhYmVscycgaW4gdGhpcy51c2VyX2F0dHJzXykpIHtcbiAgICAvLyBVc2VyIGhhc24ndCBleHBsaWNpdGx5IHNldCBsYWJlbHMsIHNvIHRoZXkncmUgKHByZXN1bWFibHkpIGluIHRoZSBDU1YuXG4gICAgc3RhcnQgPSAxO1xuICAgIHRoaXMuYXR0cnNfLmxhYmVscyA9IGxpbmVzWzBdLnNwbGl0KGRlbGltKTsgIC8vIE5PVEU6IF9ub3RfIHVzZXJfYXR0cnNfLlxuICAgIHRoaXMuYXR0cmlidXRlc18ucmVwYXJzZVNlcmllcygpO1xuICB9XG4gIHZhciBsaW5lX25vID0gMDtcblxuICB2YXIgeFBhcnNlcjtcbiAgdmFyIGRlZmF1bHRQYXJzZXJTZXQgPSBmYWxzZTsgIC8vIGF0dGVtcHQgdG8gYXV0by1kZXRlY3QgeCB2YWx1ZSB0eXBlXG4gIHZhciBleHBlY3RlZENvbHMgPSB0aGlzLmF0dHJfKFwibGFiZWxzXCIpLmxlbmd0aDtcbiAgdmFyIG91dE9mT3JkZXIgPSBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgIGxpbmVfbm8gPSBpO1xuICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMCkgY29udGludWU7ICAvLyBza2lwIGJsYW5rIGxpbmVzXG4gICAgaWYgKGxpbmVbMF0gPT0gJyMnKSBjb250aW51ZTsgICAgLy8gc2tpcCBjb21tZW50IGxpbmVzXG4gICAgdmFyIGluRmllbGRzID0gbGluZS5zcGxpdChkZWxpbSk7XG4gICAgaWYgKGluRmllbGRzLmxlbmd0aCA8IDIpIGNvbnRpbnVlO1xuXG4gICAgdmFyIGZpZWxkcyA9IFtdO1xuICAgIGlmICghZGVmYXVsdFBhcnNlclNldCkge1xuICAgICAgdGhpcy5kZXRlY3RUeXBlRnJvbVN0cmluZ18oaW5GaWVsZHNbMF0pO1xuICAgICAgeFBhcnNlciA9IHRoaXMuZ2V0RnVuY3Rpb25PcHRpb24oXCJ4VmFsdWVQYXJzZXJcIik7XG4gICAgICBkZWZhdWx0UGFyc2VyU2V0ID0gdHJ1ZTtcbiAgICB9XG4gICAgZmllbGRzWzBdID0geFBhcnNlcihpbkZpZWxkc1swXSwgdGhpcyk7XG5cbiAgICAvLyBJZiBmcmFjdGlvbnMgYXJlIGV4cGVjdGVkLCBwYXJzZSB0aGUgbnVtYmVycyBhcyBcIkEvQlwiXG4gICAgaWYgKHRoaXMuZnJhY3Rpb25zXykge1xuICAgICAgZm9yIChqID0gMTsgaiA8IGluRmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIC8vIFRPRE8oZGFudmspOiBmaWd1cmUgb3V0IGFuIGFwcHJvcHJpYXRlIHdheSB0byBmbGFnIHBhcnNlIGVycm9ycy5cbiAgICAgICAgdmFscyA9IGluRmllbGRzW2pdLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgaWYgKHZhbHMubGVuZ3RoICE9IDIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFeHBlY3RlZCBmcmFjdGlvbmFsIFwibnVtL2RlblwiIHZhbHVlcyBpbiBDU1YgZGF0YSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYnV0IGZvdW5kIGEgdmFsdWUgJ1wiICsgaW5GaWVsZHNbal0gKyBcIicgb24gbGluZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAoMSArIGkpICsgXCIgKCdcIiArIGxpbmUgKyBcIicpIHdoaWNoIGlzIG5vdCBvZiB0aGlzIGZvcm0uXCIpO1xuICAgICAgICAgIGZpZWxkc1tqXSA9IFswLCAwXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWVsZHNbal0gPSBbdXRpbHMucGFyc2VGbG9hdF8odmFsc1swXSwgaSwgbGluZSksXG4gICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLnBhcnNlRmxvYXRfKHZhbHNbMV0sIGksIGxpbmUpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5nZXRCb29sZWFuT3B0aW9uKFwiZXJyb3JCYXJzXCIpKSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgZXJyb3IgYmFycywgdmFsdWVzIGFyZSAodmFsdWUsIHN0ZGRldikgcGFpcnNcbiAgICAgIGlmIChpbkZpZWxkcy5sZW5ndGggJSAyICE9IDEpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXhwZWN0ZWQgYWx0ZXJuYXRpbmcgKHZhbHVlLCBzdGRldi4pIHBhaXJzIGluIENTViBkYXRhICcgK1xuICAgICAgICAgICAgICAgICAgICAgICdidXQgbGluZSAnICsgKDEgKyBpKSArICcgaGFzIGFuIG9kZCBudW1iZXIgb2YgdmFsdWVzICgnICtcbiAgICAgICAgICAgICAgICAgICAgICAoaW5GaWVsZHMubGVuZ3RoIC0gMSkgKyBcIik6ICdcIiArIGxpbmUgKyBcIidcIik7XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAxOyBqIDwgaW5GaWVsZHMubGVuZ3RoOyBqICs9IDIpIHtcbiAgICAgICAgZmllbGRzWyhqICsgMSkgLyAyXSA9IFt1dGlscy5wYXJzZUZsb2F0XyhpbkZpZWxkc1tqXSwgaSwgbGluZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMucGFyc2VGbG9hdF8oaW5GaWVsZHNbaiArIDFdLCBpLCBsaW5lKV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmdldEJvb2xlYW5PcHRpb24oXCJjdXN0b21CYXJzXCIpKSB7XG4gICAgICAvLyBCYXJzIGFyZSBhIGxvdztjZW50ZXI7aGlnaCB0dXBsZVxuICAgICAgZm9yIChqID0gMTsgaiA8IGluRmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciB2YWwgPSBpbkZpZWxkc1tqXTtcbiAgICAgICAgaWYgKC9eICokLy50ZXN0KHZhbCkpIHtcbiAgICAgICAgICBmaWVsZHNbal0gPSBbbnVsbCwgbnVsbCwgbnVsbF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFscyA9IHZhbC5zcGxpdChcIjtcIik7XG4gICAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICAgIGZpZWxkc1tqXSA9IFsgdXRpbHMucGFyc2VGbG9hdF8odmFsc1swXSwgaSwgbGluZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLnBhcnNlRmxvYXRfKHZhbHNbMV0sIGksIGxpbmUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlscy5wYXJzZUZsb2F0Xyh2YWxzWzJdLCBpLCBsaW5lKSBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1doZW4gdXNpbmcgY3VzdG9tQmFycywgdmFsdWVzIG11c3QgYmUgZWl0aGVyIGJsYW5rICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdvciBcImxvdztjZW50ZXI7aGlnaFwiIHR1cGxlcyAoZ290IFwiJyArIHZhbCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ1wiIG9uIGxpbmUgJyArICgxK2kpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVmFsdWVzIGFyZSBqdXN0IG51bWJlcnNcbiAgICAgIGZvciAoaiA9IDE7IGogPCBpbkZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICBmaWVsZHNbal0gPSB1dGlscy5wYXJzZUZsb2F0XyhpbkZpZWxkc1tqXSwgaSwgbGluZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXQubGVuZ3RoID4gMCAmJiBmaWVsZHNbMF0gPCByZXRbcmV0Lmxlbmd0aCAtIDFdWzBdKSB7XG4gICAgICBvdXRPZk9yZGVyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZmllbGRzLmxlbmd0aCAhPSBleHBlY3RlZENvbHMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJOdW1iZXIgb2YgY29sdW1ucyBpbiBsaW5lIFwiICsgaSArIFwiIChcIiArIGZpZWxkcy5sZW5ndGggK1xuICAgICAgICAgICAgICAgICAgICBcIikgZG9lcyBub3QgYWdyZWUgd2l0aCBudW1iZXIgb2YgbGFiZWxzIChcIiArIGV4cGVjdGVkQ29scyArXG4gICAgICAgICAgICAgICAgICAgIFwiKSBcIiArIGxpbmUpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB1c2VyIHNwZWNpZmllZCB0aGUgJ2xhYmVscycgb3B0aW9uIGFuZCBub25lIG9mIHRoZSBjZWxscyBvZiB0aGVcbiAgICAvLyBmaXJzdCByb3cgcGFyc2VkIGNvcnJlY3RseSwgdGhlbiB0aGV5IHByb2JhYmx5IGRvdWJsZS1zcGVjaWZpZWQgdGhlXG4gICAgLy8gbGFiZWxzLiBXZSBnbyB3aXRoIHRoZSB2YWx1ZXMgc2V0IGluIHRoZSBvcHRpb24sIGRpc2NhcmQgdGhpcyByb3cgYW5kXG4gICAgLy8gbG9nIGEgd2FybmluZyB0byB0aGUgSlMgY29uc29sZS5cbiAgICBpZiAoaSA9PT0gMCAmJiB0aGlzLmF0dHJfKCdsYWJlbHMnKSkge1xuICAgICAgdmFyIGFsbF9udWxsID0gdHJ1ZTtcbiAgICAgIGZvciAoaiA9IDA7IGFsbF9udWxsICYmIGogPCBmaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKGZpZWxkc1tqXSkgYWxsX251bGwgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChhbGxfbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgZHlncmFwaHMgJ2xhYmVscycgb3B0aW9uIGlzIHNldCwgYnV0IHRoZSBmaXJzdCByb3cgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgXCJvZiBDU1YgZGF0YSAoJ1wiICsgbGluZSArIFwiJykgYXBwZWFycyB0byBhbHNvIGNvbnRhaW4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgXCJsYWJlbHMuIFdpbGwgZHJvcCB0aGUgQ1NWIGxhYmVscyBhbmQgdXNlIHRoZSBvcHRpb24gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgXCJsYWJlbHMuXCIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0LnB1c2goZmllbGRzKTtcbiAgfVxuXG4gIGlmIChvdXRPZk9yZGVyKSB7XG4gICAgY29uc29sZS53YXJuKFwiQ1NWIGlzIG91dCBvZiBvcmRlcjsgb3JkZXIgaXQgY29ycmVjdGx5IHRvIHNwZWVkIGxvYWRpbmcuXCIpO1xuICAgIHJldC5zb3J0KGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYVswXSAtIGJbMF07IH0pO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8vIEluIG5hdGl2ZSBmb3JtYXQsIGFsbCB2YWx1ZXMgbXVzdCBiZSBkYXRlcyBvciBudW1iZXJzLlxuLy8gVGhpcyBjaGVjayBpc24ndCBwZXJmZWN0IGJ1dCB3aWxsIGNhdGNoIG1vc3QgbWlzdGFrZW4gdXNlcyBvZiBzdHJpbmdzLlxuZnVuY3Rpb24gdmFsaWRhdGVOYXRpdmVGb3JtYXQoZGF0YSkge1xuICBjb25zdCBmaXJzdFJvdyA9IGRhdGFbMF07XG4gIGNvbnN0IGZpcnN0WCA9IGZpcnN0Um93WzBdO1xuICBpZiAodHlwZW9mIGZpcnN0WCAhPT0gJ251bWJlcicgJiYgIXV0aWxzLmlzRGF0ZUxpa2UoZmlyc3RYKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgbnVtYmVyIG9yIGRhdGUgYnV0IGdvdCAke3R5cGVvZiBmaXJzdFh9OiAke2ZpcnN0WH0uYCk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBmaXJzdFJvdy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbCA9IGZpcnN0Um93W2ldO1xuICAgIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykgY29udGludWU7XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlMaWtlKHZhbCkpIGNvbnRpbnVlOyAgLy8gZS5nLiBlcnJvciBiYXJzIG9yIGN1c3RvbSBiYXJzLlxuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgbnVtYmVyIG9yIGFycmF5IGJ1dCBnb3QgJHt0eXBlb2YgdmFsfTogJHt2YWx9LmApO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHVzZXIgaGFzIHByb3ZpZGVkIHRoZWlyIGRhdGEgYXMgYSBwcmUtcGFja2FnZWQgSlMgYXJyYXkuIElmIHRoZSB4IHZhbHVlc1xuICogYXJlIG51bWVyaWMsIHRoaXMgaXMgdGhlIHNhbWUgYXMgZHlncmFwaHMnIGludGVybmFsIGZvcm1hdC4gSWYgdGhlIHggdmFsdWVzXG4gKiBhcmUgZGF0ZXMsIHdlIG5lZWQgdG8gY29udmVydCB0aGVtIGZyb20gRGF0ZSBvYmplY3RzIHRvIG1zIHNpbmNlIGVwb2NoLlxuICogQHBhcmFtIHshQXJyYXl9IGRhdGFcbiAqIEByZXR1cm4ge09iamVjdH0gZGF0YSB3aXRoIG51bWVyaWMgeCB2YWx1ZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5wYXJzZUFycmF5XyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgLy8gUGVlayBhdCB0aGUgZmlyc3QgeCB2YWx1ZSB0byBzZWUgaWYgaXQncyBudW1lcmljLlxuICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICBjb25zb2xlLmVycm9yKFwiQ2FuJ3QgcGxvdCBlbXB0eSBkYXRhIHNldFwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoZGF0YVswXS5sZW5ndGggPT09IDApIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRGF0YSBzZXQgY2Fubm90IGNvbnRhaW4gYW4gZW1wdHkgcm93XCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFsaWRhdGVOYXRpdmVGb3JtYXQoZGF0YSk7XG5cbiAgdmFyIGk7XG4gIGlmICh0aGlzLmF0dHJfKFwibGFiZWxzXCIpID09PSBudWxsKSB7XG4gICAgY29uc29sZS53YXJuKFwiVXNpbmcgZGVmYXVsdCBsYWJlbHMuIFNldCBsYWJlbHMgZXhwbGljaXRseSB2aWEgJ2xhYmVscycgXCIgK1xuICAgICAgICAgICAgICAgICBcImluIHRoZSBvcHRpb25zIHBhcmFtZXRlclwiKTtcbiAgICB0aGlzLmF0dHJzXy5sYWJlbHMgPSBbIFwiWFwiIF07XG4gICAgZm9yIChpID0gMTsgaSA8IGRhdGFbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuYXR0cnNfLmxhYmVscy5wdXNoKFwiWVwiICsgaSk7IC8vIE5vdCB1c2VyX2F0dHJzXy5cbiAgICB9XG4gICAgdGhpcy5hdHRyaWJ1dGVzXy5yZXBhcnNlU2VyaWVzKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG51bV9sYWJlbHMgPSB0aGlzLmF0dHJfKFwibGFiZWxzXCIpO1xuICAgIGlmIChudW1fbGFiZWxzLmxlbmd0aCAhPSBkYXRhWzBdLmxlbmd0aCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIk1pc21hdGNoIGJldHdlZW4gbnVtYmVyIG9mIGxhYmVscyAoXCIgKyBudW1fbGFiZWxzICsgXCIpXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIiBhbmQgbnVtYmVyIG9mIGNvbHVtbnMgaW4gYXJyYXkgKFwiICsgZGF0YVswXS5sZW5ndGggKyBcIilcIik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBpZiAodXRpbHMuaXNEYXRlTGlrZShkYXRhWzBdWzBdKSkge1xuICAgIC8vIFNvbWUgaW50ZWxsaWdlbnQgZGVmYXVsdHMgZm9yIGEgZGF0ZSB4LWF4aXMuXG4gICAgdGhpcy5hdHRyc18uYXhlcy54LnZhbHVlRm9ybWF0dGVyID0gdXRpbHMuZGF0ZVZhbHVlRm9ybWF0dGVyO1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC50aWNrZXIgPSBEeWdyYXBoVGlja2Vycy5kYXRlVGlja2VyO1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC5heGlzTGFiZWxGb3JtYXR0ZXIgPSB1dGlscy5kYXRlQXhpc0xhYmVsRm9ybWF0dGVyO1xuXG4gICAgLy8gQXNzdW1lIHRoZXkncmUgYWxsIGRhdGVzLlxuICAgIHZhciBwYXJzZWREYXRhID0gdXRpbHMuY2xvbmUoZGF0YSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwYXJzZWREYXRhW2ldLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiUm93IFwiICsgKDEgKyBpKSArIFwiIG9mIGRhdGEgaXMgZW1wdHlcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnNlZERhdGFbaV1bMF0gPT09IG51bGwgfHxcbiAgICAgICAgICB0eXBlb2YocGFyc2VkRGF0YVtpXVswXS5nZXRUaW1lKSAhPSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgaXNOYU4ocGFyc2VkRGF0YVtpXVswXS5nZXRUaW1lKCkpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJ4IHZhbHVlIGluIHJvdyBcIiArICgxICsgaSkgKyBcIiBpcyBub3QgYSBEYXRlXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHBhcnNlZERhdGFbaV1bMF0gPSBwYXJzZWREYXRhW2ldWzBdLmdldFRpbWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZERhdGE7XG4gIH0gZWxzZSB7XG4gICAgLy8gU29tZSBpbnRlbGxpZ2VudCBkZWZhdWx0cyBmb3IgYSBudW1lcmljIHgtYXhpcy5cbiAgICAvKiogQHByaXZhdGUgKHNodXQgdXAsIGpzZG9jISkgKi9cbiAgICB0aGlzLmF0dHJzXy5heGVzLngudmFsdWVGb3JtYXR0ZXIgPSBmdW5jdGlvbih4KSB7IHJldHVybiB4OyB9O1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC50aWNrZXIgPSBEeWdyYXBoVGlja2Vycy5udW1lcmljVGlja3M7XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LmF4aXNMYWJlbEZvcm1hdHRlciA9IHV0aWxzLm51bWJlckF4aXNMYWJlbEZvcm1hdHRlcjtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBEYXRhVGFibGUgb2JqZWN0IGZyb20gZ3Zpei5cbiAqIFRoZSBkYXRhIGlzIGV4cGVjdGVkIHRvIGhhdmUgYSBmaXJzdCBjb2x1bW4gdGhhdCBpcyBlaXRoZXIgYSBkYXRlIG9yIGFcbiAqIG51bWJlci4gQWxsIHN1YnNlcXVlbnQgY29sdW1ucyBtdXN0IGJlIG51bWJlcnMuIElmIHRoZXJlIGlzIGEgY2xlYXIgbWlzbWF0Y2hcbiAqIGJldHdlZW4gdGhpcy54VmFsdWVQYXJzZXJfIGFuZCB0aGUgdHlwZSBvZiB0aGUgZmlyc3QgY29sdW1uLCBpdCB3aWxsIGJlXG4gKiBmaXhlZC4gRmlsbHMgb3V0IHJhd0RhdGFfLlxuICogQHBhcmFtIHshZ29vZ2xlLnZpc3VhbGl6YXRpb24uRGF0YVRhYmxlfSBkYXRhIFNlZSBhYm92ZS5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnBhcnNlRGF0YVRhYmxlXyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIHNob3J0VGV4dEZvckFubm90YXRpb25OdW0gPSBmdW5jdGlvbihudW0pIHtcbiAgICAvLyBjb252ZXJ0cyBbMC05XSsgW0EtWl1bYS16XSpcbiAgICAvLyBleGFtcGxlOiAwPUEsIDE9QiwgMjU9WiwgMjY9QWEsIDI3PUFiXG4gICAgLy8gYW5kIGNvbnRpbnVlcyBsaWtlLi4gQmEgQmIgLi4gWmEgLi4gWnouLkFhYS4uLlp6eiBBYWFhIFp6enpcbiAgICB2YXIgc2hvcnRUZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZSg2NSAvKiBBICovICsgbnVtICUgMjYpO1xuICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gMjYpO1xuICAgIHdoaWxlICggbnVtID4gMCApIHtcbiAgICAgIHNob3J0VGV4dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoNjUgLyogQSAqLyArIChudW0gLSAxKSAlIDI2ICkgKyBzaG9ydFRleHQudG9Mb3dlckNhc2UoKTtcbiAgICAgIG51bSA9IE1hdGguZmxvb3IoKG51bSAtIDEpIC8gMjYpO1xuICAgIH1cbiAgICByZXR1cm4gc2hvcnRUZXh0O1xuICB9O1xuXG4gIHZhciBjb2xzID0gZGF0YS5nZXROdW1iZXJPZkNvbHVtbnMoKTtcbiAgdmFyIHJvd3MgPSBkYXRhLmdldE51bWJlck9mUm93cygpO1xuXG4gIHZhciBpbmRlcFR5cGUgPSBkYXRhLmdldENvbHVtblR5cGUoMCk7XG4gIGlmIChpbmRlcFR5cGUgPT0gJ2RhdGUnIHx8IGluZGVwVHlwZSA9PSAnZGF0ZXRpbWUnKSB7XG4gICAgdGhpcy5hdHRyc18ueFZhbHVlUGFyc2VyID0gdXRpbHMuZGF0ZVBhcnNlcjtcbiAgICB0aGlzLmF0dHJzXy5heGVzLngudmFsdWVGb3JtYXR0ZXIgPSB1dGlscy5kYXRlVmFsdWVGb3JtYXR0ZXI7XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LnRpY2tlciA9IER5Z3JhcGhUaWNrZXJzLmRhdGVUaWNrZXI7XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LmF4aXNMYWJlbEZvcm1hdHRlciA9IHV0aWxzLmRhdGVBeGlzTGFiZWxGb3JtYXR0ZXI7XG4gIH0gZWxzZSBpZiAoaW5kZXBUeXBlID09ICdudW1iZXInKSB7XG4gICAgdGhpcy5hdHRyc18ueFZhbHVlUGFyc2VyID0gZnVuY3Rpb24oeCkgeyByZXR1cm4gcGFyc2VGbG9hdCh4KTsgfTtcbiAgICB0aGlzLmF0dHJzXy5heGVzLngudmFsdWVGb3JtYXR0ZXIgPSBmdW5jdGlvbih4KSB7IHJldHVybiB4OyB9O1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC50aWNrZXIgPSBEeWdyYXBoVGlja2Vycy5udW1lcmljVGlja3M7XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LmF4aXNMYWJlbEZvcm1hdHRlciA9IHRoaXMuYXR0cnNfLmF4ZXMueC52YWx1ZUZvcm1hdHRlcjtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJvbmx5ICdkYXRlJywgJ2RhdGV0aW1lJyBhbmQgJ251bWJlcicgdHlwZXMgYXJlIHN1cHBvcnRlZCBcIiArXG4gICAgICAgICAgXCJmb3IgY29sdW1uIDEgb2YgRGF0YVRhYmxlIGlucHV0IChHb3QgJ1wiICsgaW5kZXBUeXBlICsgXCInKVwiKTtcbiAgfVxuXG4gIC8vIEFycmF5IG9mIHRoZSBjb2x1bW4gaW5kaWNlcyB3aGljaCBjb250YWluIGRhdGEgKGFuZCBub3QgYW5ub3RhdGlvbnMpLlxuICB2YXIgY29sSWR4ID0gW107XG4gIHZhciBhbm5vdGF0aW9uQ29scyA9IHt9OyAgLy8gZGF0YSBpbmRleCAtPiBbYW5ub3RhdGlvbiBjb2xzXVxuICB2YXIgaGFzQW5ub3RhdGlvbnMgPSBmYWxzZTtcbiAgdmFyIGksIGo7XG4gIGZvciAoaSA9IDE7IGkgPCBjb2xzOyBpKyspIHtcbiAgICB2YXIgdHlwZSA9IGRhdGEuZ2V0Q29sdW1uVHlwZShpKTtcbiAgICBpZiAodHlwZSA9PSAnbnVtYmVyJykge1xuICAgICAgY29sSWR4LnB1c2goaSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09ICdzdHJpbmcnICYmIHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbignZGlzcGxheUFubm90YXRpb25zJykpIHtcbiAgICAgIC8vIFRoaXMgaXMgT0sgLS0gaXQncyBhbiBhbm5vdGF0aW9uIGNvbHVtbi5cbiAgICAgIHZhciBkYXRhSWR4ID0gY29sSWR4W2NvbElkeC5sZW5ndGggLSAxXTtcbiAgICAgIGlmICghYW5ub3RhdGlvbkNvbHMuaGFzT3duUHJvcGVydHkoZGF0YUlkeCkpIHtcbiAgICAgICAgYW5ub3RhdGlvbkNvbHNbZGF0YUlkeF0gPSBbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbm5vdGF0aW9uQ29sc1tkYXRhSWR4XS5wdXNoKGkpO1xuICAgICAgfVxuICAgICAgaGFzQW5ub3RhdGlvbnMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJPbmx5ICdudW1iZXInIGlzIHN1cHBvcnRlZCBhcyBhIGRlcGVuZGVudCB0eXBlIHdpdGggR3Zpei5cIiArXG4gICAgICAgICAgXCIgJ3N0cmluZycgaXMgb25seSBzdXBwb3J0ZWQgaWYgZGlzcGxheUFubm90YXRpb25zIGlzIHRydWVcIik7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVhZCBjb2x1bW4gbGFiZWxzXG4gIC8vIFRPRE8oZGFudmspOiBhZGQgc3VwcG9ydCBiYWNrIGZvciBlcnJvckJhcnNcbiAgdmFyIGxhYmVscyA9IFtkYXRhLmdldENvbHVtbkxhYmVsKDApXTtcbiAgZm9yIChpID0gMDsgaSA8IGNvbElkeC5sZW5ndGg7IGkrKykge1xuICAgIGxhYmVscy5wdXNoKGRhdGEuZ2V0Q29sdW1uTGFiZWwoY29sSWR4W2ldKSk7XG4gICAgaWYgKHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbihcImVycm9yQmFyc1wiKSkgaSArPSAxO1xuICB9XG4gIHRoaXMuYXR0cnNfLmxhYmVscyA9IGxhYmVscztcbiAgY29scyA9IGxhYmVscy5sZW5ndGg7XG5cbiAgdmFyIHJldCA9IFtdO1xuICB2YXIgb3V0T2ZPcmRlciA9IGZhbHNlO1xuICB2YXIgYW5ub3RhdGlvbnMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgIHZhciByb3cgPSBbXTtcbiAgICBpZiAodHlwZW9mKGRhdGEuZ2V0VmFsdWUoaSwgMCkpID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICBkYXRhLmdldFZhbHVlKGksIDApID09PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJJZ25vcmluZyByb3cgXCIgKyBpICtcbiAgICAgICAgICAgICAgICAgICBcIiBvZiBEYXRhVGFibGUgYmVjYXVzZSBvZiB1bmRlZmluZWQgb3IgbnVsbCBmaXJzdCBjb2x1bW4uXCIpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGluZGVwVHlwZSA9PSAnZGF0ZScgfHwgaW5kZXBUeXBlID09ICdkYXRldGltZScpIHtcbiAgICAgIHJvdy5wdXNoKGRhdGEuZ2V0VmFsdWUoaSwgMCkuZ2V0VGltZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm93LnB1c2goZGF0YS5nZXRWYWx1ZShpLCAwKSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5nZXRCb29sZWFuT3B0aW9uKFwiZXJyb3JCYXJzXCIpKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgY29sSWR4Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBjb2wgPSBjb2xJZHhbal07XG4gICAgICAgIHJvdy5wdXNoKGRhdGEuZ2V0VmFsdWUoaSwgY29sKSk7XG4gICAgICAgIGlmIChoYXNBbm5vdGF0aW9ucyAmJlxuICAgICAgICAgICAgYW5ub3RhdGlvbkNvbHMuaGFzT3duUHJvcGVydHkoY29sKSAmJlxuICAgICAgICAgICAgZGF0YS5nZXRWYWx1ZShpLCBhbm5vdGF0aW9uQ29sc1tjb2xdWzBdKSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBhbm4gPSB7fTtcbiAgICAgICAgICBhbm4uc2VyaWVzID0gZGF0YS5nZXRDb2x1bW5MYWJlbChjb2wpO1xuICAgICAgICAgIGFubi54dmFsID0gcm93WzBdO1xuICAgICAgICAgIGFubi5zaG9ydFRleHQgPSBzaG9ydFRleHRGb3JBbm5vdGF0aW9uTnVtKGFubm90YXRpb25zLmxlbmd0aCk7XG4gICAgICAgICAgYW5uLnRleHQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGFubm90YXRpb25Db2xzW2NvbF0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChrKSBhbm4udGV4dCArPSBcIlxcblwiO1xuICAgICAgICAgICAgYW5uLnRleHQgKz0gZGF0YS5nZXRWYWx1ZShpLCBhbm5vdGF0aW9uQ29sc1tjb2xdW2tdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYW5ub3RhdGlvbnMucHVzaChhbm4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFN0cmlwIG91dCBpbmZpbml0aWVzLCB3aGljaCBnaXZlIGR5Z3JhcGhzIHByb2JsZW1zIGxhdGVyIG9uLlxuICAgICAgZm9yIChqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIWlzRmluaXRlKHJvd1tqXSkpIHJvd1tqXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBjb2xzIC0gMTsgaisrKSB7XG4gICAgICAgIHJvdy5wdXNoKFsgZGF0YS5nZXRWYWx1ZShpLCAxICsgMiAqIGopLCBkYXRhLmdldFZhbHVlKGksIDIgKyAyICogaikgXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXQubGVuZ3RoID4gMCAmJiByb3dbMF0gPCByZXRbcmV0Lmxlbmd0aCAtIDFdWzBdKSB7XG4gICAgICBvdXRPZk9yZGVyID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0LnB1c2gocm93KTtcbiAgfVxuXG4gIGlmIChvdXRPZk9yZGVyKSB7XG4gICAgY29uc29sZS53YXJuKFwiRGF0YVRhYmxlIGlzIG91dCBvZiBvcmRlcjsgb3JkZXIgaXQgY29ycmVjdGx5IHRvIHNwZWVkIGxvYWRpbmcuXCIpO1xuICAgIHJldC5zb3J0KGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYVswXSAtIGJbMF07IH0pO1xuICB9XG4gIHRoaXMucmF3RGF0YV8gPSByZXQ7XG5cbiAgaWYgKGFubm90YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLnNldEFubm90YXRpb25zKGFubm90YXRpb25zLCB0cnVlKTtcbiAgfVxuICB0aGlzLmF0dHJpYnV0ZXNfLnJlcGFyc2VTZXJpZXMoKTtcbn07XG5cbi8qKlxuICogU2lnbmFscyB0byBwbHVnaW5zIHRoYXQgdGhlIGNoYXJ0IGRhdGEgaGFzIHVwZGF0ZWQuXG4gKiBUaGlzIGhhcHBlbnMgYWZ0ZXIgdGhlIGRhdGEgaGFzIHVwZGF0ZWQgYnV0IGJlZm9yZSB0aGUgY2hhcnQgaGFzIHJlZHJhd24uXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5jYXNjYWRlRGF0YURpZFVwZGF0ZUV2ZW50XyA9IGZ1bmN0aW9uKCkge1xuICAvLyBUT0RPKGRhbnZrKTogdGhlcmUgYXJlIHNvbWUgaXNzdWVzIGNoZWNraW5nIHhBeGlzUmFuZ2UoKSBhbmQgdXNpbmdcbiAgLy8gdG9Eb21Db29yZHMgZnJvbSBoYW5kbGVycyBvZiB0aGlzIGV2ZW50LiBUaGUgdmlzaWJsZSByYW5nZSBzaG91bGQgYmUgc2V0XG4gIC8vIHdoZW4gdGhlIGNoYXJ0IGlzIGRyYXduLCBub3QgZGVyaXZlZCBmcm9tIHRoZSBkYXRhLlxuICB0aGlzLmNhc2NhZGVFdmVudHNfKCdkYXRhRGlkVXBkYXRlJywge30pO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIENTViBkYXRhLiBJZiBpdCdzIGluIGEgZnVuY3Rpb24sIGNhbGwgdGhhdCBmdW5jdGlvbi4gSWYgaXQncyBpbiBhXG4gKiBmaWxlLCBkbyBhbiBYTUxIdHRwUmVxdWVzdCB0byBnZXQgaXQuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5zdGFydF8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLmZpbGVfO1xuXG4gIC8vIEZ1bmN0aW9ucyBjYW4gcmV0dXJuIHJlZmVyZW5jZXMgb2YgYWxsIG90aGVyIHR5cGVzLlxuICBpZiAodHlwZW9mIGRhdGEgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGRhdGEgPSBkYXRhKCk7XG4gIH1cblxuICBpZiAodXRpbHMuaXNBcnJheUxpa2UoZGF0YSkpIHtcbiAgICB0aGlzLnJhd0RhdGFfID0gdGhpcy5wYXJzZUFycmF5XyhkYXRhKTtcbiAgICB0aGlzLmNhc2NhZGVEYXRhRGlkVXBkYXRlRXZlbnRfKCk7XG4gICAgdGhpcy5wcmVkcmF3XygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgdHlwZW9mIGRhdGEuZ2V0Q29sdW1uUmFuZ2UgPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIG11c3QgYmUgYSBEYXRhVGFibGUgZnJvbSBndml6LlxuICAgIHRoaXMucGFyc2VEYXRhVGFibGVfKGRhdGEpO1xuICAgIHRoaXMuY2FzY2FkZURhdGFEaWRVcGRhdGVFdmVudF8oKTtcbiAgICB0aGlzLnByZWRyYXdfKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcbiAgICAvLyBIZXVyaXN0aWM6IGEgbmV3bGluZSBtZWFucyBpdCdzIENTViBkYXRhLiBPdGhlcndpc2UgaXQncyBhbiBVUkwuXG4gICAgdmFyIGxpbmVfZGVsaW1pdGVyID0gdXRpbHMuZGV0ZWN0TGluZURlbGltaXRlcihkYXRhKTtcbiAgICBpZiAobGluZV9kZWxpbWl0ZXIpIHtcbiAgICAgIHRoaXMubG9hZGVkRXZlbnRfKGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSRU1PVkVfRk9SX0lFXG4gICAgICB2YXIgcmVxO1xuICAgICAgaWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICAvLyBGaXJlZm94LCBPcGVyYSwgSUU3LCBhbmQgb3RoZXIgYnJvd3NlcnMgd2lsbCB1c2UgdGhlIG5hdGl2ZSBvYmplY3RcbiAgICAgICAgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJRSA1IGFuZCA2IHdpbGwgdXNlIHRoZSBBY3RpdmVYIGNvbnRyb2xcbiAgICAgICAgcmVxID0gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhbGxlciA9IHRoaXM7XG4gICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgIGlmIChyZXEuc3RhdHVzID09PSAyMDAgfHwgIC8vIE5vcm1hbCBodHRwXG4gICAgICAgICAgICAgIHJlcS5zdGF0dXMgPT09IDApIHsgICAgLy8gQ2hyb21lIHcvIC0tYWxsb3ctZmlsZS1hY2Nlc3MtZnJvbS1maWxlc1xuICAgICAgICAgICAgY2FsbGVyLmxvYWRlZEV2ZW50XyhyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlcS5vcGVuKFwiR0VUXCIsIGRhdGEsIHRydWUpO1xuICAgICAgcmVxLnNlbmQobnVsbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbmtub3duIGRhdGEgZm9ybWF0OiBcIiArICh0eXBlb2YgZGF0YSkpO1xuICB9XG59O1xuXG4vKipcbiAqIENoYW5nZXMgdmFyaW91cyBwcm9wZXJ0aWVzIG9mIHRoZSBncmFwaC4gVGhlc2UgY2FuIGluY2x1ZGU6XG4gKiA8dWw+XG4gKiA8bGk+ZmlsZTogY2hhbmdlcyB0aGUgc291cmNlIGRhdGEgZm9yIHRoZSBncmFwaDwvbGk+XG4gKiA8bGk+ZXJyb3JCYXJzOiBjaGFuZ2VzIHdoZXRoZXIgdGhlIGRhdGEgY29udGFpbnMgc3RkZGV2PC9saT5cbiAqIDwvdWw+XG4gKlxuICogVGhlcmUncyBhIGh1Z2UgdmFyaWV0eSBvZiBvcHRpb25zIHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGlzIG1ldGhvZC4gRm9yIGFcbiAqIGZ1bGwgbGlzdCwgc2VlIGh0dHA6Ly9keWdyYXBocy5jb20vb3B0aW9ucy5odG1sLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dF9hdHRycyBUaGUgbmV3IHByb3BlcnRpZXMgYW5kIHZhbHVlc1xuICogQHBhcmFtIHtib29sZWFufSBibG9ja19yZWRyYXcgVXN1YWxseSB0aGUgY2hhcnQgaXMgcmVkcmF3biBhZnRlciBldmVyeVxuICogICAgIGNhbGwgdG8gdXBkYXRlT3B0aW9ucygpLiBJZiB5b3Uga25vdyBiZXR0ZXIsIHlvdSBjYW4gcGFzcyB0cnVlIHRvXG4gKiAgICAgZXhwbGljaXRseSBibG9jayB0aGUgcmVkcmF3LiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yIGNoYWluaW5nXG4gKiAgICAgdXBkYXRlT3B0aW9ucygpIGNhbGxzLCBhdm9pZGluZyB0aGUgb2NjYXNpb25hbCBpbmZpbml0ZSBsb29wIGFuZFxuICogICAgIHByZXZlbnRpbmcgcmVkcmF3cyB3aGVuIGl0J3Mgbm90IG5lY2Vzc2FyeSAoZS5nLiB3aGVuIHVwZGF0aW5nIGFcbiAqICAgICBjYWxsYmFjaykuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnVwZGF0ZU9wdGlvbnMgPSBmdW5jdGlvbihpbnB1dF9hdHRycywgYmxvY2tfcmVkcmF3KSB7XG4gIGlmICh0eXBlb2YoYmxvY2tfcmVkcmF3KSA9PSAndW5kZWZpbmVkJykgYmxvY2tfcmVkcmF3ID0gZmFsc2U7XG5cbiAgLy8gY29weVVzZXJBdHRyc18gZHJvcHMgdGhlIFwiZmlsZVwiIHBhcmFtZXRlciBhcyBhIGNvbnZlbmllbmNlIHRvIHVzLlxuICB2YXIgZmlsZSA9IGlucHV0X2F0dHJzLmZpbGU7XG4gIHZhciBhdHRycyA9IER5Z3JhcGguY29weVVzZXJBdHRyc18oaW5wdXRfYXR0cnMpO1xuXG4gIC8vIFRPRE8oZGFudmspOiB0aGlzIGlzIGEgbWVzcy4gTW92ZSB0aGVzZSBvcHRpb25zIGludG8gYXR0cl8uXG4gIGlmICgncm9sbFBlcmlvZCcgaW4gYXR0cnMpIHtcbiAgICB0aGlzLnJvbGxQZXJpb2RfID0gYXR0cnMucm9sbFBlcmlvZDtcbiAgfVxuICBpZiAoJ2RhdGVXaW5kb3cnIGluIGF0dHJzKSB7XG4gICAgdGhpcy5kYXRlV2luZG93XyA9IGF0dHJzLmRhdGVXaW5kb3c7XG4gIH1cblxuICAvLyBUT0RPKGRhbnZrKTogdmFsaWRhdGUgcGVyLXNlcmllcyBvcHRpb25zLlxuICAvLyBTdXBwb3J0ZWQ6XG4gIC8vIHN0cm9rZVdpZHRoXG4gIC8vIHBvaW50U2l6ZVxuICAvLyBkcmF3UG9pbnRzXG4gIC8vIGhpZ2hsaWdodENpcmNsZVNpemVcblxuICAvLyBDaGVjayBpZiB0aGlzIHNldCBvcHRpb25zIHdpbGwgcmVxdWlyZSBuZXcgcG9pbnRzLlxuICB2YXIgcmVxdWlyZXNOZXdQb2ludHMgPSB1dGlscy5pc1BpeGVsQ2hhbmdpbmdPcHRpb25MaXN0KHRoaXMuYXR0cl8oXCJsYWJlbHNcIiksIGF0dHJzKTtcblxuICB1dGlscy51cGRhdGVEZWVwKHRoaXMudXNlcl9hdHRyc18sIGF0dHJzKTtcblxuICB0aGlzLmF0dHJpYnV0ZXNfLnJlcGFyc2VTZXJpZXMoKTtcblxuICBpZiAoZmlsZSkge1xuICAgIC8vIFRoaXMgZXZlbnQgaW5kaWNhdGVzIHRoYXQgdGhlIGRhdGEgaXMgYWJvdXQgdG8gY2hhbmdlLCBidXQgaGFzbid0IHlldC5cbiAgICAvLyBUT0RPKGRhbnZrKTogc3VwcG9ydCBjYW5jZWxsYXRpb24gb2YgdGhlIHVwZGF0ZSB2aWEgdGhpcyBldmVudC5cbiAgICB0aGlzLmNhc2NhZGVFdmVudHNfKCdkYXRhV2lsbFVwZGF0ZScsIHt9KTtcblxuICAgIHRoaXMuZmlsZV8gPSBmaWxlO1xuICAgIGlmICghYmxvY2tfcmVkcmF3KSB0aGlzLnN0YXJ0XygpO1xuICB9IGVsc2Uge1xuICAgIGlmICghYmxvY2tfcmVkcmF3KSB7XG4gICAgICBpZiAocmVxdWlyZXNOZXdQb2ludHMpIHtcbiAgICAgICAgdGhpcy5wcmVkcmF3XygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW5kZXJHcmFwaF8oZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNYWtlIGEgY29weSBvZiBpbnB1dCBhdHRyaWJ1dGVzLCByZW1vdmluZyBmaWxlIGFzIGEgY29udmVuaWVuY2UuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLmNvcHlVc2VyQXR0cnNfID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgdmFyIG15X2F0dHJzID0ge307XG4gIGZvciAodmFyIGsgaW4gYXR0cnMpIHtcbiAgICBpZiAoIWF0dHJzLmhhc093blByb3BlcnR5KGspKSBjb250aW51ZTtcbiAgICBpZiAoayA9PSAnZmlsZScpIGNvbnRpbnVlO1xuICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eShrKSkgbXlfYXR0cnNba10gPSBhdHRyc1trXTtcbiAgfVxuICByZXR1cm4gbXlfYXR0cnM7XG59O1xuXG4vKipcbiAqIFJlc2l6ZXMgdGhlIGR5Z3JhcGguIElmIG5vIHBhcmFtZXRlcnMgYXJlIHNwZWNpZmllZCwgcmVzaXplcyB0byBmaWxsIHRoZVxuICogY29udGFpbmluZyBkaXYgKHdoaWNoIGhhcyBwcmVzdW1hYmx5IGNoYW5nZWQgc2l6ZSBzaW5jZSB0aGUgZHlncmFwaCB3YXNcbiAqIGluc3RhbnRpYXRlZC4gSWYgdGhlIHdpZHRoL2hlaWdodCBhcmUgc3BlY2lmaWVkLCB0aGUgZGl2IHdpbGwgYmUgcmVzaXplZC5cbiAqXG4gKiBUaGlzIGlzIGZhciBtb3JlIGVmZmljaWVudCB0aGFuIGRlc3Ryb3lpbmcgYW5kIHJlLWluc3RhbnRpYXRpbmcgYVxuICogRHlncmFwaCwgc2luY2UgaXQgZG9lc24ndCBoYXZlIHRvIHJlcGFyc2UgdGhlIHVuZGVybHlpbmcgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGggKGluIHBpeGVscylcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IChpbiBwaXhlbHMpXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgaWYgKHRoaXMucmVzaXplX2xvY2spIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZXNpemVfbG9jayA9IHRydWU7XG5cbiAgaWYgKCh3aWR0aCA9PT0gbnVsbCkgIT0gKGhlaWdodCA9PT0gbnVsbCkpIHtcbiAgICBjb25zb2xlLndhcm4oXCJEeWdyYXBoLnJlc2l6ZSgpIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB6ZXJvIHBhcmFtZXRlcnMgb3IgXCIgK1xuICAgICAgICAgICAgICAgICBcInR3byBub24tTlVMTCBwYXJhbWV0ZXJzLiBQcmV0ZW5kaW5nIGl0IHdhcyB6ZXJvLlwiKTtcbiAgICB3aWR0aCA9IGhlaWdodCA9IG51bGw7XG4gIH1cblxuICB2YXIgb2xkX3dpZHRoID0gdGhpcy53aWR0aF87XG4gIHZhciBvbGRfaGVpZ2h0ID0gdGhpcy5oZWlnaHRfO1xuXG4gIGlmICh3aWR0aCkge1xuICAgIHRoaXMubWFpbmRpdl8uc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICB0aGlzLm1haW5kaXZfLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICB0aGlzLndpZHRoXyA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0XyA9IGhlaWdodDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndpZHRoXyA9IHRoaXMubWFpbmRpdl8uY2xpZW50V2lkdGg7XG4gICAgdGhpcy5oZWlnaHRfID0gdGhpcy5tYWluZGl2Xy5jbGllbnRIZWlnaHQ7XG4gIH1cblxuICBpZiAob2xkX3dpZHRoICE9IHRoaXMud2lkdGhfIHx8IG9sZF9oZWlnaHQgIT0gdGhpcy5oZWlnaHRfKSB7XG4gICAgLy8gUmVzaXppbmcgYSBjYW52YXMgZXJhc2VzIGl0LCBldmVuIHdoZW4gdGhlIHNpemUgZG9lc24ndCBjaGFuZ2UsIHNvXG4gICAgLy8gYW55IHJlc2l6ZSBuZWVkcyB0byBiZSBmb2xsb3dlZCBieSBhIHJlZHJhdy5cbiAgICB0aGlzLnJlc2l6ZUVsZW1lbnRzXygpO1xuICAgIHRoaXMucHJlZHJhd18oKTtcbiAgfVxuXG4gIHRoaXMucmVzaXplX2xvY2sgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQWRqdXN0cyB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiB0aGUgcm9sbGluZyBhdmVyYWdlLiBVcGRhdGVzIHRoZSBncmFwaCB0b1xuICogcmVmbGVjdCB0aGUgbmV3IGF2ZXJhZ2luZyBwZXJpb2QuXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBwb2ludHMgb3ZlciB3aGljaCB0byBhdmVyYWdlIHRoZSBkYXRhLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5hZGp1c3RSb2xsID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gIHRoaXMucm9sbFBlcmlvZF8gPSBsZW5ndGg7XG4gIHRoaXMucHJlZHJhd18oKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGJvb2xlYW4gYXJyYXkgb2YgdmlzaWJpbGl0eSBzdGF0dXNlcy5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUudmlzaWJpbGl0eSA9IGZ1bmN0aW9uKCkge1xuICAvLyBEbyBsYXp5LWluaXRpYWxpemF0aW9uLCBzbyB0aGF0IHRoaXMgaGFwcGVucyBhZnRlciB3ZSBrbm93IHRoZSBudW1iZXIgb2ZcbiAgLy8gZGF0YSBzZXJpZXMuXG4gIGlmICghdGhpcy5nZXRPcHRpb24oXCJ2aXNpYmlsaXR5XCIpKSB7XG4gICAgdGhpcy5hdHRyc18udmlzaWJpbGl0eSA9IFtdO1xuICB9XG4gIC8vIFRPRE8oZGFudmspOiBpdCBsb29rcyBsaWtlIHRoaXMgY291bGQgZ28gaW50byBhbiBpbmZpbml0ZSBsb29wIHcvIHVzZXJfYXR0cnMuXG4gIHdoaWxlICh0aGlzLmdldE9wdGlvbihcInZpc2liaWxpdHlcIikubGVuZ3RoIDwgdGhpcy5udW1Db2x1bW5zKCkgLSAxKSB7XG4gICAgdGhpcy5hdHRyc18udmlzaWJpbGl0eS5wdXNoKHRydWUpO1xuICB9XG4gIHJldHVybiB0aGlzLmdldE9wdGlvbihcInZpc2liaWxpdHlcIik7XG59O1xuXG4vKipcbiAqIENoYW5nZXMgdGhlIHZpc2liaWxpdHkgb2Ygb25lIG9yIG1vcmUgc2VyaWVzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfG9iamVjdH0gbnVtIHRoZSBzZXJpZXMgaW5kZXggb3IgYW4gYXJyYXkgb2Ygc2VyaWVzIGluZGljZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGEgYm9vbGVhbiBhcnJheSBvZiB2aXNpYmlsaXR5IHN0YXRlcyBieSBpbmRleFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgYW4gb2JqZWN0IG1hcHBpbmcgc2VyaWVzIG51bWJlcnMsIGFzIGtleXMsIHRvXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5IHN0YXRlIChib29sZWFuIHZhbHVlcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgdGhlIHZpc2liaWxpdHkgc3RhdGUgZXhwcmVzc2VkIGFzIGEgYm9vbGVhblxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5zZXRWaXNpYmlsaXR5ID0gZnVuY3Rpb24obnVtLCB2YWx1ZSkge1xuICB2YXIgeCA9IHRoaXMudmlzaWJpbGl0eSgpO1xuICB2YXIgbnVtSXNPYmplY3QgPSBmYWxzZTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkobnVtKSkge1xuICAgIGlmIChudW0gIT09IG51bGwgJiYgdHlwZW9mIG51bSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG51bUlzT2JqZWN0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtID0gW251bV07XG4gICAgfVxuICB9XG5cbiAgaWYgKG51bUlzT2JqZWN0KSB7XG4gICAgZm9yICh2YXIgaSBpbiBudW0pIHtcbiAgICAgIGlmIChudW0uaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0geC5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHNlcmllcyBudW1iZXIgaW4gc2V0VmlzaWJpbGl0eTogXCIgKyBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4W2ldID0gbnVtW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIG51bVtpXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGlmIChpID49IHgubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCBzZXJpZXMgbnVtYmVyIGluIHNldFZpc2liaWxpdHk6IFwiICsgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeFtpXSA9IG51bVtpXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG51bVtpXSA8IDAgfHwgbnVtW2ldID49IHgubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCBzZXJpZXMgbnVtYmVyIGluIHNldFZpc2liaWxpdHk6IFwiICsgbnVtW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4W251bVtpXV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMucHJlZHJhd18oKTtcbn07XG5cbi8qKlxuICogSG93IGxhcmdlIG9mIGFuIGFyZWEgd2lsbCB0aGUgZHlncmFwaCByZW5kZXIgaXRzZWxmIGluP1xuICogVGhpcyBpcyB1c2VkIGZvciB0ZXN0aW5nLlxuICogQHJldHVybiBBIHt3aWR0aDogdywgaGVpZ2h0OiBofSBvYmplY3QuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7IHdpZHRoOiB0aGlzLndpZHRoXywgaGVpZ2h0OiB0aGlzLmhlaWdodF8gfTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBsaXN0IG9mIGFubm90YXRpb25zIGFuZCByZWRyYXcgdGhlIGNoYXJ0LlxuICogU2VlIGR5Z3JhcGhzLmNvbS9hbm5vdGF0aW9ucy5odG1sIGZvciBtb3JlIGluZm8gb24gaG93IHRvIHVzZSBhbm5vdGF0aW9ucy5cbiAqIEBwYXJhbSBhbm4ge0FycmF5fSBBbiBhcnJheSBvZiBhbm5vdGF0aW9uIG9iamVjdHMuXG4gKiBAcGFyYW0gc3VwcHJlc3NEcmF3IHtCb29sZWFufSBTZXQgdG8gXCJ0cnVlXCIgdG8gYmxvY2sgY2hhcnQgcmVkcmF3IChvcHRpb25hbCkuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnNldEFubm90YXRpb25zID0gZnVuY3Rpb24oYW5uLCBzdXBwcmVzc0RyYXcpIHtcbiAgLy8gT25seSBhZGQgdGhlIGFubm90YXRpb24gQ1NTIHJ1bGUgb25jZSB3ZSBrbm93IGl0IHdpbGwgYmUgdXNlZC5cbiAgdGhpcy5hbm5vdGF0aW9uc18gPSBhbm47XG4gIGlmICghdGhpcy5sYXlvdXRfKSB7XG4gICAgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gc2V0QW5ub3RhdGlvbnMgYmVmb3JlIGR5Z3JhcGggd2FzIHJlYWR5LiBcIiArXG4gICAgICAgICAgICAgICAgIFwiVHJ5IHNldHRpbmcgdGhlbSBpbiBhIHJlYWR5KCkgYmxvY2suIFNlZSBcIiArXG4gICAgICAgICAgICAgICAgIFwiZHlncmFwaHMuY29tL3Rlc3RzL2Fubm90YXRpb24uaHRtbFwiKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmxheW91dF8uc2V0QW5ub3RhdGlvbnModGhpcy5hbm5vdGF0aW9uc18pO1xuICBpZiAoIXN1cHByZXNzRHJhdykge1xuICAgIHRoaXMucHJlZHJhd18oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3Qgb2YgYW5ub3RhdGlvbnMuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmFubm90YXRpb25zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmFubm90YXRpb25zXztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsaXN0IG9mIGxhYmVsIG5hbWVzIGZvciB0aGlzIGdyYXBoLiBUaGUgZmlyc3QgY29sdW1uIGlzIHRoZVxuICogeC1heGlzLCBzbyB0aGUgZGF0YSBzZXJpZXMgbmFtZXMgc3RhcnQgYXQgaW5kZXggMS5cbiAqXG4gKiBSZXR1cm5zIG51bGwgd2hlbiBsYWJlbHMgaGF2ZSBub3QgeWV0IGJlZW4gZGVmaW5lZC5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0TGFiZWxzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsYWJlbHMgPSB0aGlzLmF0dHJfKFwibGFiZWxzXCIpO1xuICByZXR1cm4gbGFiZWxzID8gbGFiZWxzLnNsaWNlKCkgOiBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGluZGV4IG9mIGEgc2VyaWVzIChjb2x1bW4pIGdpdmVuIGl0cyBuYW1lLiBUaGUgZmlyc3QgY29sdW1uIGlzIHRoZVxuICogeC1heGlzLCBzbyB0aGUgZGF0YSBzZXJpZXMgc3RhcnQgd2l0aCBpbmRleCAxLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5pbmRleEZyb21TZXROYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5zZXRJbmRleEJ5TmFtZV9bbmFtZV07XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIHJvdyBudW1iZXIgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4geC12YWx1ZS5cbiAqIFJldHVybnMgbnVsbCBpZiB0aGVyZSBpcyBubyBzdWNoIHgtdmFsdWUgaW4gdGhlIGRhdGEuXG4gKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgcm93cyB3aXRoIHRoZSBzYW1lIHgtdmFsdWUsIHRoaXMgd2lsbCByZXR1cm4gdGhlXG4gKiBmaXJzdCBvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0geFZhbCBUaGUgeC12YWx1ZSB0byBsb29rIGZvciAoZS5nLiBtaWxsaXMgc2luY2UgZXBvY2gpLlxuICogQHJldHVybiB7P251bWJlcn0gVGhlIHJvdyBudW1iZXIsIHdoaWNoIHlvdSBjYW4gcGFzcyB0byBnZXRWYWx1ZSgpLCBvciBudWxsLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRSb3dGb3JYID0gZnVuY3Rpb24oeFZhbCkge1xuICB2YXIgbG93ID0gMCxcbiAgICAgIGhpZ2ggPSB0aGlzLm51bVJvd3MoKSAtIDE7XG5cbiAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgdmFyIGlkeCA9IChoaWdoICsgbG93KSA+PiAxO1xuICAgIHZhciB4ID0gdGhpcy5nZXRWYWx1ZShpZHgsIDApO1xuICAgIGlmICh4IDwgeFZhbCkge1xuICAgICAgbG93ID0gaWR4ICsgMTtcbiAgICB9IGVsc2UgaWYgKHggPiB4VmFsKSB7XG4gICAgICBoaWdoID0gaWR4IC0gMTtcbiAgICB9IGVsc2UgaWYgKGxvdyAhPSBpZHgpIHsgIC8vIGVxdWFsLCBidXQgdGhlcmUgbWF5IGJlIGFuIGVhcmxpZXIgbWF0Y2guXG4gICAgICBoaWdoID0gaWR4O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaWR4O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGEgY2FsbGJhY2sgd2hlbiB0aGUgZHlncmFwaCBoYXMgZHJhd24gaXRzZWxmIGFuZCBpcyByZWFkeSB0byBiZVxuICogbWFuaXB1bGF0ZWQuIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCB3aGVuIGR5Z3JhcGhzIGhhcyB0byBkbyBhbiBYSFIgZm9yIHRoZVxuICogZGF0YSAoaS5lLiBhIFVSTCBpcyBwYXNzZWQgYXMgdGhlIGRhdGEgc291cmNlKSBhbmQgdGhlIGNoYXJ0IGlzIGRyYXduXG4gKiBhc3luY2hyb25vdXNseS4gSWYgdGhlIGNoYXJ0IGhhcyBhbHJlYWR5IGRyYXduLCB0aGUgY2FsbGJhY2sgd2lsbCBmaXJlXG4gKiBpbW1lZGlhdGVseS5cbiAqXG4gKiBUaGlzIGlzIGEgZ29vZCBwbGFjZSB0byBjYWxsIHNldEFubm90YXRpb24oKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCFEeWdyYXBoKX0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIHRyaWdnZXIgd2hlbiB0aGUgY2hhcnRcbiAqICAgICBpcyByZWFkeS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICBpZiAodGhpcy5pc19pbml0aWFsX2RyYXdfKSB7XG4gICAgdGhpcy5yZWFkeUZuc18ucHVzaChjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBZGQgYW4gZXZlbnQgaGFuZGxlci4gVGhpcyBldmVudCBoYW5kbGVyIGlzIGtlcHQgdW50aWwgdGhlIGdyYXBoIGlzXG4gKiBkZXN0cm95ZWQgd2l0aCBhIGNhbGwgdG8gZ3JhcGguZGVzdHJveSgpLlxuICpcbiAqIEBwYXJhbSB7IU5vZGV9IGVsZW0gVGhlIGVsZW1lbnQgdG8gYWRkIHRoZSBldmVudCB0by5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBldmVudCwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW1vdmUnLlxuICogQHBhcmFtIHtmdW5jdGlvbihFdmVudCk6KGJvb2xlYW58dW5kZWZpbmVkKX0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGxcbiAqICAgICBvbiB0aGUgZXZlbnQuIFRoZSBmdW5jdGlvbiB0YWtlcyBvbmUgcGFyYW1ldGVyOiB0aGUgZXZlbnQgb2JqZWN0LlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuYWRkQW5kVHJhY2tFdmVudCA9IGZ1bmN0aW9uKGVsZW0sIHR5cGUsIGZuKSB7XG4gIHV0aWxzLmFkZEV2ZW50KGVsZW0sIHR5cGUsIGZuKTtcbiAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzXy5wdXNoKHtlbGVtLCB0eXBlLCBmbn0pO1xufTtcblxuRHlncmFwaC5wcm90b3R5cGUucmVtb3ZlVHJhY2tlZEV2ZW50c18gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVnaXN0ZXJlZEV2ZW50c18pIHtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCB0aGlzLnJlZ2lzdGVyZWRFdmVudHNfLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgIHZhciByZWcgPSB0aGlzLnJlZ2lzdGVyZWRFdmVudHNfW2lkeF07XG4gICAgICB1dGlscy5yZW1vdmVFdmVudChyZWcuZWxlbSwgcmVnLnR5cGUsIHJlZy5mbik7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzXyA9IFtdO1xufTtcblxuXG4vLyBJbnN0YWxsZWQgcGx1Z2lucywgaW4gb3JkZXIgb2YgcHJlY2VkZW5jZSAobW9zdC1nZW5lcmFsIHRvIG1vc3Qtc3BlY2lmaWMpLlxuRHlncmFwaC5QTFVHSU5TID0gW1xuICBMZWdlbmRQbHVnaW4sXG4gIEF4ZXNQbHVnaW4sXG4gIFJhbmdlU2VsZWN0b3JQbHVnaW4sIC8vIEhhcyB0byBiZSBiZWZvcmUgQ2hhcnRMYWJlbHMgc28gdGhhdCBpdHMgY2FsbGJhY2tzIGFyZSBjYWxsZWQgYWZ0ZXIgQ2hhcnRMYWJlbHMnIGNhbGxiYWNrcy5cbiAgQ2hhcnRMYWJlbHNQbHVnaW4sXG4gIEFubm90YXRpb25zUGx1Z2luLFxuICBHcmlkUGx1Z2luXG5dO1xuXG4vLyBUaGVyZSBhcmUgbWFueSBzeW1ib2xzIHdoaWNoIGhhdmUgaGlzdG9yaWNhbGx5IGJlZW4gYXZhaWxhYmxlIHRocm91Z2ggdGhlXG4vLyBEeWdyYXBoIGNsYXNzLiBUaGVzZSBhcmUgZXhwb3J0ZWQgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5EeWdyYXBoLkdWaXpDaGFydCA9IEdWaXpDaGFydDtcbkR5Z3JhcGguREFTSEVEX0xJTkUgPSB1dGlscy5EQVNIRURfTElORTtcbkR5Z3JhcGguRE9UX0RBU0hfTElORSA9IHV0aWxzLkRPVF9EQVNIX0xJTkU7XG5EeWdyYXBoLmRhdGVBeGlzTGFiZWxGb3JtYXR0ZXIgPSB1dGlscy5kYXRlQXhpc0xhYmVsRm9ybWF0dGVyO1xuRHlncmFwaC50b1JHQl8gPSB1dGlscy50b1JHQl87XG5EeWdyYXBoLmZpbmRQb3MgPSB1dGlscy5maW5kUG9zO1xuRHlncmFwaC5wYWdlWCA9IHV0aWxzLnBhZ2VYO1xuRHlncmFwaC5wYWdlWSA9IHV0aWxzLnBhZ2VZO1xuRHlncmFwaC5kYXRlU3RyaW5nXyA9IHV0aWxzLmRhdGVTdHJpbmdfO1xuRHlncmFwaC5kZWZhdWx0SW50ZXJhY3Rpb25Nb2RlbCA9IER5Z3JhcGhJbnRlcmFjdGlvbi5kZWZhdWx0TW9kZWw7XG5EeWdyYXBoLm5vbkludGVyYWN0aXZlTW9kZWwgPSBEeWdyYXBoLm5vbkludGVyYWN0aXZlTW9kZWxfID0gRHlncmFwaEludGVyYWN0aW9uLm5vbkludGVyYWN0aXZlTW9kZWxfO1xuRHlncmFwaC5DaXJjbGVzID0gdXRpbHMuQ2lyY2xlcztcblxuRHlncmFwaC5QbHVnaW5zID0ge1xuICBMZWdlbmQ6IExlZ2VuZFBsdWdpbixcbiAgQXhlczogQXhlc1BsdWdpbixcbiAgQW5ub3RhdGlvbnM6IEFubm90YXRpb25zUGx1Z2luLFxuICBDaGFydExhYmVsczogQ2hhcnRMYWJlbHNQbHVnaW4sXG4gIEdyaWQ6IEdyaWRQbHVnaW4sXG4gIFJhbmdlU2VsZWN0b3I6IFJhbmdlU2VsZWN0b3JQbHVnaW5cbn07XG5cbkR5Z3JhcGguRGF0YUhhbmRsZXJzID0ge1xuICBEZWZhdWx0SGFuZGxlcixcbiAgQmFyc0hhbmRsZXIsXG4gIEN1c3RvbUJhcnNIYW5kbGVyLFxuICBEZWZhdWx0RnJhY3Rpb25IYW5kbGVyLFxuICBFcnJvckJhcnNIYW5kbGVyLFxuICBGcmFjdGlvbnNCYXJzSGFuZGxlclxufTtcblxuRHlncmFwaC5zdGFydFBhbiA9IER5Z3JhcGhJbnRlcmFjdGlvbi5zdGFydFBhbjtcbkR5Z3JhcGguc3RhcnRab29tID0gRHlncmFwaEludGVyYWN0aW9uLnN0YXJ0Wm9vbTtcbkR5Z3JhcGgubW92ZVBhbiA9IER5Z3JhcGhJbnRlcmFjdGlvbi5tb3ZlUGFuO1xuRHlncmFwaC5tb3ZlWm9vbSA9IER5Z3JhcGhJbnRlcmFjdGlvbi5tb3ZlWm9vbTtcbkR5Z3JhcGguZW5kUGFuID0gRHlncmFwaEludGVyYWN0aW9uLmVuZFBhbjtcbkR5Z3JhcGguZW5kWm9vbSA9IER5Z3JhcGhJbnRlcmFjdGlvbi5lbmRab29tO1xuXG5EeWdyYXBoLm51bWVyaWNMaW5lYXJUaWNrcyA9IER5Z3JhcGhUaWNrZXJzLm51bWVyaWNMaW5lYXJUaWNrcztcbkR5Z3JhcGgubnVtZXJpY1RpY2tzID0gRHlncmFwaFRpY2tlcnMubnVtZXJpY1RpY2tzO1xuRHlncmFwaC5kYXRlVGlja2VyID0gRHlncmFwaFRpY2tlcnMuZGF0ZVRpY2tlcjtcbkR5Z3JhcGguR3JhbnVsYXJpdHkgPSBEeWdyYXBoVGlja2Vycy5HcmFudWxhcml0eTtcbkR5Z3JhcGguZ2V0RGF0ZUF4aXMgPSBEeWdyYXBoVGlja2Vycy5nZXREYXRlQXhpcztcbkR5Z3JhcGguZmxvYXRGb3JtYXQgPSB1dGlscy5mbG9hdEZvcm1hdDtcblxuZXhwb3J0IGRlZmF1bHQgRHlncmFwaDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZHlncmFwaHMvc3JjL2R5Z3JhcGguanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n    return [];\n};\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZSIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJjYWxsIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwiaSIsInB1c2giLCJJdGVtIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwibmFtZSIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUlBLFVBQVVDLE9BQU9DLE9BQVAsR0FBaUIsRUFBL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSUMsZ0JBQUo7QUFDQSxJQUFJQyxrQkFBSjs7QUFFQSxTQUFTQyxnQkFBVCxHQUE0QjtBQUN4QixVQUFNLElBQUlDLEtBQUosQ0FBVSxpQ0FBVixDQUFOO0FBQ0g7QUFDRCxT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QUFWLEVBQWU7QUFDM0IsVUFBTSxJQUFJcEQsS0FBSixDQUFVLGdDQUFWLENBQU47QUFDSCxDQUZEO0FBR0FOLFFBQVEyRCxLQUFSLEdBQWdCLFlBQVc7QUFBRSxXQUFPLENBQVA7QUFBVyxDQUF4QyIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcHJvY2Vzcy9icm93c2VyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_dygraph__ = __webpack_require__(5);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__src_dygraph__[\"a\"]; });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__datahandler__ = __webpack_require__(2);\n/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler default implementation used for simple line charts.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * @constructor\n * @extends Dygraph.DataHandler\n */\nvar DefaultHandler = function DefaultHandler() {};\n\nDefaultHandler.prototype = new __WEBPACK_IMPORTED_MODULE_0__datahandler__[\"a\" /* default */]();\n\n/** @inheritDoc */\nDefaultHandler.prototype.extractSeries = function (rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var logScale = options.get('logscale');\n  for (var j = 0; j < rawData.length; j++) {\n    var x = rawData[j][0];\n    var point = rawData[j][i];\n    if (logScale) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point <= 0) {\n        point = null;\n      }\n    }\n    series.push([x, point]);\n  }\n  return series;\n};\n\n/** @inheritDoc */\nDefaultHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n\n  var i, j, y, sum, num_ok;\n  // Calculate the rolling average for the first rollPeriod - 1 points\n  // where\n  // there is not enough data to roll over the full number of points\n  if (rollPeriod == 1) {\n    return originalData;\n  }\n  for (i = 0; i < originalData.length; i++) {\n    sum = 0;\n    num_ok = 0;\n    for (j = Math.max(0, i - rollPeriod + 1); j < i + 1; j++) {\n      y = originalData[j][1];\n      if (y === null || isNaN(y)) continue;\n      num_ok++;\n      sum += originalData[j][1];\n    }\n    if (num_ok) {\n      rollingData[i] = [originalData[i][0], sum / num_ok];\n    } else {\n      rollingData[i] = [originalData[i][0], null];\n    }\n  }\n\n  return rollingData;\n};\n\n/** @inheritDoc */\nDefaultHandler.prototype.getExtremeYValues = function (series, dateWindow, options) {\n  var minY = null,\n      maxY = null,\n      y;\n  var firstIdx = 0,\n      lastIdx = series.length - 1;\n\n  for (var j = firstIdx; j <= lastIdx; j++) {\n    y = series[j][1];\n    if (y === null || isNaN(y)) continue;\n    if (maxY === null || y > maxY) {\n      maxY = y;\n    }\n    if (minY === null || y < minY) {\n      minY = y;\n    }\n  }\n  return [minY, maxY];\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DefaultHandler);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9kZWZhdWx0LmpzPzVhM2EiXSwibmFtZXMiOlsiRGVmYXVsdEhhbmRsZXIiLCJwcm90b3R5cGUiLCJleHRyYWN0U2VyaWVzIiwicmF3RGF0YSIsImkiLCJvcHRpb25zIiwic2VyaWVzIiwibG9nU2NhbGUiLCJnZXQiLCJqIiwibGVuZ3RoIiwieCIsInBvaW50IiwicHVzaCIsInJvbGxpbmdBdmVyYWdlIiwib3JpZ2luYWxEYXRhIiwicm9sbFBlcmlvZCIsIk1hdGgiLCJtaW4iLCJyb2xsaW5nRGF0YSIsInkiLCJzdW0iLCJudW1fb2siLCJtYXgiLCJpc05hTiIsImdldEV4dHJlbWVZVmFsdWVzIiwiZGF0ZVdpbmRvdyIsIm1pblkiLCJtYXhZIiwiZmlyc3RJZHgiLCJsYXN0SWR4Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOzs7Ozs7QUFNQTs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUEsSUFBSUEsaUJBQWlCLFNBQWpCQSxjQUFpQixHQUFXLENBQy9CLENBREQ7O0FBR0FBLGVBQWVDLFNBQWYsR0FBMkIsSUFBSSw2REFBSixFQUEzQjs7QUFFQTtBQUNBRCxlQUFlQyxTQUFmLENBQXlCQyxhQUF6QixHQUF5QyxVQUFTQyxPQUFULEVBQWtCQyxDQUFsQixFQUFxQkMsT0FBckIsRUFBOEI7QUFDckU7QUFDQSxNQUFJQyxTQUFTLEVBQWI7QUFDQSxNQUFJQyxXQUFXRixRQUFRRyxHQUFSLENBQVksVUFBWixDQUFmO0FBQ0EsT0FBTSxJQUFJQyxJQUFJLENBQWQsRUFBaUJBLElBQUlOLFFBQVFPLE1BQTdCLEVBQXFDRCxHQUFyQyxFQUEwQztBQUN4QyxRQUFJRSxJQUFJUixRQUFRTSxDQUFSLEVBQVcsQ0FBWCxDQUFSO0FBQ0EsUUFBSUcsUUFBUVQsUUFBUU0sQ0FBUixFQUFXTCxDQUFYLENBQVo7QUFDQSxRQUFJRyxRQUFKLEVBQWM7QUFDWjtBQUNBO0FBQ0EsVUFBSUssU0FBUyxDQUFiLEVBQWdCO0FBQ2RBLGdCQUFRLElBQVI7QUFDRDtBQUNGO0FBQ0ROLFdBQU9PLElBQVAsQ0FBWSxDQUFFRixDQUFGLEVBQUtDLEtBQUwsQ0FBWjtBQUNEO0FBQ0QsU0FBT04sTUFBUDtBQUNELENBakJEOztBQW1CQTtBQUNBTixlQUFlQyxTQUFmLENBQXlCYSxjQUF6QixHQUEwQyxVQUFTQyxZQUFULEVBQXVCQyxVQUF2QixFQUN0Q1gsT0FEc0MsRUFDN0I7QUFDWFcsZUFBYUMsS0FBS0MsR0FBTCxDQUFTRixVQUFULEVBQXFCRCxhQUFhTCxNQUFsQyxDQUFiO0FBQ0EsTUFBSVMsY0FBYyxFQUFsQjs7QUFFQSxNQUFJZixDQUFKLEVBQU9LLENBQVAsRUFBVVcsQ0FBVixFQUFhQyxHQUFiLEVBQWtCQyxNQUFsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUlOLGNBQWMsQ0FBbEIsRUFBcUI7QUFDbkIsV0FBT0QsWUFBUDtBQUNEO0FBQ0QsT0FBS1gsSUFBSSxDQUFULEVBQVlBLElBQUlXLGFBQWFMLE1BQTdCLEVBQXFDTixHQUFyQyxFQUEwQztBQUN4Q2lCLFVBQU0sQ0FBTjtBQUNBQyxhQUFTLENBQVQ7QUFDQSxTQUFLYixJQUFJUSxLQUFLTSxHQUFMLENBQVMsQ0FBVCxFQUFZbkIsSUFBSVksVUFBSixHQUFpQixDQUE3QixDQUFULEVBQTBDUCxJQUFJTCxJQUFJLENBQWxELEVBQXFESyxHQUFyRCxFQUEwRDtBQUN4RFcsVUFBSUwsYUFBYU4sQ0FBYixFQUFnQixDQUFoQixDQUFKO0FBQ0EsVUFBSVcsTUFBTSxJQUFOLElBQWNJLE1BQU1KLENBQU4sQ0FBbEIsRUFDRTtBQUNGRTtBQUNBRCxhQUFPTixhQUFhTixDQUFiLEVBQWdCLENBQWhCLENBQVA7QUFDRDtBQUNELFFBQUlhLE1BQUosRUFBWTtBQUNWSCxrQkFBWWYsQ0FBWixJQUFpQixDQUFFVyxhQUFhWCxDQUFiLEVBQWdCLENBQWhCLENBQUYsRUFBc0JpQixNQUFNQyxNQUE1QixDQUFqQjtBQUNELEtBRkQsTUFFTztBQUNMSCxrQkFBWWYsQ0FBWixJQUFpQixDQUFFVyxhQUFhWCxDQUFiLEVBQWdCLENBQWhCLENBQUYsRUFBc0IsSUFBdEIsQ0FBakI7QUFDRDtBQUNGOztBQUVELFNBQU9lLFdBQVA7QUFDRCxDQTlCRDs7QUFnQ0E7QUFDQW5CLGVBQWVDLFNBQWYsQ0FBeUJ3QixpQkFBekIsR0FBNkMsVUFBU25CLE1BQVQsRUFBaUJvQixVQUFqQixFQUN6Q3JCLE9BRHlDLEVBQ2hDO0FBQ1gsTUFBSXNCLE9BQU8sSUFBWDtBQUFBLE1BQWlCQyxPQUFPLElBQXhCO0FBQUEsTUFBOEJSLENBQTlCO0FBQ0EsTUFBSVMsV0FBVyxDQUFmO0FBQUEsTUFBa0JDLFVBQVV4QixPQUFPSSxNQUFQLEdBQWdCLENBQTVDOztBQUVBLE9BQU0sSUFBSUQsSUFBSW9CLFFBQWQsRUFBd0JwQixLQUFLcUIsT0FBN0IsRUFBc0NyQixHQUF0QyxFQUEyQztBQUN6Q1csUUFBSWQsT0FBT0csQ0FBUCxFQUFVLENBQVYsQ0FBSjtBQUNBLFFBQUlXLE1BQU0sSUFBTixJQUFjSSxNQUFNSixDQUFOLENBQWxCLEVBQ0U7QUFDRixRQUFJUSxTQUFTLElBQVQsSUFBaUJSLElBQUlRLElBQXpCLEVBQStCO0FBQzdCQSxhQUFPUixDQUFQO0FBQ0Q7QUFDRCxRQUFJTyxTQUFTLElBQVQsSUFBaUJQLElBQUlPLElBQXpCLEVBQStCO0FBQzdCQSxhQUFPUCxDQUFQO0FBQ0Q7QUFDRjtBQUNELFNBQU8sQ0FBRU8sSUFBRixFQUFRQyxJQUFSLENBQVA7QUFDRCxDQWpCRDs7QUFtQkEseURBQWU1QixjQUFmIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMyBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGF0YUhhbmRsZXIgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB1c2VkIGZvciBzaW1wbGUgbGluZSBjaGFydHMuXG4gKiBAYXV0aG9yIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRHlncmFwaERhdGFIYW5kbGVyIGZyb20gJy4vZGF0YWhhbmRsZXInO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRHlncmFwaC5EYXRhSGFuZGxlclxuICovXG52YXIgRGVmYXVsdEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbn07XG5cbkRlZmF1bHRIYW5kbGVyLnByb3RvdHlwZSA9IG5ldyBEeWdyYXBoRGF0YUhhbmRsZXIoKTtcblxuLyoqIEBpbmhlcml0RG9jICovXG5EZWZhdWx0SGFuZGxlci5wcm90b3R5cGUuZXh0cmFjdFNlcmllcyA9IGZ1bmN0aW9uKHJhd0RhdGEsIGksIG9wdGlvbnMpIHtcbiAgLy8gVE9ETyhkYW52ayk6IHByZS1hbGxvY2F0ZSBzZXJpZXMgaGVyZS5cbiAgdmFyIHNlcmllcyA9IFtdO1xuICB2YXIgbG9nU2NhbGUgPSBvcHRpb25zLmdldCgnbG9nc2NhbGUnKTtcbiAgZm9yICggdmFyIGogPSAwOyBqIDwgcmF3RGF0YS5sZW5ndGg7IGorKykge1xuICAgIHZhciB4ID0gcmF3RGF0YVtqXVswXTtcbiAgICB2YXIgcG9pbnQgPSByYXdEYXRhW2pdW2ldO1xuICAgIGlmIChsb2dTY2FsZSkge1xuICAgICAgLy8gT24gdGhlIGxvZyBzY2FsZSwgcG9pbnRzIGxlc3MgdGhhbiB6ZXJvIGRvIG5vdCBleGlzdC5cbiAgICAgIC8vIFRoaXMgd2lsbCBjcmVhdGUgYSBnYXAgaW4gdGhlIGNoYXJ0LlxuICAgICAgaWYgKHBvaW50IDw9IDApIHtcbiAgICAgICAgcG9pbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXJpZXMucHVzaChbIHgsIHBvaW50IF0pO1xuICB9XG4gIHJldHVybiBzZXJpZXM7XG59O1xuXG4vKiogQGluaGVyaXREb2MgKi9cbkRlZmF1bHRIYW5kbGVyLnByb3RvdHlwZS5yb2xsaW5nQXZlcmFnZSA9IGZ1bmN0aW9uKG9yaWdpbmFsRGF0YSwgcm9sbFBlcmlvZCxcbiAgICBvcHRpb25zKSB7XG4gIHJvbGxQZXJpb2QgPSBNYXRoLm1pbihyb2xsUGVyaW9kLCBvcmlnaW5hbERhdGEubGVuZ3RoKTtcbiAgdmFyIHJvbGxpbmdEYXRhID0gW107XG5cbiAgdmFyIGksIGosIHksIHN1bSwgbnVtX29rO1xuICAvLyBDYWxjdWxhdGUgdGhlIHJvbGxpbmcgYXZlcmFnZSBmb3IgdGhlIGZpcnN0IHJvbGxQZXJpb2QgLSAxIHBvaW50c1xuICAvLyB3aGVyZVxuICAvLyB0aGVyZSBpcyBub3QgZW5vdWdoIGRhdGEgdG8gcm9sbCBvdmVyIHRoZSBmdWxsIG51bWJlciBvZiBwb2ludHNcbiAgaWYgKHJvbGxQZXJpb2QgPT0gMSkge1xuICAgIHJldHVybiBvcmlnaW5hbERhdGE7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IG9yaWdpbmFsRGF0YS5sZW5ndGg7IGkrKykge1xuICAgIHN1bSA9IDA7XG4gICAgbnVtX29rID0gMDtcbiAgICBmb3IgKGogPSBNYXRoLm1heCgwLCBpIC0gcm9sbFBlcmlvZCArIDEpOyBqIDwgaSArIDE7IGorKykge1xuICAgICAgeSA9IG9yaWdpbmFsRGF0YVtqXVsxXTtcbiAgICAgIGlmICh5ID09PSBudWxsIHx8IGlzTmFOKHkpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIG51bV9vaysrO1xuICAgICAgc3VtICs9IG9yaWdpbmFsRGF0YVtqXVsxXTtcbiAgICB9XG4gICAgaWYgKG51bV9vaykge1xuICAgICAgcm9sbGluZ0RhdGFbaV0gPSBbIG9yaWdpbmFsRGF0YVtpXVswXSwgc3VtIC8gbnVtX29rIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvbGxpbmdEYXRhW2ldID0gWyBvcmlnaW5hbERhdGFbaV1bMF0sIG51bGwgXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm9sbGluZ0RhdGE7XG59O1xuXG4vKiogQGluaGVyaXREb2MgKi9cbkRlZmF1bHRIYW5kbGVyLnByb3RvdHlwZS5nZXRFeHRyZW1lWVZhbHVlcyA9IGZ1bmN0aW9uKHNlcmllcywgZGF0ZVdpbmRvdyxcbiAgICBvcHRpb25zKSB7XG4gIHZhciBtaW5ZID0gbnVsbCwgbWF4WSA9IG51bGwsIHk7XG4gIHZhciBmaXJzdElkeCA9IDAsIGxhc3RJZHggPSBzZXJpZXMubGVuZ3RoIC0gMTtcblxuICBmb3IgKCB2YXIgaiA9IGZpcnN0SWR4OyBqIDw9IGxhc3RJZHg7IGorKykge1xuICAgIHkgPSBzZXJpZXNbal1bMV07XG4gICAgaWYgKHkgPT09IG51bGwgfHwgaXNOYU4oeSkpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAobWF4WSA9PT0gbnVsbCB8fCB5ID4gbWF4WSkge1xuICAgICAgbWF4WSA9IHk7XG4gICAgfVxuICAgIGlmIChtaW5ZID09PSBudWxsIHx8IHkgPCBtaW5ZKSB7XG4gICAgICBtaW5ZID0geTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsgbWluWSwgbWF4WSBdO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRGVmYXVsdEhhbmRsZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9kZWZhdWx0LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dygraph__ = __webpack_require__(5);\n/**\n * @license\n * Copyright 2006 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview Based on PlotKit.CanvasRenderer, but modified to meet the\n * needs of dygraphs.\n *\n * In particular, support for:\n * - grid overlays\n * - error bars\n * - dygraphs attribute system\n */\n\n/**\n * The DygraphCanvasRenderer class does the actual rendering of the chart onto\n * a canvas. It's based on PlotKit.CanvasRenderer.\n * @param {Object} element The canvas to attach to\n * @param {Object} elementContext The 2d context of the canvas (injected so it\n * can be mocked for testing.)\n * @param {Layout} layout The DygraphLayout object for this graph.\n * @constructor\n */\n\n/*global Dygraph:false */\n\n\n\n\n\n/**\n * @constructor\n *\n * This gets called when there are \"new points\" to chart. This is generally the\n * case when the underlying data being charted has changed. It is _not_ called\n * in the common case that the user has zoomed or is panning the view.\n *\n * The chart canvas has already been created by the Dygraph object. The\n * renderer simply gets a drawing context.\n *\n * @param {Dygraph} dygraph The chart to which this renderer belongs.\n * @param {HTMLCanvasElement} element The &lt;canvas&gt; DOM element on which to draw.\n * @param {CanvasRenderingContext2D} elementContext The drawing context.\n * @param {DygraphLayout} layout The chart's DygraphLayout object.\n *\n * TODO(danvk): remove the elementContext property.\n */\nvar DygraphCanvasRenderer = function DygraphCanvasRenderer(dygraph, element, elementContext, layout) {\n  this.dygraph_ = dygraph;\n\n  this.layout = layout;\n  this.element = element;\n  this.elementContext = elementContext;\n\n  this.height = dygraph.height_;\n  this.width = dygraph.width_;\n\n  // --- check whether everything is ok before we return\n  if (!__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"Q\" /* isCanvasSupported */](this.element)) {\n    throw \"Canvas is not supported.\";\n  }\n\n  // internal state\n  this.area = layout.getPlotArea();\n\n  // Set up a clipping area for the canvas (and the interaction canvas).\n  // This ensures that we don't overdraw.\n  var ctx = this.dygraph_.canvas_ctx_;\n  ctx.beginPath();\n  ctx.rect(this.area.x, this.area.y, this.area.w, this.area.h);\n  ctx.clip();\n\n  ctx = this.dygraph_.hidden_ctx_;\n  ctx.beginPath();\n  ctx.rect(this.area.x, this.area.y, this.area.w, this.area.h);\n  ctx.clip();\n};\n\n/**\n * Clears out all chart content and DOM elements.\n * This is called immediately before render() on every frame, including\n * during zooms and pans.\n * @private\n */\nDygraphCanvasRenderer.prototype.clear = function () {\n  this.elementContext.clearRect(0, 0, this.width, this.height);\n};\n\n/**\n * This method is responsible for drawing everything on the chart, including\n * lines, error bars, fills and axes.\n * It is called immediately after clear() on every frame, including during pans\n * and zooms.\n * @private\n */\nDygraphCanvasRenderer.prototype.render = function () {\n  // attaches point.canvas{x,y}\n  this._updatePoints();\n\n  // actually draws the chart.\n  this._renderLineChart();\n};\n\n/**\n * Returns a predicate to be used with an iterator, which will\n * iterate over points appropriately, depending on whether\n * connectSeparatedPoints is true. When it's false, the predicate will\n * skip over points with missing yVals.\n */\nDygraphCanvasRenderer._getIteratorPredicate = function (connectSeparatedPoints) {\n  return connectSeparatedPoints ? DygraphCanvasRenderer._predicateThatSkipsEmptyPoints : null;\n};\n\nDygraphCanvasRenderer._predicateThatSkipsEmptyPoints = function (array, idx) {\n  return array[idx].yval !== null;\n};\n\n/**\n * Draws a line with the styles passed in and calls all the drawPointCallbacks.\n * @param {Object} e The dictionary passed to the plotter function.\n * @private\n */\nDygraphCanvasRenderer._drawStyledLine = function (e, color, strokeWidth, strokePattern, drawPoints, drawPointCallback, pointSize) {\n  var g = e.dygraph;\n  // TODO(konigsberg): Compute attributes outside this method call.\n  var stepPlot = g.getBooleanOption(\"stepPlot\", e.setName);\n\n  if (!__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"B\" /* isArrayLike */](strokePattern)) {\n    strokePattern = null;\n  }\n\n  var drawGapPoints = g.getBooleanOption('drawGapEdgePoints', e.setName);\n\n  var points = e.points;\n  var setName = e.setName;\n  var iter = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"R\" /* createIterator */](points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n  var stroking = strokePattern && strokePattern.length >= 2;\n\n  var ctx = e.drawingContext;\n  ctx.save();\n  if (stroking) {\n    if (ctx.setLineDash) ctx.setLineDash(strokePattern);\n  }\n\n  var pointsOnLine = DygraphCanvasRenderer._drawSeries(e, iter, strokeWidth, pointSize, drawPoints, drawGapPoints, stepPlot, color);\n  DygraphCanvasRenderer._drawPointsOnLine(e, pointsOnLine, drawPointCallback, color, pointSize);\n\n  if (stroking) {\n    if (ctx.setLineDash) ctx.setLineDash([]);\n  }\n\n  ctx.restore();\n};\n\n/**\n * This does the actual drawing of lines on the canvas, for just one series.\n * Returns a list of [canvasx, canvasy] pairs for points for which a\n * drawPointCallback should be fired.  These include isolated points, or all\n * points if drawPoints=true.\n * @param {Object} e The dictionary passed to the plotter function.\n * @private\n */\nDygraphCanvasRenderer._drawSeries = function (e, iter, strokeWidth, pointSize, drawPoints, drawGapPoints, stepPlot, color) {\n\n  var prevCanvasX = null;\n  var prevCanvasY = null;\n  var nextCanvasY = null;\n  var isIsolated; // true if this point is isolated (no line segments)\n  var point; // the point being processed in the while loop\n  var pointsOnLine = []; // Array of [canvasx, canvasy] pairs.\n  var first = true; // the first cycle through the while loop\n\n  var ctx = e.drawingContext;\n  ctx.beginPath();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = strokeWidth;\n\n  // NOTE: we break the iterator's encapsulation here for about a 25% speedup.\n  var arr = iter.array_;\n  var limit = iter.end_;\n  var predicate = iter.predicate_;\n\n  for (var i = iter.start_; i < limit; i++) {\n    point = arr[i];\n    if (predicate) {\n      while (i < limit && !predicate(arr, i)) {\n        i++;\n      }\n      if (i == limit) break;\n      point = arr[i];\n    }\n\n    // FIXME: The 'canvasy != canvasy' test here catches NaN values but the test\n    // doesn't catch Infinity values. Could change this to\n    // !isFinite(point.canvasy), but I assume it avoids isNaN for performance?\n    if (point.canvasy === null || point.canvasy != point.canvasy) {\n      if (stepPlot && prevCanvasX !== null) {\n        // Draw a horizontal line to the start of the missing data\n        ctx.moveTo(prevCanvasX, prevCanvasY);\n        ctx.lineTo(point.canvasx, prevCanvasY);\n      }\n      prevCanvasX = prevCanvasY = null;\n    } else {\n      isIsolated = false;\n      if (drawGapPoints || prevCanvasX === null) {\n        iter.nextIdx_ = i;\n        iter.next();\n        nextCanvasY = iter.hasNext ? iter.peek.canvasy : null;\n\n        var isNextCanvasYNullOrNaN = nextCanvasY === null || nextCanvasY != nextCanvasY;\n        isIsolated = prevCanvasX === null && isNextCanvasYNullOrNaN;\n        if (drawGapPoints) {\n          // Also consider a point to be \"isolated\" if it's adjacent to a\n          // null point, excluding the graph edges.\n          if (!first && prevCanvasX === null || iter.hasNext && isNextCanvasYNullOrNaN) {\n            isIsolated = true;\n          }\n        }\n      }\n\n      if (prevCanvasX !== null) {\n        if (strokeWidth) {\n          if (stepPlot) {\n            ctx.moveTo(prevCanvasX, prevCanvasY);\n            ctx.lineTo(point.canvasx, prevCanvasY);\n          }\n\n          ctx.lineTo(point.canvasx, point.canvasy);\n        }\n      } else {\n        ctx.moveTo(point.canvasx, point.canvasy);\n      }\n      if (drawPoints || isIsolated) {\n        pointsOnLine.push([point.canvasx, point.canvasy, point.idx]);\n      }\n      prevCanvasX = point.canvasx;\n      prevCanvasY = point.canvasy;\n    }\n    first = false;\n  }\n  ctx.stroke();\n  return pointsOnLine;\n};\n\n/**\n * This fires the drawPointCallback functions, which draw dots on the points by\n * default. This gets used when the \"drawPoints\" option is set, or when there\n * are isolated points.\n * @param {Object} e The dictionary passed to the plotter function.\n * @private\n */\nDygraphCanvasRenderer._drawPointsOnLine = function (e, pointsOnLine, drawPointCallback, color, pointSize) {\n  var ctx = e.drawingContext;\n  for (var idx = 0; idx < pointsOnLine.length; idx++) {\n    var cb = pointsOnLine[idx];\n    ctx.save();\n    drawPointCallback.call(e.dygraph, e.dygraph, e.setName, ctx, cb[0], cb[1], color, pointSize, cb[2]);\n    ctx.restore();\n  }\n};\n\n/**\n * Attaches canvas coordinates to the points array.\n * @private\n */\nDygraphCanvasRenderer.prototype._updatePoints = function () {\n  // Update Points\n  // TODO(danvk): here\n  //\n  // TODO(bhs): this loop is a hot-spot for high-point-count charts. These\n  // transformations can be pushed into the canvas via linear transformation\n  // matrices.\n  // NOTE(danvk): this is trickier than it sounds at first. The transformation\n  // needs to be done before the .moveTo() and .lineTo() calls, but must be\n  // undone before the .stroke() call to ensure that the stroke width is\n  // unaffected.  An alternative is to reduce the stroke width in the\n  // transformed coordinate space, but you can't specify different values for\n  // each dimension (as you can with .scale()). The speedup here is ~12%.\n  var sets = this.layout.points;\n  for (var i = sets.length; i--;) {\n    var points = sets[i];\n    for (var j = points.length; j--;) {\n      var point = points[j];\n      point.canvasx = this.area.w * point.x + this.area.x;\n      point.canvasy = this.area.h * point.y + this.area.y;\n    }\n  }\n};\n\n/**\n * Add canvas Actually draw the lines chart, including error bars.\n *\n * This function can only be called if DygraphLayout's points array has been\n * updated with canvas{x,y} attributes, i.e. by\n * DygraphCanvasRenderer._updatePoints.\n *\n * @param {string=} opt_seriesName when specified, only that series will\n *     be drawn. (This is used for expedited redrawing with highlightSeriesOpts)\n * @param {CanvasRenderingContext2D} opt_ctx when specified, the drawing\n *     context.  However, lines are typically drawn on the object's\n *     elementContext.\n * @private\n */\nDygraphCanvasRenderer.prototype._renderLineChart = function (opt_seriesName, opt_ctx) {\n  var ctx = opt_ctx || this.elementContext;\n  var i;\n\n  var sets = this.layout.points;\n  var setNames = this.layout.setNames;\n  var setName;\n\n  this.colors = this.dygraph_.colorsMap_;\n\n  // Determine which series have specialized plotters.\n  var plotter_attr = this.dygraph_.getOption(\"plotter\");\n  var plotters = plotter_attr;\n  if (!__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"B\" /* isArrayLike */](plotters)) {\n    plotters = [plotters];\n  }\n\n  var setPlotters = {}; // series name -> plotter fn.\n  for (i = 0; i < setNames.length; i++) {\n    setName = setNames[i];\n    var setPlotter = this.dygraph_.getOption(\"plotter\", setName);\n    if (setPlotter == plotter_attr) continue; // not specialized.\n\n    setPlotters[setName] = setPlotter;\n  }\n\n  for (i = 0; i < plotters.length; i++) {\n    var plotter = plotters[i];\n    var is_last = i == plotters.length - 1;\n\n    for (var j = 0; j < sets.length; j++) {\n      setName = setNames[j];\n      if (opt_seriesName && setName != opt_seriesName) continue;\n\n      var points = sets[j];\n\n      // Only throw in the specialized plotters on the last iteration.\n      var p = plotter;\n      if (setName in setPlotters) {\n        if (is_last) {\n          p = setPlotters[setName];\n        } else {\n          // Don't use the standard plotters in this case.\n          continue;\n        }\n      }\n\n      var color = this.colors[setName];\n      var strokeWidth = this.dygraph_.getOption(\"strokeWidth\", setName);\n\n      ctx.save();\n      ctx.strokeStyle = color;\n      ctx.lineWidth = strokeWidth;\n      p({\n        points: points,\n        setName: setName,\n        drawingContext: ctx,\n        color: color,\n        strokeWidth: strokeWidth,\n        dygraph: this.dygraph_,\n        axis: this.dygraph_.axisPropertiesForSeries(setName),\n        plotArea: this.area,\n        seriesIndex: j,\n        seriesCount: sets.length,\n        singleSeriesName: opt_seriesName,\n        allSeriesPoints: sets\n      });\n      ctx.restore();\n    }\n  }\n};\n\n/**\n * Standard plotters. These may be used by clients via Dygraph.Plotters.\n * See comments there for more details.\n */\nDygraphCanvasRenderer._Plotters = {\n  linePlotter: function linePlotter(e) {\n    DygraphCanvasRenderer._linePlotter(e);\n  },\n\n  fillPlotter: function fillPlotter(e) {\n    DygraphCanvasRenderer._fillPlotter(e);\n  },\n\n  errorPlotter: function errorPlotter(e) {\n    DygraphCanvasRenderer._errorPlotter(e);\n  }\n};\n\n/**\n * Plotter which draws the central lines for a series.\n * @private\n */\nDygraphCanvasRenderer._linePlotter = function (e) {\n  var g = e.dygraph;\n  var setName = e.setName;\n  var strokeWidth = e.strokeWidth;\n\n  // TODO(danvk): Check if there's any performance impact of just calling\n  // getOption() inside of _drawStyledLine. Passing in so many parameters makes\n  // this code a bit nasty.\n  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) || __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"u\" /* Circles */].DEFAULT;\n  var strokePattern = g.getOption(\"strokePattern\", setName);\n  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\n  if (borderWidth && strokeWidth) {\n    DygraphCanvasRenderer._drawStyledLine(e, g.getOption(\"strokeBorderColor\", setName), strokeWidth + 2 * borderWidth, strokePattern, drawPoints, drawPointCallback, pointSize);\n  }\n\n  DygraphCanvasRenderer._drawStyledLine(e, e.color, strokeWidth, strokePattern, drawPoints, drawPointCallback, pointSize);\n};\n\n/**\n * Draws the shaded error bars/confidence intervals for each series.\n * This happens before the center lines are drawn, since the center lines\n * need to be drawn on top of the error bars for all series.\n * @private\n */\nDygraphCanvasRenderer._errorPlotter = function (e) {\n  var g = e.dygraph;\n  var setName = e.setName;\n  var errorBars = g.getBooleanOption(\"errorBars\") || g.getBooleanOption(\"customBars\");\n  if (!errorBars) return;\n\n  var fillGraph = g.getBooleanOption(\"fillGraph\", setName);\n  if (fillGraph) {\n    console.warn(\"Can't use fillGraph option with error bars\");\n  }\n\n  var ctx = e.drawingContext;\n  var color = e.color;\n  var fillAlpha = g.getNumericOption('fillAlpha', setName);\n  var stepPlot = g.getBooleanOption(\"stepPlot\", setName);\n  var points = e.points;\n\n  var iter = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"R\" /* createIterator */](points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n  var newYs;\n\n  // setup graphics context\n  var prevX = NaN;\n  var prevY = NaN;\n  var prevYs = [-1, -1];\n  // should be same color as the lines but only 15% opaque.\n  var rgb = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"t\" /* toRGB_ */](color);\n  var err_color = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n  ctx.fillStyle = err_color;\n  ctx.beginPath();\n\n  var isNullUndefinedOrNaN = function isNullUndefinedOrNaN(x) {\n    return x === null || x === undefined || isNaN(x);\n  };\n\n  while (iter.hasNext) {\n    var point = iter.next();\n    if (!stepPlot && isNullUndefinedOrNaN(point.y) || stepPlot && !isNaN(prevY) && isNullUndefinedOrNaN(prevY)) {\n      prevX = NaN;\n      continue;\n    }\n\n    newYs = [point.y_bottom, point.y_top];\n    if (stepPlot) {\n      prevY = point.y;\n    }\n\n    // The documentation specifically disallows nulls inside the point arrays,\n    // but in case it happens we should do something sensible.\n    if (isNaN(newYs[0])) newYs[0] = point.y;\n    if (isNaN(newYs[1])) newYs[1] = point.y;\n\n    newYs[0] = e.plotArea.h * newYs[0] + e.plotArea.y;\n    newYs[1] = e.plotArea.h * newYs[1] + e.plotArea.y;\n    if (!isNaN(prevX)) {\n      if (stepPlot) {\n        ctx.moveTo(prevX, prevYs[0]);\n        ctx.lineTo(point.canvasx, prevYs[0]);\n        ctx.lineTo(point.canvasx, prevYs[1]);\n      } else {\n        ctx.moveTo(prevX, prevYs[0]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n        ctx.lineTo(point.canvasx, newYs[1]);\n      }\n      ctx.lineTo(prevX, prevYs[1]);\n      ctx.closePath();\n    }\n    prevYs = newYs;\n    prevX = point.canvasx;\n  }\n  ctx.fill();\n};\n\n/**\n * Proxy for CanvasRenderingContext2D which drops moveTo/lineTo calls which are\n * superfluous. It accumulates all movements which haven't changed the x-value\n * and only applies the two with the most extreme y-values.\n *\n * Calls to lineTo/moveTo must have non-decreasing x-values.\n */\nDygraphCanvasRenderer._fastCanvasProxy = function (context) {\n  var pendingActions = []; // array of [type, x, y] tuples\n  var lastRoundedX = null;\n  var lastFlushedX = null;\n\n  var LINE_TO = 1,\n      MOVE_TO = 2;\n\n  var actionCount = 0; // number of moveTos and lineTos passed to context.\n\n  // Drop superfluous motions\n  // Assumes all pendingActions have the same (rounded) x-value.\n  var compressActions = function compressActions(opt_losslessOnly) {\n    if (pendingActions.length <= 1) return;\n\n    // Lossless compression: drop inconsequential moveTos.\n    for (var i = pendingActions.length - 1; i > 0; i--) {\n      var action = pendingActions[i];\n      if (action[0] == MOVE_TO) {\n        var prevAction = pendingActions[i - 1];\n        if (prevAction[1] == action[1] && prevAction[2] == action[2]) {\n          pendingActions.splice(i, 1);\n        }\n      }\n    }\n\n    // Lossless compression: ... drop consecutive moveTos ...\n    for (var i = 0; i < pendingActions.length - 1;) /* incremented internally */{\n      var action = pendingActions[i];\n      if (action[0] == MOVE_TO && pendingActions[i + 1][0] == MOVE_TO) {\n        pendingActions.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Lossy compression: ... drop all but the extreme y-values ...\n    if (pendingActions.length > 2 && !opt_losslessOnly) {\n      // keep an initial moveTo, but drop all others.\n      var startIdx = 0;\n      if (pendingActions[0][0] == MOVE_TO) startIdx++;\n      var minIdx = null,\n          maxIdx = null;\n      for (var i = startIdx; i < pendingActions.length; i++) {\n        var action = pendingActions[i];\n        if (action[0] != LINE_TO) continue;\n        if (minIdx === null && maxIdx === null) {\n          minIdx = i;\n          maxIdx = i;\n        } else {\n          var y = action[2];\n          if (y < pendingActions[minIdx][2]) {\n            minIdx = i;\n          } else if (y > pendingActions[maxIdx][2]) {\n            maxIdx = i;\n          }\n        }\n      }\n      var minAction = pendingActions[minIdx],\n          maxAction = pendingActions[maxIdx];\n      pendingActions.splice(startIdx, pendingActions.length - startIdx);\n      if (minIdx < maxIdx) {\n        pendingActions.push(minAction);\n        pendingActions.push(maxAction);\n      } else if (minIdx > maxIdx) {\n        pendingActions.push(maxAction);\n        pendingActions.push(minAction);\n      } else {\n        pendingActions.push(minAction);\n      }\n    }\n  };\n\n  var flushActions = function flushActions(opt_noLossyCompression) {\n    compressActions(opt_noLossyCompression);\n    for (var i = 0, len = pendingActions.length; i < len; i++) {\n      var action = pendingActions[i];\n      if (action[0] == LINE_TO) {\n        context.lineTo(action[1], action[2]);\n      } else if (action[0] == MOVE_TO) {\n        context.moveTo(action[1], action[2]);\n      }\n    }\n    if (pendingActions.length) {\n      lastFlushedX = pendingActions[pendingActions.length - 1][1];\n    }\n    actionCount += pendingActions.length;\n    pendingActions = [];\n  };\n\n  var addAction = function addAction(action, x, y) {\n    var rx = Math.round(x);\n    if (lastRoundedX === null || rx != lastRoundedX) {\n      // if there are large gaps on the x-axis, it's essential to keep the\n      // first and last point as well.\n      var hasGapOnLeft = lastRoundedX - lastFlushedX > 1,\n          hasGapOnRight = rx - lastRoundedX > 1,\n          hasGap = hasGapOnLeft || hasGapOnRight;\n      flushActions(hasGap);\n      lastRoundedX = rx;\n    }\n    pendingActions.push([action, x, y]);\n  };\n\n  return {\n    moveTo: function moveTo(x, y) {\n      addAction(MOVE_TO, x, y);\n    },\n    lineTo: function lineTo(x, y) {\n      addAction(LINE_TO, x, y);\n    },\n\n    // for major operations like stroke/fill, we skip compression to ensure\n    // that there are no artifacts at the right edge.\n    stroke: function stroke() {\n      flushActions(true);context.stroke();\n    },\n    fill: function fill() {\n      flushActions(true);context.fill();\n    },\n    beginPath: function beginPath() {\n      flushActions(true);context.beginPath();\n    },\n    closePath: function closePath() {\n      flushActions(true);context.closePath();\n    },\n\n    _count: function _count() {\n      return actionCount;\n    }\n  };\n};\n\n/**\n * Draws the shaded regions when \"fillGraph\" is set. Not to be confused with\n * error bars.\n *\n * For stacked charts, it's more convenient to handle all the series\n * simultaneously. So this plotter plots all the points on the first series\n * it's asked to draw, then ignores all the other series.\n *\n * @private\n */\nDygraphCanvasRenderer._fillPlotter = function (e) {\n  // Skip if we're drawing a single series for interactive highlight overlay.\n  if (e.singleSeriesName) return;\n\n  // We'll handle all the series at once, not one-by-one.\n  if (e.seriesIndex !== 0) return;\n\n  var g = e.dygraph;\n  var setNames = g.getLabels().slice(1); // remove x-axis\n\n  // getLabels() includes names for invisible series, which are not included in\n  // allSeriesPoints. We remove those to make the two match.\n  // TODO(danvk): provide a simpler way to get this information.\n  for (var i = setNames.length; i >= 0; i--) {\n    if (!g.visibility()[i]) setNames.splice(i, 1);\n  }\n\n  var anySeriesFilled = function () {\n    for (var i = 0; i < setNames.length; i++) {\n      if (g.getBooleanOption(\"fillGraph\", setNames[i])) return true;\n    }\n    return false;\n  }();\n\n  if (!anySeriesFilled) return;\n\n  var area = e.plotArea;\n  var sets = e.allSeriesPoints;\n  var setCount = sets.length;\n\n  var stackedGraph = g.getBooleanOption(\"stackedGraph\");\n  var colors = g.getColors();\n\n  // For stacked graphs, track the baseline for filling.\n  //\n  // The filled areas below graph lines are trapezoids with two\n  // vertical edges. The top edge is the line segment being drawn, and\n  // the baseline is the bottom edge. Each baseline corresponds to the\n  // top line segment from the previous stacked line. In the case of\n  // step plots, the trapezoids are rectangles.\n  var baseline = {};\n  var currBaseline;\n  var prevStepPlot; // for different line drawing modes (line/step) per series\n\n  // Helper function to trace a line back along the baseline.\n  var traceBackPath = function traceBackPath(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    if (stackedGraph) {\n      for (var i = pathBack.length - 1; i >= 0; i--) {\n        var pt = pathBack[i];\n        ctx.lineTo(pt[0], pt[1]);\n      }\n    }\n  };\n\n  // process sets in reverse order (needed for stacked graphs)\n  for (var setIdx = setCount - 1; setIdx >= 0; setIdx--) {\n    var ctx = e.drawingContext;\n    var setName = setNames[setIdx];\n    if (!g.getBooleanOption('fillGraph', setName)) continue;\n\n    var fillAlpha = g.getNumericOption('fillAlpha', setName);\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n    var color = colors[setIdx];\n    var axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n    var points = sets[setIdx];\n    var iter = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"R\" /* createIterator */](points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    // setup graphics context\n    var prevX = NaN;\n    var prevYs = [-1, -1];\n    var newYs;\n    // should be same color as the lines but only 15% opaque.\n    var rgb = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"t\" /* toRGB_ */](color);\n    var err_color = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x,\n        is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || __WEBPACK_IMPORTED_MODULE_1__dygraph__[\"a\" /* default */].FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // For filled charts, we draw points from left to right, then back along\n    // the x-axis to complete a shape for filling.\n    // For stacked plots, this \"back path\" is a more complex shape. This array\n    // stores the [x, y] values needed to trace that shape.\n    var pathBack = [];\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"S\" /* isOK */](point.y) && !stepPlot) {\n        traceBackPath(ctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (stackedGraph) {\n        if (!is_first && last_x == point.xval) {\n          continue;\n        } else {\n          is_first = false;\n          last_x = point.xval;\n        }\n\n        currBaseline = baseline[point.canvasx];\n        var lastY;\n        if (currBaseline === undefined) {\n          lastY = axisY;\n        } else {\n          if (prevStepPlot) {\n            lastY = currBaseline[0];\n          } else {\n            lastY = currBaseline;\n          }\n        }\n        newYs = [point.canvasy, lastY];\n\n        if (stepPlot) {\n          // Step plots must keep track of the top and bottom of\n          // the baseline at each point.\n          if (prevYs[0] === -1) {\n            baseline[point.canvasx] = [point.canvasy, axisY];\n          } else {\n            baseline[point.canvasx] = [point.canvasy, prevYs[0]];\n          }\n        } else {\n          baseline[point.canvasx] = point.canvasy;\n        }\n      } else {\n        if (isNaN(point.canvasy) && stepPlot) {\n          newYs = [area.y + area.h, axisY];\n        } else {\n          newYs = [point.canvasy, axisY];\n        }\n      }\n      if (!isNaN(prevX)) {\n        // Move to top fill point\n        if (stepPlot) {\n          ctx.lineTo(point.canvasx, prevYs[0]);\n          ctx.lineTo(point.canvasx, newYs[0]);\n        } else {\n          ctx.lineTo(point.canvasx, newYs[0]);\n        }\n\n        // Record the baseline for the reverse path.\n        if (stackedGraph) {\n          pathBack.push([prevX, prevYs[1]]);\n          if (prevStepPlot && currBaseline) {\n            // Draw to the bottom of the baseline\n            pathBack.push([point.canvasx, currBaseline[1]]);\n          } else {\n            pathBack.push([point.canvasx, newYs[1]]);\n          }\n        }\n      } else {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n    }\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      traceBackPath(ctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DygraphCanvasRenderer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLWNhbnZhcy5qcz9mMjg0Il0sIm5hbWVzIjpbIkR5Z3JhcGhDYW52YXNSZW5kZXJlciIsImR5Z3JhcGgiLCJlbGVtZW50IiwiZWxlbWVudENvbnRleHQiLCJsYXlvdXQiLCJkeWdyYXBoXyIsImhlaWdodCIsImhlaWdodF8iLCJ3aWR0aCIsIndpZHRoXyIsImFyZWEiLCJnZXRQbG90QXJlYSIsImN0eCIsImNhbnZhc19jdHhfIiwiYmVnaW5QYXRoIiwicmVjdCIsIngiLCJ5IiwidyIsImgiLCJjbGlwIiwiaGlkZGVuX2N0eF8iLCJwcm90b3R5cGUiLCJjbGVhciIsImNsZWFyUmVjdCIsInJlbmRlciIsIl91cGRhdGVQb2ludHMiLCJfcmVuZGVyTGluZUNoYXJ0IiwiX2dldEl0ZXJhdG9yUHJlZGljYXRlIiwiY29ubmVjdFNlcGFyYXRlZFBvaW50cyIsIl9wcmVkaWNhdGVUaGF0U2tpcHNFbXB0eVBvaW50cyIsImFycmF5IiwiaWR4IiwieXZhbCIsIl9kcmF3U3R5bGVkTGluZSIsImUiLCJjb2xvciIsInN0cm9rZVdpZHRoIiwic3Ryb2tlUGF0dGVybiIsImRyYXdQb2ludHMiLCJkcmF3UG9pbnRDYWxsYmFjayIsInBvaW50U2l6ZSIsImciLCJzdGVwUGxvdCIsImdldEJvb2xlYW5PcHRpb24iLCJzZXROYW1lIiwiZHJhd0dhcFBvaW50cyIsInBvaW50cyIsIml0ZXIiLCJsZW5ndGgiLCJzdHJva2luZyIsImRyYXdpbmdDb250ZXh0Iiwic2F2ZSIsInNldExpbmVEYXNoIiwicG9pbnRzT25MaW5lIiwiX2RyYXdTZXJpZXMiLCJfZHJhd1BvaW50c09uTGluZSIsInJlc3RvcmUiLCJwcmV2Q2FudmFzWCIsInByZXZDYW52YXNZIiwibmV4dENhbnZhc1kiLCJpc0lzb2xhdGVkIiwicG9pbnQiLCJmaXJzdCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwiYXJyIiwiYXJyYXlfIiwibGltaXQiLCJlbmRfIiwicHJlZGljYXRlIiwicHJlZGljYXRlXyIsImkiLCJzdGFydF8iLCJjYW52YXN5IiwibW92ZVRvIiwibGluZVRvIiwiY2FudmFzeCIsIm5leHRJZHhfIiwibmV4dCIsImhhc05leHQiLCJwZWVrIiwiaXNOZXh0Q2FudmFzWU51bGxPck5hTiIsInB1c2giLCJzdHJva2UiLCJjYiIsImNhbGwiLCJzZXRzIiwiaiIsIm9wdF9zZXJpZXNOYW1lIiwib3B0X2N0eCIsInNldE5hbWVzIiwiY29sb3JzIiwiY29sb3JzTWFwXyIsInBsb3R0ZXJfYXR0ciIsImdldE9wdGlvbiIsInBsb3R0ZXJzIiwic2V0UGxvdHRlcnMiLCJzZXRQbG90dGVyIiwicGxvdHRlciIsImlzX2xhc3QiLCJwIiwiYXhpcyIsImF4aXNQcm9wZXJ0aWVzRm9yU2VyaWVzIiwicGxvdEFyZWEiLCJzZXJpZXNJbmRleCIsInNlcmllc0NvdW50Iiwic2luZ2xlU2VyaWVzTmFtZSIsImFsbFNlcmllc1BvaW50cyIsIl9QbG90dGVycyIsImxpbmVQbG90dGVyIiwiX2xpbmVQbG90dGVyIiwiZmlsbFBsb3R0ZXIiLCJfZmlsbFBsb3R0ZXIiLCJlcnJvclBsb3R0ZXIiLCJfZXJyb3JQbG90dGVyIiwiYm9yZGVyV2lkdGgiLCJnZXROdW1lcmljT3B0aW9uIiwiREVGQVVMVCIsImVycm9yQmFycyIsImZpbGxHcmFwaCIsImNvbnNvbGUiLCJ3YXJuIiwiZmlsbEFscGhhIiwibmV3WXMiLCJwcmV2WCIsIk5hTiIsInByZXZZIiwicHJldllzIiwicmdiIiwiZXJyX2NvbG9yIiwiciIsImIiLCJmaWxsU3R5bGUiLCJpc051bGxVbmRlZmluZWRPck5hTiIsInVuZGVmaW5lZCIsImlzTmFOIiwieV9ib3R0b20iLCJ5X3RvcCIsImNsb3NlUGF0aCIsImZpbGwiLCJfZmFzdENhbnZhc1Byb3h5IiwiY29udGV4dCIsInBlbmRpbmdBY3Rpb25zIiwibGFzdFJvdW5kZWRYIiwibGFzdEZsdXNoZWRYIiwiTElORV9UTyIsIk1PVkVfVE8iLCJhY3Rpb25Db3VudCIsImNvbXByZXNzQWN0aW9ucyIsIm9wdF9sb3NzbGVzc09ubHkiLCJhY3Rpb24iLCJwcmV2QWN0aW9uIiwic3BsaWNlIiwic3RhcnRJZHgiLCJtaW5JZHgiLCJtYXhJZHgiLCJtaW5BY3Rpb24iLCJtYXhBY3Rpb24iLCJmbHVzaEFjdGlvbnMiLCJvcHRfbm9Mb3NzeUNvbXByZXNzaW9uIiwibGVuIiwiYWRkQWN0aW9uIiwicngiLCJNYXRoIiwicm91bmQiLCJoYXNHYXBPbkxlZnQiLCJoYXNHYXBPblJpZ2h0IiwiaGFzR2FwIiwiX2NvdW50IiwiZ2V0TGFiZWxzIiwic2xpY2UiLCJ2aXNpYmlsaXR5IiwiYW55U2VyaWVzRmlsbGVkIiwic2V0Q291bnQiLCJzdGFja2VkR3JhcGgiLCJnZXRDb2xvcnMiLCJiYXNlbGluZSIsImN1cnJCYXNlbGluZSIsInByZXZTdGVwUGxvdCIsInRyYWNlQmFja1BhdGgiLCJiYXNlbGluZVgiLCJiYXNlbGluZVkiLCJwYXRoQmFjayIsInB0Iiwic2V0SWR4IiwiYXhpc1kiLCJtaW55dmFsIiwieXNjYWxlIiwibGFzdF94IiwiaXNfZmlyc3QiLCJEeWdyYXBoIiwiRk9SQ0VfRkFTVF9QUk9YWSIsInlfc3RhY2tlZCIsInh2YWwiLCJsYXN0WSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQUE7Ozs7OztBQU1BOzs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLElBQUlBLHdCQUF3QixTQUF4QkEscUJBQXdCLENBQVNDLE9BQVQsRUFBa0JDLE9BQWxCLEVBQTJCQyxjQUEzQixFQUEyQ0MsTUFBM0MsRUFBbUQ7QUFDN0UsT0FBS0MsUUFBTCxHQUFnQkosT0FBaEI7O0FBRUEsT0FBS0csTUFBTCxHQUFjQSxNQUFkO0FBQ0EsT0FBS0YsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsT0FBS0MsY0FBTCxHQUFzQkEsY0FBdEI7O0FBRUEsT0FBS0csTUFBTCxHQUFjTCxRQUFRTSxPQUF0QjtBQUNBLE9BQUtDLEtB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QUFDQWhILFlBQUlnRSxNQUFKLENBQVdkLE1BQU1lLE9BQWpCLEVBQTBCK0MsTUFBTSxDQUFOLENBQTFCO0FBQ0Q7QUFDREksZUFBU0osS0FBVDtBQUNBQyxjQUFRL0QsTUFBTWUsT0FBZDtBQUNEO0FBQ0RzRyxtQkFBZXhJLFFBQWY7QUFDQSxRQUFJaUYsU0FBUzlELEtBQWIsRUFBb0I7QUFDbEJzSCxvQkFBY3hLLEdBQWQsRUFBbUJrRCxNQUFNZSxPQUF6QixFQUFrQytDLE1BQU0sQ0FBTixDQUFsQyxFQUE0QzJELFFBQTVDO0FBQ0FBLGlCQUFXLEVBQVg7QUFDRDtBQUNEM0ssUUFBSWdJLElBQUo7QUFDRDtBQUNGLENBM0xEOztBQTZMQSx5REFBZTVJLHFCQUFmIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAwNiBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBCYXNlZCBvbiBQbG90S2l0LkNhbnZhc1JlbmRlcmVyLCBidXQgbW9kaWZpZWQgdG8gbWVldCB0aGVcbiAqIG5lZWRzIG9mIGR5Z3JhcGhzLlxuICpcbiAqIEluIHBhcnRpY3VsYXIsIHN1cHBvcnQgZm9yOlxuICogLSBncmlkIG92ZXJsYXlzXG4gKiAtIGVycm9yIGJhcnNcbiAqIC0gZHlncmFwaHMgYXR0cmlidXRlIHN5c3RlbVxuICovXG5cbi8qKlxuICogVGhlIER5Z3JhcGhDYW52YXNSZW5kZXJlciBjbGFzcyBkb2VzIHRoZSBhY3R1YWwgcmVuZGVyaW5nIG9mIHRoZSBjaGFydCBvbnRvXG4gKiBhIGNhbnZhcy4gSXQncyBiYXNlZCBvbiBQbG90S2l0LkNhbnZhc1JlbmRlcmVyLlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgVGhlIGNhbnZhcyB0byBhdHRhY2ggdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50Q29udGV4dCBUaGUgMmQgY29udGV4dCBvZiB0aGUgY2FudmFzIChpbmplY3RlZCBzbyBpdFxuICogY2FuIGJlIG1vY2tlZCBmb3IgdGVzdGluZy4pXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IFRoZSBEeWdyYXBoTGF5b3V0IG9iamVjdCBmb3IgdGhpcyBncmFwaC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2R5Z3JhcGgtdXRpbHMnO1xuaW1wb3J0IER5Z3JhcGggZnJvbSAnLi9keWdyYXBoJztcblxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiB0aGVyZSBhcmUgXCJuZXcgcG9pbnRzXCIgdG8gY2hhcnQuIFRoaXMgaXMgZ2VuZXJhbGx5IHRoZVxuICogY2FzZSB3aGVuIHRoZSB1bmRlcmx5aW5nIGRhdGEgYmVpbmcgY2hhcnRlZCBoYXMgY2hhbmdlZC4gSXQgaXMgX25vdF8gY2FsbGVkXG4gKiBpbiB0aGUgY29tbW9uIGNhc2UgdGhhdCB0aGUgdXNlciBoYXMgem9vbWVkIG9yIGlzIHBhbm5pbmcgdGhlIHZpZXcuXG4gKlxuICogVGhlIGNoYXJ0IGNhbnZhcyBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgYnkgdGhlIER5Z3JhcGggb2JqZWN0LiBUaGVcbiAqIHJlbmRlcmVyIHNpbXBseSBnZXRzIGEgZHJhd2luZyBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7RHlncmFwaH0gZHlncmFwaCBUaGUgY2hhcnQgdG8gd2hpY2ggdGhpcyByZW5kZXJlciBiZWxvbmdzLlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gZWxlbWVudCBUaGUgJmx0O2NhbnZhcyZndDsgRE9NIGVsZW1lbnQgb24gd2hpY2ggdG8gZHJhdy5cbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBlbGVtZW50Q29udGV4dCBUaGUgZHJhd2luZyBjb250ZXh0LlxuICogQHBhcmFtIHtEeWdyYXBoTGF5b3V0fSBsYXlvdXQgVGhlIGNoYXJ0J3MgRHlncmFwaExheW91dCBvYmplY3QuXG4gKlxuICogVE9ETyhkYW52ayk6IHJlbW92ZSB0aGUgZWxlbWVudENvbnRleHQgcHJvcGVydHkuXG4gKi9cbnZhciBEeWdyYXBoQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbihkeWdyYXBoLCBlbGVtZW50LCBlbGVtZW50Q29udGV4dCwgbGF5b3V0KSB7XG4gIHRoaXMuZHlncmFwaF8gPSBkeWdyYXBoO1xuXG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLmVsZW1lbnRDb250ZXh0ID0gZWxlbWVudENvbnRleHQ7XG5cbiAgdGhpcy5oZWlnaHQgPSBkeWdyYXBoLmhlaWdodF87XG4gIHRoaXMud2lkdGggPSBkeWdyYXBoLndpZHRoXztcblxuICAvLyAtLS0gY2hlY2sgd2hldGhlciBldmVyeXRoaW5nIGlzIG9rIGJlZm9yZSB3ZSByZXR1cm5cbiAgaWYgKCF1dGlscy5pc0NhbnZhc1N1cHBvcnRlZCh0aGlzLmVsZW1lbnQpKSB7XG4gICAgdGhyb3cgXCJDYW52YXMgaXMgbm90IHN1cHBvcnRlZC5cIjtcbiAgfVxuXG4gIC8vIGludGVybmFsIHN0YXRlXG4gIHRoaXMuYXJlYSA9IGxheW91dC5nZXRQbG90QXJlYSgpO1xuXG4gIC8vIFNldCB1cCBhIGNsaXBwaW5nIGFyZWEgZm9yIHRoZSBjYW52YXMgKGFuZCB0aGUgaW50ZXJhY3Rpb24gY2FudmFzKS5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3Qgb3ZlcmRyYXcuXG4gIHZhciBjdHggPSB0aGlzLmR5Z3JhcGhfLmNhbnZhc19jdHhfO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5yZWN0KHRoaXMuYXJlYS54LCB0aGlzLmFyZWEueSwgdGhpcy5hcmVhLncsIHRoaXMuYXJlYS5oKTtcbiAgY3R4LmNsaXAoKTtcblxuICBjdHggPSB0aGlzLmR5Z3JhcGhfLmhpZGRlbl9jdHhfO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5yZWN0KHRoaXMuYXJlYS54LCB0aGlzLmFyZWEueSwgdGhpcy5hcmVhLncsIHRoaXMuYXJlYS5oKTtcbiAgY3R4LmNsaXAoKTtcbn07XG5cbi8qKlxuICogQ2xlYXJzIG91dCBhbGwgY2hhcnQgY29udGVudCBhbmQgRE9NIGVsZW1lbnRzLlxuICogVGhpcyBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgYmVmb3JlIHJlbmRlcigpIG9uIGV2ZXJ5IGZyYW1lLCBpbmNsdWRpbmdcbiAqIGR1cmluZyB6b29tcyBhbmQgcGFucy5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbGVtZW50Q29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyBldmVyeXRoaW5nIG9uIHRoZSBjaGFydCwgaW5jbHVkaW5nXG4gKiBsaW5lcywgZXJyb3IgYmFycywgZmlsbHMgYW5kIGF4ZXMuXG4gKiBJdCBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgY2xlYXIoKSBvbiBldmVyeSBmcmFtZSwgaW5jbHVkaW5nIGR1cmluZyBwYW5zXG4gKiBhbmQgem9vbXMuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAvLyBhdHRhY2hlcyBwb2ludC5jYW52YXN7eCx5fVxuICB0aGlzLl91cGRhdGVQb2ludHMoKTtcblxuICAvLyBhY3R1YWxseSBkcmF3cyB0aGUgY2hhcnQuXG4gIHRoaXMuX3JlbmRlckxpbmVDaGFydCgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJlZGljYXRlIHRvIGJlIHVzZWQgd2l0aCBhbiBpdGVyYXRvciwgd2hpY2ggd2lsbFxuICogaXRlcmF0ZSBvdmVyIHBvaW50cyBhcHByb3ByaWF0ZWx5LCBkZXBlbmRpbmcgb24gd2hldGhlclxuICogY29ubmVjdFNlcGFyYXRlZFBvaW50cyBpcyB0cnVlLiBXaGVuIGl0J3MgZmFsc2UsIHRoZSBwcmVkaWNhdGUgd2lsbFxuICogc2tpcCBvdmVyIHBvaW50cyB3aXRoIG1pc3NpbmcgeVZhbHMuXG4gKi9cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5fZ2V0SXRlcmF0b3JQcmVkaWNhdGUgPSBmdW5jdGlvbihjb25uZWN0U2VwYXJhdGVkUG9pbnRzKSB7XG4gIHJldHVybiBjb25uZWN0U2VwYXJhdGVkUG9pbnRzID9cbiAgICAgIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fcHJlZGljYXRlVGhhdFNraXBzRW1wdHlQb2ludHMgOlxuICAgICAgbnVsbDtcbn07XG5cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5fcHJlZGljYXRlVGhhdFNraXBzRW1wdHlQb2ludHMgPVxuICAgIGZ1bmN0aW9uKGFycmF5LCBpZHgpIHtcbiAgcmV0dXJuIGFycmF5W2lkeF0ueXZhbCAhPT0gbnVsbDtcbn07XG5cbi8qKlxuICogRHJhd3MgYSBsaW5lIHdpdGggdGhlIHN0eWxlcyBwYXNzZWQgaW4gYW5kIGNhbGxzIGFsbCB0aGUgZHJhd1BvaW50Q2FsbGJhY2tzLlxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGRpY3Rpb25hcnkgcGFzc2VkIHRvIHRoZSBwbG90dGVyIGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3U3R5bGVkTGluZSA9IGZ1bmN0aW9uKGUsXG4gICAgY29sb3IsIHN0cm9rZVdpZHRoLCBzdHJva2VQYXR0ZXJuLCBkcmF3UG9pbnRzLFxuICAgIGRyYXdQb2ludENhbGxiYWNrLCBwb2ludFNpemUpIHtcbiAgdmFyIGcgPSBlLmR5Z3JhcGg7XG4gIC8vIFRPRE8oa29uaWdzYmVyZyk6IENvbXB1dGUgYXR0cmlidXRlcyBvdXRzaWRlIHRoaXMgbWV0aG9kIGNhbGwuXG4gIHZhciBzdGVwUGxvdCA9IGcuZ2V0Qm9vbGVhbk9wdGlvbihcInN0ZXBQbG90XCIsIGUuc2V0TmFtZSk7XG5cbiAgaWYgKCF1dGlscy5pc0FycmF5TGlrZShzdHJva2VQYXR0ZXJuKSkge1xuICAgIHN0cm9rZVBhdHRlcm4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGRyYXdHYXBQb2ludHMgPSBnLmdldEJvb2xlYW5PcHRpb24oJ2RyYXdHYXBFZGdlUG9pbnRzJywgZS5zZXROYW1lKTtcblxuICB2YXIgcG9pbnRzID0gZS5wb2ludHM7XG4gIHZhciBzZXROYW1lID0gZS5zZXROYW1lO1xuICB2YXIgaXRlciA9IHV0aWxzLmNyZWF0ZUl0ZXJhdG9yKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCxcbiAgICAgIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fZ2V0SXRlcmF0b3JQcmVkaWNhdGUoXG4gICAgICAgICAgZy5nZXRCb29sZWFuT3B0aW9uKFwiY29ubmVjdFNlcGFyYXRlZFBvaW50c1wiLCBzZXROYW1lKSkpO1xuXG4gIHZhciBzdHJva2luZyA9IHN0cm9rZVBhdHRlcm4gJiYgKHN0cm9rZVBhdHRlcm4ubGVuZ3RoID49IDIpO1xuXG4gIHZhciBjdHggPSBlLmRyYXdpbmdDb250ZXh0O1xuICBjdHguc2F2ZSgpO1xuICBpZiAoc3Ryb2tpbmcpIHtcbiAgICBpZiAoY3R4LnNldExpbmVEYXNoKSBjdHguc2V0TGluZURhc2goc3Ryb2tlUGF0dGVybik7XG4gIH1cblxuICB2YXIgcG9pbnRzT25MaW5lID0gRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3U2VyaWVzKFxuICAgICAgZSwgaXRlciwgc3Ryb2tlV2lkdGgsIHBvaW50U2l6ZSwgZHJhd1BvaW50cywgZHJhd0dhcFBvaW50cywgc3RlcFBsb3QsIGNvbG9yKTtcbiAgRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3UG9pbnRzT25MaW5lKFxuICAgICAgZSwgcG9pbnRzT25MaW5lLCBkcmF3UG9pbnRDYWxsYmFjaywgY29sb3IsIHBvaW50U2l6ZSk7XG5cbiAgaWYgKHN0cm9raW5nKSB7XG4gICAgaWYgKGN0eC5zZXRMaW5lRGFzaCkgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgfVxuXG4gIGN0eC5yZXN0b3JlKCk7XG59O1xuXG4vKipcbiAqIFRoaXMgZG9lcyB0aGUgYWN0dWFsIGRyYXdpbmcgb2YgbGluZXMgb24gdGhlIGNhbnZhcywgZm9yIGp1c3Qgb25lIHNlcmllcy5cbiAqIFJldHVybnMgYSBsaXN0IG9mIFtjYW52YXN4LCBjYW52YXN5XSBwYWlycyBmb3IgcG9pbnRzIGZvciB3aGljaCBhXG4gKiBkcmF3UG9pbnRDYWxsYmFjayBzaG91bGQgYmUgZmlyZWQuICBUaGVzZSBpbmNsdWRlIGlzb2xhdGVkIHBvaW50cywgb3IgYWxsXG4gKiBwb2ludHMgaWYgZHJhd1BvaW50cz10cnVlLlxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGRpY3Rpb25hcnkgcGFzc2VkIHRvIHRoZSBwbG90dGVyIGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3U2VyaWVzID0gZnVuY3Rpb24oZSxcbiAgICBpdGVyLCBzdHJva2VXaWR0aCwgcG9pbnRTaXplLCBkcmF3UG9pbnRzLCBkcmF3R2FwUG9pbnRzLCBzdGVwUGxvdCwgY29sb3IpIHtcblxuICB2YXIgcHJldkNhbnZhc1ggPSBudWxsO1xuICB2YXIgcHJldkNhbnZhc1kgPSBudWxsO1xuICB2YXIgbmV4dENhbnZhc1kgPSBudWxsO1xuICB2YXIgaXNJc29sYXRlZDsgLy8gdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGlzb2xhdGVkIChubyBsaW5lIHNlZ21lbnRzKVxuICB2YXIgcG9pbnQ7IC8vIHRoZSBwb2ludCBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHdoaWxlIGxvb3BcbiAgdmFyIHBvaW50c09uTGluZSA9IFtdOyAvLyBBcnJheSBvZiBbY2FudmFzeCwgY2FudmFzeV0gcGFpcnMuXG4gIHZhciBmaXJzdCA9IHRydWU7IC8vIHRoZSBmaXJzdCBjeWNsZSB0aHJvdWdoIHRoZSB3aGlsZSBsb29wXG5cbiAgdmFyIGN0eCA9IGUuZHJhd2luZ0NvbnRleHQ7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gIGN0eC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcblxuICAvLyBOT1RFOiB3ZSBicmVhayB0aGUgaXRlcmF0b3IncyBlbmNhcHN1bGF0aW9uIGhlcmUgZm9yIGFib3V0IGEgMjUlIHNwZWVkdXAuXG4gIHZhciBhcnIgPSBpdGVyLmFycmF5XztcbiAgdmFyIGxpbWl0ID0gaXRlci5lbmRfO1xuICB2YXIgcHJlZGljYXRlID0gaXRlci5wcmVkaWNhdGVfO1xuXG4gIGZvciAodmFyIGkgPSBpdGVyLnN0YXJ0XzsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICBwb2ludCA9IGFycltpXTtcbiAgICBpZiAocHJlZGljYXRlKSB7XG4gICAgICB3aGlsZSAoaSA8IGxpbWl0ICYmICFwcmVkaWNhdGUoYXJyLCBpKSkge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBpZiAoaSA9PSBsaW1pdCkgYnJlYWs7XG4gICAgICBwb2ludCA9IGFycltpXTtcbiAgICB9XG5cbiAgICAvLyBGSVhNRTogVGhlICdjYW52YXN5ICE9IGNhbnZhc3knIHRlc3QgaGVyZSBjYXRjaGVzIE5hTiB2YWx1ZXMgYnV0IHRoZSB0ZXN0XG4gICAgLy8gZG9lc24ndCBjYXRjaCBJbmZpbml0eSB2YWx1ZXMuIENvdWxkIGNoYW5nZSB0aGlzIHRvXG4gICAgLy8gIWlzRmluaXRlKHBvaW50LmNhbnZhc3kpLCBidXQgSSBhc3N1bWUgaXQgYXZvaWRzIGlzTmFOIGZvciBwZXJmb3JtYW5jZT9cbiAgICBpZiAocG9pbnQuY2FudmFzeSA9PT0gbnVsbCB8fCBwb2ludC5jYW52YXN5ICE9IHBvaW50LmNhbnZhc3kpIHtcbiAgICAgIGlmIChzdGVwUGxvdCAmJiBwcmV2Q2FudmFzWCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBEcmF3IGEgaG9yaXpvbnRhbCBsaW5lIHRvIHRoZSBzdGFydCBvZiB0aGUgbWlzc2luZyBkYXRhXG4gICAgICAgIGN0eC5tb3ZlVG8ocHJldkNhbnZhc1gsIHByZXZDYW52YXNZKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludC5jYW52YXN4LCBwcmV2Q2FudmFzWSk7XG4gICAgICB9XG4gICAgICBwcmV2Q2FudmFzWCA9IHByZXZDYW52YXNZID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNJc29sYXRlZCA9IGZhbHNlO1xuICAgICAgaWYgKGRyYXdHYXBQb2ludHMgfHwgcHJldkNhbnZhc1ggPT09IG51bGwpIHtcbiAgICAgICAgaXRlci5uZXh0SWR4XyA9IGk7XG4gICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICBuZXh0Q2FudmFzWSA9IGl0ZXIuaGFzTmV4dCA/IGl0ZXIucGVlay5jYW52YXN5IDogbnVsbDtcblxuICAgICAgICB2YXIgaXNOZXh0Q2FudmFzWU51bGxPck5hTiA9IG5leHRDYW52YXNZID09PSBudWxsIHx8XG4gICAgICAgICAgICBuZXh0Q2FudmFzWSAhPSBuZXh0Q2FudmFzWTtcbiAgICAgICAgaXNJc29sYXRlZCA9IChwcmV2Q2FudmFzWCA9PT0gbnVsbCAmJiBpc05leHRDYW52YXNZTnVsbE9yTmFOKTtcbiAgICAgICAgaWYgKGRyYXdHYXBQb2ludHMpIHtcbiAgICAgICAgICAvLyBBbHNvIGNvbnNpZGVyIGEgcG9pbnQgdG8gYmUgXCJpc29sYXRlZFwiIGlmIGl0J3MgYWRqYWNlbnQgdG8gYVxuICAgICAgICAgIC8vIG51bGwgcG9pbnQsIGV4Y2x1ZGluZyB0aGUgZ3JhcGggZWRnZXMuXG4gICAgICAgICAgaWYgKCghZmlyc3QgJiYgcHJldkNhbnZhc1ggPT09IG51bGwpIHx8XG4gICAgICAgICAgICAgIChpdGVyLmhhc05leHQgJiYgaXNOZXh0Q2FudmFzWU51bGxPck5hTikpIHtcbiAgICAgICAgICAgIGlzSXNvbGF0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJldkNhbnZhc1ggIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0cm9rZVdpZHRoKSB7XG4gICAgICAgICAgaWYgKHN0ZXBQbG90KSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHByZXZDYW52YXNYLCBwcmV2Q2FudmFzWSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBvaW50LmNhbnZhc3gsIHByZXZDYW52YXNZKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdHgubGluZVRvKHBvaW50LmNhbnZhc3gsIHBvaW50LmNhbnZhc3kpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHgubW92ZVRvKHBvaW50LmNhbnZhc3gsIHBvaW50LmNhbnZhc3kpO1xuICAgICAgfVxuICAgICAgaWYgKGRyYXdQb2ludHMgfHwgaXNJc29sYXRlZCkge1xuICAgICAgICBwb2ludHNPbkxpbmUucHVzaChbcG9pbnQuY2FudmFzeCwgcG9pbnQuY2FudmFzeSwgcG9pbnQuaWR4XSk7XG4gICAgICB9XG4gICAgICBwcmV2Q2FudmFzWCA9IHBvaW50LmNhbnZhc3g7XG4gICAgICBwcmV2Q2FudmFzWSA9IHBvaW50LmNhbnZhc3k7XG4gICAgfVxuICAgIGZpcnN0ID0gZmFsc2U7XG4gIH1cbiAgY3R4LnN0cm9rZSgpO1xuICByZXR1cm4gcG9pbnRzT25MaW5lO1xufTtcblxuLyoqXG4gKiBUaGlzIGZpcmVzIHRoZSBkcmF3UG9pbnRDYWxsYmFjayBmdW5jdGlvbnMsIHdoaWNoIGRyYXcgZG90cyBvbiB0aGUgcG9pbnRzIGJ5XG4gKiBkZWZhdWx0LiBUaGlzIGdldHMgdXNlZCB3aGVuIHRoZSBcImRyYXdQb2ludHNcIiBvcHRpb24gaXMgc2V0LCBvciB3aGVuIHRoZXJlXG4gKiBhcmUgaXNvbGF0ZWQgcG9pbnRzLlxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGRpY3Rpb25hcnkgcGFzc2VkIHRvIHRoZSBwbG90dGVyIGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3UG9pbnRzT25MaW5lID0gZnVuY3Rpb24oXG4gICAgZSwgcG9pbnRzT25MaW5lLCBkcmF3UG9pbnRDYWxsYmFjaywgY29sb3IsIHBvaW50U2l6ZSkge1xuICB2YXIgY3R4ID0gZS5kcmF3aW5nQ29udGV4dDtcbiAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgcG9pbnRzT25MaW5lLmxlbmd0aDsgaWR4KyspIHtcbiAgICB2YXIgY2IgPSBwb2ludHNPbkxpbmVbaWR4XTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGRyYXdQb2ludENhbGxiYWNrLmNhbGwoZS5keWdyYXBoLFxuICAgICAgICBlLmR5Z3JhcGgsIGUuc2V0TmFtZSwgY3R4LCBjYlswXSwgY2JbMV0sIGNvbG9yLCBwb2ludFNpemUsIGNiWzJdKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dGFjaGVzIGNhbnZhcyBjb29yZGluYXRlcyB0byB0aGUgcG9pbnRzIGFycmF5LlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlUG9pbnRzID0gZnVuY3Rpb24oKSB7XG4gIC8vIFVwZGF0ZSBQb2ludHNcbiAgLy8gVE9ETyhkYW52ayk6IGhlcmVcbiAgLy9cbiAgLy8gVE9ETyhiaHMpOiB0aGlzIGxvb3AgaXMgYSBob3Qtc3BvdCBmb3IgaGlnaC1wb2ludC1jb3VudCBjaGFydHMuIFRoZXNlXG4gIC8vIHRyYW5zZm9ybWF0aW9ucyBjYW4gYmUgcHVzaGVkIGludG8gdGhlIGNhbnZhcyB2aWEgbGluZWFyIHRyYW5zZm9ybWF0aW9uXG4gIC8vIG1hdHJpY2VzLlxuICAvLyBOT1RFKGRhbnZrKTogdGhpcyBpcyB0cmlja2llciB0aGFuIGl0IHNvdW5kcyBhdCBmaXJzdC4gVGhlIHRyYW5zZm9ybWF0aW9uXG4gIC8vIG5lZWRzIHRvIGJlIGRvbmUgYmVmb3JlIHRoZSAubW92ZVRvKCkgYW5kIC5saW5lVG8oKSBjYWxscywgYnV0IG11c3QgYmVcbiAgLy8gdW5kb25lIGJlZm9yZSB0aGUgLnN0cm9rZSgpIGNhbGwgdG8gZW5zdXJlIHRoYXQgdGhlIHN0cm9rZSB3aWR0aCBpc1xuICAvLyB1bmFmZmVjdGVkLiAgQW4gYWx0ZXJuYXRpdmUgaXMgdG8gcmVkdWNlIHRoZSBzdHJva2Ugd2lkdGggaW4gdGhlXG4gIC8vIHRyYW5zZm9ybWVkIGNvb3JkaW5hdGUgc3BhY2UsIGJ1dCB5b3UgY2FuJ3Qgc3BlY2lmeSBkaWZmZXJlbnQgdmFsdWVzIGZvclxuICAvLyBlYWNoIGRpbWVuc2lvbiAoYXMgeW91IGNhbiB3aXRoIC5zY2FsZSgpKS4gVGhlIHNwZWVkdXAgaGVyZSBpcyB+MTIlLlxuICB2YXIgc2V0cyA9IHRoaXMubGF5b3V0LnBvaW50cztcbiAgZm9yICh2YXIgaSA9IHNldHMubGVuZ3RoOyBpLS07KSB7XG4gICAgdmFyIHBvaW50cyA9IHNldHNbaV07XG4gICAgZm9yICh2YXIgaiA9IHBvaW50cy5sZW5ndGg7IGotLTspIHtcbiAgICAgIHZhciBwb2ludCA9IHBvaW50c1tqXTtcbiAgICAgIHBvaW50LmNhbnZhc3ggPSB0aGlzLmFyZWEudyAqIHBvaW50LnggKyB0aGlzLmFyZWEueDtcbiAgICAgIHBvaW50LmNhbnZhc3kgPSB0aGlzLmFyZWEuaCAqIHBvaW50LnkgKyB0aGlzLmFyZWEueTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIGNhbnZhcyBBY3R1YWxseSBkcmF3IHRoZSBsaW5lcyBjaGFydCwgaW5jbHVkaW5nIGVycm9yIGJhcnMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgaWYgRHlncmFwaExheW91dCdzIHBvaW50cyBhcnJheSBoYXMgYmVlblxuICogdXBkYXRlZCB3aXRoIGNhbnZhc3t4LHl9IGF0dHJpYnV0ZXMsIGkuZS4gYnlcbiAqIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fdXBkYXRlUG9pbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Nlcmllc05hbWUgd2hlbiBzcGVjaWZpZWQsIG9ubHkgdGhhdCBzZXJpZXMgd2lsbFxuICogICAgIGJlIGRyYXduLiAoVGhpcyBpcyB1c2VkIGZvciBleHBlZGl0ZWQgcmVkcmF3aW5nIHdpdGggaGlnaGxpZ2h0U2VyaWVzT3B0cylcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBvcHRfY3R4IHdoZW4gc3BlY2lmaWVkLCB0aGUgZHJhd2luZ1xuICogICAgIGNvbnRleHQuICBIb3dldmVyLCBsaW5lcyBhcmUgdHlwaWNhbGx5IGRyYXduIG9uIHRoZSBvYmplY3Qnc1xuICogICAgIGVsZW1lbnRDb250ZXh0LlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5fcmVuZGVyTGluZUNoYXJ0ID0gZnVuY3Rpb24ob3B0X3Nlcmllc05hbWUsIG9wdF9jdHgpIHtcbiAgdmFyIGN0eCA9IG9wdF9jdHggfHwgdGhpcy5lbGVtZW50Q29udGV4dDtcbiAgdmFyIGk7XG5cbiAgdmFyIHNldHMgPSB0aGlzLmxheW91dC5wb2ludHM7XG4gIHZhciBzZXROYW1lcyA9IHRoaXMubGF5b3V0LnNldE5hbWVzO1xuICB2YXIgc2V0TmFtZTtcblxuICB0aGlzLmNvbG9ycyA9IHRoaXMuZHlncmFwaF8uY29sb3JzTWFwXztcblxuICAvLyBEZXRlcm1pbmUgd2hpY2ggc2VyaWVzIGhhdmUgc3BlY2lhbGl6ZWQgcGxvdHRlcnMuXG4gIHZhciBwbG90dGVyX2F0dHIgPSB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbihcInBsb3R0ZXJcIik7XG4gIHZhciBwbG90dGVycyA9IHBsb3R0ZXJfYXR0cjtcbiAgaWYgKCF1dGlscy5pc0FycmF5TGlrZShwbG90dGVycykpIHtcbiAgICBwbG90dGVycyA9IFtwbG90dGVyc107XG4gIH1cblxuICB2YXIgc2V0UGxvdHRlcnMgPSB7fTsgIC8vIHNlcmllcyBuYW1lIC0+IHBsb3R0ZXIgZm4uXG4gIGZvciAoaSA9IDA7IGkgPCBzZXROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHNldE5hbWUgPSBzZXROYW1lc1tpXTtcbiAgICB2YXIgc2V0UGxvdHRlciA9IHRoaXMuZHlncmFwaF8uZ2V0T3B0aW9uKFwicGxvdHRlclwiLCBzZXROYW1lKTtcbiAgICBpZiAoc2V0UGxvdHRlciA9PSBwbG90dGVyX2F0dHIpIGNvbnRpbnVlOyAgLy8gbm90IHNwZWNpYWxpemVkLlxuXG4gICAgc2V0UGxvdHRlcnNbc2V0TmFtZV0gPSBzZXRQbG90dGVyO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IHBsb3R0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsb3R0ZXIgPSBwbG90dGVyc1tpXTtcbiAgICB2YXIgaXNfbGFzdCA9IChpID09IHBsb3R0ZXJzLmxlbmd0aCAtIDEpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBzZXROYW1lID0gc2V0TmFtZXNbal07XG4gICAgICBpZiAob3B0X3Nlcmllc05hbWUgJiYgc2V0TmFtZSAhPSBvcHRfc2VyaWVzTmFtZSkgY29udGludWU7XG5cbiAgICAgIHZhciBwb2ludHMgPSBzZXRzW2pdO1xuXG4gICAgICAvLyBPbmx5IHRocm93IGluIHRoZSBzcGVjaWFsaXplZCBwbG90dGVycyBvbiB0aGUgbGFzdCBpdGVyYXRpb24uXG4gICAgICB2YXIgcCA9IHBsb3R0ZXI7XG4gICAgICBpZiAoc2V0TmFtZSBpbiBzZXRQbG90dGVycykge1xuICAgICAgICBpZiAoaXNfbGFzdCkge1xuICAgICAgICAgIHAgPSBzZXRQbG90dGVyc1tzZXROYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEb24ndCB1c2UgdGhlIHN0YW5kYXJkIHBsb3R0ZXJzIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29sb3IgPSB0aGlzLmNvbG9yc1tzZXROYW1lXTtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuZHlncmFwaF8uZ2V0T3B0aW9uKFwic3Ryb2tlV2lkdGhcIiwgc2V0TmFtZSk7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICAgIHAoe1xuICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgc2V0TmFtZTogc2V0TmFtZSxcbiAgICAgICAgZHJhd2luZ0NvbnRleHQ6IGN0eCxcbiAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgIGR5Z3JhcGg6IHRoaXMuZHlncmFwaF8sXG4gICAgICAgIGF4aXM6IHRoaXMuZHlncmFwaF8uYXhpc1Byb3BlcnRpZXNGb3JTZXJpZXMoc2V0TmFtZSksXG4gICAgICAgIHBsb3RBcmVhOiB0aGlzLmFyZWEsXG4gICAgICAgIHNlcmllc0luZGV4OiBqLFxuICAgICAgICBzZXJpZXNDb3VudDogc2V0cy5sZW5ndGgsXG4gICAgICAgIHNpbmdsZVNlcmllc05hbWU6IG9wdF9zZXJpZXNOYW1lLFxuICAgICAgICBhbGxTZXJpZXNQb2ludHM6IHNldHNcbiAgICAgIH0pO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU3RhbmRhcmQgcGxvdHRlcnMuIFRoZXNlIG1heSBiZSB1c2VkIGJ5IGNsaWVudHMgdmlhIER5Z3JhcGguUGxvdHRlcnMuXG4gKiBTZWUgY29tbWVudHMgdGhlcmUgZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLl9QbG90dGVycyA9IHtcbiAgbGluZVBsb3R0ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2xpbmVQbG90dGVyKGUpO1xuICB9LFxuXG4gIGZpbGxQbG90dGVyOiBmdW5jdGlvbihlKSB7XG4gICAgRHlncmFwaENhbnZhc1JlbmRlcmVyLl9maWxsUGxvdHRlcihlKTtcbiAgfSxcblxuICBlcnJvclBsb3R0ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2Vycm9yUGxvdHRlcihlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQbG90dGVyIHdoaWNoIGRyYXdzIHRoZSBjZW50cmFsIGxpbmVzIGZvciBhIHNlcmllcy5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5fbGluZVBsb3R0ZXIgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBnID0gZS5keWdyYXBoO1xuICB2YXIgc2V0TmFtZSA9IGUuc2V0TmFtZTtcbiAgdmFyIHN0cm9rZVdpZHRoID0gZS5zdHJva2VXaWR0aDtcblxuICAvLyBUT0RPKGRhbnZrKTogQ2hlY2sgaWYgdGhlcmUncyBhbnkgcGVyZm9ybWFuY2UgaW1wYWN0IG9mIGp1c3QgY2FsbGluZ1xuICAvLyBnZXRPcHRpb24oKSBpbnNpZGUgb2YgX2RyYXdTdHlsZWRMaW5lLiBQYXNzaW5nIGluIHNvIG1hbnkgcGFyYW1ldGVycyBtYWtlc1xuICAvLyB0aGlzIGNvZGUgYSBiaXQgbmFzdHkuXG4gIHZhciBib3JkZXJXaWR0aCA9IGcuZ2V0TnVtZXJpY09wdGlvbihcInN0cm9rZUJvcmRlcldpZHRoXCIsIHNldE5hbWUpO1xuICB2YXIgZHJhd1BvaW50Q2FsbGJhY2sgPSBnLmdldE9wdGlvbihcImRyYXdQb2ludENhbGxiYWNrXCIsIHNldE5hbWUpIHx8XG4gICAgICB1dGlscy5DaXJjbGVzLkRFRkFVTFQ7XG4gIHZhciBzdHJva2VQYXR0ZXJuID0gZy5nZXRPcHRpb24oXCJzdHJva2VQYXR0ZXJuXCIsIHNldE5hbWUpO1xuICB2YXIgZHJhd1BvaW50cyA9IGcuZ2V0Qm9vbGVhbk9wdGlvbihcImRyYXdQb2ludHNcIiwgc2V0TmFtZSk7XG4gIHZhciBwb2ludFNpemUgPSBnLmdldE51bWVyaWNPcHRpb24oXCJwb2ludFNpemVcIiwgc2V0TmFtZSk7XG5cbiAgaWYgKGJvcmRlcldpZHRoICYmIHN0cm9rZVdpZHRoKSB7XG4gICAgRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3U3R5bGVkTGluZShlLFxuICAgICAgICBnLmdldE9wdGlvbihcInN0cm9rZUJvcmRlckNvbG9yXCIsIHNldE5hbWUpLFxuICAgICAgICBzdHJva2VXaWR0aCArIDIgKiBib3JkZXJXaWR0aCxcbiAgICAgICAgc3Ryb2tlUGF0dGVybixcbiAgICAgICAgZHJhd1BvaW50cyxcbiAgICAgICAgZHJhd1BvaW50Q2FsbGJhY2ssXG4gICAgICAgIHBvaW50U2l6ZVxuICAgICAgICApO1xuICB9XG5cbiAgRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3U3R5bGVkTGluZShlLFxuICAgICAgZS5jb2xvcixcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlUGF0dGVybixcbiAgICAgIGRyYXdQb2ludHMsXG4gICAgICBkcmF3UG9pbnRDYWxsYmFjayxcbiAgICAgIHBvaW50U2l6ZVxuICApO1xufTtcblxuLyoqXG4gKiBEcmF3cyB0aGUgc2hhZGVkIGVycm9yIGJhcnMvY29uZmlkZW5jZSBpbnRlcnZhbHMgZm9yIGVhY2ggc2VyaWVzLlxuICogVGhpcyBoYXBwZW5zIGJlZm9yZSB0aGUgY2VudGVyIGxpbmVzIGFyZSBkcmF3biwgc2luY2UgdGhlIGNlbnRlciBsaW5lc1xuICogbmVlZCB0byBiZSBkcmF3biBvbiB0b3Agb2YgdGhlIGVycm9yIGJhcnMgZm9yIGFsbCBzZXJpZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2Vycm9yUGxvdHRlciA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIGcgPSBlLmR5Z3JhcGg7XG4gIHZhciBzZXROYW1lID0gZS5zZXROYW1lO1xuICB2YXIgZXJyb3JCYXJzID0gZy5nZXRCb29sZWFuT3B0aW9uKFwiZXJyb3JCYXJzXCIpIHx8XG4gICAgICBnLmdldEJvb2xlYW5PcHRpb24oXCJjdXN0b21CYXJzXCIpO1xuICBpZiAoIWVycm9yQmFycykgcmV0dXJuO1xuXG4gIHZhciBmaWxsR3JhcGggPSBnLmdldEJvb2xlYW5PcHRpb24oXCJmaWxsR3JhcGhcIiwgc2V0TmFtZSk7XG4gIGlmIChmaWxsR3JhcGgpIHtcbiAgICBjb25zb2xlLndhcm4oXCJDYW4ndCB1c2UgZmlsbEdyYXBoIG9wdGlvbiB3aXRoIGVycm9yIGJhcnNcIik7XG4gIH1cblxuICB2YXIgY3R4ID0gZS5kcmF3aW5nQ29udGV4dDtcbiAgdmFyIGNvbG9yID0gZS5jb2xvcjtcbiAgdmFyIGZpbGxBbHBoYSA9IGcuZ2V0TnVtZXJpY09wdGlvbignZmlsbEFscGhhJywgc2V0TmFtZSk7XG4gIHZhciBzdGVwUGxvdCA9IGcuZ2V0Qm9vbGVhbk9wdGlvbihcInN0ZXBQbG90XCIsIHNldE5hbWUpO1xuICB2YXIgcG9pbnRzID0gZS5wb2ludHM7XG5cbiAgdmFyIGl0ZXIgPSB1dGlscy5jcmVhdGVJdGVyYXRvcihwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsXG4gICAgICBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2dldEl0ZXJhdG9yUHJlZGljYXRlKFxuICAgICAgICAgIGcuZ2V0Qm9vbGVhbk9wdGlvbihcImNvbm5lY3RTZXBhcmF0ZWRQb2ludHNcIiwgc2V0TmFtZSkpKTtcblxuICB2YXIgbmV3WXM7XG5cbiAgLy8gc2V0dXAgZ3JhcGhpY3MgY29udGV4dFxuICB2YXIgcHJldlggPSBOYU47XG4gIHZhciBwcmV2WSA9IE5hTjtcbiAgdmFyIHByZXZZcyA9IFstMSwgLTFdO1xuICAvLyBzaG91bGQgYmUgc2FtZSBjb2xvciBhcyB0aGUgbGluZXMgYnV0IG9ubHkgMTUlIG9wYXF1ZS5cbiAgdmFyIHJnYiA9IHV0aWxzLnRvUkdCXyhjb2xvcik7XG4gIHZhciBlcnJfY29sb3IgPVxuICAgICAgJ3JnYmEoJyArIHJnYi5yICsgJywnICsgcmdiLmcgKyAnLCcgKyByZ2IuYiArICcsJyArIGZpbGxBbHBoYSArICcpJztcbiAgY3R4LmZpbGxTdHlsZSA9IGVycl9jb2xvcjtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gIHZhciBpc051bGxVbmRlZmluZWRPck5hTiA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gKHggPT09IG51bGwgfHxcbiAgICAgICAgICAgIHggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgaXNOYU4oeCkpO1xuICB9O1xuXG4gIHdoaWxlIChpdGVyLmhhc05leHQpIHtcbiAgICB2YXIgcG9pbnQgPSBpdGVyLm5leHQoKTtcbiAgICBpZiAoKCFzdGVwUGxvdCAmJiBpc051bGxVbmRlZmluZWRPck5hTihwb2ludC55KSkgfHxcbiAgICAgICAgKHN0ZXBQbG90ICYmICFpc05hTihwcmV2WSkgJiYgaXNOdWxsVW5kZWZpbmVkT3JOYU4ocHJldlkpKSkge1xuICAgICAgcHJldlggPSBOYU47XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBuZXdZcyA9IFsgcG9pbnQueV9ib3R0b20sIHBvaW50LnlfdG9wIF07XG4gICAgaWYgKHN0ZXBQbG90KSB7XG4gICAgICBwcmV2WSA9IHBvaW50Lnk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGRvY3VtZW50YXRpb24gc3BlY2lmaWNhbGx5IGRpc2FsbG93cyBudWxscyBpbnNpZGUgdGhlIHBvaW50IGFycmF5cyxcbiAgICAvLyBidXQgaW4gY2FzZSBpdCBoYXBwZW5zIHdlIHNob3VsZCBkbyBzb21ldGhpbmcgc2Vuc2libGUuXG4gICAgaWYgKGlzTmFOKG5ld1lzWzBdKSkgbmV3WXNbMF0gPSBwb2ludC55O1xuICAgIGlmIChpc05hTihuZXdZc1sxXSkpIG5ld1lzWzFdID0gcG9pbnQueTtcblxuICAgIG5ld1lzWzBdID0gZS5wbG90QXJlYS5oICogbmV3WXNbMF0gKyBlLnBsb3RBcmVhLnk7XG4gICAgbmV3WXNbMV0gPSBlLnBsb3RBcmVhLmggKiBuZXdZc1sxXSArIGUucGxvdEFyZWEueTtcbiAgICBpZiAoIWlzTmFOKHByZXZYKSkge1xuICAgICAgaWYgKHN0ZXBQbG90KSB7XG4gICAgICAgIGN0eC5tb3ZlVG8ocHJldlgsIHByZXZZc1swXSk7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQuY2FudmFzeCwgcHJldllzWzBdKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludC5jYW52YXN4LCBwcmV2WXNbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhwcmV2WCwgcHJldllzWzBdKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludC5jYW52YXN4LCBuZXdZc1swXSk7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQuY2FudmFzeCwgbmV3WXNbMV0pO1xuICAgICAgfVxuICAgICAgY3R4LmxpbmVUbyhwcmV2WCwgcHJldllzWzFdKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgcHJldllzID0gbmV3WXM7XG4gICAgcHJldlggPSBwb2ludC5jYW52YXN4O1xuICB9XG4gIGN0eC5maWxsKCk7XG59O1xuXG5cbi8qKlxuICogUHJveHkgZm9yIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB3aGljaCBkcm9wcyBtb3ZlVG8vbGluZVRvIGNhbGxzIHdoaWNoIGFyZVxuICogc3VwZXJmbHVvdXMuIEl0IGFjY3VtdWxhdGVzIGFsbCBtb3ZlbWVudHMgd2hpY2ggaGF2ZW4ndCBjaGFuZ2VkIHRoZSB4LXZhbHVlXG4gKiBhbmQgb25seSBhcHBsaWVzIHRoZSB0d28gd2l0aCB0aGUgbW9zdCBleHRyZW1lIHktdmFsdWVzLlxuICpcbiAqIENhbGxzIHRvIGxpbmVUby9tb3ZlVG8gbXVzdCBoYXZlIG5vbi1kZWNyZWFzaW5nIHgtdmFsdWVzLlxuICovXG5EeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2Zhc3RDYW52YXNQcm94eSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIHBlbmRpbmdBY3Rpb25zID0gW107ICAvLyBhcnJheSBvZiBbdHlwZSwgeCwgeV0gdHVwbGVzXG4gIHZhciBsYXN0Um91bmRlZFggPSBudWxsO1xuICB2YXIgbGFzdEZsdXNoZWRYID0gbnVsbDtcblxuICB2YXIgTElORV9UTyA9IDEsXG4gICAgICBNT1ZFX1RPID0gMjtcblxuICB2YXIgYWN0aW9uQ291bnQgPSAwOyAgLy8gbnVtYmVyIG9mIG1vdmVUb3MgYW5kIGxpbmVUb3MgcGFzc2VkIHRvIGNvbnRleHQuXG5cbiAgLy8gRHJvcCBzdXBlcmZsdW91cyBtb3Rpb25zXG4gIC8vIEFzc3VtZXMgYWxsIHBlbmRpbmdBY3Rpb25zIGhhdmUgdGhlIHNhbWUgKHJvdW5kZWQpIHgtdmFsdWUuXG4gIHZhciBjb21wcmVzc0FjdGlvbnMgPSBmdW5jdGlvbihvcHRfbG9zc2xlc3NPbmx5KSB7XG4gICAgaWYgKHBlbmRpbmdBY3Rpb25zLmxlbmd0aCA8PSAxKSByZXR1cm47XG5cbiAgICAvLyBMb3NzbGVzcyBjb21wcmVzc2lvbjogZHJvcCBpbmNvbnNlcXVlbnRpYWwgbW92ZVRvcy5cbiAgICBmb3IgKHZhciBpID0gcGVuZGluZ0FjdGlvbnMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgdmFyIGFjdGlvbiA9IHBlbmRpbmdBY3Rpb25zW2ldO1xuICAgICAgaWYgKGFjdGlvblswXSA9PSBNT1ZFX1RPKSB7XG4gICAgICAgIHZhciBwcmV2QWN0aW9uID0gcGVuZGluZ0FjdGlvbnNbaSAtIDFdO1xuICAgICAgICBpZiAocHJldkFjdGlvblsxXSA9PSBhY3Rpb25bMV0gJiYgcHJldkFjdGlvblsyXSA9PSBhY3Rpb25bMl0pIHtcbiAgICAgICAgICBwZW5kaW5nQWN0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMb3NzbGVzcyBjb21wcmVzc2lvbjogLi4uIGRyb3AgY29uc2VjdXRpdmUgbW92ZVRvcyAuLi5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBlbmRpbmdBY3Rpb25zLmxlbmd0aCAtIDE7IC8qIGluY3JlbWVudGVkIGludGVybmFsbHkgKi8pIHtcbiAgICAgIHZhciBhY3Rpb24gPSBwZW5kaW5nQWN0aW9uc1tpXTtcbiAgICAgIGlmIChhY3Rpb25bMF0gPT0gTU9WRV9UTyAmJiBwZW5kaW5nQWN0aW9uc1tpICsgMV1bMF0gPT0gTU9WRV9UTykge1xuICAgICAgICBwZW5kaW5nQWN0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTG9zc3kgY29tcHJlc3Npb246IC4uLiBkcm9wIGFsbCBidXQgdGhlIGV4dHJlbWUgeS12YWx1ZXMgLi4uXG4gICAgaWYgKHBlbmRpbmdBY3Rpb25zLmxlbmd0aCA+IDIgJiYgIW9wdF9sb3NzbGVzc09ubHkpIHtcbiAgICAgIC8vIGtlZXAgYW4gaW5pdGlhbCBtb3ZlVG8sIGJ1dCBkcm9wIGFsbCBvdGhlcnMuXG4gICAgICB2YXIgc3RhcnRJZHggPSAwO1xuICAgICAgaWYgKHBlbmRpbmdBY3Rpb25zWzBdWzBdID09IE1PVkVfVE8pIHN0YXJ0SWR4Kys7XG4gICAgICB2YXIgbWluSWR4ID0gbnVsbCwgbWF4SWR4ID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydElkeDsgaSA8IHBlbmRpbmdBY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSBwZW5kaW5nQWN0aW9uc1tpXTtcbiAgICAgICAgaWYgKGFjdGlvblswXSAhPSBMSU5FX1RPKSBjb250aW51ZTtcbiAgICAgICAgaWYgKG1pbklkeCA9PT0gbnVsbCAmJiBtYXhJZHggPT09IG51bGwpIHtcbiAgICAgICAgICBtaW5JZHggPSBpO1xuICAgICAgICAgIG1heElkeCA9IGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHkgPSBhY3Rpb25bMl07XG4gICAgICAgICAgaWYgKHkgPCBwZW5kaW5nQWN0aW9uc1ttaW5JZHhdWzJdKSB7XG4gICAgICAgICAgICBtaW5JZHggPSBpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoeSA+IHBlbmRpbmdBY3Rpb25zW21heElkeF1bMl0pIHtcbiAgICAgICAgICAgIG1heElkeCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbWluQWN0aW9uID0gcGVuZGluZ0FjdGlvbnNbbWluSWR4XSxcbiAgICAgICAgICBtYXhBY3Rpb24gPSBwZW5kaW5nQWN0aW9uc1ttYXhJZHhdO1xuICAgICAgcGVuZGluZ0FjdGlvbnMuc3BsaWNlKHN0YXJ0SWR4LCBwZW5kaW5nQWN0aW9ucy5sZW5ndGggLSBzdGFydElkeCk7XG4gICAgICBpZiAobWluSWR4IDwgbWF4SWR4KSB7XG4gICAgICAgIHBlbmRpbmdBY3Rpb25zLnB1c2gobWluQWN0aW9uKTtcbiAgICAgICAgcGVuZGluZ0FjdGlvbnMucHVzaChtYXhBY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmIChtaW5JZHggPiBtYXhJZHgpIHtcbiAgICAgICAgcGVuZGluZ0FjdGlvbnMucHVzaChtYXhBY3Rpb24pO1xuICAgICAgICBwZW5kaW5nQWN0aW9ucy5wdXNoKG1pbkFjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZW5kaW5nQWN0aW9ucy5wdXNoKG1pbkFjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBmbHVzaEFjdGlvbnMgPSBmdW5jdGlvbihvcHRfbm9Mb3NzeUNvbXByZXNzaW9uKSB7XG4gICAgY29tcHJlc3NBY3Rpb25zKG9wdF9ub0xvc3N5Q29tcHJlc3Npb24pO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwZW5kaW5nQWN0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGFjdGlvbiA9IHBlbmRpbmdBY3Rpb25zW2ldO1xuICAgICAgaWYgKGFjdGlvblswXSA9PSBMSU5FX1RPKSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKGFjdGlvblsxXSwgYWN0aW9uWzJdKTtcbiAgICAgIH0gZWxzZSBpZiAoYWN0aW9uWzBdID09IE1PVkVfVE8pIHtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oYWN0aW9uWzFdLCBhY3Rpb25bMl0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGVuZGluZ0FjdGlvbnMubGVuZ3RoKSB7XG4gICAgICBsYXN0Rmx1c2hlZFggPSBwZW5kaW5nQWN0aW9uc1twZW5kaW5nQWN0aW9ucy5sZW5ndGggLSAxXVsxXTtcbiAgICB9XG4gICAgYWN0aW9uQ291bnQgKz0gcGVuZGluZ0FjdGlvbnMubGVuZ3RoO1xuICAgIHBlbmRpbmdBY3Rpb25zID0gW107XG4gIH07XG5cbiAgdmFyIGFkZEFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgeCwgeSkge1xuICAgIHZhciByeCA9IE1hdGgucm91bmQoeCk7XG4gICAgaWYgKGxhc3RSb3VuZGVkWCA9PT0gbnVsbCB8fCByeCAhPSBsYXN0Um91bmRlZFgpIHtcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBsYXJnZSBnYXBzIG9uIHRoZSB4LWF4aXMsIGl0J3MgZXNzZW50aWFsIHRvIGtlZXAgdGhlXG4gICAgICAvLyBmaXJzdCBhbmQgbGFzdCBwb2ludCBhcyB3ZWxsLlxuICAgICAgdmFyIGhhc0dhcE9uTGVmdCA9IChsYXN0Um91bmRlZFggLSBsYXN0Rmx1c2hlZFggPiAxKSxcbiAgICAgICAgICBoYXNHYXBPblJpZ2h0ID0gKHJ4IC0gbGFzdFJvdW5kZWRYID4gMSksXG4gICAgICAgICAgaGFzR2FwID0gaGFzR2FwT25MZWZ0IHx8IGhhc0dhcE9uUmlnaHQ7XG4gICAgICBmbHVzaEFjdGlvbnMoaGFzR2FwKTtcbiAgICAgIGxhc3RSb3VuZGVkWCA9IHJ4O1xuICAgIH1cbiAgICBwZW5kaW5nQWN0aW9ucy5wdXNoKFthY3Rpb24sIHgsIHldKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG1vdmVUbzogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgYWRkQWN0aW9uKE1PVkVfVE8sIHgsIHkpO1xuICAgIH0sXG4gICAgbGluZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBhZGRBY3Rpb24oTElORV9UTywgeCwgeSk7XG4gICAgfSxcblxuICAgIC8vIGZvciBtYWpvciBvcGVyYXRpb25zIGxpa2Ugc3Ryb2tlL2ZpbGwsIHdlIHNraXAgY29tcHJlc3Npb24gdG8gZW5zdXJlXG4gICAgLy8gdGhhdCB0aGVyZSBhcmUgbm8gYXJ0aWZhY3RzIGF0IHRoZSByaWdodCBlZGdlLlxuICAgIHN0cm9rZTogICAgZnVuY3Rpb24oKSB7IGZsdXNoQWN0aW9ucyh0cnVlKTsgY29udGV4dC5zdHJva2UoKTsgfSxcbiAgICBmaWxsOiAgICAgIGZ1bmN0aW9uKCkgeyBmbHVzaEFjdGlvbnModHJ1ZSk7IGNvbnRleHQuZmlsbCgpOyB9LFxuICAgIGJlZ2luUGF0aDogZnVuY3Rpb24oKSB7IGZsdXNoQWN0aW9ucyh0cnVlKTsgY29udGV4dC5iZWdpblBhdGgoKTsgfSxcbiAgICBjbG9zZVBhdGg6IGZ1bmN0aW9uKCkgeyBmbHVzaEFjdGlvbnModHJ1ZSk7IGNvbnRleHQuY2xvc2VQYXRoKCk7IH0sXG5cbiAgICBfY291bnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gYWN0aW9uQ291bnQ7IH1cbiAgfTtcbn07XG5cbi8qKlxuICogRHJhd3MgdGhlIHNoYWRlZCByZWdpb25zIHdoZW4gXCJmaWxsR3JhcGhcIiBpcyBzZXQuIE5vdCB0byBiZSBjb25mdXNlZCB3aXRoXG4gKiBlcnJvciBiYXJzLlxuICpcbiAqIEZvciBzdGFja2VkIGNoYXJ0cywgaXQncyBtb3JlIGNvbnZlbmllbnQgdG8gaGFuZGxlIGFsbCB0aGUgc2VyaWVzXG4gKiBzaW11bHRhbmVvdXNseS4gU28gdGhpcyBwbG90dGVyIHBsb3RzIGFsbCB0aGUgcG9pbnRzIG9uIHRoZSBmaXJzdCBzZXJpZXNcbiAqIGl0J3MgYXNrZWQgdG8gZHJhdywgdGhlbiBpZ25vcmVzIGFsbCB0aGUgb3RoZXIgc2VyaWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5fZmlsbFBsb3R0ZXIgPSBmdW5jdGlvbihlKSB7XG4gIC8vIFNraXAgaWYgd2UncmUgZHJhd2luZyBhIHNpbmdsZSBzZXJpZXMgZm9yIGludGVyYWN0aXZlIGhpZ2hsaWdodCBvdmVybGF5LlxuICBpZiAoZS5zaW5nbGVTZXJpZXNOYW1lKSByZXR1cm47XG5cbiAgLy8gV2UnbGwgaGFuZGxlIGFsbCB0aGUgc2VyaWVzIGF0IG9uY2UsIG5vdCBvbmUtYnktb25lLlxuICBpZiAoZS5zZXJpZXNJbmRleCAhPT0gMCkgcmV0dXJuO1xuXG4gIHZhciBnID0gZS5keWdyYXBoO1xuICB2YXIgc2V0TmFtZXMgPSBnLmdldExhYmVscygpLnNsaWNlKDEpOyAgLy8gcmVtb3ZlIHgtYXhpc1xuXG4gIC8vIGdldExhYmVscygpIGluY2x1ZGVzIG5hbWVzIGZvciBpbnZpc2libGUgc2VyaWVzLCB3aGljaCBhcmUgbm90IGluY2x1ZGVkIGluXG4gIC8vIGFsbFNlcmllc1BvaW50cy4gV2UgcmVtb3ZlIHRob3NlIHRvIG1ha2UgdGhlIHR3byBtYXRjaC5cbiAgLy8gVE9ETyhkYW52ayk6IHByb3ZpZGUgYSBzaW1wbGVyIHdheSB0byBnZXQgdGhpcyBpbmZvcm1hdGlvbi5cbiAgZm9yICh2YXIgaSA9IHNldE5hbWVzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoIWcudmlzaWJpbGl0eSgpW2ldKSBzZXROYW1lcy5zcGxpY2UoaSwgMSk7XG4gIH1cblxuICB2YXIgYW55U2VyaWVzRmlsbGVkID0gKGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChnLmdldEJvb2xlYW5PcHRpb24oXCJmaWxsR3JhcGhcIiwgc2V0TmFtZXNbaV0pKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KSgpO1xuXG4gIGlmICghYW55U2VyaWVzRmlsbGVkKSByZXR1cm47XG5cbiAgdmFyIGFyZWEgPSBlLnBsb3RBcmVhO1xuICB2YXIgc2V0cyA9IGUuYWxsU2VyaWVzUG9pbnRzO1xuICB2YXIgc2V0Q291bnQgPSBzZXRzLmxlbmd0aDtcblxuICB2YXIgc3RhY2tlZEdyYXBoID0gZy5nZXRCb29sZWFuT3B0aW9uKFwic3RhY2tlZEdyYXBoXCIpO1xuICB2YXIgY29sb3JzID0gZy5nZXRDb2xvcnMoKTtcblxuICAvLyBGb3Igc3RhY2tlZCBncmFwaHMsIHRyYWNrIHRoZSBiYXNlbGluZSBmb3IgZmlsbGluZy5cbiAgLy9cbiAgLy8gVGhlIGZpbGxlZCBhcmVhcyBiZWxvdyBncmFwaCBsaW5lcyBhcmUgdHJhcGV6b2lkcyB3aXRoIHR3b1xuICAvLyB2ZXJ0aWNhbCBlZGdlcy4gVGhlIHRvcCBlZGdlIGlzIHRoZSBsaW5lIHNlZ21lbnQgYmVpbmcgZHJhd24sIGFuZFxuICAvLyB0aGUgYmFzZWxpbmUgaXMgdGhlIGJvdHRvbSBlZGdlLiBFYWNoIGJhc2VsaW5lIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAvLyB0b3AgbGluZSBzZWdtZW50IGZyb20gdGhlIHByZXZpb3VzIHN0YWNrZWQgbGluZS4gSW4gdGhlIGNhc2Ugb2ZcbiAgLy8gc3RlcCBwbG90cywgdGhlIHRyYXBlem9pZHMgYXJlIHJlY3RhbmdsZXMuXG4gIHZhciBiYXNlbGluZSA9IHt9O1xuICB2YXIgY3VyckJhc2VsaW5lO1xuICB2YXIgcHJldlN0ZXBQbG90OyAgLy8gZm9yIGRpZmZlcmVudCBsaW5lIGRyYXdpbmcgbW9kZXMgKGxpbmUvc3RlcCkgcGVyIHNlcmllc1xuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byB0cmFjZSBhIGxpbmUgYmFjayBhbG9uZyB0aGUgYmFzZWxpbmUuXG4gIHZhciB0cmFjZUJhY2tQYXRoID0gZnVuY3Rpb24oY3R4LCBiYXNlbGluZVgsIGJhc2VsaW5lWSwgcGF0aEJhY2spIHtcbiAgICBjdHgubGluZVRvKGJhc2VsaW5lWCwgYmFzZWxpbmVZKTtcbiAgICBpZiAoc3RhY2tlZEdyYXBoKSB7XG4gICAgICBmb3IgKHZhciBpID0gcGF0aEJhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHB0ID0gcGF0aEJhY2tbaV07XG4gICAgICAgIGN0eC5saW5lVG8ocHRbMF0sIHB0WzFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gcHJvY2VzcyBzZXRzIGluIHJldmVyc2Ugb3JkZXIgKG5lZWRlZCBmb3Igc3RhY2tlZCBncmFwaHMpXG4gIGZvciAodmFyIHNldElkeCA9IHNldENvdW50IC0gMTsgc2V0SWR4ID49IDA7IHNldElkeC0tKSB7XG4gICAgdmFyIGN0eCA9IGUuZHJhd2luZ0NvbnRleHQ7XG4gICAgdmFyIHNldE5hbWUgPSBzZXROYW1lc1tzZXRJZHhdO1xuICAgIGlmICghZy5nZXRCb29sZWFuT3B0aW9uKCdmaWxsR3JhcGgnLCBzZXROYW1lKSkgY29udGludWU7XG5cbiAgICB2YXIgZmlsbEFscGhhID0gZy5nZXROdW1lcmljT3B0aW9uKCdmaWxsQWxwaGEnLCBzZXROYW1lKTtcbiAgICB2YXIgc3RlcFBsb3QgPSBnLmdldEJvb2xlYW5PcHRpb24oJ3N0ZXBQbG90Jywgc2V0TmFtZSk7XG4gICAgdmFyIGNvbG9yID0gY29sb3JzW3NldElkeF07XG4gICAgdmFyIGF4aXMgPSBnLmF4aXNQcm9wZXJ0aWVzRm9yU2VyaWVzKHNldE5hbWUpO1xuICAgIHZhciBheGlzWSA9IDEuMCArIGF4aXMubWlueXZhbCAqIGF4aXMueXNjYWxlO1xuICAgIGlmIChheGlzWSA8IDAuMCkgYXhpc1kgPSAwLjA7XG4gICAgZWxzZSBpZiAoYXhpc1kgPiAxLjApIGF4aXNZID0gMS4wO1xuICAgIGF4aXNZID0gYXJlYS5oICogYXhpc1kgKyBhcmVhLnk7XG5cbiAgICB2YXIgcG9pbnRzID0gc2V0c1tzZXRJZHhdO1xuICAgIHZhciBpdGVyID0gdXRpbHMuY3JlYXRlSXRlcmF0b3IocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLFxuICAgICAgICBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2dldEl0ZXJhdG9yUHJlZGljYXRlKFxuICAgICAgICAgICAgZy5nZXRCb29sZWFuT3B0aW9uKFwiY29ubmVjdFNlcGFyYXRlZFBvaW50c1wiLCBzZXROYW1lKSkpO1xuXG4gICAgLy8gc2V0dXAgZ3JhcGhpY3MgY29udGV4dFxuICAgIHZhciBwcmV2WCA9IE5hTjtcbiAgICB2YXIgcHJldllzID0gWy0xLCAtMV07XG4gICAgdmFyIG5ld1lzO1xuICAgIC8vIHNob3VsZCBiZSBzYW1lIGNvbG9yIGFzIHRoZSBsaW5lcyBidXQgb25seSAxNSUgb3BhcXVlLlxuICAgIHZhciByZ2IgPSB1dGlscy50b1JHQl8oY29sb3IpO1xuICAgIHZhciBlcnJfY29sb3IgPVxuICAgICAgICAncmdiYSgnICsgcmdiLnIgKyAnLCcgKyByZ2IuZyArICcsJyArIHJnYi5iICsgJywnICsgZmlsbEFscGhhICsgJyknO1xuICAgIGN0eC5maWxsU3R5bGUgPSBlcnJfY29sb3I7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIHZhciBsYXN0X3gsIGlzX2ZpcnN0ID0gdHJ1ZTtcblxuICAgIC8vIElmIHRoZSBwb2ludCBkZW5zaXR5IGlzIGhpZ2ggZW5vdWdoLCBkcm9wcGluZyBzZWdtZW50cyBvbiB0aGVpciB3YXkgdG9cbiAgICAvLyB0aGUgY2FudmFzIGp1c3RpZmllcyB0aGUgb3ZlcmhlYWQgb2YgZG9pbmcgc28uXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPiAyICogZy53aWR0aF8gfHwgRHlncmFwaC5GT1JDRV9GQVNUX1BST1hZKSB7XG4gICAgICBjdHggPSBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2Zhc3RDYW52YXNQcm94eShjdHgpO1xuICAgIH1cblxuICAgIC8vIEZvciBmaWxsZWQgY2hhcnRzLCB3ZSBkcmF3IHBvaW50cyBmcm9tIGxlZnQgdG8gcmlnaHQsIHRoZW4gYmFjayBhbG9uZ1xuICAgIC8vIHRoZSB4LWF4aXMgdG8gY29tcGxldGUgYSBzaGFwZSBmb3IgZmlsbGluZy5cbiAgICAvLyBGb3Igc3RhY2tlZCBwbG90cywgdGhpcyBcImJhY2sgcGF0aFwiIGlzIGEgbW9yZSBjb21wbGV4IHNoYXBlLiBUaGlzIGFycmF5XG4gICAgLy8gc3RvcmVzIHRoZSBbeCwgeV0gdmFsdWVzIG5lZWRlZCB0byB0cmFjZSB0aGF0IHNoYXBlLlxuICAgIHZhciBwYXRoQmFjayA9IFtdO1xuXG4gICAgLy8gVE9ETyhkYW52ayk6IHRoZXJlIGFyZSBhIGxvdCBvZiBvcHRpb25zIGF0IHBsYXkgaW4gdGhpcyBsb29wLlxuICAgIC8vICAgICBUaGUgbG9naWMgd291bGQgYmUgbXVjaCBjbGVhcmVyIGlmIHNvbWUgKGUuZy4gc3RhY2tHcmFwaCBhbmRcbiAgICAvLyAgICAgc3RlcFBsb3QpIHdlcmUgc3BsaXQgb2ZmIGludG8gc2VwYXJhdGUgc3ViLXBsb3R0ZXJzLlxuICAgIHZhciBwb2ludDtcbiAgICB3aGlsZSAoaXRlci5oYXNOZXh0KSB7XG4gICAgICBwb2ludCA9IGl0ZXIubmV4dCgpO1xuICAgICAgaWYgKCF1dGlscy5pc09LKHBvaW50LnkpICYmICFzdGVwUGxvdCkge1xuICAgICAgICB0cmFjZUJhY2tQYXRoKGN0eCwgcHJldlgsIHByZXZZc1sxXSwgcGF0aEJhY2spO1xuICAgICAgICBwYXRoQmFjayA9IFtdO1xuICAgICAgICBwcmV2WCA9IE5hTjtcbiAgICAgICAgaWYgKHBvaW50Lnlfc3RhY2tlZCAhPT0gbnVsbCAmJiAhaXNOYU4ocG9pbnQueV9zdGFja2VkKSkge1xuICAgICAgICAgIGJhc2VsaW5lW3BvaW50LmNhbnZhc3hdID0gYXJlYS5oICogcG9pbnQueV9zdGFja2VkICsgYXJlYS55O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YWNrZWRHcmFwaCkge1xuICAgICAgICBpZiAoIWlzX2ZpcnN0ICYmIGxhc3RfeCA9PSBwb2ludC54dmFsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNfZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICBsYXN0X3ggPSBwb2ludC54dmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VyckJhc2VsaW5lID0gYmFzZWxpbmVbcG9pbnQuY2FudmFzeF07XG4gICAgICAgIHZhciBsYXN0WTtcbiAgICAgICAgaWYgKGN1cnJCYXNlbGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGFzdFkgPSBheGlzWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZihwcmV2U3RlcFBsb3QpIHtcbiAgICAgICAgICAgIGxhc3RZID0gY3VyckJhc2VsaW5lWzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0WSA9IGN1cnJCYXNlbGluZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3WXMgPSBbIHBvaW50LmNhbnZhc3ksIGxhc3RZIF07XG5cbiAgICAgICAgaWYgKHN0ZXBQbG90KSB7XG4gICAgICAgICAgLy8gU3RlcCBwbG90cyBtdXN0IGtlZXAgdHJhY2sgb2YgdGhlIHRvcCBhbmQgYm90dG9tIG9mXG4gICAgICAgICAgLy8gdGhlIGJhc2VsaW5lIGF0IGVhY2ggcG9pbnQuXG4gICAgICAgICAgaWYgKHByZXZZc1swXSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGJhc2VsaW5lW3BvaW50LmNhbnZhc3hdID0gWyBwb2ludC5jYW52YXN5LCBheGlzWSBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlbGluZVtwb2ludC5jYW52YXN4XSA9IFsgcG9pbnQuY2FudmFzeSwgcHJldllzWzBdIF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VsaW5lW3BvaW50LmNhbnZhc3hdID0gcG9pbnQuY2FudmFzeTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNOYU4ocG9pbnQuY2FudmFzeSkgJiYgc3RlcFBsb3QpIHtcbiAgICAgICAgICBuZXdZcyA9IFsgYXJlYS55ICsgYXJlYS5oLCBheGlzWSBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1lzID0gWyBwb2ludC5jYW52YXN5LCBheGlzWSBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzTmFOKHByZXZYKSkge1xuICAgICAgICAvLyBNb3ZlIHRvIHRvcCBmaWxsIHBvaW50XG4gICAgICAgIGlmIChzdGVwUGxvdCkge1xuICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnQuY2FudmFzeCwgcHJldllzWzBdKTtcbiAgICAgICAgICBjdHgubGluZVRvKHBvaW50LmNhbnZhc3gsIG5ld1lzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgubGluZVRvKHBvaW50LmNhbnZhc3gsIG5ld1lzWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlY29yZCB0aGUgYmFzZWxpbmUgZm9yIHRoZSByZXZlcnNlIHBhdGguXG4gICAgICAgIGlmIChzdGFja2VkR3JhcGgpIHtcbiAgICAgICAgICBwYXRoQmFjay5wdXNoKFtwcmV2WCwgcHJldllzWzFdXSk7XG4gICAgICAgICAgaWYgKHByZXZTdGVwUGxvdCAmJiBjdXJyQmFzZWxpbmUpIHtcbiAgICAgICAgICAgIC8vIERyYXcgdG8gdGhlIGJvdHRvbSBvZiB0aGUgYmFzZWxpbmVcbiAgICAgICAgICAgIHBhdGhCYWNrLnB1c2goW3BvaW50LmNhbnZhc3gsIGN1cnJCYXNlbGluZVsxXV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoQmFjay5wdXNoKFtwb2ludC5jYW52YXN4LCBuZXdZc1sxXV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhwb2ludC5jYW52YXN4LCBuZXdZc1sxXSk7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQuY2FudmFzeCwgbmV3WXNbMF0pO1xuICAgICAgfVxuICAgICAgcHJldllzID0gbmV3WXM7XG4gICAgICBwcmV2WCA9IHBvaW50LmNhbnZhc3g7XG4gICAgfVxuICAgIHByZXZTdGVwUGxvdCA9IHN0ZXBQbG90O1xuICAgIGlmIChuZXdZcyAmJiBwb2ludCkge1xuICAgICAgdHJhY2VCYWNrUGF0aChjdHgsIHBvaW50LmNhbnZhc3gsIG5ld1lzWzFdLCBwYXRoQmFjayk7XG4gICAgICBwYXRoQmFjayA9IFtdO1xuICAgIH1cbiAgICBjdHguZmlsbCgpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEeWdyYXBoQ2FudmFzUmVuZGVyZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLWNhbnZhcy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dygraph_interaction_model__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__dygraph_canvas__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__dygraph_utils__ = __webpack_require__(0);\n\n\n\n\n\n\n\n// Default attribute values.\nvar DEFAULT_ATTRS = {\n  highlightCircleSize: 3,\n  highlightSeriesOpts: null,\n  highlightSeriesBackgroundAlpha: 0.5,\n  highlightSeriesBackgroundColor: 'rgb(255, 255, 255)',\n\n  labelsSeparateLines: false,\n  labelsShowZeroValues: true,\n  labelsKMB: false,\n  labelsKMG2: false,\n  showLabelsOnHighlight: true,\n\n  digitsAfterDecimal: 2,\n  maxNumberWidth: 6,\n  sigFigs: null,\n\n  strokeWidth: 1.0,\n  strokeBorderWidth: 0,\n  strokeBorderColor: \"white\",\n\n  axisTickSize: 3,\n  axisLabelFontSize: 14,\n  rightGap: 5,\n\n  showRoller: false,\n  xValueParser: undefined,\n\n  delimiter: ',',\n\n  sigma: 2.0,\n  errorBars: false,\n  fractions: false,\n  wilsonInterval: true, // only relevant if fractions is true\n  customBars: false,\n  fillGraph: false,\n  fillAlpha: 0.15,\n  connectSeparatedPoints: false,\n\n  stackedGraph: false,\n  stackedGraphNaNFill: 'all',\n  hideOverlayOnMouseOut: true,\n\n  legend: 'onmouseover',\n  stepPlot: false,\n  xRangePad: 0,\n  yRangePad: null,\n  drawAxesAtZero: false,\n\n  // Sizes of the various chart labels.\n  titleHeight: 28,\n  xLabelHeight: 18,\n  yLabelWidth: 18,\n\n  axisLineColor: \"black\",\n  axisLineWidth: 0.3,\n  gridLineWidth: 0.3,\n  axisLabelWidth: 50,\n  gridLineColor: \"rgb(128,128,128)\",\n\n  interactionModel: __WEBPACK_IMPORTED_MODULE_1__dygraph_interaction_model__[\"a\" /* default */].defaultModel,\n  animatedZooms: false, // (for now)\n\n  // Range selector options\n  showRangeSelector: false,\n  rangeSelectorHeight: 40,\n  rangeSelectorPlotStrokeColor: \"#808FAB\",\n  rangeSelectorPlotFillGradientColor: \"white\",\n  rangeSelectorPlotFillColor: \"#A7B1C4\",\n  rangeSelectorBackgroundStrokeColor: \"gray\",\n  rangeSelectorBackgroundLineWidth: 1,\n  rangeSelectorPlotLineWidth: 1.5,\n  rangeSelectorForegroundStrokeColor: \"black\",\n  rangeSelectorForegroundLineWidth: 1,\n  rangeSelectorAlpha: 0.6,\n  showInRangeSelector: null,\n\n  // The ordering here ensures that central lines always appear above any\n  // fill bars/error bars.\n  plotter: [__WEBPACK_IMPORTED_MODULE_2__dygraph_canvas__[\"a\" /* default */]._fillPlotter, __WEBPACK_IMPORTED_MODULE_2__dygraph_canvas__[\"a\" /* default */]._errorPlotter, __WEBPACK_IMPORTED_MODULE_2__dygraph_canvas__[\"a\" /* default */]._linePlotter],\n\n  plugins: [],\n\n  // per-axis options\n  axes: {\n    x: {\n      pixelsPerLabel: 70,\n      axisLabelWidth: 60,\n      axisLabelFormatter: __WEBPACK_IMPORTED_MODULE_3__dygraph_utils__[\"x\" /* dateAxisLabelFormatter */],\n      valueFormatter: __WEBPACK_IMPORTED_MODULE_3__dygraph_utils__[\"w\" /* dateValueFormatter */],\n      drawGrid: true,\n      drawAxis: true,\n      independentTicks: true,\n      ticker: __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__[\"a\" /* dateTicker */]\n    },\n    y: {\n      axisLabelWidth: 50,\n      pixelsPerLabel: 30,\n      valueFormatter: __WEBPACK_IMPORTED_MODULE_3__dygraph_utils__[\"P\" /* numberValueFormatter */],\n      axisLabelFormatter: __WEBPACK_IMPORTED_MODULE_3__dygraph_utils__[\"D\" /* numberAxisLabelFormatter */],\n      drawGrid: true,\n      drawAxis: true,\n      independentTicks: true,\n      ticker: __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__[\"b\" /* numericTicks */]\n    },\n    y2: {\n      axisLabelWidth: 50,\n      pixelsPerLabel: 30,\n      valueFormatter: __WEBPACK_IMPORTED_MODULE_3__dygraph_utils__[\"P\" /* numberValueFormatter */],\n      axisLabelFormatter: __WEBPACK_IMPORTED_MODULE_3__dygraph_utils__[\"D\" /* numberAxisLabelFormatter */],\n      drawAxis: true, // only applies when there are two axes of data.\n      drawGrid: false,\n      independentTicks: false,\n      ticker: __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__[\"b\" /* numericTicks */]\n    }\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DEFAULT_ATTRS);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLWRlZmF1bHQtYXR0cnMuanM/ZmIxYiJdLCJuYW1lcyI6WyJERUZBVUxUX0FUVFJTIiwiaGlnaGxpZ2h0Q2lyY2xlU2l6ZSIsImhpZ2hsaWdodFNlcmllc09wdHMiLCJoaWdobGlnaHRTZXJpZXNCYWNrZ3JvdW5kQWxwaGEiLCJoaWdobGlnaHRTZXJpZXNCYWNrZ3JvdW5kQ29sb3IiLCJsYWJlbHNTZXBhcmF0ZUxpbmVzIiwibGFiZWxzU2hvd1plcm9WYWx1ZXMiLCJsYWJlbHNLTUIiLCJsYWJlbHNLTUcyIiwic2hvd0xhYmVsc09uSGlnaGxpZ2h0IiwiZGlnaXRzQWZ0ZXJEZWNpbWFsIiwibWF4TnVtYmVyV2lkdGgiLCJzaWdGaWdzIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VCb3JkZXJXaWR0aCIsInN0cm9rZUJvcmRlckNvbG9yIiwiYXhpc1RpY2tTaXplIiwiYXhpc0xhYmVsRm9udFNpemUiLCJyaWdodEdhcCIsInNob3dSb2xsZXIiLCJ4VmFsdWVQYXJzZXIiLCJ1bmRlZmluZWQiLCJkZWxpbWl0ZXIiLCJzaWdtYSIsImVycm9yQmFycyIsImZyYWN0aW9ucyIsIndpbHNvbkludGVydmFsIiwiY3VzdG9tQmFycyIsImZpbGxHcmFwaCIsImZpbGxBbHBoYSIsImNvbm5lY3RTZXBhcmF0ZWRQb2ludHMiLCJzdGFja2VkR3JhcGgiLCJzdGFja2VkR3JhcGhOYU5GaWxsIiwiaGlkZU92ZXJsYXlPbk1vdXNlT3V0IiwibGVnZW5kIiwic3RlcFBsb3QiLCJ4UmFuZ2VQYWQiLCJ5UmFuZ2VQYWQiLCJkcmF3QXhlc0F0WmVybyIsInRpdGxlSGVpZ2h0IiwieExhYmVsSGVpZ2h0IiwieUxhYmVsV2lkdGgiLCJheGlzTGluZUNvbG9yIiwiYXhpc0xpbmVXaWR0aCIsImdyaWRMaW5lV2lkdGgiLCJheGlzTGFiZWxXaWR0aCIsImdyaWRMaW5lQ29sb3IiLCJpbnRlcmFjdGlvbk1vZGVsIiwiRHlncmFwaEludGVyYWN0aW9uIiwiZGVmYXVsdE1vZGVsIiwiYW5pbWF0ZWRab29tcyIsInNob3dSYW5nZVNlbGVjdG9yIiwicmFuZ2VTZWxlY3RvckhlaWdodCIsInJhbmdlU2VsZWN0b3JQbG90U3Ryb2tlQ29sb3IiLCJyYW5nZVNlbGVjdG9yUGxvdEZpbGxHcmFkaWVudENvbG9yIiwicmFuZ2VTZWxlY3RvclBsb3RGaWxsQ29sb3IiLCJyYW5nZVNlbGVjdG9yQmFja2dyb3VuZFN0cm9rZUNvbG9yIiwicmFuZ2VTZWxlY3RvckJhY2tncm91bmRMaW5lV2lkdGgiLCJyYW5nZVNlbGVjdG9yUGxvdExpbmVXaWR0aCIsInJhbmdlU2VsZWN0b3JGb3JlZ3JvdW5kU3Ryb2tlQ29sb3IiLCJyYW5nZVNlbGVjdG9yRm9yZWdyb3VuZExpbmVXaWR0aCIsInJhbmdlU2VsZWN0b3JBbHBoYSIsInNob3dJblJhbmdlU2VsZWN0b3IiLCJwbG90dGVyIiwiRHlncmFwaENhbnZhc1JlbmRlcmVyIiwiX2ZpbGxQbG90dGVyIiwiX2Vycm9yUGxvdHRlciIsIl9saW5lUGxvdHRlciIsInBsdWdpbnMiLCJheGVzIiwieCIsInBpeGVsc1BlckxhYmVsIiwiYXhpc0xhYmVsRm9ybWF0dGVyIiwidmFsdWVGb3JtYXR0ZXIiLCJkcmF3R3JpZCIsImRyYXdBeGlzIiwiaW5kZXBlbmRlbnRUaWNrcyIsInRpY2tlciIsImRhdGVUaWNrZXIiLCJ5IiwibnVtZXJpY1RpY2tzIiwieTIiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUlBLGdCQUFnQjtBQUNsQkMsdUJBQXFCLENBREg7QUFFbEJDLHVCQUFxQixJQUZIO0FBR2xCQyxrQ0FBZ0MsR0FIZDtBQUlsQkMsa0NBQWdDLG9CQUpkOztBQU1sQkMsdUJBQXFCLEtBTkg7QUFPbEJDLHdCQUFzQixJQVBKO0FBUWxCQyxhQUFXLEtBUk87QUFTbEJDLGNBQVksS0FUTTtBQVVsQkMseUJBQXVCLElBVkw7O0FBWWxCQyxzQkFBb0IsQ0FaRjtBQWFsQkMsa0JBQWdCLENBYkU7QUFjbEJDLFdBQVMsSUFkUzs7QUFnQmxCQyxlQUFhLEdBaEJLO0FBaUJsQkMscUJBQW1CLENBakJEO0FBa0JsQkMscUJBQW1CLE9BbEJEOztBQW9CbEJDLGdCQUFjLENBcEJJO0FBcUJsQkMscUJBQW1CLEVBckJEO0FBc0JsQkMsWUFBVSxDQXRCUTs7QUF3QmxCQyxjQUFZLEtBeEJNO0FBeUJsQkMsZ0JBQWNDLFNBekJJOztBQTJCbEJDLGFBQVcsR0EzQk87O0FBNkJsQkMsU0FBTyxHQTdCVztBQThCbEJDLGFBQVcsS0E5Qk87QUErQmxCQyxhQUFXLEtBL0JPO0FBZ0NsQkMsa0JBQWdCLElBaENFLEVBZ0NLO0FBQ3ZCQyxjQUFZLEtBakNNO0FBa0NsQkMsYUFBVyxLQWxDTztBQW1DbEJDLGFBQVcsSUFuQ087QUFvQ2xCQywwQkFBd0IsS0FwQ047O0FBc0NsQkMsZ0JBQWMsS0F0Q0k7QUF1Q2xCQyx1QkFBcUIsS0F2Q0g7QUF3Q2xCQyx5QkFBdUIsSUF4Q0w7O0FBMENsQkMsVUFBUSxhQTFDVTtBQTJDbEJDLFlBQVUsS0EzQ1E7QUE0Q2xCQyxhQUFXLENBNUNPO0FBNkNsQkMsYUFBVyxJQTdDTztBQThDbEJDLGtCQUFnQixLQTlDRTs7QUFnRGxCO0FBQ0FDLGVBQWEsRUFqREs7QUFrRGxCQyxnQkFBYyxFQWxESTtBQW1EbEJDLGVBQWEsRUFuREs7O0FBcURsQkMsaUJBQWUsT0FyREc7QUFzRGxCQyxpQkFBZSxHQXRERztBQXVEbEJDLGlCQUFlLEdBdkRHO0FBd0RsQkMsa0JBQWdCLEVBeERFO0FBeURsQkMsaUJBQWUsa0JBekRHOztBQTJEbEJDLG9CQUFrQiwyRUFBQUMsQ0FBbUJDLFlBM0RuQjtBQTREbEJDLGlCQUFlLEtBNURHLEVBNERLOztBQUV2QjtBQUNBQyxxQkFBbUIsS0EvREQ7QUFnRWxCQyx1QkFBcUIsRUFoRUg7QUFpRWxCQyxnQ0FBOEIsU0FqRVo7QUFrRWxCQyxzQ0FBb0MsT0FsRWxCO0FBbUVsQkMsOEJBQTRCLFNBbkVWO0FBb0VsQkMsc0NBQW9DLE1BcEVsQjtBQXFFbEJDLG9DQUFrQyxDQXJFaEI7QUFzRWxCQyw4QkFBMkIsR0F0RVQ7QUF1RWxCQyxzQ0FBb0MsT0F2RWxCO0FBd0VsQkMsb0NBQWtDLENBeEVoQjtBQXlFbEJDLHNCQUFvQixHQXpFRjtBQTBFbEJDLHVCQUFxQixJQTFFSDs7QUE0RWxCO0FBQ0E7QUFDQUMsV0FBUyxDQUNQLGdFQUFBQyxDQUFzQkMsWUFEZixFQUVQLGdFQUFBRCxDQUFzQkUsYUFGZixFQUdQLGdFQUFBRixDQUFzQkcsWUFIZixDQTlFUzs7QUFvRmxCQyxXQUFTLEVBcEZTOztBQXNGbEI7QUFDQUMsUUFBTTtBQUNKQyxPQUFHO0FBQ0RDLHNCQUFnQixFQURmO0FBRUQxQixzQkFBZ0IsRUFGZjtBQUdEMkIsMEJBQW9CLDhFQUhuQjtBQUlEQyxzQkFBZ0IsMEVBSmY7QUFLREMsZ0JBQVUsSUFMVDtBQU1EQyxnQkFBVSxJQU5UO0FBT0RDLHdCQUFrQixJQVBqQjtBQVFEQyxjQUFRLG9FQUFlQztBQVJ0QixLQURDO0FBV0pDLE9BQUc7QUFDRGxDLHNCQUFnQixFQURmO0FBRUQwQixzQkFBZ0IsRUFGZjtBQUdERSxzQkFBZ0IsNEVBSGY7QUFJREQsMEJBQW9CLGdGQUpuQjtBQUtERSxnQkFBVSxJQUxUO0FBTURDLGdCQUFVLElBTlQ7QUFPREMsd0JBQWtCLElBUGpCO0FBUURDLGNBQVEsc0VBQWVHO0FBUnRCLEtBWEM7QUFxQkpDLFFBQUk7QUFDRnBDLHNCQUFnQixFQURkO0FBRUYwQixzQkFBZ0IsRUFGZDtBQUdGRSxzQkFBZ0IsNEVBSGQ7QUFJRkQsMEJBQW9CLGdGQUpsQjtBQUtGRyxnQkFBVSxJQUxSLEVBS2U7QUFDakJELGdCQUFVLEtBTlI7QUFPRkUsd0JBQWtCLEtBUGhCO0FBUUZDLGNBQVEsc0VBQWVHO0FBUnJCO0FBckJBO0FBdkZZLENBQXBCOztBQXlIQSx5REFBZWhGLGFBQWYiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuaW1wb3J0ICogYXMgRHlncmFwaFRpY2tlcnMgZnJvbSAnLi9keWdyYXBoLXRpY2tlcnMnO1xuaW1wb3J0IER5Z3JhcGhJbnRlcmFjdGlvbiBmcm9tICcuL2R5Z3JhcGgtaW50ZXJhY3Rpb24tbW9kZWwnO1xuaW1wb3J0IER5Z3JhcGhDYW52YXNSZW5kZXJlciBmcm9tICcuL2R5Z3JhcGgtY2FudmFzJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vZHlncmFwaC11dGlscyc7XG5cbi8vIERlZmF1bHQgYXR0cmlidXRlIHZhbHVlcy5cbnZhciBERUZBVUxUX0FUVFJTID0ge1xuICBoaWdobGlnaHRDaXJjbGVTaXplOiAzLFxuICBoaWdobGlnaHRTZXJpZXNPcHRzOiBudWxsLFxuICBoaWdobGlnaHRTZXJpZXNCYWNrZ3JvdW5kQWxwaGE6IDAuNSxcbiAgaGlnaGxpZ2h0U2VyaWVzQmFja2dyb3VuZENvbG9yOiAncmdiKDI1NSwgMjU1LCAyNTUpJyxcblxuICBsYWJlbHNTZXBhcmF0ZUxpbmVzOiBmYWxzZSxcbiAgbGFiZWxzU2hvd1plcm9WYWx1ZXM6IHRydWUsXG4gIGxhYmVsc0tNQjogZmFsc2UsXG4gIGxhYmVsc0tNRzI6IGZhbHNlLFxuICBzaG93TGFiZWxzT25IaWdobGlnaHQ6IHRydWUsXG5cbiAgZGlnaXRzQWZ0ZXJEZWNpbWFsOiAyLFxuICBtYXhOdW1iZXJXaWR0aDogNixcbiAgc2lnRmlnczogbnVsbCxcblxuICBzdHJva2VXaWR0aDogMS4wLFxuICBzdHJva2VCb3JkZXJXaWR0aDogMCxcbiAgc3Ryb2tlQm9yZGVyQ29sb3I6IFwid2hpdGVcIixcblxuICBheGlzVGlja1NpemU6IDMsXG4gIGF4aXNMYWJlbEZvbnRTaXplOiAxNCxcbiAgcmlnaHRHYXA6IDUsXG5cbiAgc2hvd1JvbGxlcjogZmFsc2UsXG4gIHhWYWx1ZVBhcnNlcjogdW5kZWZpbmVkLFxuXG4gIGRlbGltaXRlcjogJywnLFxuXG4gIHNpZ21hOiAyLjAsXG4gIGVycm9yQmFyczogZmFsc2UsXG4gIGZyYWN0aW9uczogZmFsc2UsXG4gIHdpbHNvbkludGVydmFsOiB0cnVlLCAgLy8gb25seSByZWxldmFudCBpZiBmcmFjdGlvbnMgaXMgdHJ1ZVxuICBjdXN0b21CYXJzOiBmYWxzZSxcbiAgZmlsbEdyYXBoOiBmYWxzZSxcbiAgZmlsbEFscGhhOiAwLjE1LFxuICBjb25uZWN0U2VwYXJhdGVkUG9pbnRzOiBmYWxzZSxcblxuICBzdGFja2VkR3JhcGg6IGZhbHNlLFxuICBzdGFja2VkR3JhcGhOYU5GaWxsOiAnYWxsJyxcbiAgaGlkZU92ZXJsYXlPbk1vdXNlT3V0OiB0cnVlLFxuXG4gIGxlZ2VuZDogJ29ubW91c2VvdmVyJyxcbiAgc3RlcFBsb3Q6IGZhbHNlLFxuICB4UmFuZ2VQYWQ6IDAsXG4gIHlSYW5nZVBhZDogbnVsbCxcbiAgZHJhd0F4ZXNBdFplcm86IGZhbHNlLFxuXG4gIC8vIFNpemVzIG9mIHRoZSB2YXJpb3VzIGNoYXJ0IGxhYmVscy5cbiAgdGl0bGVIZWlnaHQ6IDI4LFxuICB4TGFiZWxIZWlnaHQ6IDE4LFxuICB5TGFiZWxXaWR0aDogMTgsXG5cbiAgYXhpc0xpbmVDb2xvcjogXCJibGFja1wiLFxuICBheGlzTGluZVdpZHRoOiAwLjMsXG4gIGdyaWRMaW5lV2lkdGg6IDAuMyxcbiAgYXhpc0xhYmVsV2lkdGg6IDUwLFxuICBncmlkTGluZUNvbG9yOiBcInJnYigxMjgsMTI4LDEyOClcIixcblxuICBpbnRlcmFjdGlvbk1vZGVsOiBEeWdyYXBoSW50ZXJhY3Rpb24uZGVmYXVsdE1vZGVsLFxuICBhbmltYXRlZFpvb21zOiBmYWxzZSwgIC8vIChmb3Igbm93KVxuXG4gIC8vIFJhbmdlIHNlbGVjdG9yIG9wdGlvbnNcbiAgc2hvd1JhbmdlU2VsZWN0b3I6IGZhbHNlLFxuICByYW5nZVNlbGVjdG9ySGVpZ2h0OiA0MCxcbiAgcmFuZ2VTZWxlY3RvclBsb3RTdHJva2VDb2xvcjogXCIjODA4RkFCXCIsXG4gIHJhbmdlU2VsZWN0b3JQbG90RmlsbEdyYWRpZW50Q29sb3I6IFwid2hpdGVcIixcbiAgcmFuZ2VTZWxlY3RvclBsb3RGaWxsQ29sb3I6IFwiI0E3QjFDNFwiLFxuICByYW5nZVNlbGVjdG9yQmFja2dyb3VuZFN0cm9rZUNvbG9yOiBcImdyYXlcIixcbiAgcmFuZ2VTZWxlY3RvckJhY2tncm91bmRMaW5lV2lkdGg6IDEsXG4gIHJhbmdlU2VsZWN0b3JQbG90TGluZVdpZHRoOjEuNSxcbiAgcmFuZ2VTZWxlY3RvckZvcmVncm91bmRTdHJva2VDb2xvcjogXCJibGFja1wiLFxuICByYW5nZVNlbGVjdG9yRm9yZWdyb3VuZExpbmVXaWR0aDogMSxcbiAgcmFuZ2VTZWxlY3RvckFscGhhOiAwLjYsXG4gIHNob3dJblJhbmdlU2VsZWN0b3I6IG51bGwsXG5cbiAgLy8gVGhlIG9yZGVyaW5nIGhlcmUgZW5zdXJlcyB0aGF0IGNlbnRyYWwgbGluZXMgYWx3YXlzIGFwcGVhciBhYm92ZSBhbnlcbiAgLy8gZmlsbCBiYXJzL2Vycm9yIGJhcnMuXG4gIHBsb3R0ZXI6IFtcbiAgICBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2ZpbGxQbG90dGVyLFxuICAgIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fZXJyb3JQbG90dGVyLFxuICAgIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fbGluZVBsb3R0ZXJcbiAgXSxcblxuICBwbHVnaW5zOiBbIF0sXG5cbiAgLy8gcGVyLWF4aXMgb3B0aW9uc1xuICBheGVzOiB7XG4gICAgeDoge1xuICAgICAgcGl4ZWxzUGVyTGFiZWw6IDcwLFxuICAgICAgYXhpc0xhYmVsV2lkdGg6IDYwLFxuICAgICAgYXhpc0xhYmVsRm9ybWF0dGVyOiB1dGlscy5kYXRlQXhpc0xhYmVsRm9ybWF0dGVyLFxuICAgICAgdmFsdWVGb3JtYXR0ZXI6IHV0aWxzLmRhdGVWYWx1ZUZvcm1hdHRlcixcbiAgICAgIGRyYXdHcmlkOiB0cnVlLFxuICAgICAgZHJhd0F4aXM6IHRydWUsXG4gICAgICBpbmRlcGVuZGVudFRpY2tzOiB0cnVlLFxuICAgICAgdGlja2VyOiBEeWdyYXBoVGlja2Vycy5kYXRlVGlja2VyXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICBheGlzTGFiZWxXaWR0aDogNTAsXG4gICAgICBwaXhlbHNQZXJMYWJlbDogMzAsXG4gICAgICB2YWx1ZUZvcm1hdHRlcjogdXRpbHMubnVtYmVyVmFsdWVGb3JtYXR0ZXIsXG4gICAgICBheGlzTGFiZWxGb3JtYXR0ZXI6IHV0aWxzLm51bWJlckF4aXNMYWJlbEZvcm1hdHRlcixcbiAgICAgIGRyYXdHcmlkOiB0cnVlLFxuICAgICAgZHJhd0F4aXM6IHRydWUsXG4gICAgICBpbmRlcGVuZGVudFRpY2tzOiB0cnVlLFxuICAgICAgdGlja2VyOiBEeWdyYXBoVGlja2Vycy5udW1lcmljVGlja3NcbiAgICB9LFxuICAgIHkyOiB7XG4gICAgICBheGlzTGFiZWxXaWR0aDogNTAsXG4gICAgICBwaXhlbHNQZXJMYWJlbDogMzAsXG4gICAgICB2YWx1ZUZvcm1hdHRlcjogdXRpbHMubnVtYmVyVmFsdWVGb3JtYXR0ZXIsXG4gICAgICBheGlzTGFiZWxGb3JtYXR0ZXI6IHV0aWxzLm51bWJlckF4aXNMYWJlbEZvcm1hdHRlcixcbiAgICAgIGRyYXdBeGlzOiB0cnVlLCAgLy8gb25seSBhcHBsaWVzIHdoZW4gdGhlcmUgYXJlIHR3byBheGVzIG9mIGRhdGEuXG4gICAgICBkcmF3R3JpZDogZmFsc2UsXG4gICAgICBpbmRlcGVuZGVudFRpY2tzOiBmYWxzZSxcbiAgICAgIHRpY2tlcjogRHlncmFwaFRpY2tlcnMubnVtZXJpY1RpY2tzXG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBERUZBVUxUX0FUVFJTO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9keWdyYXBocy9zcmMvZHlncmFwaC1kZWZhdWx0LWF0dHJzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__ = __webpack_require__(0);\n/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview Based on PlotKitLayout, but modified to meet the needs of\n * dygraphs.\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * Creates a new DygraphLayout object.\n *\n * This class contains all the data to be charted.\n * It uses data coordinates, but also records the chart range (in data\n * coordinates) and hence is able to calculate percentage positions ('In this\n * view, Point A lies 25% down the x-axis.')\n *\n * Two things that it does not do are:\n * 1. Record pixel coordinates for anything.\n * 2. (oddly) determine anything about the layout of chart elements.\n *\n * The naming is a vestige of Dygraph's original PlotKit roots.\n *\n * @constructor\n */\nvar DygraphLayout = function DygraphLayout(dygraph) {\n  this.dygraph_ = dygraph;\n  /**\n   * Array of points for each series.\n   *\n   * [series index][row index in series] = |Point| structure,\n   * where series index refers to visible series only, and the\n   * point index is for the reduced set of points for the current\n   * zoom region (including one point just outside the window).\n   * All points in the same row index share the same X value.\n   *\n   * @type {Array.<Array.<Dygraph.PointType>>}\n   */\n  this.points = [];\n  this.setNames = [];\n  this.annotations = [];\n  this.yAxes_ = null;\n\n  // TODO(danvk): it's odd that xTicks_ and yTicks_ are inputs, but xticks and\n  // yticks are outputs. Clean this up.\n  this.xTicks_ = null;\n  this.yTicks_ = null;\n};\n\n/**\n * Add points for a single series.\n *\n * @param {string} setname Name of the series.\n * @param {Array.<Dygraph.PointType>} set_xy Points for the series.\n */\nDygraphLayout.prototype.addDataset = function (setname, set_xy) {\n  this.points.push(set_xy);\n  this.setNames.push(setname);\n};\n\n/**\n * Returns the box which the chart should be drawn in. This is the canvas's\n * box, less space needed for the axis and chart labels.\n *\n * @return {{x: number, y: number, w: number, h: number}}\n */\nDygraphLayout.prototype.getPlotArea = function () {\n  return this.area_;\n};\n\n// Compute the box which the chart should be drawn in. This is the canvas's\n// box, less space needed for axis, chart labels, and other plug-ins.\n// NOTE: This should only be called by Dygraph.predraw_().\nDygraphLayout.prototype.computePlotArea = function () {\n  var area = {\n    // TODO(danvk): per-axis setting.\n    x: 0,\n    y: 0\n  };\n\n  area.w = this.dygraph_.width_ - area.x - this.dygraph_.getOption('rightGap');\n  area.h = this.dygraph_.height_;\n\n  // Let plugins reserve space.\n  var e = {\n    chart_div: this.dygraph_.graphDiv,\n    reserveSpaceLeft: function reserveSpaceLeft(px) {\n      var r = {\n        x: area.x,\n        y: area.y,\n        w: px,\n        h: area.h\n      };\n      area.x += px;\n      area.w -= px;\n      return r;\n    },\n    reserveSpaceRight: function reserveSpaceRight(px) {\n      var r = {\n        x: area.x + area.w - px,\n        y: area.y,\n        w: px,\n        h: area.h\n      };\n      area.w -= px;\n      return r;\n    },\n    reserveSpaceTop: function reserveSpaceTop(px) {\n      var r = {\n        x: area.x,\n        y: area.y,\n        w: area.w,\n        h: px\n      };\n      area.y += px;\n      area.h -= px;\n      return r;\n    },\n    reserveSpaceBottom: function reserveSpaceBottom(px) {\n      var r = {\n        x: area.x,\n        y: area.y + area.h - px,\n        w: area.w,\n        h: px\n      };\n      area.h -= px;\n      return r;\n    },\n    chartRect: function chartRect() {\n      return { x: area.x, y: area.y, w: area.w, h: area.h };\n    }\n  };\n  this.dygraph_.cascadeEvents_('layout', e);\n\n  this.area_ = area;\n};\n\nDygraphLayout.prototype.setAnnotations = function (ann) {\n  // The Dygraph object's annotations aren't parsed. We parse them here and\n  // save a copy. If there is no parser, then the user must be using raw format.\n  this.annotations = [];\n  var parse = this.dygraph_.getOption('xValueParser') || function (x) {\n    return x;\n  };\n  for (var i = 0; i < ann.length; i++) {\n    var a = {};\n    if (!ann[i].xval && ann[i].x === undefined) {\n      console.error(\"Annotations must have an 'x' property\");\n      return;\n    }\n    if (ann[i].icon && !(ann[i].hasOwnProperty('width') && ann[i].hasOwnProperty('height'))) {\n      console.error(\"Must set width and height when setting \" + \"annotation.icon property\");\n      return;\n    }\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"a\" /* update */](a, ann[i]);\n    if (!a.xval) a.xval = parse(a.x);\n    this.annotations.push(a);\n  }\n};\n\nDygraphLayout.prototype.setXTicks = function (xTicks) {\n  this.xTicks_ = xTicks;\n};\n\n// TODO(danvk): add this to the Dygraph object's API or move it into Layout.\nDygraphLayout.prototype.setYAxes = function (yAxes) {\n  this.yAxes_ = yAxes;\n};\n\nDygraphLayout.prototype.evaluate = function () {\n  this._xAxis = {};\n  this._evaluateLimits();\n  this._evaluateLineCharts();\n  this._evaluateLineTicks();\n  this._evaluateAnnotations();\n};\n\nDygraphLayout.prototype._evaluateLimits = function () {\n  var xlimits = this.dygraph_.xAxisRange();\n  this._xAxis.minval = xlimits[0];\n  this._xAxis.maxval = xlimits[1];\n  var xrange = xlimits[1] - xlimits[0];\n  this._xAxis.scale = xrange !== 0 ? 1 / xrange : 1.0;\n\n  if (this.dygraph_.getOptionForAxis(\"logscale\", 'x')) {\n    this._xAxis.xlogrange = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](this._xAxis.maxval) - __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](this._xAxis.minval);\n    this._xAxis.xlogscale = this._xAxis.xlogrange !== 0 ? 1.0 / this._xAxis.xlogrange : 1.0;\n  }\n  for (var i = 0; i < this.yAxes_.length; i++) {\n    var axis = this.yAxes_[i];\n    axis.minyval = axis.computedValueRange[0];\n    axis.maxyval = axis.computedValueRange[1];\n    axis.yrange = axis.maxyval - axis.minyval;\n    axis.yscale = axis.yrange !== 0 ? 1.0 / axis.yrange : 1.0;\n\n    if (this.dygraph_.getOption(\"logscale\")) {\n      axis.ylogrange = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](axis.maxyval) - __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](axis.minyval);\n      axis.ylogscale = axis.ylogrange !== 0 ? 1.0 / axis.ylogrange : 1.0;\n      if (!isFinite(axis.ylogrange) || isNaN(axis.ylogrange)) {\n        console.error('axis ' + i + ' of graph at ' + axis.g + ' can\\'t be displayed in log scale for range [' + axis.minyval + ' - ' + axis.maxyval + ']');\n      }\n    }\n  }\n};\n\nDygraphLayout.calcXNormal_ = function (value, xAxis, logscale) {\n  if (logscale) {\n    return (__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](value) - __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](xAxis.minval)) * xAxis.xlogscale;\n  } else {\n    return (value - xAxis.minval) * xAxis.scale;\n  }\n};\n\n/**\n * @param {DygraphAxisType} axis\n * @param {number} value\n * @param {boolean} logscale\n * @return {number}\n */\nDygraphLayout.calcYNormal_ = function (axis, value, logscale) {\n  if (logscale) {\n    var x = 1.0 - (__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](value) - __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](axis.minyval)) * axis.ylogscale;\n    return isFinite(x) ? x : NaN; // shim for v8 issue; see pull request 276\n  } else {\n    return 1.0 - (value - axis.minyval) * axis.yscale;\n  }\n};\n\nDygraphLayout.prototype._evaluateLineCharts = function () {\n  var isStacked = this.dygraph_.getOption(\"stackedGraph\");\n  var isLogscaleForX = this.dygraph_.getOptionForAxis(\"logscale\", 'x');\n\n  for (var setIdx = 0; setIdx < this.points.length; setIdx++) {\n    var points = this.points[setIdx];\n    var setName = this.setNames[setIdx];\n    var connectSeparated = this.dygraph_.getOption('connectSeparatedPoints', setName);\n    var axis = this.dygraph_.axisPropertiesForSeries(setName);\n    // TODO (konigsberg): use optionsForAxis instead.\n    var logscale = this.dygraph_.attributes_.getForSeries(\"logscale\", setName);\n\n    for (var j = 0; j < points.length; j++) {\n      var point = points[j];\n\n      // Range from 0-1 where 0 represents left and 1 represents right.\n      point.x = DygraphLayout.calcXNormal_(point.xval, this._xAxis, isLogscaleForX);\n      // Range from 0-1 where 0 represents top and 1 represents bottom\n      var yval = point.yval;\n      if (isStacked) {\n        point.y_stacked = DygraphLayout.calcYNormal_(axis, point.yval_stacked, logscale);\n        if (yval !== null && !isNaN(yval)) {\n          yval = point.yval_stacked;\n        }\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    }\n\n    this.dygraph_.dataHandler_.onLineEvaluated(points, axis, logscale);\n  }\n};\n\nDygraphLayout.prototype._evaluateLineTicks = function () {\n  var i, tick, label, pos, v, has_tick;\n  this.xticks = [];\n  for (i = 0; i < this.xTicks_.length; i++) {\n    tick = this.xTicks_[i];\n    label = tick.label;\n    has_tick = !('label_v' in tick);\n    v = has_tick ? tick.v : tick.label_v;\n    pos = this.dygraph_.toPercentXCoord(v);\n    if (pos >= 0.0 && pos < 1.0) {\n      this.xticks.push({ pos: pos, label: label, has_tick: has_tick });\n    }\n  }\n\n  this.yticks = [];\n  for (i = 0; i < this.yAxes_.length; i++) {\n    var axis = this.yAxes_[i];\n    for (var j = 0; j < axis.ticks.length; j++) {\n      tick = axis.ticks[j];\n      label = tick.label;\n      has_tick = !('label_v' in tick);\n      v = has_tick ? tick.v : tick.label_v;\n      pos = this.dygraph_.toPercentYCoord(v, i);\n      if (pos > 0.0 && pos <= 1.0) {\n        this.yticks.push({ axis: i, pos: pos, label: label, has_tick: has_tick });\n      }\n    }\n  }\n};\n\nDygraphLayout.prototype._evaluateAnnotations = function () {\n  // Add the annotations to the point to which they belong.\n  // Make a map from (setName, xval) to annotation for quick lookups.\n  var i;\n  var annotations = {};\n  for (i = 0; i < this.annotations.length; i++) {\n    var a = this.annotations[i];\n    annotations[a.xval + \",\" + a.series] = a;\n  }\n\n  this.annotated_points = [];\n\n  // Exit the function early if there are no annotations.\n  if (!this.annotations || !this.annotations.length) {\n    return;\n  }\n\n  // TODO(antrob): loop through annotations not points.\n  for (var setIdx = 0; setIdx < this.points.length; setIdx++) {\n    var points = this.points[setIdx];\n    for (i = 0; i < points.length; i++) {\n      var p = points[i];\n      var k = p.xval + \",\" + p.name;\n      if (k in annotations) {\n        p.annotation = annotations[k];\n        this.annotated_points.push(p);\n      }\n    }\n  }\n};\n\n/**\n * Convenience function to remove all the data sets from a graph\n */\nDygraphLayout.prototype.removeAllDatasets = function () {\n  delete this.points;\n  delete this.setNames;\n  delete this.setPointsLengths;\n  delete this.setPointsOffsets;\n  this.points = [];\n  this.setNames = [];\n  this.setPointsLengths = [];\n  this.setPointsOffsets = [];\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DygraphLayout);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLWxheW91dC5qcz9mODlkIl0sIm5hbWVzIjpbIkR5Z3JhcGhMYXlvdXQiLCJkeWdyYXBoIiwiZHlncmFwaF8iLCJwb2ludHMiLCJzZXROYW1lcyIsImFubm90YXRpb25zIiwieUF4ZXNfIiwieFRpY2tzXyIsInlUaWNrc18iLCJwcm90b3R5cGUiLCJhZGREYXRhc2V0Iiwic2V0bmFtZSIsInNldF94eSIsInB1c2giLCJnZXRQbG90QXJlYSIsImFyZWFfIiwiY29tcHV0ZVBsb3RBcmVhIiwiYXJlYSIsIngiLCJ5IiwidyIsIndpZHRoXyIsImdldE9wdGlvbiIsImgiLCJoZWlnaHRfIiwiZSIsImNoYXJ0X2RpdiIsImdyYXBoRGl2IiwicmVzZXJ2ZVNwYWNlTGVmdCIsInB4IiwiciIsInJlc2VydmVTcGFjZVJpZ2h0IiwicmVzZXJ2ZVNwYWNlVG9wIiwicmVzZXJ2ZVNwYWNlQm90dG9tIiwiY2hhcnRSZWN0IiwiY2FzY2FkZUV2ZW50c18iLCJzZXRBbm5vdGF0aW9ucyIsImFubiIsInBhcnNlIiwiaSIsImxlbmd0aCIsImEiLCJ4dmFsIiwidW5kZWZpbmVkIiwiY29uc29sZSIsImVycm9yIiwiaWNvbiIsImhhc093blByb3BlcnR5IiwidXRpbHMiLCJzZXRYVGlja3MiLCJ4VGlja3MiLCJzZXRZQXhlcyIsInlBeGVzIiwiZXZhbHVhdGUiLCJfeEF4aXMiLCJfZXZhbHVhdGVMaW1pdHMiLCJfZXZhbHVhdGVMaW5lQ2hhcnRzIiwiX2V2YWx1YXRlTGluZVRpY2tzIiwiX2V2YWx1YXRlQW5ub3RhdGlvbnMiLCJ4bGltaXRzIiwieEF4aXNSYW5nZSIsIm1pbnZhbCIsIm1heHZhbCIsInhyYW5nZSIsInNjYWxlIiwiZ2V0T3B0aW9uRm9yQXhpcyIsInhsb2dyYW5nZSIsInhsb2dzY2FsZSIsImF4aXMiLCJtaW55dmFsIiwiY29tcHV0ZWRWYWx1ZVJhbmdlIiwibWF4eXZhbCIsInlyYW5nZSIsInlzY2FsZSIsInlsb2dyYW5nZSIsInlsb2dzY2FsZSIsImlzRmluaXRlIiwiaXNOYU4iLCJnIiwiY2FsY1hOb3JtYWxfIiwidmFsdWUiLCJ4QXhpcyIsImxvZ3NjYWxlIiwiY2FsY1lOb3JtYWxfIiwiTmFOIiwiaXNTdGFja2VkIiwiaXNMb2dzY2FsZUZvclgiLCJzZXRJZHgiLCJzZXROYW1lIiwiY29ubmVjdFNlcGFyYXRlZCIsImF4aXNQcm9wZXJ0aWVzRm9yU2VyaWVzIiwiYXR0cmlidXRlc18iLCJnZXRGb3JTZXJpZXMiLCJqIiwicG9pbnQiLCJ5dmFsIiwieV9zdGFja2VkIiwieXZhbF9zdGFja2VkIiwiZGF0YUhhbmRsZXJfIiwib25MaW5lRXZhbHVhdGVkIiwidGljayIsImxhYmVsIiwicG9zIiwidiIsImhhc190aWNrIiwieHRpY2tzIiwibGFiZWxfdiIsInRvUGVyY2VudFhDb29yZCIsInl0aWNrcyIsInRpY2tzIiwidG9QZXJjZW50WUNvb3JkIiwic2VyaWVzIiwiYW5ub3RhdGVkX3BvaW50cyIsInAiLCJrIiwibmFtZSIsImFubm90YXRpb24iLCJyZW1vdmVBbGxEYXRhc2V0cyIsInNldFBvaW50c0xlbmd0aHMiLCJzZXRQb2ludHNPZmZzZXRzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOzs7Ozs7QUFNQTs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLElBQUlBLGdCQUFnQixTQUFoQkEsYUFBZ0IsQ0FBU0MsT0FBVCxFQUFrQjtBQUNwQyxPQUFLQyxRQUFMLEdBQWdCRCxPQUFoQjtBQUNBOzs7Ozs7Ozs7OztBQVdBLE9BQUtFLE1BQUwsR0FBYyxFQUFkO0FBQ0EsT0FBS0MsUUFBTCxHQUFnQixFQUFoQjtBQUNBLE9BQUtDLFdBQUwsR0FBbUIsRUFBbkI7QUFDQSxPQUFLQyxNQUFMLEdBQWMsSUFBZDs7QUFFQTtBQUNBO0FBQ0EsT0FBS0MsT0FBTCxHQUFlLElBQWY7QUFDQSxPQUFLQyxPQUFMLEdBQWUsSUFBZjtBQUNELENBdEJEOztBQXdCQTs7Ozs7O0FB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QUFGLEdBQWUvRyxZQUFZNkcsQ0FBWixDQUFmO0FBQ0EsYUFBS0YsZ0JBQUwsQ0FBc0JuRyxJQUF0QixDQUEyQm9HLENBQTNCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsQ0E3QkQ7O0FBK0JBOzs7QUFHQWpILGNBQWNTLFNBQWQsQ0FBd0I0RyxpQkFBeEIsR0FBNEMsWUFBVztBQUNyRCxTQUFPLEtBQUtsSCxNQUFaO0FBQ0EsU0FBTyxLQUFLQyxRQUFaO0FBQ0EsU0FBTyxLQUFLa0gsZ0JBQVo7QUFDQSxTQUFPLEtBQUtDLGdCQUFaO0FBQ0EsT0FBS3BILE1BQUwsR0FBYyxFQUFkO0FBQ0EsT0FBS0MsUUFBTCxHQUFnQixFQUFoQjtBQUNBLE9BQUtrSCxnQkFBTCxHQUF3QixFQUF4QjtBQUNBLE9BQUtDLGdCQUFMLEdBQXdCLEVBQXhCO0FBQ0QsQ0FURDs7QUFXQSx5REFBZXZILGFBQWYiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMSBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBCYXNlZCBvbiBQbG90S2l0TGF5b3V0LCBidXQgbW9kaWZpZWQgdG8gbWVldCB0aGUgbmVlZHMgb2ZcbiAqIGR5Z3JhcGhzLlxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2R5Z3JhcGgtdXRpbHMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgRHlncmFwaExheW91dCBvYmplY3QuXG4gKlxuICogVGhpcyBjbGFzcyBjb250YWlucyBhbGwgdGhlIGRhdGEgdG8gYmUgY2hhcnRlZC5cbiAqIEl0IHVzZXMgZGF0YSBjb29yZGluYXRlcywgYnV0IGFsc28gcmVjb3JkcyB0aGUgY2hhcnQgcmFuZ2UgKGluIGRhdGFcbiAqIGNvb3JkaW5hdGVzKSBhbmQgaGVuY2UgaXMgYWJsZSB0byBjYWxjdWxhdGUgcGVyY2VudGFnZSBwb3NpdGlvbnMgKCdJbiB0aGlzXG4gKiB2aWV3LCBQb2ludCBBIGxpZXMgMjUlIGRvd24gdGhlIHgtYXhpcy4nKVxuICpcbiAqIFR3byB0aGluZ3MgdGhhdCBpdCBkb2VzIG5vdCBkbyBhcmU6XG4gKiAxLiBSZWNvcmQgcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGFueXRoaW5nLlxuICogMi4gKG9kZGx5KSBkZXRlcm1pbmUgYW55dGhpbmcgYWJvdXQgdGhlIGxheW91dCBvZiBjaGFydCBlbGVtZW50cy5cbiAqXG4gKiBUaGUgbmFtaW5nIGlzIGEgdmVzdGlnZSBvZiBEeWdyYXBoJ3Mgb3JpZ2luYWwgUGxvdEtpdCByb290cy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIER5Z3JhcGhMYXlvdXQgPSBmdW5jdGlvbihkeWdyYXBoKSB7XG4gIHRoaXMuZHlncmFwaF8gPSBkeWdyYXBoO1xuICAvKipcbiAgICogQXJyYXkgb2YgcG9pbnRzIGZvciBlYWNoIHNlcmllcy5cbiAgICpcbiAgICogW3NlcmllcyBpbmRleF1bcm93IGluZGV4IGluIHNlcmllc10gPSB8UG9pbnR8IHN0cnVjdHVyZSxcbiAgICogd2hlcmUgc2VyaWVzIGluZGV4IHJlZmVycyB0byB2aXNpYmxlIHNlcmllcyBvbmx5LCBhbmQgdGhlXG4gICAqIHBvaW50IGluZGV4IGlzIGZvciB0aGUgcmVkdWNlZCBzZXQgb2YgcG9pbnRzIGZvciB0aGUgY3VycmVudFxuICAgKiB6b29tIHJlZ2lvbiAoaW5jbHVkaW5nIG9uZSBwb2ludCBqdXN0IG91dHNpZGUgdGhlIHdpbmRvdykuXG4gICAqIEFsbCBwb2ludHMgaW4gdGhlIHNhbWUgcm93IGluZGV4IHNoYXJlIHRoZSBzYW1lIFggdmFsdWUuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheS48QXJyYXkuPER5Z3JhcGguUG9pbnRUeXBlPj59XG4gICAqL1xuICB0aGlzLnBvaW50cyA9IFtdO1xuICB0aGlzLnNldE5hbWVzID0gW107XG4gIHRoaXMuYW5ub3RhdGlvbnMgPSBbXTtcbiAgdGhpcy55QXhlc18gPSBudWxsO1xuXG4gIC8vIFRPRE8oZGFudmspOiBpdCdzIG9kZCB0aGF0IHhUaWNrc18gYW5kIHlUaWNrc18gYXJlIGlucHV0cywgYnV0IHh0aWNrcyBhbmRcbiAgLy8geXRpY2tzIGFyZSBvdXRwdXRzLiBDbGVhbiB0aGlzIHVwLlxuICB0aGlzLnhUaWNrc18gPSBudWxsO1xuICB0aGlzLnlUaWNrc18gPSBudWxsO1xufTtcblxuLyoqXG4gKiBBZGQgcG9pbnRzIGZvciBhIHNpbmdsZSBzZXJpZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNldG5hbWUgTmFtZSBvZiB0aGUgc2VyaWVzLlxuICogQHBhcmFtIHtBcnJheS48RHlncmFwaC5Qb2ludFR5cGU+fSBzZXRfeHkgUG9pbnRzIGZvciB0aGUgc2VyaWVzLlxuICovXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5hZGREYXRhc2V0ID0gZnVuY3Rpb24oc2V0bmFtZSwgc2V0X3h5KSB7XG4gIHRoaXMucG9pbnRzLnB1c2goc2V0X3h5KTtcbiAgdGhpcy5zZXROYW1lcy5wdXNoKHNldG5hbWUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBib3ggd2hpY2ggdGhlIGNoYXJ0IHNob3VsZCBiZSBkcmF3biBpbi4gVGhpcyBpcyB0aGUgY2FudmFzJ3NcbiAqIGJveCwgbGVzcyBzcGFjZSBuZWVkZWQgZm9yIHRoZSBheGlzIGFuZCBjaGFydCBsYWJlbHMuXG4gKlxuICogQHJldHVybiB7e3g6IG51bWJlciwgeTogbnVtYmVyLCB3OiBudW1iZXIsIGg6IG51bWJlcn19XG4gKi9cbkR5Z3JhcGhMYXlvdXQucHJvdG90eXBlLmdldFBsb3RBcmVhID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmFyZWFfO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgYm94IHdoaWNoIHRoZSBjaGFydCBzaG91bGQgYmUgZHJhd24gaW4uIFRoaXMgaXMgdGhlIGNhbnZhcydzXG4vLyBib3gsIGxlc3Mgc3BhY2UgbmVlZGVkIGZvciBheGlzLCBjaGFydCBsYWJlbHMsIGFuZCBvdGhlciBwbHVnLWlucy5cbi8vIE5PVEU6IFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJ5IER5Z3JhcGgucHJlZHJhd18oKS5cbkR5Z3JhcGhMYXlvdXQucHJvdG90eXBlLmNvbXB1dGVQbG90QXJlYSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXJlYSA9IHtcbiAgICAvLyBUT0RPKGRhbnZrKTogcGVyLWF4aXMgc2V0dGluZy5cbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBhcmVhLncgPSB0aGlzLmR5Z3JhcGhfLndpZHRoXyAtIGFyZWEueCAtIHRoaXMuZHlncmFwaF8uZ2V0T3B0aW9uKCdyaWdodEdhcCcpO1xuICBhcmVhLmggPSB0aGlzLmR5Z3JhcGhfLmhlaWdodF87XG5cbiAgLy8gTGV0IHBsdWdpbnMgcmVzZXJ2ZSBzcGFjZS5cbiAgdmFyIGUgPSB7XG4gICAgY2hhcnRfZGl2OiB0aGlzLmR5Z3JhcGhfLmdyYXBoRGl2LFxuICAgIHJlc2VydmVTcGFjZUxlZnQ6IGZ1bmN0aW9uKHB4KSB7XG4gICAgICB2YXIgciA9IHtcbiAgICAgICAgeDogYXJlYS54LFxuICAgICAgICB5OiBhcmVhLnksXG4gICAgICAgIHc6IHB4LFxuICAgICAgICBoOiBhcmVhLmhcbiAgICAgIH07XG4gICAgICBhcmVhLnggKz0gcHg7XG4gICAgICBhcmVhLncgLT0gcHg7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIHJlc2VydmVTcGFjZVJpZ2h0OiBmdW5jdGlvbihweCkge1xuICAgICAgdmFyIHIgPSB7XG4gICAgICAgIHg6IGFyZWEueCArIGFyZWEudyAtIHB4LFxuICAgICAgICB5OiBhcmVhLnksXG4gICAgICAgIHc6IHB4LFxuICAgICAgICBoOiBhcmVhLmhcbiAgICAgIH07XG4gICAgICBhcmVhLncgLT0gcHg7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIHJlc2VydmVTcGFjZVRvcDogZnVuY3Rpb24ocHgpIHtcbiAgICAgIHZhciByID0ge1xuICAgICAgICB4OiBhcmVhLngsXG4gICAgICAgIHk6IGFyZWEueSxcbiAgICAgICAgdzogYXJlYS53LFxuICAgICAgICBoOiBweFxuICAgICAgfTtcbiAgICAgIGFyZWEueSArPSBweDtcbiAgICAgIGFyZWEuaCAtPSBweDtcbiAgICAgIHJldHVybiByO1xuICAgIH0sXG4gICAgcmVzZXJ2ZVNwYWNlQm90dG9tOiBmdW5jdGlvbihweCkge1xuICAgICAgdmFyIHIgPSB7XG4gICAgICAgIHg6IGFyZWEueCxcbiAgICAgICAgeTogYXJlYS55ICsgYXJlYS5oIC0gcHgsXG4gICAgICAgIHc6IGFyZWEudyxcbiAgICAgICAgaDogcHhcbiAgICAgIH07XG4gICAgICBhcmVhLmggLT0gcHg7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIGNoYXJ0UmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge3g6YXJlYS54LCB5OmFyZWEueSwgdzphcmVhLncsIGg6YXJlYS5ofTtcbiAgICB9XG4gIH07XG4gIHRoaXMuZHlncmFwaF8uY2FzY2FkZUV2ZW50c18oJ2xheW91dCcsIGUpO1xuXG4gIHRoaXMuYXJlYV8gPSBhcmVhO1xufTtcblxuRHlncmFwaExheW91dC5wcm90b3R5cGUuc2V0QW5ub3RhdGlvbnMgPSBmdW5jdGlvbihhbm4pIHtcbiAgLy8gVGhlIER5Z3JhcGggb2JqZWN0J3MgYW5ub3RhdGlvbnMgYXJlbid0IHBhcnNlZC4gV2UgcGFyc2UgdGhlbSBoZXJlIGFuZFxuICAvLyBzYXZlIGEgY29weS4gSWYgdGhlcmUgaXMgbm8gcGFyc2VyLCB0aGVuIHRoZSB1c2VyIG11c3QgYmUgdXNpbmcgcmF3IGZvcm1hdC5cbiAgdGhpcy5hbm5vdGF0aW9ucyA9IFtdO1xuICB2YXIgcGFyc2UgPSB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbigneFZhbHVlUGFyc2VyJykgfHwgZnVuY3Rpb24oeCkgeyByZXR1cm4geDsgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbm4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYSA9IHt9O1xuICAgIGlmICghYW5uW2ldLnh2YWwgJiYgYW5uW2ldLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkFubm90YXRpb25zIG11c3QgaGF2ZSBhbiAneCcgcHJvcGVydHlcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhbm5baV0uaWNvbiAmJlxuICAgICAgICAhKGFubltpXS5oYXNPd25Qcm9wZXJ0eSgnd2lkdGgnKSAmJlxuICAgICAgICAgIGFubltpXS5oYXNPd25Qcm9wZXJ0eSgnaGVpZ2h0JykpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiTXVzdCBzZXQgd2lkdGggYW5kIGhlaWdodCB3aGVuIHNldHRpbmcgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImFubm90YXRpb24uaWNvbiBwcm9wZXJ0eVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXRpbHMudXBkYXRlKGEsIGFubltpXSk7XG4gICAgaWYgKCFhLnh2YWwpIGEueHZhbCA9IHBhcnNlKGEueCk7XG4gICAgdGhpcy5hbm5vdGF0aW9ucy5wdXNoKGEpO1xuICB9XG59O1xuXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5zZXRYVGlja3MgPSBmdW5jdGlvbih4VGlja3MpIHtcbiAgdGhpcy54VGlja3NfID0geFRpY2tzO1xufTtcblxuLy8gVE9ETyhkYW52ayk6IGFkZCB0aGlzIHRvIHRoZSBEeWdyYXBoIG9iamVjdCdzIEFQSSBvciBtb3ZlIGl0IGludG8gTGF5b3V0LlxuRHlncmFwaExheW91dC5wcm90b3R5cGUuc2V0WUF4ZXMgPSBmdW5jdGlvbiAoeUF4ZXMpIHtcbiAgdGhpcy55QXhlc18gPSB5QXhlcztcbn07XG5cbkR5Z3JhcGhMYXlvdXQucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3hBeGlzID0ge307XG4gIHRoaXMuX2V2YWx1YXRlTGltaXRzKCk7XG4gIHRoaXMuX2V2YWx1YXRlTGluZUNoYXJ0cygpO1xuICB0aGlzLl9ldmFsdWF0ZUxpbmVUaWNrcygpO1xuICB0aGlzLl9ldmFsdWF0ZUFubm90YXRpb25zKCk7XG59O1xuXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5fZXZhbHVhdGVMaW1pdHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHhsaW1pdHMgPSB0aGlzLmR5Z3JhcGhfLnhBeGlzUmFuZ2UoKTtcbiAgdGhpcy5feEF4aXMubWludmFsID0geGxpbWl0c1swXTtcbiAgdGhpcy5feEF4aXMubWF4dmFsID0geGxpbWl0c1sxXTtcbiAgdmFyIHhyYW5nZSA9IHhsaW1pdHNbMV0gLSB4bGltaXRzWzBdO1xuICB0aGlzLl94QXhpcy5zY2FsZSA9ICh4cmFuZ2UgIT09IDAgPyAxIC8geHJhbmdlIDogMS4wKTtcblxuICBpZiAodGhpcy5keWdyYXBoXy5nZXRPcHRpb25Gb3JBeGlzKFwibG9nc2NhbGVcIiwgJ3gnKSkge1xuICAgIHRoaXMuX3hBeGlzLnhsb2dyYW5nZSA9IHV0aWxzLmxvZzEwKHRoaXMuX3hBeGlzLm1heHZhbCkgLSB1dGlscy5sb2cxMCh0aGlzLl94QXhpcy5taW52YWwpO1xuICAgIHRoaXMuX3hBeGlzLnhsb2dzY2FsZSA9ICh0aGlzLl94QXhpcy54bG9ncmFuZ2UgIT09IDAgPyAxLjAgLyB0aGlzLl94QXhpcy54bG9ncmFuZ2UgOiAxLjApO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy55QXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXhpcyA9IHRoaXMueUF4ZXNfW2ldO1xuICAgIGF4aXMubWlueXZhbCA9IGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdO1xuICAgIGF4aXMubWF4eXZhbCA9IGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzFdO1xuICAgIGF4aXMueXJhbmdlID0gYXhpcy5tYXh5dmFsIC0gYXhpcy5taW55dmFsO1xuICAgIGF4aXMueXNjYWxlID0gKGF4aXMueXJhbmdlICE9PSAwID8gMS4wIC8gYXhpcy55cmFuZ2UgOiAxLjApO1xuXG4gICAgaWYgKHRoaXMuZHlncmFwaF8uZ2V0T3B0aW9uKFwibG9nc2NhbGVcIikpIHtcbiAgICAgIGF4aXMueWxvZ3JhbmdlID0gdXRpbHMubG9nMTAoYXhpcy5tYXh5dmFsKSAtIHV0aWxzLmxvZzEwKGF4aXMubWlueXZhbCk7XG4gICAgICBheGlzLnlsb2dzY2FsZSA9IChheGlzLnlsb2dyYW5nZSAhPT0gMCA/IDEuMCAvIGF4aXMueWxvZ3JhbmdlIDogMS4wKTtcbiAgICAgIGlmICghaXNGaW5pdGUoYXhpcy55bG9ncmFuZ2UpIHx8IGlzTmFOKGF4aXMueWxvZ3JhbmdlKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdheGlzICcgKyBpICsgJyBvZiBncmFwaCBhdCAnICsgYXhpcy5nICtcbiAgICAgICAgICAgICAgICAgICAgICAnIGNhblxcJ3QgYmUgZGlzcGxheWVkIGluIGxvZyBzY2FsZSBmb3IgcmFuZ2UgWycgK1xuICAgICAgICAgICAgICAgICAgICAgIGF4aXMubWlueXZhbCArICcgLSAnICsgYXhpcy5tYXh5dmFsICsgJ10nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkR5Z3JhcGhMYXlvdXQuY2FsY1hOb3JtYWxfID0gZnVuY3Rpb24odmFsdWUsIHhBeGlzLCBsb2dzY2FsZSkge1xuICBpZiAobG9nc2NhbGUpIHtcbiAgICByZXR1cm4gKCh1dGlscy5sb2cxMCh2YWx1ZSkgLSB1dGlscy5sb2cxMCh4QXhpcy5taW52YWwpKSAqIHhBeGlzLnhsb2dzY2FsZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh2YWx1ZSAtIHhBeGlzLm1pbnZhbCkgKiB4QXhpcy5zY2FsZTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0R5Z3JhcGhBeGlzVHlwZX0gYXhpc1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvZ3NjYWxlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkR5Z3JhcGhMYXlvdXQuY2FsY1lOb3JtYWxfID0gZnVuY3Rpb24oYXhpcywgdmFsdWUsIGxvZ3NjYWxlKSB7XG4gIGlmIChsb2dzY2FsZSkge1xuICAgIHZhciB4ID0gMS4wIC0gKCh1dGlscy5sb2cxMCh2YWx1ZSkgLSB1dGlscy5sb2cxMChheGlzLm1pbnl2YWwpKSAqIGF4aXMueWxvZ3NjYWxlKTtcbiAgICByZXR1cm4gaXNGaW5pdGUoeCkgPyB4IDogTmFOOyAgLy8gc2hpbSBmb3IgdjggaXNzdWU7IHNlZSBwdWxsIHJlcXVlc3QgMjc2XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDEuMCAtICgodmFsdWUgLSBheGlzLm1pbnl2YWwpICogYXhpcy55c2NhbGUpO1xuICB9XG59O1xuXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5fZXZhbHVhdGVMaW5lQ2hhcnRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpc1N0YWNrZWQgPSB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbihcInN0YWNrZWRHcmFwaFwiKTtcbiAgdmFyIGlzTG9nc2NhbGVGb3JYID0gdGhpcy5keWdyYXBoXy5nZXRPcHRpb25Gb3JBeGlzKFwibG9nc2NhbGVcIiwgJ3gnKTtcblxuICBmb3IgKHZhciBzZXRJZHggPSAwOyBzZXRJZHggPCB0aGlzLnBvaW50cy5sZW5ndGg7IHNldElkeCsrKSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzW3NldElkeF07XG4gICAgdmFyIHNldE5hbWUgPSB0aGlzLnNldE5hbWVzW3NldElkeF07XG4gICAgdmFyIGNvbm5lY3RTZXBhcmF0ZWQgPSB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbignY29ubmVjdFNlcGFyYXRlZFBvaW50cycsIHNldE5hbWUpO1xuICAgIHZhciBheGlzID0gdGhpcy5keWdyYXBoXy5heGlzUHJvcGVydGllc0ZvclNlcmllcyhzZXROYW1lKTtcbiAgICAvLyBUT0RPIChrb25pZ3NiZXJnKTogdXNlIG9wdGlvbnNGb3JBeGlzIGluc3RlYWQuXG4gICAgdmFyIGxvZ3NjYWxlID0gdGhpcy5keWdyYXBoXy5hdHRyaWJ1dGVzXy5nZXRGb3JTZXJpZXMoXCJsb2dzY2FsZVwiLCBzZXROYW1lKTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcG9pbnQgPSBwb2ludHNbal07XG5cbiAgICAgIC8vIFJhbmdlIGZyb20gMC0xIHdoZXJlIDAgcmVwcmVzZW50cyBsZWZ0IGFuZCAxIHJlcHJlc2VudHMgcmlnaHQuXG4gICAgICBwb2ludC54ID0gRHlncmFwaExheW91dC5jYWxjWE5vcm1hbF8ocG9pbnQueHZhbCwgdGhpcy5feEF4aXMsIGlzTG9nc2NhbGVGb3JYKTtcbiAgICAgIC8vIFJhbmdlIGZyb20gMC0xIHdoZXJlIDAgcmVwcmVzZW50cyB0b3AgYW5kIDEgcmVwcmVzZW50cyBib3R0b21cbiAgICAgIHZhciB5dmFsID0gcG9pbnQueXZhbDtcbiAgICAgIGlmIChpc1N0YWNrZWQpIHtcbiAgICAgICAgcG9pbnQueV9zdGFja2VkID0gRHlncmFwaExheW91dC5jYWxjWU5vcm1hbF8oXG4gICAgICAgICAgICBheGlzLCBwb2ludC55dmFsX3N0YWNrZWQsIGxvZ3NjYWxlKTtcbiAgICAgICAgaWYgKHl2YWwgIT09IG51bGwgJiYgIWlzTmFOKHl2YWwpKSB7XG4gICAgICAgICAgeXZhbCA9IHBvaW50Lnl2YWxfc3RhY2tlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHl2YWwgPT09IG51bGwpIHtcbiAgICAgICAgeXZhbCA9IE5hTjtcbiAgICAgICAgaWYgKCFjb25uZWN0U2VwYXJhdGVkKSB7XG4gICAgICAgICAgcG9pbnQueXZhbCA9IE5hTjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcG9pbnQueSA9IER5Z3JhcGhMYXlvdXQuY2FsY1lOb3JtYWxfKGF4aXMsIHl2YWwsIGxvZ3NjYWxlKTtcbiAgICB9XG5cbiAgICB0aGlzLmR5Z3JhcGhfLmRhdGFIYW5kbGVyXy5vbkxpbmVFdmFsdWF0ZWQocG9pbnRzLCBheGlzLCBsb2dzY2FsZSk7XG4gIH1cbn07XG5cbkR5Z3JhcGhMYXlvdXQucHJvdG90eXBlLl9ldmFsdWF0ZUxpbmVUaWNrcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaSwgdGljaywgbGFiZWwsIHBvcywgdiwgaGFzX3RpY2s7XG4gIHRoaXMueHRpY2tzID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnhUaWNrc18ubGVuZ3RoOyBpKyspIHtcbiAgICB0aWNrID0gdGhpcy54VGlja3NfW2ldO1xuICAgIGxhYmVsID0gdGljay5sYWJlbDtcbiAgICBoYXNfdGljayA9ICEoJ2xhYmVsX3YnIGluIHRpY2spO1xuICAgIHYgPSBoYXNfdGljayA/IHRpY2sudiA6IHRpY2subGFiZWxfdjtcbiAgICBwb3MgPSB0aGlzLmR5Z3JhcGhfLnRvUGVyY2VudFhDb29yZCh2KTtcbiAgICBpZiAoKHBvcyA+PSAwLjApICYmIChwb3MgPCAxLjApKSB7XG4gICAgICB0aGlzLnh0aWNrcy5wdXNoKHtwb3MsIGxhYmVsLCBoYXNfdGlja30pO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMueXRpY2tzID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnlBeGVzXy5sZW5ndGg7IGkrKyApIHtcbiAgICB2YXIgYXhpcyA9IHRoaXMueUF4ZXNfW2ldO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXhpcy50aWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgdGljayA9IGF4aXMudGlja3Nbal07XG4gICAgICBsYWJlbCA9IHRpY2subGFiZWw7XG4gICAgICBoYXNfdGljayA9ICEoJ2xhYmVsX3YnIGluIHRpY2spO1xuICAgICAgdiA9IGhhc190aWNrID8gdGljay52IDogdGljay5sYWJlbF92O1xuICAgICAgcG9zID0gdGhpcy5keWdyYXBoXy50b1BlcmNlbnRZQ29vcmQodiwgaSk7XG4gICAgICBpZiAoKHBvcyA+IDAuMCkgJiYgKHBvcyA8PSAxLjApKSB7XG4gICAgICAgIHRoaXMueXRpY2tzLnB1c2goe2F4aXM6IGksIHBvcywgbGFiZWwsIGhhc190aWNrfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5fZXZhbHVhdGVBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAvLyBBZGQgdGhlIGFubm90YXRpb25zIHRvIHRoZSBwb2ludCB0byB3aGljaCB0aGV5IGJlbG9uZy5cbiAgLy8gTWFrZSBhIG1hcCBmcm9tIChzZXROYW1lLCB4dmFsKSB0byBhbm5vdGF0aW9uIGZvciBxdWljayBsb29rdXBzLlxuICB2YXIgaTtcbiAgdmFyIGFubm90YXRpb25zID0ge307XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLmFubm90YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGEgPSB0aGlzLmFubm90YXRpb25zW2ldO1xuICAgIGFubm90YXRpb25zW2EueHZhbCArIFwiLFwiICsgYS5zZXJpZXNdID0gYTtcbiAgfVxuXG4gIHRoaXMuYW5ub3RhdGVkX3BvaW50cyA9IFtdO1xuXG4gIC8vIEV4aXQgdGhlIGZ1bmN0aW9uIGVhcmx5IGlmIHRoZXJlIGFyZSBubyBhbm5vdGF0aW9ucy5cbiAgaWYgKCF0aGlzLmFubm90YXRpb25zIHx8ICF0aGlzLmFubm90YXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE8oYW50cm9iKTogbG9vcCB0aHJvdWdoIGFubm90YXRpb25zIG5vdCBwb2ludHMuXG4gIGZvciAodmFyIHNldElkeCA9IDA7IHNldElkeCA8IHRoaXMucG9pbnRzLmxlbmd0aDsgc2V0SWR4KyspIHtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHNbc2V0SWR4XTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICAgIHZhciBrID0gcC54dmFsICsgXCIsXCIgKyBwLm5hbWU7XG4gICAgICBpZiAoayBpbiBhbm5vdGF0aW9ucykge1xuICAgICAgICBwLmFubm90YXRpb24gPSBhbm5vdGF0aW9uc1trXTtcbiAgICAgICAgdGhpcy5hbm5vdGF0ZWRfcG9pbnRzLnB1c2gocCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHJlbW92ZSBhbGwgdGhlIGRhdGEgc2V0cyBmcm9tIGEgZ3JhcGhcbiAqL1xuRHlncmFwaExheW91dC5wcm90b3R5cGUucmVtb3ZlQWxsRGF0YXNldHMgPSBmdW5jdGlvbigpIHtcbiAgZGVsZXRlIHRoaXMucG9pbnRzO1xuICBkZWxldGUgdGhpcy5zZXROYW1lcztcbiAgZGVsZXRlIHRoaXMuc2V0UG9pbnRzTGVuZ3RocztcbiAgZGVsZXRlIHRoaXMuc2V0UG9pbnRzT2Zmc2V0cztcbiAgdGhpcy5wb2ludHMgPSBbXTtcbiAgdGhpcy5zZXROYW1lcyA9IFtdO1xuICB0aGlzLnNldFBvaW50c0xlbmd0aHMgPSBbXTtcbiAgdGhpcy5zZXRQb2ludHNPZmZzZXRzID0gW107XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEeWdyYXBoTGF5b3V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9keWdyYXBocy9zcmMvZHlncmFwaC1sYXlvdXQuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar OPTIONS_REFERENCE = null;\n\n// For \"production\" code, this gets removed by uglifyjs.\nif (typeof process !== 'undefined') {\n  if (process.env.NODE_ENV != 'production') {\n\n    // NOTE: in addition to parsing as JS, this snippet is expected to be valid\n    // JSON. This assumption cannot be checked in JS, but it will be checked when\n    // documentation is generated by the generate-documentation.py script. For the\n    // most part, this just means that you should always use double quotes.\n    OPTIONS_REFERENCE = // <JSON>\n    {\n      \"xValueParser\": {\n        \"default\": \"parseFloat() or Date.parse()*\",\n        \"labels\": [\"CSV parsing\"],\n        \"type\": \"function(str) -> number\",\n        \"description\": \"A function which parses x-values (i.e. the dependent series). Must return a number, even when the values are dates. In this case, millis since epoch are used. This is used primarily for parsing CSV data. *=Dygraphs is slightly more accepting in the dates which it will parse. See code for details.\"\n      },\n      \"stackedGraph\": {\n        \"default\": \"false\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"boolean\",\n        \"description\": \"If set, stack series on top of one another rather than drawing them independently. The first series specified in the input data will wind up on top of the chart and the last will be on bottom. NaN values are drawn as white areas without a line on top, see stackedGraphNaNFill for details.\"\n      },\n      \"stackedGraphNaNFill\": {\n        \"default\": \"all\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"string\",\n        \"description\": \"Controls handling of NaN values inside a stacked graph. NaN values are interpolated/extended for stacking purposes, but the actual point value remains NaN in the legend display. Valid option values are \\\"all\\\" (interpolate internally, repeat leftmost and rightmost value as needed), \\\"inside\\\" (interpolate internally only, use zero outside leftmost and rightmost value), and \\\"none\\\" (treat NaN as zero everywhere).\"\n      },\n      \"pointSize\": {\n        \"default\": \"1\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"integer\",\n        \"description\": \"The size of the dot to draw on each point in pixels (see drawPoints). A dot is always drawn when a point is \\\"isolated\\\", i.e. there is a missing point on either side of it. This also controls the size of those dots.\"\n      },\n      \"drawPoints\": {\n        \"default\": \"false\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"boolean\",\n        \"description\": \"Draw a small dot at each point, in addition to a line going through the point. This makes the individual data points easier to see, but can increase visual clutter in the chart. The small dot can be replaced with a custom rendering by supplying a <a href='#drawPointCallback'>drawPointCallback</a>.\"\n      },\n      \"drawGapEdgePoints\": {\n        \"default\": \"false\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"boolean\",\n        \"description\": \"Draw points at the edges of gaps in the data. This improves visibility of small data segments or other data irregularities.\"\n      },\n      \"drawPointCallback\": {\n        \"default\": \"null\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"function(g, seriesName, canvasContext, cx, cy, color, pointSize)\",\n        \"parameters\": [[\"g\", \"the reference graph\"], [\"seriesName\", \"the name of the series\"], [\"canvasContext\", \"the canvas to draw on\"], [\"cx\", \"center x coordinate\"], [\"cy\", \"center y coordinate\"], [\"color\", \"series color\"], [\"pointSize\", \"the radius of the image.\"], [\"idx\", \"the row-index of the point in the data.\"]],\n        \"description\": \"Draw a custom item when drawPoints is enabled. Default is a small dot matching the series color. This method should constrain drawing to within pointSize pixels from (cx, cy).  Also see <a href='#drawHighlightPointCallback'>drawHighlightPointCallback</a>\"\n      },\n      \"height\": {\n        \"default\": \"320\",\n        \"labels\": [\"Overall display\"],\n        \"type\": \"integer\",\n        \"description\": \"Height, in pixels, of the chart. If the container div has been explicitly sized, this will be ignored.\"\n      },\n      \"zoomCallback\": {\n        \"default\": \"null\",\n        \"labels\": [\"Callbacks\"],\n        \"type\": \"function(minDate, maxDate, yRanges)\",\n        \"parameters\": [[\"minDate\", \"milliseconds since epoch\"], [\"maxDate\", \"milliseconds since epoch.\"], [\"yRanges\", \"is an array of [bottom, top] pairs, one for each y-axis.\"]],\n        \"description\": \"A function to call when the zoom window is changed (either by zooming in or out). When animatedZooms is set, zoomCallback is called once at the end of the transition (it will not be called for intermediate frames).\"\n      },\n      \"pointClickCallback\": {\n        \"snippet\": \"function(e, point){<br>&nbsp;&nbsp;alert(point);<br>}\",\n        \"default\": \"null\",\n        \"labels\": [\"Callbacks\", \"Interactive Elements\"],\n        \"type\": \"function(e, point)\",\n        \"parameters\": [[\"e\", \"the event object for the click\"], [\"point\", \"the point that was clicked See <a href='#point_properties'>Point properties</a> for details\"]],\n        \"description\": \"A function to call when a data point is clicked. and the point that was clicked.\"\n      },\n      \"color\": {\n        \"default\": \"(see description)\",\n        \"labels\": [\"Data Series Colors\"],\n        \"type\": \"string\",\n        \"example\": \"red\",\n        \"description\": \"A per-series color definition. Used in conjunction with, and overrides, the colors option.\"\n      },\n      \"colors\": {\n        \"default\": \"(see description)\",\n        \"labels\": [\"Data Series Colors\"],\n        \"type\": \"array<string>\",\n        \"example\": \"['red', '#00FF00']\",\n        \"description\": \"List of colors for the data series. These can be of the form \\\"#AABBCC\\\" or \\\"rgb(255,100,200)\\\" or \\\"yellow\\\", etc. If not specified, equally-spaced points around a color wheel are used. Overridden by the 'color' option.\"\n      },\n      \"connectSeparatedPoints\": {\n        \"default\": \"false\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"boolean\",\n        \"description\": \"Usually, when Dygraphs encounters a missing value in a data series, it interprets this as a gap and draws it as such. If, instead, the missing values represents an x-value for which only a different series has data, then you'll want to connect the dots by setting this to true. To explicitly include a gap with this option set, use a value of NaN.\"\n      },\n      \"highlightCallback\": {\n        \"default\": \"null\",\n        \"labels\": [\"Callbacks\"],\n        \"type\": \"function(event, x, points, row, seriesName)\",\n        \"description\": \"When set, this callback gets called every time a new point is highlighted.\",\n        \"parameters\": [[\"event\", \"the JavaScript mousemove event\"], [\"x\", \"the x-coordinate of the highlighted points\"], [\"points\", \"an array of highlighted points: <code>[ {name: 'series', yval: y-value}, &hellip; ]</code>\"], [\"row\", \"integer index of the highlighted row in the data table, starting from 0\"], [\"seriesName\", \"name of the highlighted series, only present if highlightSeriesOpts is set.\"]]\n      },\n      \"drawHighlightPointCallback\": {\n        \"default\": \"null\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"function(g, seriesName, canvasContext, cx, cy, color, pointSize)\",\n        \"parameters\": [[\"g\", \"the reference graph\"], [\"seriesName\", \"the name of the series\"], [\"canvasContext\", \"the canvas to draw on\"], [\"cx\", \"center x coordinate\"], [\"cy\", \"center y coordinate\"], [\"color\", \"series color\"], [\"pointSize\", \"the radius of the image.\"], [\"idx\", \"the row-index of the point in the data.\"]],\n        \"description\": \"Draw a custom item when a point is highlighted.  Default is a small dot matching the series color. This method should constrain drawing to within pointSize pixels from (cx, cy) Also see <a href='#drawPointCallback'>drawPointCallback</a>\"\n      },\n      \"highlightSeriesOpts\": {\n        \"default\": \"null\",\n        \"labels\": [\"Interactive Elements\"],\n        \"type\": \"Object\",\n        \"description\": \"When set, the options from this object are applied to the timeseries closest to the mouse pointer for interactive highlighting. See also 'highlightCallback'. Example: highlightSeriesOpts: { strokeWidth: 3 }.\"\n      },\n      \"highlightSeriesBackgroundAlpha\": {\n        \"default\": \"0.5\",\n        \"labels\": [\"Interactive Elements\"],\n        \"type\": \"float\",\n        \"description\": \"Fade the background while highlighting series. 1=fully visible background (disable fading), 0=hiddden background (show highlighted series only).\"\n      },\n      \"highlightSeriesBackgroundColor\": {\n        \"default\": \"rgb(255, 255, 255)\",\n        \"labels\": [\"Interactive Elements\"],\n        \"type\": \"string\",\n        \"description\": \"Sets the background color used to fade out the series in conjunction with 'highlightSeriesBackgroundAlpha'.\"\n      },\n      \"includeZero\": {\n        \"default\": \"false\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"boolean\",\n        \"description\": \"Usually, dygraphs will use the range of the data plus some padding to set the range of the y-axis. If this option is set, the y-axis will always include zero, typically as the lowest value. This can be used to avoid exaggerating the variance in the data\"\n      },\n      \"rollPeriod\": {\n        \"default\": \"1\",\n        \"labels\": [\"Error Bars\", \"Rolling Averages\"],\n        \"type\": \"integer &gt;= 1\",\n        \"description\": \"Number of days over which to average data. Discussed extensively above.\"\n      },\n      \"unhighlightCallback\": {\n        \"default\": \"null\",\n        \"labels\": [\"Callbacks\"],\n        \"type\": \"function(event)\",\n        \"parameters\": [[\"event\", \"the mouse event\"]],\n        \"description\": \"When set, this callback gets called every time the user stops highlighting any point by mousing out of the graph.\"\n      },\n      \"axisTickSize\": {\n        \"default\": \"3.0\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"number\",\n        \"description\": \"The size of the line to display next to each tick mark on x- or y-axes.\"\n      },\n      \"labelsSeparateLines\": {\n        \"default\": \"false\",\n        \"labels\": [\"Legend\"],\n        \"type\": \"boolean\",\n        \"description\": \"Put <code>&lt;br/&gt;</code> between lines in the label string. Often used in conjunction with <strong>labelsDiv</strong>.\"\n      },\n      \"valueFormatter\": {\n        \"default\": \"Depends on the type of your data.\",\n        \"labels\": [\"Legend\", \"Value display/formatting\"],\n        \"type\": \"function(num or millis, opts, seriesName, dygraph, row, col)\",\n        \"description\": \"Function to provide a custom display format for the values displayed on mouseover. This does not affect the values that appear on tick marks next to the axes. To format those, see axisLabelFormatter. This is usually set on a <a href='per-axis.html'>per-axis</a> basis. .\",\n        \"parameters\": [[\"num_or_millis\", \"The value to be formatted. This is always a number. For date axes, it's millis since epoch. You can call new Date(millis) to get a Date object.\"], [\"opts\", \"This is a function you can call to access various options (e.g. opts('labelsKMB')). It returns per-axis values for the option when available.\"], [\"seriesName\", \"The name of the series from which the point came, e.g. 'X', 'Y', 'A', etc.\"], [\"dygraph\", \"The dygraph object for which the formatting is being done\"], [\"row\", \"The row of the data from which this point comes. g.getValue(row, 0) will return the x-value for this point.\"], [\"col\", \"The column of the data from which this point comes. g.getValue(row, col) will return the original y-value for this point. This can be used to get the full confidence interval for the point, or access un-rolled values for the point.\"]]\n      },\n      \"annotationMouseOverHandler\": {\n        \"default\": \"null\",\n        \"labels\": [\"Annotations\"],\n        \"type\": \"function(annotation, point, dygraph, event)\",\n        \"description\": \"If provided, this function is called whenever the user mouses over an annotation.\"\n      },\n      \"annotationMouseOutHandler\": {\n        \"default\": \"null\",\n        \"labels\": [\"Annotations\"],\n        \"type\": \"function(annotation, point, dygraph, event)\",\n        \"parameters\": [[\"annotation\", \"the annotation left\"], [\"point\", \"the point associated with the annotation\"], [\"dygraph\", \"the reference graph\"], [\"event\", \"the mouse event\"]],\n        \"description\": \"If provided, this function is called whenever the user mouses out of an annotation.\"\n      },\n      \"annotationClickHandler\": {\n        \"default\": \"null\",\n        \"labels\": [\"Annotations\"],\n        \"type\": \"function(annotation, point, dygraph, event)\",\n        \"parameters\": [[\"annotation\", \"the annotation left\"], [\"point\", \"the point associated with the annotation\"], [\"dygraph\", \"the reference graph\"], [\"event\", \"the mouse event\"]],\n        \"description\": \"If provided, this function is called whenever the user clicks on an annotation.\"\n      },\n      \"annotationDblClickHandler\": {\n        \"default\": \"null\",\n        \"labels\": [\"Annotations\"],\n        \"type\": \"function(annotation, point, dygraph, event)\",\n        \"parameters\": [[\"annotation\", \"the annotation left\"], [\"point\", \"the point associated with the annotation\"], [\"dygraph\", \"the reference graph\"], [\"event\", \"the mouse event\"]],\n        \"description\": \"If provided, this function is called whenever the user double-clicks on an annotation.\"\n      },\n      \"drawCallback\": {\n        \"default\": \"null\",\n        \"labels\": [\"Callbacks\"],\n        \"type\": \"function(dygraph, is_initial)\",\n        \"parameters\": [[\"dygraph\", \"The graph being drawn\"], [\"is_initial\", \"True if this is the initial draw, false for subsequent draws.\"]],\n        \"description\": \"When set, this callback gets called every time the dygraph is drawn. This includes the initial draw, after zooming and repeatedly while panning.\"\n      },\n      \"labelsKMG2\": {\n        \"default\": \"false\",\n        \"labels\": [\"Value display/formatting\"],\n        \"type\": \"boolean\",\n        \"description\": \"Show k/M/G for kilo/Mega/Giga on y-axis. This is different than <code>labelsKMB</code> in that it uses base 2, not 10.\"\n      },\n      \"delimiter\": {\n        \"default\": \",\",\n        \"labels\": [\"CSV parsing\"],\n        \"type\": \"string\",\n        \"description\": \"The delimiter to look for when separating fields of a CSV file. Setting this to a tab is not usually necessary, since tab-delimited data is auto-detected.\"\n      },\n      \"axisLabelFontSize\": {\n        \"default\": \"14\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"integer\",\n        \"description\": \"Size of the font (in pixels) to use in the axis labels, both x- and y-axis.\"\n      },\n      \"underlayCallback\": {\n        \"default\": \"null\",\n        \"labels\": [\"Callbacks\"],\n        \"type\": \"function(context, area, dygraph)\",\n        \"parameters\": [[\"context\", \"the canvas drawing context on which to draw\"], [\"area\", \"An object with {x,y,w,h} properties describing the drawing area.\"], [\"dygraph\", \"the reference graph\"]],\n        \"description\": \"When set, this callback gets called before the chart is drawn. It details on how to use this.\"\n      },\n      \"width\": {\n        \"default\": \"480\",\n        \"labels\": [\"Overall display\"],\n        \"type\": \"integer\",\n        \"description\": \"Width, in pixels, of the chart. If the container div has been explicitly sized, this will be ignored.\"\n      },\n      \"pixelRatio\": {\n        \"default\": \"(devicePixelRatio / context.backingStoreRatio)\",\n        \"labels\": [\"Overall display\"],\n        \"type\": \"float\",\n        \"description\": \"Overrides the pixel ratio scaling factor for the canvas's 2d context. Ordinarily, this is set to the devicePixelRatio / (context.backingStoreRatio || 1), so on mobile devices, where the devicePixelRatio can be somewhere around 3, performance can be improved by overriding this value to something less precise, like 1, at the expense of resolution.\"\n      },\n      \"interactionModel\": {\n        \"default\": \"...\",\n        \"labels\": [\"Interactive Elements\"],\n        \"type\": \"Object\",\n        \"description\": \"TODO(konigsberg): document this\"\n      },\n      \"ticker\": {\n        \"default\": \"Dygraph.dateTicker or Dygraph.numericTicks\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"function(min, max, pixels, opts, dygraph, vals) -> [{v: ..., label: ...}, ...]\",\n        \"parameters\": [[\"min\", \"\"], [\"max\", \"\"], [\"pixels\", \"\"], [\"opts\", \"\"], [\"dygraph\", \"the reference graph\"], [\"vals\", \"\"]],\n        \"description\": \"This lets you specify an arbitrary function to generate tick marks on an axis. The tick marks are an array of (value, label) pairs. The built-in functions go to great lengths to choose good tick marks so, if you set this option, you'll most likely want to call one of them and modify the result. See dygraph-tickers.js for an extensive discussion. This is set on a <a href='per-axis.html'>per-axis</a> basis.\"\n      },\n      \"xAxisHeight\": {\n        \"default\": \"(null)\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"integer\",\n        \"description\": \"Height, in pixels, of the x-axis. If not set explicitly, this is computed based on axisLabelFontSize and axisTickSize.\"\n      },\n      \"showLabelsOnHighlight\": {\n        \"default\": \"true\",\n        \"labels\": [\"Interactive Elements\", \"Legend\"],\n        \"type\": \"boolean\",\n        \"description\": \"Whether to show the legend upon mouseover.\"\n      },\n      \"axis\": {\n        \"default\": \"(none)\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"string\",\n        \"description\": \"Set to either 'y1' or 'y2' to assign a series to a y-axis (primary or secondary). Must be set per-series.\"\n      },\n      \"pixelsPerLabel\": {\n        \"default\": \"70 (x-axis) or 30 (y-axes)\",\n        \"labels\": [\"Axis display\", \"Grid\"],\n        \"type\": \"integer\",\n        \"description\": \"Number of pixels to require between each x- and y-label. Larger values will yield a sparser axis with fewer ticks. This is set on a <a href='per-axis.html'>per-axis</a> basis.\"\n      },\n      \"labelsDiv\": {\n        \"default\": \"null\",\n        \"labels\": [\"Legend\"],\n        \"type\": \"DOM element or string\",\n        \"example\": \"<code style='font-size: small'>document.getElementById('foo')</code>or<code>'foo'\",\n        \"description\": \"Show data labels in an external div, rather than on the graph.  This value can either be a div element or a div id.\"\n      },\n      \"fractions\": {\n        \"default\": \"false\",\n        \"labels\": [\"CSV parsing\", \"Error Bars\"],\n        \"type\": \"boolean\",\n        \"description\": \"When set, attempt to parse each cell in the CSV file as \\\"a/b\\\", where a and b are integers. The ratio will be plotted. This allows computation of Wilson confidence intervals (see below).\"\n      },\n      \"logscale\": {\n        \"default\": \"false\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"boolean\",\n        \"description\": \"When set for the y-axis or x-axis, the graph shows that axis in log scale. Any values less than or equal to zero are not displayed. Showing log scale with ranges that go below zero will result in an unviewable graph.\\n\\n Not compatible with showZero. connectSeparatedPoints is ignored. This is ignored for date-based x-axes.\"\n      },\n      \"strokeWidth\": {\n        \"default\": \"1.0\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"float\",\n        \"example\": \"0.5, 2.0\",\n        \"description\": \"The width of the lines connecting data points. This can be used to increase the contrast or some graphs.\"\n      },\n      \"strokePattern\": {\n        \"default\": \"null\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"array<integer>\",\n        \"example\": \"[10, 2, 5, 2]\",\n        \"description\": \"A custom pattern array where the even index is a draw and odd is a space in pixels. If null then it draws a solid line. The array should have a even length as any odd lengthed array could be expressed as a smaller even length array. This is used to create dashed lines.\"\n      },\n      \"strokeBorderWidth\": {\n        \"default\": \"null\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"float\",\n        \"example\": \"1.0\",\n        \"description\": \"Draw a border around graph lines to make crossing lines more easily distinguishable. Useful for graphs with many lines.\"\n      },\n      \"strokeBorderColor\": {\n        \"default\": \"white\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"string\",\n        \"example\": \"red, #ccffdd\",\n        \"description\": \"Color for the line border used if strokeBorderWidth is set.\"\n      },\n      \"wilsonInterval\": {\n        \"default\": \"true\",\n        \"labels\": [\"Error Bars\"],\n        \"type\": \"boolean\",\n        \"description\": \"Use in conjunction with the \\\"fractions\\\" option. Instead of plotting +/- N standard deviations, dygraphs will compute a Wilson confidence interval and plot that. This has more reasonable behavior for ratios close to 0 or 1.\"\n      },\n      \"fillGraph\": {\n        \"default\": \"false\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"boolean\",\n        \"description\": \"Should the area underneath the graph be filled? This option is not compatible with error bars. This may be set on a <a href='per-axis.html'>per-series</a> basis.\"\n      },\n      \"highlightCircleSize\": {\n        \"default\": \"3\",\n        \"labels\": [\"Interactive Elements\"],\n        \"type\": \"integer\",\n        \"description\": \"The size in pixels of the dot drawn over highlighted points.\"\n      },\n      \"gridLineColor\": {\n        \"default\": \"rgb(128,128,128)\",\n        \"labels\": [\"Grid\"],\n        \"type\": \"red, blue\",\n        \"description\": \"The color of the gridlines. This may be set on a per-axis basis to define each axis' grid separately.\"\n      },\n      \"gridLinePattern\": {\n        \"default\": \"null\",\n        \"labels\": [\"Grid\"],\n        \"type\": \"array<integer>\",\n        \"example\": \"[10, 2, 5, 2]\",\n        \"description\": \"A custom pattern array where the even index is a draw and odd is a space in pixels. If null then it draws a solid line. The array should have a even length as any odd lengthed array could be expressed as a smaller even length array. This is used to create dashed gridlines.\"\n      },\n      \"visibility\": {\n        \"default\": \"[true, true, ...]\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"Array of booleans\",\n        \"description\": \"Which series should initially be visible? Once the Dygraph has been constructed, you can access and modify the visibility of each series using the <code>visibility</code> and <code>setVisibility</code> methods.\"\n      },\n      \"valueRange\": {\n        \"default\": \"Full range of the input is shown\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"Array of two numbers\",\n        \"example\": \"[10, 110]\",\n        \"description\": \"Explicitly set the vertical range of the graph to [low, high]. This may be set on a per-axis basis to define each y-axis separately. If either limit is unspecified, it will be calculated automatically (e.g. [null, 30] to automatically calculate just the lower bound)\"\n      },\n      \"colorSaturation\": {\n        \"default\": \"1.0\",\n        \"labels\": [\"Data Series Colors\"],\n        \"type\": \"float (0.0 - 1.0)\",\n        \"description\": \"If <strong>colors</strong> is not specified, saturation of the automatically-generated data series colors.\"\n      },\n      \"hideOverlayOnMouseOut\": {\n        \"default\": \"true\",\n        \"labels\": [\"Interactive Elements\", \"Legend\"],\n        \"type\": \"boolean\",\n        \"description\": \"Whether to hide the legend when the mouse leaves the chart area.\"\n      },\n      \"legend\": {\n        \"default\": \"onmouseover\",\n        \"labels\": [\"Legend\"],\n        \"type\": \"string\",\n        \"description\": \"When to display the legend. By default, it only appears when a user mouses over the chart. Set it to \\\"always\\\" to always display a legend of some sort. When set to \\\"follow\\\", legend follows highlighted points.\"\n      },\n      \"legendFormatter\": {\n        \"default\": \"null\",\n        \"labels\": [\"Legend\"],\n        \"type\": \"function(data): string\",\n        \"params\": [[\"data\", \"An object containing information about the selection (or lack of a selection). This includes formatted values and series information. See <a href=\\\"https://github.com/danvk/dygraphs/pull/683\\\">here</a> for sample values.\"]],\n        \"description\": \"Set this to supply a custom formatter for the legend. See <a href=\\\"https://github.com/danvk/dygraphs/pull/683\\\">this comment</a> and the <a href=\\\"tests/legend-formatter.html\\\">legendFormatter demo</a> for usage.\"\n      },\n      \"labelsShowZeroValues\": {\n        \"default\": \"true\",\n        \"labels\": [\"Legend\"],\n        \"type\": \"boolean\",\n        \"description\": \"Show zero value labels in the labelsDiv.\"\n      },\n      \"stepPlot\": {\n        \"default\": \"false\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"boolean\",\n        \"description\": \"When set, display the graph as a step plot instead of a line plot. This option may either be set for the whole graph or for single series.\"\n      },\n      \"labelsUTC\": {\n        \"default\": \"false\",\n        \"labels\": [\"Value display/formatting\", \"Axis display\"],\n        \"type\": \"boolean\",\n        \"description\": \"Show date/time labels according to UTC (instead of local time).\"\n      },\n      \"labelsKMB\": {\n        \"default\": \"false\",\n        \"labels\": [\"Value display/formatting\"],\n        \"type\": \"boolean\",\n        \"description\": \"Show K/M/B for thousands/millions/billions on y-axis.\"\n      },\n      \"rightGap\": {\n        \"default\": \"5\",\n        \"labels\": [\"Overall display\"],\n        \"type\": \"integer\",\n        \"description\": \"Number of pixels to leave blank at the right edge of the Dygraph. This makes it easier to highlight the right-most data point.\"\n      },\n      \"drawAxesAtZero\": {\n        \"default\": \"false\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"boolean\",\n        \"description\": \"When set, draw the X axis at the Y=0 position and the Y axis at the X=0 position if those positions are inside the graph's visible area. Otherwise, draw the axes at the bottom or left graph edge as usual.\"\n      },\n      \"xRangePad\": {\n        \"default\": \"0\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"float\",\n        \"description\": \"Add the specified amount of extra space (in pixels) around the X-axis value range to ensure points at the edges remain visible.\"\n      },\n      \"yRangePad\": {\n        \"default\": \"null\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"float\",\n        \"description\": \"If set, add the specified amount of extra space (in pixels) around the Y-axis value range to ensure points at the edges remain visible. If unset, use the traditional Y padding algorithm.\"\n      },\n      \"axisLabelFormatter\": {\n        \"default\": \"Depends on the data type\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"function(number or Date, granularity, opts, dygraph)\",\n        \"parameters\": [[\"number or date\", \"Either a number (for a numeric axis) or a Date object (for a date axis)\"], [\"granularity\", \"specifies how fine-grained the axis is. For date axes, this is a reference to the time granularity enumeration, defined in dygraph-tickers.js, e.g. Dygraph.WEEKLY.\"], [\"opts\", \"a function which provides access to various options on the dygraph, e.g. opts('labelsKMB').\"], [\"dygraph\", \"the referenced graph\"]],\n        \"description\": \"Function to call to format the tick values that appear along an axis. This is usually set on a <a href='per-axis.html'>per-axis</a> basis.\"\n      },\n      \"clickCallback\": {\n        \"snippet\": \"function(e, date_millis){<br>&nbsp;&nbsp;alert(new Date(date_millis));<br>}\",\n        \"default\": \"null\",\n        \"labels\": [\"Callbacks\"],\n        \"type\": \"function(e, x, points)\",\n        \"parameters\": [[\"e\", \"The event object for the click\"], [\"x\", \"The x value that was clicked (for dates, this is milliseconds since epoch)\"], [\"points\", \"The closest points along that date. See <a href='#point_properties'>Point properties</a> for details.\"]],\n        \"description\": \"A function to call when the canvas is clicked.\"\n      },\n      \"labels\": {\n        \"default\": \"[\\\"X\\\", \\\"Y1\\\", \\\"Y2\\\", ...]*\",\n        \"labels\": [\"Legend\"],\n        \"type\": \"array<string>\",\n        \"description\": \"A name for each data series, including the independent (X) series. For CSV files and DataTable objections, this is determined by context. For raw data, this must be specified. If it is not, default values are supplied and a warning is logged.\"\n      },\n      \"dateWindow\": {\n        \"default\": \"Full range of the input is shown\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"Array of two numbers\",\n        \"example\": \"[<br>&nbsp;&nbsp;Date.parse('2006-01-01'),<br>&nbsp;&nbsp;(new Date()).valueOf()<br>]\",\n        \"description\": \"Initially zoom in on a section of the graph. Is of the form [earliest, latest], where earliest/latest are milliseconds since epoch. If the data for the x-axis is numeric, the values in dateWindow must also be numbers.\"\n      },\n      \"showRoller\": {\n        \"default\": \"false\",\n        \"labels\": [\"Interactive Elements\", \"Rolling Averages\"],\n        \"type\": \"boolean\",\n        \"description\": \"If the rolling average period text box should be shown.\"\n      },\n      \"sigma\": {\n        \"default\": \"2.0\",\n        \"labels\": [\"Error Bars\"],\n        \"type\": \"float\",\n        \"description\": \"When errorBars is set, shade this many standard deviations above/below each point.\"\n      },\n      \"customBars\": {\n        \"default\": \"false\",\n        \"labels\": [\"CSV parsing\", \"Error Bars\"],\n        \"type\": \"boolean\",\n        \"description\": \"When set, parse each CSV cell as \\\"low;middle;high\\\". Error bars will be drawn for each point between low and high, with the series itself going through middle.\"\n      },\n      \"colorValue\": {\n        \"default\": \"1.0\",\n        \"labels\": [\"Data Series Colors\"],\n        \"type\": \"float (0.0 - 1.0)\",\n        \"description\": \"If colors is not specified, value of the data series colors, as in hue/saturation/value. (0.0-1.0, default 0.5)\"\n      },\n      \"errorBars\": {\n        \"default\": \"false\",\n        \"labels\": [\"CSV parsing\", \"Error Bars\"],\n        \"type\": \"boolean\",\n        \"description\": \"Does the data contain standard deviations? Setting this to true alters the input format (see above).\"\n      },\n      \"displayAnnotations\": {\n        \"default\": \"false\",\n        \"labels\": [\"Annotations\"],\n        \"type\": \"boolean\",\n        \"description\": \"Only applies when Dygraphs is used as a GViz chart. Causes string columns following a data series to be interpreted as annotations on points in that series. This is the same format used by Google's AnnotatedTimeLine chart.\"\n      },\n      \"panEdgeFraction\": {\n        \"default\": \"null\",\n        \"labels\": [\"Axis display\", \"Interactive Elements\"],\n        \"type\": \"float\",\n        \"description\": \"A value representing the farthest a graph may be panned, in percent of the display. For example, a value of 0.1 means that the graph can only be panned 10% passed the edges of the displayed values. null means no bounds.\"\n      },\n      \"title\": {\n        \"labels\": [\"Chart labels\"],\n        \"type\": \"string\",\n        \"default\": \"null\",\n        \"description\": \"Text to display above the chart. You can supply any HTML for this value, not just text. If you wish to style it using CSS, use the 'dygraph-label' or 'dygraph-title' classes.\"\n      },\n      \"titleHeight\": {\n        \"default\": \"18\",\n        \"labels\": [\"Chart labels\"],\n        \"type\": \"integer\",\n        \"description\": \"Height of the chart title, in pixels. This also controls the default font size of the title. If you style the title on your own, this controls how much space is set aside above the chart for the title's div.\"\n      },\n      \"xlabel\": {\n        \"labels\": [\"Chart labels\"],\n        \"type\": \"string\",\n        \"default\": \"null\",\n        \"description\": \"Text to display below the chart's x-axis. You can supply any HTML for this value, not just text. If you wish to style it using CSS, use the 'dygraph-label' or 'dygraph-xlabel' classes.\"\n      },\n      \"xLabelHeight\": {\n        \"labels\": [\"Chart labels\"],\n        \"type\": \"integer\",\n        \"default\": \"18\",\n        \"description\": \"Height of the x-axis label, in pixels. This also controls the default font size of the x-axis label. If you style the label on your own, this controls how much space is set aside below the chart for the x-axis label's div.\"\n      },\n      \"ylabel\": {\n        \"labels\": [\"Chart labels\"],\n        \"type\": \"string\",\n        \"default\": \"null\",\n        \"description\": \"Text to display to the left of the chart's y-axis. You can supply any HTML for this value, not just text. If you wish to style it using CSS, use the 'dygraph-label' or 'dygraph-ylabel' classes. The text will be rotated 90 degrees by default, so CSS rules may behave in unintuitive ways. No additional space is set aside for a y-axis label. If you need more space, increase the width of the y-axis tick labels using the yAxisLabelWidth option. If you need a wider div for the y-axis label, either style it that way with CSS (but remember that it's rotated, so width is controlled by the 'height' property) or set the yLabelWidth option.\"\n      },\n      \"y2label\": {\n        \"labels\": [\"Chart labels\"],\n        \"type\": \"string\",\n        \"default\": \"null\",\n        \"description\": \"Text to display to the right of the chart's secondary y-axis. This label is only displayed if a secondary y-axis is present. See <a href='http://dygraphs.com/tests/two-axes.html'>this test</a> for an example of how to do this. The comments for the 'ylabel' option generally apply here as well. This label gets a 'dygraph-y2label' instead of a 'dygraph-ylabel' class.\"\n      },\n      \"yLabelWidth\": {\n        \"labels\": [\"Chart labels\"],\n        \"type\": \"integer\",\n        \"default\": \"18\",\n        \"description\": \"Width of the div which contains the y-axis label. Since the y-axis label appears rotated 90 degrees, this actually affects the height of its div.\"\n      },\n      \"drawGrid\": {\n        \"default\": \"true for x and y, false for y2\",\n        \"labels\": [\"Grid\"],\n        \"type\": \"boolean\",\n        \"description\": \"Whether to display gridlines in the chart. This may be set on a per-axis basis to define the visibility of each axis' grid separately.\"\n      },\n      \"independentTicks\": {\n        \"default\": \"true for y, false for y2\",\n        \"labels\": [\"Axis display\", \"Grid\"],\n        \"type\": \"boolean\",\n        \"description\": \"Only valid for y and y2, has no effect on x: This option defines whether the y axes should align their ticks or if they should be independent. Possible combinations: 1.) y=true, y2=false (default): y is the primary axis and the y2 ticks are aligned to the the ones of y. (only 1 grid) 2.) y=false, y2=true: y2 is the primary axis and the y ticks are aligned to the the ones of y2. (only 1 grid) 3.) y=true, y2=true: Both axis are independent and have their own ticks. (2 grids) 4.) y=false, y2=false: Invalid configuration causes an error.\"\n      },\n      \"drawAxis\": {\n        \"default\": \"true for x and y, false for y2\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"boolean\",\n        \"description\": \"Whether to draw the specified axis. This may be set on a per-axis basis to define the visibility of each axis separately. Setting this to false also prevents axis ticks from being drawn and reclaims the space for the chart grid/lines.\"\n      },\n      \"gridLineWidth\": {\n        \"default\": \"0.3\",\n        \"labels\": [\"Grid\"],\n        \"type\": \"float\",\n        \"description\": \"Thickness (in pixels) of the gridlines drawn under the chart. The vertical/horizontal gridlines can be turned off entirely by using the drawGrid option. This may be set on a per-axis basis to define each axis' grid separately.\"\n      },\n      \"axisLineWidth\": {\n        \"default\": \"0.3\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"float\",\n        \"description\": \"Thickness (in pixels) of the x- and y-axis lines.\"\n      },\n      \"axisLineColor\": {\n        \"default\": \"black\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"string\",\n        \"description\": \"Color of the x- and y-axis lines. Accepts any value which the HTML canvas strokeStyle attribute understands, e.g. 'black' or 'rgb(0, 100, 255)'.\"\n      },\n      \"fillAlpha\": {\n        \"default\": \"0.15\",\n        \"labels\": [\"Error Bars\", \"Data Series Colors\"],\n        \"type\": \"float (0.0 - 1.0)\",\n        \"description\": \"Error bars (or custom bars) for each series are drawn in the same color as the series, but with partial transparency. This sets the transparency. A value of 0.0 means that the error bars will not be drawn, whereas a value of 1.0 means that the error bars will be as dark as the line for the series itself. This can be used to produce chart lines whose thickness varies at each point.\"\n      },\n      \"axisLabelWidth\": {\n        \"default\": \"50 (y-axis), 60 (x-axis)\",\n        \"labels\": [\"Axis display\", \"Chart labels\"],\n        \"type\": \"integer\",\n        \"description\": \"Width (in pixels) of the containing divs for x- and y-axis labels. For the y-axis, this also controls the width of the y-axis. Note that for the x-axis, this is independent from pixelsPerLabel, which controls the spacing between labels.\"\n      },\n      \"sigFigs\": {\n        \"default\": \"null\",\n        \"labels\": [\"Value display/formatting\"],\n        \"type\": \"integer\",\n        \"description\": \"By default, dygraphs displays numbers with a fixed number of digits after the decimal point. If you'd prefer to have a fixed number of significant figures, set this option to that number of sig figs. A value of 2, for instance, would cause 1 to be display as 1.0 and 1234 to be displayed as 1.23e+3.\"\n      },\n      \"digitsAfterDecimal\": {\n        \"default\": \"2\",\n        \"labels\": [\"Value display/formatting\"],\n        \"type\": \"integer\",\n        \"description\": \"Unless it's run in scientific mode (see the <code>sigFigs</code> option), dygraphs displays numbers with <code>digitsAfterDecimal</code> digits after the decimal point. Trailing zeros are not displayed, so with a value of 2 you'll get '0', '0.1', '0.12', '123.45' but not '123.456' (it will be rounded to '123.46'). Numbers with absolute value less than 0.1^digitsAfterDecimal (i.e. those which would show up as '0.00') will be displayed in scientific notation.\"\n      },\n      \"maxNumberWidth\": {\n        \"default\": \"6\",\n        \"labels\": [\"Value display/formatting\"],\n        \"type\": \"integer\",\n        \"description\": \"When displaying numbers in normal (not scientific) mode, large numbers will be displayed with many trailing zeros (e.g. 100000000 instead of 1e9). This can lead to unwieldy y-axis labels. If there are more than <code>maxNumberWidth</code> digits to the left of the decimal in a number, dygraphs will switch to scientific notation, even when not operating in scientific mode. If you'd like to see all those digits, set this to something large, like 20 or 30.\"\n      },\n      \"file\": {\n        \"default\": \"(set when constructed)\",\n        \"labels\": [\"Data\"],\n        \"type\": \"string (URL of CSV or CSV), GViz DataTable or 2D Array\",\n        \"description\": \"Sets the data being displayed in the chart. This can only be set when calling updateOptions; it cannot be set from the constructor. For a full description of valid data formats, see the <a href='http://dygraphs.com/data.html'>Data Formats</a> page.\"\n      },\n      \"timingName\": {\n        \"default\": \"null\",\n        \"labels\": [\"Debugging\", \"Deprecated\"],\n        \"type\": \"string\",\n        \"description\": \"Set this option to log timing information. The value of the option will be logged along with the timimg, so that you can distinguish multiple dygraphs on the same page.\"\n      },\n      \"showRangeSelector\": {\n        \"default\": \"false\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"boolean\",\n        \"description\": \"Show or hide the range selector widget.\"\n      },\n      \"rangeSelectorHeight\": {\n        \"default\": \"40\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"integer\",\n        \"description\": \"Height, in pixels, of the range selector widget. This option can only be specified at Dygraph creation time.\"\n      },\n      \"rangeSelectorPlotStrokeColor\": {\n        \"default\": \"#808FAB\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"string\",\n        \"description\": \"The range selector mini plot stroke color. This can be of the form \\\"#AABBCC\\\" or \\\"rgb(255,100,200)\\\" or \\\"yellow\\\". You can also specify null or \\\"\\\" to turn off stroke.\"\n      },\n      \"rangeSelectorPlotFillColor\": {\n        \"default\": \"#A7B1C4\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"string\",\n        \"description\": \"The range selector mini plot fill color. This can be of the form \\\"#AABBCC\\\" or \\\"rgb(255,100,200)\\\" or \\\"yellow\\\". You can also specify null or \\\"\\\" to turn off fill.\"\n      },\n      \"rangeSelectorPlotFillGradientColor\": {\n        \"default\": \"white\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"string\",\n        \"description\": \"The top color for the range selector mini plot fill color gradient. This can be of the form \\\"#AABBCC\\\" or \\\"rgb(255,100,200)\\\" or \\\"rgba(255,100,200,42)\\\" or \\\"yellow\\\". You can also specify null or \\\"\\\" to disable the gradient and fill with one single color.\"\n      },\n      \"rangeSelectorBackgroundStrokeColor\": {\n        \"default\": \"gray\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"string\",\n        \"description\": \"The color of the lines below and on both sides of the range selector mini plot. This can be of the form \\\"#AABBCC\\\" or \\\"rgb(255,100,200)\\\" or \\\"yellow\\\".\"\n      },\n      \"rangeSelectorBackgroundLineWidth\": {\n        \"default\": \"1\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"float\",\n        \"description\": \"The width of the lines below and on both sides of the range selector mini plot.\"\n      },\n      \"rangeSelectorPlotLineWidth\": {\n        \"default\": \"1.5\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"float\",\n        \"description\": \"The width of the range selector mini plot line.\"\n      },\n      \"rangeSelectorForegroundStrokeColor\": {\n        \"default\": \"black\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"string\",\n        \"description\": \"The color of the lines in the interactive layer of the range selector. This can be of the form \\\"#AABBCC\\\" or \\\"rgb(255,100,200)\\\" or \\\"yellow\\\".\"\n      },\n      \"rangeSelectorForegroundLineWidth\": {\n        \"default\": \"1\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"float\",\n        \"description\": \"The width the lines in the interactive layer of the range selector.\"\n      },\n      \"rangeSelectorAlpha\": {\n        \"default\": \"0.6\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"float (0.0 - 1.0)\",\n        \"description\": \"The transparency of the veil that is drawn over the unselected portions of the range selector mini plot. A value of 0 represents full transparency and the unselected portions of the mini plot will appear as normal. A value of 1 represents full opacity and the unselected portions of the mini plot will be hidden.\"\n      },\n      \"showInRangeSelector\": {\n        \"default\": \"null\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"boolean\",\n        \"description\": \"Mark this series for inclusion in the range selector. The mini plot curve will be an average of all such series. If this is not specified for any series, the default behavior is to average all the visible series. Setting it for one series will result in that series being charted alone in the range selector. Once it's set for a single series, it needs to be set for all series which should be included (regardless of visibility).\"\n      },\n      \"animatedZooms\": {\n        \"default\": \"false\",\n        \"labels\": [\"Interactive Elements\"],\n        \"type\": \"boolean\",\n        \"description\": \"Set this option to animate the transition between zoom windows. Applies to programmatic and interactive zooms. Note that if you also set a drawCallback, it will be called several times on each zoom. If you set a zoomCallback, it will only be called after the animation is complete.\"\n      },\n      \"plotter\": {\n        \"default\": \"[DygraphCanvasRenderer.Plotters.fillPlotter, DygraphCanvasRenderer.Plotters.errorPlotter, DygraphCanvasRenderer.Plotters.linePlotter]\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"array or function\",\n        \"description\": \"A function (or array of functions) which plot each data series on the chart. TODO(danvk): more details! May be set per-series.\"\n      },\n      \"axes\": {\n        \"default\": \"null\",\n        \"labels\": [\"Configuration\"],\n        \"type\": \"Object\",\n        \"description\": \"Defines per-axis options. Valid keys are 'x', 'y' and 'y2'. Only some options may be set on a per-axis basis. If an option may be set in this way, it will be noted on this page. See also documentation on <a href='http://dygraphs.com/per-axis.html'>per-series and per-axis options</a>.\"\n      },\n      \"series\": {\n        \"default\": \"null\",\n        \"labels\": [\"Series\"],\n        \"type\": \"Object\",\n        \"description\": \"Defines per-series options. Its keys match the y-axis label names, and the values are dictionaries themselves that contain options specific to that series.\"\n      },\n      \"plugins\": {\n        \"default\": \"[]\",\n        \"labels\": [\"Configuration\"],\n        \"type\": \"Array<plugin>\",\n        \"description\": \"Defines per-graph plugins. Useful for per-graph customization\"\n      },\n      \"dataHandler\": {\n        \"default\": \"(depends on data)\",\n        \"labels\": [\"Data\"],\n        \"type\": \"Dygraph.DataHandler\",\n        \"description\": \"Custom DataHandler. This is an advanced customization. See http://bit.ly/151E7Aq.\"\n      }\n    }; // </JSON>\n    // NOTE: in addition to parsing as JS, this snippet is expected to be valid\n    // JSON. This assumption cannot be checked in JS, but it will be checked when\n    // documentation is generated by the generate-documentation.py script. For the\n    // most part, this just means that you should always use double quotes.\n\n    // Do a quick sanity check on the options reference.\n    var warn = function warn(msg) {\n      if (window.console) window.console.warn(msg);\n    };\n    var flds = ['type', 'default', 'description'];\n    var valid_cats = ['Annotations', 'Axis display', 'Chart labels', 'CSV parsing', 'Callbacks', 'Data', 'Data Line display', 'Data Series Colors', 'Error Bars', 'Grid', 'Interactive Elements', 'Range Selector', 'Legend', 'Overall display', 'Rolling Averages', 'Series', 'Value display/formatting', 'Zooming', 'Debugging', 'Configuration', 'Deprecated'];\n    var i;\n    var cats = {};\n    for (i = 0; i < valid_cats.length; i++) {\n      cats[valid_cats[i]] = true;\n    }for (var k in OPTIONS_REFERENCE) {\n      if (!OPTIONS_REFERENCE.hasOwnProperty(k)) continue;\n      var op = OPTIONS_REFERENCE[k];\n      for (i = 0; i < flds.length; i++) {\n        if (!op.hasOwnProperty(flds[i])) {\n          warn('Option ' + k + ' missing \"' + flds[i] + '\" property');\n        } else if (typeof op[flds[i]] != 'string') {\n          warn(k + '.' + flds[i] + ' must be of type string');\n        }\n      }\n      var labels = op.labels;\n      if ((typeof labels === 'undefined' ? 'undefined' : _typeof(labels)) !== 'object') {\n        warn('Option \"' + k + '\" is missing a \"labels\": [...] option');\n      } else {\n        for (i = 0; i < labels.length; i++) {\n          if (!cats.hasOwnProperty(labels[i])) {\n            warn('Option \"' + k + '\" has label \"' + labels[i] + '\", which is invalid.');\n          }\n        }\n      }\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (OPTIONS_REFERENCE);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(6)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLW9wdGlvbnMtcmVmZXJlbmNlLmpzP2M0ZTEiXSwibmFtZXMiOlsiT1BUSU9OU19SRUZFUkVOQ0UiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJ3YXJuIiwibXNnIiwid2luZG93IiwiY29uc29sZSIsImZsZHMiLCJ2YWxpZF9jYXRzIiwiaSIsImNhdHMiLCJsZW5ndGgiLCJrIiwiaGFzT3duUHJvcGVydHkiLCJvcCIsImxhYmVscyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQU1BOzs7O0FBRUEsSUFBSUEsb0JBQW9CLElBQXhCOztBQUVBO0FBQ0EsSUFBSSxPQUFPQyxPQUFQLEtBQW9CLFdBQXhCLEVBQXFDO0FBQ3JDLE1BQUlBLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixJQUF3QixZQUE1QixFQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQUgsd0JBQXFCO0FBQ3JCO0FBQ0Usc0JBQWdCO0FBQ2QsbUJBQVcsK0JBREc7QUFFZCxrQkFBVSxDQUFDLGFBQUQsQ0FGSTtBQUdkLGdCQUFRLHlCQUhNO0FBSWQsdUJBQWU7QUFKRCxPQURsQjtBQU9FLHNCQUFnQjtBQUNkLG1CQUFXLE9BREc7QUFFZCxrQkFBVSxDQUFDLG1CQUFELENBRkk7QUFHZCxnQkFBUSxTQUhNO0FBSWQsdUJBQWU7QUFKRCxPQVBsQjtBQWFFLDZCQUF1QjtBQUNyQixtQkFBVyxLQURVO0FBRXJCLGtCQUFVLENBQUMsbUJBQUQsQ0FGVztBQUdyQixnQkFBUSxRQUhhO0FBSXJCLHVCQUFlO0FBSk0sT0FiekI7QUFtQkUsbUJBQWE7QUFDWCxtQkFBVyxHQURBO0FBRVgsa0JBQVUsQ0FBQyxtQkFBRCxDQUZDO0FBR1gsZ0JBQVEsU0FIRztBQUlYLHVCQUFlO0FBSkosT0FuQmY7QUF5QkUsb0JBQWM7QUFDWixtQkFBVyxPQURDO0FBRVosa0JBQVUsQ0FBQyxtQkFBRCxDQUZFO0FBR1osZ0JBQVEsU0FISTtBQUlaLHVC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UyxDQUFaLEdBQWdCLFlBQWhCLEdBQStCTCxLQUFLRSxDQUFMLENBQS9CLEdBQXlDLFlBQTlDO0FBQ0QsU0FGRCxNQUVPLElBQUksT0FBT0ssR0FBR1AsS0FBS0UsQ0FBTCxDQUFILENBQVAsSUFBdUIsUUFBM0IsRUFBcUM7QUFDMUNOLGVBQUtTLElBQUksR0FBSixHQUFVTCxLQUFLRSxDQUFMLENBQVYsR0FBb0IseUJBQXpCO0FBQ0Q7QUFDRjtBQUNELFVBQUlNLFNBQVNELEdBQUdDLE1BQWhCO0FBQ0EsVUFBSSxRQUFPQSxNQUFQLHlDQUFPQSxNQUFQLE9BQW1CLFFBQXZCLEVBQWlDO0FBQy9CWixhQUFLLGFBQWFTLENBQWIsR0FBaUIsdUNBQXRCO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsYUFBS0gsSUFBSSxDQUFULEVBQVlBLElBQUlNLE9BQU9KLE1BQXZCLEVBQStCRixHQUEvQixFQUFvQztBQUNsQyxjQUFJLENBQUNDLEtBQUtHLGNBQUwsQ0FBb0JFLE9BQU9OLENBQVAsQ0FBcEIsQ0FBTCxFQUFxQztBQUNuQ04saUJBQUssYUFBYVMsQ0FBYixHQUFpQixlQUFqQixHQUFtQ0csT0FBT04sQ0FBUCxDQUFuQyxHQUNBLHNCQURMO0FBRUQ7QUFDRjtBQUNGO0FBQ0Y7QUFFQTtBQUNBOztBQUVELHlEQUFlVixpQkFBZixFIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTEgRGFuIFZhbmRlcmthbSAoZGFudmRrQGdtYWlsLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIE9QVElPTlNfUkVGRVJFTkNFID0gbnVsbDtcblxuLy8gRm9yIFwicHJvZHVjdGlvblwiIGNvZGUsIHRoaXMgZ2V0cyByZW1vdmVkIGJ5IHVnbGlmeWpzLlxuaWYgKHR5cGVvZihwcm9jZXNzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPSAncHJvZHVjdGlvbicpIHtcblxuLy8gTk9URTogaW4gYWRkaXRpb24gdG8gcGFyc2luZyBhcyBKUywgdGhpcyBzbmlwcGV0IGlzIGV4cGVjdGVkIHRvIGJlIHZhbGlkXG4vLyBKU09OLiBUaGlzIGFzc3VtcHRpb24gY2Fubm90IGJlIGNoZWNrZWQgaW4gSlMsIGJ1dCBpdCB3aWxsIGJlIGNoZWNrZWQgd2hlblxuLy8gZG9jdW1lbnRhdGlvbiBpcyBnZW5lcmF0ZWQgYnkgdGhlIGdlbmVyYXRlLWRvY3VtZW50YXRpb24ucHkgc2NyaXB0LiBGb3IgdGhlXG4vLyBtb3N0IHBhcnQsIHRoaXMganVzdCBtZWFucyB0aGF0IHlvdSBzaG91bGQgYWx3YXlzIHVzZSBkb3VibGUgcXVvdGVzLlxuT1BUSU9OU19SRUZFUkVOQ0UgPSAgLy8gPEpTT04+XG57XG4gIFwieFZhbHVlUGFyc2VyXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJwYXJzZUZsb2F0KCkgb3IgRGF0ZS5wYXJzZSgpKlwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNTViBwYXJzaW5nXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKHN0cikgLT4gbnVtYmVyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgZnVuY3Rpb24gd2hpY2ggcGFyc2VzIHgtdmFsdWVzIChpLmUuIHRoZSBkZXBlbmRlbnQgc2VyaWVzKS4gTXVzdCByZXR1cm4gYSBudW1iZXIsIGV2ZW4gd2hlbiB0aGUgdmFsdWVzIGFyZSBkYXRlcy4gSW4gdGhpcyBjYXNlLCBtaWxsaXMgc2luY2UgZXBvY2ggYXJlIHVzZWQuIFRoaXMgaXMgdXNlZCBwcmltYXJpbHkgZm9yIHBhcnNpbmcgQ1NWIGRhdGEuICo9RHlncmFwaHMgaXMgc2xpZ2h0bHkgbW9yZSBhY2NlcHRpbmcgaW4gdGhlIGRhdGVzIHdoaWNoIGl0IHdpbGwgcGFyc2UuIFNlZSBjb2RlIGZvciBkZXRhaWxzLlwiXG4gIH0sXG4gIFwic3RhY2tlZEdyYXBoXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgc2V0LCBzdGFjayBzZXJpZXMgb24gdG9wIG9mIG9uZSBhbm90aGVyIHJhdGhlciB0aGFuIGRyYXdpbmcgdGhlbSBpbmRlcGVuZGVudGx5LiBUaGUgZmlyc3Qgc2VyaWVzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgZGF0YSB3aWxsIHdpbmQgdXAgb24gdG9wIG9mIHRoZSBjaGFydCBhbmQgdGhlIGxhc3Qgd2lsbCBiZSBvbiBib3R0b20uIE5hTiB2YWx1ZXMgYXJlIGRyYXduIGFzIHdoaXRlIGFyZWFzIHdpdGhvdXQgYSBsaW5lIG9uIHRvcCwgc2VlIHN0YWNrZWRHcmFwaE5hTkZpbGwgZm9yIGRldGFpbHMuXCJcbiAgfSxcbiAgXCJzdGFja2VkR3JhcGhOYU5GaWxsXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJhbGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIExpbmUgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQ29udHJvbHMgaGFuZGxpbmcgb2YgTmFOIHZhbHVlcyBpbnNpZGUgYSBzdGFja2VkIGdyYXBoLiBOYU4gdmFsdWVzIGFyZSBpbnRlcnBvbGF0ZWQvZXh0ZW5kZWQgZm9yIHN0YWNraW5nIHB1cnBvc2VzLCBidXQgdGhlIGFjdHVhbCBwb2ludCB2YWx1ZSByZW1haW5zIE5hTiBpbiB0aGUgbGVnZW5kIGRpc3BsYXkuIFZhbGlkIG9wdGlvbiB2YWx1ZXMgYXJlIFxcXCJhbGxcXFwiIChpbnRlcnBvbGF0ZSBpbnRlcm5hbGx5LCByZXBlYXQgbGVmdG1vc3QgYW5kIHJpZ2h0bW9zdCB2YWx1ZSBhcyBuZWVkZWQpLCBcXFwiaW5zaWRlXFxcIiAoaW50ZXJwb2xhdGUgaW50ZXJuYWxseSBvbmx5LCB1c2UgemVybyBvdXRzaWRlIGxlZnRtb3N0IGFuZCByaWdodG1vc3QgdmFsdWUpLCBhbmQgXFxcIm5vbmVcXFwiICh0cmVhdCBOYU4gYXMgemVybyBldmVyeXdoZXJlKS5cIlxuICB9LFxuICBcInBvaW50U2l6ZVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHNpemUgb2YgdGhlIGRvdCB0byBkcmF3IG9uIGVhY2ggcG9pbnQgaW4gcGl4ZWxzIChzZWUgZHJhd1BvaW50cykuIEEgZG90IGlzIGFsd2F5cyBkcmF3biB3aGVuIGEgcG9pbnQgaXMgXFxcImlzb2xhdGVkXFxcIiwgaS5lLiB0aGVyZSBpcyBhIG1pc3NpbmcgcG9pbnQgb24gZWl0aGVyIHNpZGUgb2YgaXQuIFRoaXMgYWxzbyBjb250cm9scyB0aGUgc2l6ZSBvZiB0aG9zZSBkb3RzLlwiXG4gIH0sXG4gIFwiZHJhd1BvaW50c1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIExpbmUgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkRyYXcgYSBzbWFsbCBkb3QgYXQgZWFjaCBwb2ludCwgaW4gYWRkaXRpb24gdG8gYSBsaW5lIGdvaW5nIHRocm91Z2ggdGhlIHBvaW50LiBUaGlzIG1ha2VzIHRoZSBpbmRpdmlkdWFsIGRhdGEgcG9pbnRzIGVhc2llciB0byBzZWUsIGJ1dCBjYW4gaW5jcmVhc2UgdmlzdWFsIGNsdXR0ZXIgaW4gdGhlIGNoYXJ0LiBUaGUgc21hbGwgZG90IGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgY3VzdG9tIHJlbmRlcmluZyBieSBzdXBwbHlpbmcgYSA8YSBocmVmPScjZHJhd1BvaW50Q2FsbGJhY2snPmRyYXdQb2ludENhbGxiYWNrPC9hPi5cIlxuICB9LFxuICBcImRyYXdHYXBFZGdlUG9pbnRzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRHJhdyBwb2ludHMgYXQgdGhlIGVkZ2VzIG9mIGdhcHMgaW4gdGhlIGRhdGEuIFRoaXMgaW1wcm92ZXMgdmlzaWJpbGl0eSBvZiBzbWFsbCBkYXRhIHNlZ21lbnRzIG9yIG90aGVyIGRhdGEgaXJyZWd1bGFyaXRpZXMuXCJcbiAgfSxcbiAgXCJkcmF3UG9pbnRDYWxsYmFja1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGcsIHNlcmllc05hbWUsIGNhbnZhc0NvbnRleHQsIGN4LCBjeSwgY29sb3IsIHBvaW50U2l6ZSlcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcImdcIiAsIFwidGhlIHJlZmVyZW5jZSBncmFwaFwiIF0sXG4gICAgICBbIFwic2VyaWVzTmFtZVwiICwgXCJ0aGUgbmFtZSBvZiB0aGUgc2VyaWVzXCIgXSxcbiAgICAgIFsgXCJjYW52YXNDb250ZXh0XCIgLCBcInRoZSBjYW52YXMgdG8gZHJhdyBvblwiIF0sXG4gICAgICBbIFwiY3hcIiAsIFwiY2VudGVyIHggY29vcmRpbmF0ZVwiIF0sXG4gICAgICBbIFwiY3lcIiAsIFwiY2VudGVyIHkgY29vcmRpbmF0ZVwiIF0sXG4gICAgICBbIFwiY29sb3JcIiAsIFwic2VyaWVzIGNvbG9yXCIgXSxcbiAgICAgIFsgXCJwb2ludFNpemVcIiAsIFwidGhlIHJhZGl1cyBvZiB0aGUgaW1hZ2UuXCIgXSxcbiAgICAgIFsgXCJpZHhcIiAsIFwidGhlIHJvdy1pbmRleCBvZiB0aGUgcG9pbnQgaW4gdGhlIGRhdGEuXCJdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRHJhdyBhIGN1c3RvbSBpdGVtIHdoZW4gZHJhd1BvaW50cyBpcyBlbmFibGVkLiBEZWZhdWx0IGlzIGEgc21hbGwgZG90IG1hdGNoaW5nIHRoZSBzZXJpZXMgY29sb3IuIFRoaXMgbWV0aG9kIHNob3VsZCBjb25zdHJhaW4gZHJhd2luZyB0byB3aXRoaW4gcG9pbnRTaXplIHBpeGVscyBmcm9tIChjeCwgY3kpLiAgQWxzbyBzZWUgPGEgaHJlZj0nI2RyYXdIaWdobGlnaHRQb2ludENhbGxiYWNrJz5kcmF3SGlnaGxpZ2h0UG9pbnRDYWxsYmFjazwvYT5cIlxuICB9LFxuICBcImhlaWdodFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMzIwXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiT3ZlcmFsbCBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSGVpZ2h0LCBpbiBwaXhlbHMsIG9mIHRoZSBjaGFydC4gSWYgdGhlIGNvbnRhaW5lciBkaXYgaGFzIGJlZW4gZXhwbGljaXRseSBzaXplZCwgdGhpcyB3aWxsIGJlIGlnbm9yZWQuXCJcbiAgfSxcbiAgXCJ6b29tQ2FsbGJhY2tcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJDYWxsYmFja3NcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24obWluRGF0ZSwgbWF4RGF0ZSwgeVJhbmdlcylcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcIm1pbkRhdGVcIiAsIFwibWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoXCIgXSxcbiAgICAgIFsgXCJtYXhEYXRlXCIgLCBcIm1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaC5cIiBdLFxuICAgICAgWyBcInlSYW5nZXNcIiAsIFwiaXMgYW4gYXJyYXkgb2YgW2JvdHRvbSwgdG9wXSBwYWlycywgb25lIGZvciBlYWNoIHktYXhpcy5cIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHpvb20gd2luZG93IGlzIGNoYW5nZWQgKGVpdGhlciBieSB6b29taW5nIGluIG9yIG91dCkuIFdoZW4gYW5pbWF0ZWRab29tcyBpcyBzZXQsIHpvb21DYWxsYmFjayBpcyBjYWxsZWQgb25jZSBhdCB0aGUgZW5kIG9mIHRoZSB0cmFuc2l0aW9uIChpdCB3aWxsIG5vdCBiZSBjYWxsZWQgZm9yIGludGVybWVkaWF0ZSBmcmFtZXMpLlwiXG4gIH0sXG4gIFwicG9pbnRDbGlja0NhbGxiYWNrXCI6IHtcbiAgICBcInNuaXBwZXRcIjogXCJmdW5jdGlvbihlLCBwb2ludCl7PGJyPiZuYnNwOyZuYnNwO2FsZXJ0KHBvaW50KTs8YnI+fVwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJDYWxsYmFja3NcIiwgXCJJbnRlcmFjdGl2ZSBFbGVtZW50c1wiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihlLCBwb2ludClcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcImVcIiAsIFwidGhlIGV2ZW50IG9iamVjdCBmb3IgdGhlIGNsaWNrXCIgXSxcbiAgICAgIFsgXCJwb2ludFwiICwgXCJ0aGUgcG9pbnQgdGhhdCB3YXMgY2xpY2tlZCBTZWUgPGEgaHJlZj0nI3BvaW50X3Byb3BlcnRpZXMnPlBvaW50IHByb3BlcnRpZXM8L2E+IGZvciBkZXRhaWxzXCIgXVxuICAgIF0sXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgZGF0YSBwb2ludCBpcyBjbGlja2VkLiBhbmQgdGhlIHBvaW50IHRoYXQgd2FzIGNsaWNrZWQuXCJcbiAgfSxcbiAgXCJjb2xvclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiKHNlZSBkZXNjcmlwdGlvbilcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIFNlcmllcyBDb2xvcnNcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJleGFtcGxlXCI6IFwicmVkXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgcGVyLXNlcmllcyBjb2xvciBkZWZpbml0aW9uLiBVc2VkIGluIGNvbmp1bmN0aW9uIHdpdGgsIGFuZCBvdmVycmlkZXMsIHRoZSBjb2xvcnMgb3B0aW9uLlwiXG4gIH0sXG4gIFwiY29sb3JzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIoc2VlIGRlc2NyaXB0aW9uKVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgU2VyaWVzIENvbG9yc1wiXSxcbiAgICBcInR5cGVcIjogXCJhcnJheTxzdHJpbmc+XCIsXG4gICAgXCJleGFtcGxlXCI6IFwiWydyZWQnLCAnIzAwRkYwMCddXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkxpc3Qgb2YgY29sb3JzIGZvciB0aGUgZGF0YSBzZXJpZXMuIFRoZXNlIGNhbiBiZSBvZiB0aGUgZm9ybSBcXFwiI0FBQkJDQ1xcXCIgb3IgXFxcInJnYigyNTUsMTAwLDIwMClcXFwiIG9yIFxcXCJ5ZWxsb3dcXFwiLCBldGMuIElmIG5vdCBzcGVjaWZpZWQsIGVxdWFsbHktc3BhY2VkIHBvaW50cyBhcm91bmQgYSBjb2xvciB3aGVlbCBhcmUgdXNlZC4gT3ZlcnJpZGRlbiBieSB0aGUgJ2NvbG9yJyBvcHRpb24uXCJcbiAgfSxcbiAgXCJjb25uZWN0U2VwYXJhdGVkUG9pbnRzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVXN1YWxseSwgd2hlbiBEeWdyYXBocyBlbmNvdW50ZXJzIGEgbWlzc2luZyB2YWx1ZSBpbiBhIGRhdGEgc2VyaWVzLCBpdCBpbnRlcnByZXRzIHRoaXMgYXMgYSBnYXAgYW5kIGRyYXdzIGl0IGFzIHN1Y2guIElmLCBpbnN0ZWFkLCB0aGUgbWlzc2luZyB2YWx1ZXMgcmVwcmVzZW50cyBhbiB4LXZhbHVlIGZvciB3aGljaCBvbmx5IGEgZGlmZmVyZW50IHNlcmllcyBoYXMgZGF0YSwgdGhlbiB5b3UnbGwgd2FudCB0byBjb25uZWN0IHRoZSBkb3RzIGJ5IHNldHRpbmcgdGhpcyB0byB0cnVlLiBUbyBleHBsaWNpdGx5IGluY2x1ZGUgYSBnYXAgd2l0aCB0aGlzIG9wdGlvbiBzZXQsIHVzZSBhIHZhbHVlIG9mIE5hTi5cIlxuICB9LFxuICBcImhpZ2hsaWdodENhbGxiYWNrXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ2FsbGJhY2tzXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGV2ZW50LCB4LCBwb2ludHMsIHJvdywgc2VyaWVzTmFtZSlcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hlbiBzZXQsIHRoaXMgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSBhIG5ldyBwb2ludCBpcyBoaWdobGlnaHRlZC5cIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgW1wiZXZlbnRcIiwgXCJ0aGUgSmF2YVNjcmlwdCBtb3VzZW1vdmUgZXZlbnRcIl0sXG4gICAgICBbXCJ4XCIsIFwidGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgaGlnaGxpZ2h0ZWQgcG9pbnRzXCJdLFxuICAgICAgW1wicG9pbnRzXCIsIFwiYW4gYXJyYXkgb2YgaGlnaGxpZ2h0ZWQgcG9pbnRzOiA8Y29kZT5bIHtuYW1lOiAnc2VyaWVzJywgeXZhbDogeS12YWx1ZX0sICZoZWxsaXA7IF08L2NvZGU+XCJdLFxuICAgICAgW1wicm93XCIsIFwiaW50ZWdlciBpbmRleCBvZiB0aGUgaGlnaGxpZ2h0ZWQgcm93IGluIHRoZSBkYXRhIHRhYmxlLCBzdGFydGluZyBmcm9tIDBcIl0sXG4gICAgICBbXCJzZXJpZXNOYW1lXCIsIFwibmFtZSBvZiB0aGUgaGlnaGxpZ2h0ZWQgc2VyaWVzLCBvbmx5IHByZXNlbnQgaWYgaGlnaGxpZ2h0U2VyaWVzT3B0cyBpcyBzZXQuXCJdXG4gICAgXVxuICB9LFxuICBcImRyYXdIaWdobGlnaHRQb2ludENhbGxiYWNrXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oZywgc2VyaWVzTmFtZSwgY2FudmFzQ29udGV4dCwgY3gsIGN5LCBjb2xvciwgcG9pbnRTaXplKVwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbIFwiZ1wiICwgXCJ0aGUgcmVmZXJlbmNlIGdyYXBoXCIgXSxcbiAgICAgIFsgXCJzZXJpZXNOYW1lXCIgLCBcInRoZSBuYW1lIG9mIHRoZSBzZXJpZXNcIiBdLFxuICAgICAgWyBcImNhbnZhc0NvbnRleHRcIiAsIFwidGhlIGNhbnZhcyB0byBkcmF3IG9uXCIgXSxcbiAgICAgIFsgXCJjeFwiICwgXCJjZW50ZXIgeCBjb29yZGluYXRlXCIgXSxcbiAgICAgIFsgXCJjeVwiICwgXCJjZW50ZXIgeSBjb29yZGluYXRlXCIgXSxcbiAgICAgIFsgXCJjb2xvclwiICwgXCJzZXJpZXMgY29sb3JcIiBdLFxuICAgICAgWyBcInBvaW50U2l6ZVwiICwgXCJ0aGUgcmFkaXVzIG9mIHRoZSBpbWFnZS5cIiBdLFxuICAgICAgWyBcImlkeFwiICwgXCJ0aGUgcm93LWluZGV4IG9mIHRoZSBwb2ludCBpbiB0aGUgZGF0YS5cIl1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJEcmF3IGEgY3VzdG9tIGl0ZW0gd2hlbiBhIHBvaW50IGlzIGhpZ2hsaWdodGVkLiAgRGVmYXVsdCBpcyBhIHNtYWxsIGRvdCBtYXRjaGluZyB0aGUgc2VyaWVzIGNvbG9yLiBUaGlzIG1ldGhvZCBzaG91bGQgY29uc3RyYWluIGRyYXdpbmcgdG8gd2l0aGluIHBvaW50U2l6ZSBwaXhlbHMgZnJvbSAoY3gsIGN5KSBBbHNvIHNlZSA8YSBocmVmPScjZHJhd1BvaW50Q2FsbGJhY2snPmRyYXdQb2ludENhbGxiYWNrPC9hPlwiXG4gIH0sXG4gIFwiaGlnaGxpZ2h0U2VyaWVzT3B0c1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkludGVyYWN0aXZlIEVsZW1lbnRzXCJdLFxuICAgIFwidHlwZVwiOiBcIk9iamVjdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIHNldCwgdGhlIG9wdGlvbnMgZnJvbSB0aGlzIG9iamVjdCBhcmUgYXBwbGllZCB0byB0aGUgdGltZXNlcmllcyBjbG9zZXN0IHRvIHRoZSBtb3VzZSBwb2ludGVyIGZvciBpbnRlcmFjdGl2ZSBoaWdobGlnaHRpbmcuIFNlZSBhbHNvICdoaWdobGlnaHRDYWxsYmFjaycuIEV4YW1wbGU6IGhpZ2hsaWdodFNlcmllc09wdHM6IHsgc3Ryb2tlV2lkdGg6IDMgfS5cIlxuICB9LFxuICBcImhpZ2hsaWdodFNlcmllc0JhY2tncm91bmRBbHBoYVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMC41XCIsXG4gICAgXCJsYWJlbHNcIjogW1wiSW50ZXJhY3RpdmUgRWxlbWVudHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRmFkZSB0aGUgYmFja2dyb3VuZCB3aGlsZSBoaWdobGlnaHRpbmcgc2VyaWVzLiAxPWZ1bGx5IHZpc2libGUgYmFja2dyb3VuZCAoZGlzYWJsZSBmYWRpbmcpLCAwPWhpZGRkZW4gYmFja2dyb3VuZCAoc2hvdyBoaWdobGlnaHRlZCBzZXJpZXMgb25seSkuXCJcbiAgfSxcbiAgXCJoaWdobGlnaHRTZXJpZXNCYWNrZ3JvdW5kQ29sb3JcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcInJnYigyNTUsIDI1NSwgMjU1KVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkludGVyYWN0aXZlIEVsZW1lbnRzXCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTZXRzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIHVzZWQgdG8gZmFkZSBvdXQgdGhlIHNlcmllcyBpbiBjb25qdW5jdGlvbiB3aXRoICdoaWdobGlnaHRTZXJpZXNCYWNrZ3JvdW5kQWxwaGEnLlwiXG4gIH0sXG4gIFwiaW5jbHVkZVplcm9cIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVXN1YWxseSwgZHlncmFwaHMgd2lsbCB1c2UgdGhlIHJhbmdlIG9mIHRoZSBkYXRhIHBsdXMgc29tZSBwYWRkaW5nIHRvIHNldCB0aGUgcmFuZ2Ugb2YgdGhlIHktYXhpcy4gSWYgdGhpcyBvcHRpb24gaXMgc2V0LCB0aGUgeS1heGlzIHdpbGwgYWx3YXlzIGluY2x1ZGUgemVybywgdHlwaWNhbGx5IGFzIHRoZSBsb3dlc3QgdmFsdWUuIFRoaXMgY2FuIGJlIHVzZWQgdG8gYXZvaWQgZXhhZ2dlcmF0aW5nIHRoZSB2YXJpYW5jZSBpbiB0aGUgZGF0YVwiXG4gIH0sXG4gIFwicm9sbFBlcmlvZFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkVycm9yIEJhcnNcIiwgXCJSb2xsaW5nIEF2ZXJhZ2VzXCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXIgJmd0Oz0gMVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJOdW1iZXIgb2YgZGF5cyBvdmVyIHdoaWNoIHRvIGF2ZXJhZ2UgZGF0YS4gRGlzY3Vzc2VkIGV4dGVuc2l2ZWx5IGFib3ZlLlwiXG4gIH0sXG4gIFwidW5oaWdobGlnaHRDYWxsYmFja1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNhbGxiYWNrc1wiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihldmVudClcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcImV2ZW50XCIgLCBcInRoZSBtb3VzZSBldmVudFwiIF1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIHNldCwgdGhpcyBjYWxsYmFjayBnZXRzIGNhbGxlZCBldmVyeSB0aW1lIHRoZSB1c2VyIHN0b3BzIGhpZ2hsaWdodGluZyBhbnkgcG9pbnQgYnkgbW91c2luZyBvdXQgb2YgdGhlIGdyYXBoLlwiXG4gIH0sXG4gIFwiYXhpc1RpY2tTaXplXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIzLjBcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBzaXplIG9mIHRoZSBsaW5lIHRvIGRpc3BsYXkgbmV4dCB0byBlYWNoIHRpY2sgbWFyayBvbiB4LSBvciB5LWF4ZXMuXCJcbiAgfSxcbiAgXCJsYWJlbHNTZXBhcmF0ZUxpbmVzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkxlZ2VuZFwiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlB1dCA8Y29kZT4mbHQ7YnIvJmd0OzwvY29kZT4gYmV0d2VlbiBsaW5lcyBpbiB0aGUgbGFiZWwgc3RyaW5nLiBPZnRlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggPHN0cm9uZz5sYWJlbHNEaXY8L3N0cm9uZz4uXCJcbiAgfSxcbiAgXCJ2YWx1ZUZvcm1hdHRlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiRGVwZW5kcyBvbiB0aGUgdHlwZSBvZiB5b3VyIGRhdGEuXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiTGVnZW5kXCIsIFwiVmFsdWUgZGlzcGxheS9mb3JtYXR0aW5nXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKG51bSBvciBtaWxsaXMsIG9wdHMsIHNlcmllc05hbWUsIGR5Z3JhcGgsIHJvdywgY29sKVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJGdW5jdGlvbiB0byBwcm92aWRlIGEgY3VzdG9tIGRpc3BsYXkgZm9ybWF0IGZvciB0aGUgdmFsdWVzIGRpc3BsYXllZCBvbiBtb3VzZW92ZXIuIFRoaXMgZG9lcyBub3QgYWZmZWN0IHRoZSB2YWx1ZXMgdGhhdCBhcHBlYXIgb24gdGljayBtYXJrcyBuZXh0IHRvIHRoZSBheGVzLiBUbyBmb3JtYXQgdGhvc2UsIHNlZSBheGlzTGFiZWxGb3JtYXR0ZXIuIFRoaXMgaXMgdXN1YWxseSBzZXQgb24gYSA8YSBocmVmPSdwZXItYXhpcy5odG1sJz5wZXItYXhpczwvYT4gYmFzaXMuIC5cIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgW1wibnVtX29yX21pbGxpc1wiLCBcIlRoZSB2YWx1ZSB0byBiZSBmb3JtYXR0ZWQuIFRoaXMgaXMgYWx3YXlzIGEgbnVtYmVyLiBGb3IgZGF0ZSBheGVzLCBpdCdzIG1pbGxpcyBzaW5jZSBlcG9jaC4gWW91IGNhbiBjYWxsIG5ldyBEYXRlKG1pbGxpcykgdG8gZ2V0IGEgRGF0ZSBvYmplY3QuXCJdLFxuICAgICAgW1wib3B0c1wiLCBcIlRoaXMgaXMgYSBmdW5jdGlvbiB5b3UgY2FuIGNhbGwgdG8gYWNjZXNzIHZhcmlvdXMgb3B0aW9ucyAoZS5nLiBvcHRzKCdsYWJlbHNLTUInKSkuIEl0IHJldHVybnMgcGVyLWF4aXMgdmFsdWVzIGZvciB0aGUgb3B0aW9uIHdoZW4gYXZhaWxhYmxlLlwiXSxcbiAgICAgIFtcInNlcmllc05hbWVcIiwgXCJUaGUgbmFtZSBvZiB0aGUgc2VyaWVzIGZyb20gd2hpY2ggdGhlIHBvaW50IGNhbWUsIGUuZy4gJ1gnLCAnWScsICdBJywgZXRjLlwiXSxcbiAgICAgIFtcImR5Z3JhcGhcIiwgXCJUaGUgZHlncmFwaCBvYmplY3QgZm9yIHdoaWNoIHRoZSBmb3JtYXR0aW5nIGlzIGJlaW5nIGRvbmVcIl0sXG4gICAgICBbXCJyb3dcIiwgXCJUaGUgcm93IG9mIHRoZSBkYXRhIGZyb20gd2hpY2ggdGhpcyBwb2ludCBjb21lcy4gZy5nZXRWYWx1ZShyb3csIDApIHdpbGwgcmV0dXJuIHRoZSB4LXZhbHVlIGZvciB0aGlzIHBvaW50LlwiXSxcbiAgICAgIFtcImNvbFwiLCBcIlRoZSBjb2x1bW4gb2YgdGhlIGRhdGEgZnJvbSB3aGljaCB0aGlzIHBvaW50IGNvbWVzLiBnLmdldFZhbHVlKHJvdywgY29sKSB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgeS12YWx1ZSBmb3IgdGhpcyBwb2ludC4gVGhpcyBjYW4gYmUgdXNlZCB0byBnZXQgdGhlIGZ1bGwgY29uZmlkZW5jZSBpbnRlcnZhbCBmb3IgdGhlIHBvaW50LCBvciBhY2Nlc3MgdW4tcm9sbGVkIHZhbHVlcyBmb3IgdGhlIHBvaW50LlwiXVxuICAgIF1cbiAgfSxcbiAgXCJhbm5vdGF0aW9uTW91c2VPdmVySGFuZGxlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkFubm90YXRpb25zXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGFubm90YXRpb24sIHBvaW50LCBkeWdyYXBoLCBldmVudClcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgcHJvdmlkZWQsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSB1c2VyIG1vdXNlcyBvdmVyIGFuIGFubm90YXRpb24uXCJcbiAgfSxcbiAgXCJhbm5vdGF0aW9uTW91c2VPdXRIYW5kbGVyXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQW5ub3RhdGlvbnNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oYW5ub3RhdGlvbiwgcG9pbnQsIGR5Z3JhcGgsIGV2ZW50KVwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbIFwiYW5ub3RhdGlvblwiICwgXCJ0aGUgYW5ub3RhdGlvbiBsZWZ0XCIgXSxcbiAgICAgIFsgXCJwb2ludFwiICwgXCJ0aGUgcG9pbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBhbm5vdGF0aW9uXCIgXSxcbiAgICAgIFsgXCJkeWdyYXBoXCIgLCBcInRoZSByZWZlcmVuY2UgZ3JhcGhcIiBdLFxuICAgICAgWyBcImV2ZW50XCIgLCBcInRoZSBtb3VzZSBldmVudFwiIF1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiBwcm92aWRlZCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHVzZXIgbW91c2VzIG91dCBvZiBhbiBhbm5vdGF0aW9uLlwiXG4gIH0sXG4gIFwiYW5ub3RhdGlvbkNsaWNrSGFuZGxlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkFubm90YXRpb25zXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGFubm90YXRpb24sIHBvaW50LCBkeWdyYXBoLCBldmVudClcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcImFubm90YXRpb25cIiAsIFwidGhlIGFubm90YXRpb24gbGVmdFwiIF0sXG4gICAgICBbIFwicG9pbnRcIiAsIFwidGhlIHBvaW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgYW5ub3RhdGlvblwiIF0sXG4gICAgICBbIFwiZHlncmFwaFwiICwgXCJ0aGUgcmVmZXJlbmNlIGdyYXBoXCIgXSxcbiAgICAgIFsgXCJldmVudFwiICwgXCJ0aGUgbW91c2UgZXZlbnRcIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgcHJvdmlkZWQsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSB1c2VyIGNsaWNrcyBvbiBhbiBhbm5vdGF0aW9uLlwiXG4gIH0sXG4gIFwiYW5ub3RhdGlvbkRibENsaWNrSGFuZGxlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkFubm90YXRpb25zXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGFubm90YXRpb24sIHBvaW50LCBkeWdyYXBoLCBldmVudClcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcImFubm90YXRpb25cIiAsIFwidGhlIGFubm90YXRpb24gbGVmdFwiIF0sXG4gICAgICBbIFwicG9pbnRcIiAsIFwidGhlIHBvaW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgYW5ub3RhdGlvblwiIF0sXG4gICAgICBbIFwiZHlncmFwaFwiICwgXCJ0aGUgcmVmZXJlbmNlIGdyYXBoXCIgXSxcbiAgICAgIFsgXCJldmVudFwiICwgXCJ0aGUgbW91c2UgZXZlbnRcIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgcHJvdmlkZWQsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSB1c2VyIGRvdWJsZS1jbGlja3Mgb24gYW4gYW5ub3RhdGlvbi5cIlxuICB9LFxuICBcImRyYXdDYWxsYmFja1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNhbGxiYWNrc1wiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihkeWdyYXBoLCBpc19pbml0aWFsKVwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbIFwiZHlncmFwaFwiICwgXCJUaGUgZ3JhcGggYmVpbmcgZHJhd25cIiBdLFxuICAgICAgWyBcImlzX2luaXRpYWxcIiAsIFwiVHJ1ZSBpZiB0aGlzIGlzIHRoZSBpbml0aWFsIGRyYXcsIGZhbHNlIGZvciBzdWJzZXF1ZW50IGRyYXdzLlwiIF1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIHNldCwgdGhpcyBjYWxsYmFjayBnZXRzIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBkeWdyYXBoIGlzIGRyYXduLiBUaGlzIGluY2x1ZGVzIHRoZSBpbml0aWFsIGRyYXcsIGFmdGVyIHpvb21pbmcgYW5kIHJlcGVhdGVkbHkgd2hpbGUgcGFubmluZy5cIlxuICB9LFxuICBcImxhYmVsc0tNRzJcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiVmFsdWUgZGlzcGxheS9mb3JtYXR0aW5nXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2hvdyBrL00vRyBmb3Iga2lsby9NZWdhL0dpZ2Egb24geS1heGlzLiBUaGlzIGlzIGRpZmZlcmVudCB0aGFuIDxjb2RlPmxhYmVsc0tNQjwvY29kZT4gaW4gdGhhdCBpdCB1c2VzIGJhc2UgMiwgbm90IDEwLlwiXG4gIH0sXG4gIFwiZGVsaW1pdGVyXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ1NWIHBhcnNpbmdcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBkZWxpbWl0ZXIgdG8gbG9vayBmb3Igd2hlbiBzZXBhcmF0aW5nIGZpZWxkcyBvZiBhIENTViBmaWxlLiBTZXR0aW5nIHRoaXMgdG8gYSB0YWIgaXMgbm90IHVzdWFsbHkgbmVjZXNzYXJ5LCBzaW5jZSB0YWItZGVsaW1pdGVkIGRhdGEgaXMgYXV0by1kZXRlY3RlZC5cIlxuICB9LFxuICBcImF4aXNMYWJlbEZvbnRTaXplXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIxNFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlNpemUgb2YgdGhlIGZvbnQgKGluIHBpeGVscykgdG8gdXNlIGluIHRoZSBheGlzIGxhYmVscywgYm90aCB4LSBhbmQgeS1heGlzLlwiXG4gIH0sXG4gIFwidW5kZXJsYXlDYWxsYmFja1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNhbGxiYWNrc1wiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihjb250ZXh0LCBhcmVhLCBkeWdyYXBoKVwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbIFwiY29udGV4dFwiICwgXCJ0aGUgY2FudmFzIGRyYXdpbmcgY29udGV4dCBvbiB3aGljaCB0byBkcmF3XCIgXSxcbiAgICAgIFsgXCJhcmVhXCIgLCBcIkFuIG9iamVjdCB3aXRoIHt4LHksdyxofSBwcm9wZXJ0aWVzIGRlc2NyaWJpbmcgdGhlIGRyYXdpbmcgYXJlYS5cIiBdLFxuICAgICAgWyBcImR5Z3JhcGhcIiAsIFwidGhlIHJlZmVyZW5jZSBncmFwaFwiIF1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIHNldCwgdGhpcyBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmUgdGhlIGNoYXJ0IGlzIGRyYXduLiBJdCBkZXRhaWxzIG9uIGhvdyB0byB1c2UgdGhpcy5cIlxuICB9LFxuICBcIndpZHRoXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCI0ODBcIixcbiAgICBcImxhYmVsc1wiOiBbXCJPdmVyYWxsIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaWR0aCwgaW4gcGl4ZWxzLCBvZiB0aGUgY2hhcnQuIElmIHRoZSBjb250YWluZXIgZGl2IGhhcyBiZWVuIGV4cGxpY2l0bHkgc2l6ZWQsIHRoaXMgd2lsbCBiZSBpZ25vcmVkLlwiXG4gIH0sXG4gIFwicGl4ZWxSYXRpb1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiKGRldmljZVBpeGVsUmF0aW8gLyBjb250ZXh0LmJhY2tpbmdTdG9yZVJhdGlvKVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIk92ZXJhbGwgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJPdmVycmlkZXMgdGhlIHBpeGVsIHJhdGlvIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgY2FudmFzJ3MgMmQgY29udGV4dC4gT3JkaW5hcmlseSwgdGhpcyBpcyBzZXQgdG8gdGhlIGRldmljZVBpeGVsUmF0aW8gLyAoY29udGV4dC5iYWNraW5nU3RvcmVSYXRpbyB8fCAxKSwgc28gb24gbW9iaWxlIGRldmljZXMsIHdoZXJlIHRoZSBkZXZpY2VQaXhlbFJhdGlvIGNhbiBiZSBzb21ld2hlcmUgYXJvdW5kIDMsIHBlcmZvcm1hbmNlIGNhbiBiZSBpbXByb3ZlZCBieSBvdmVycmlkaW5nIHRoaXMgdmFsdWUgdG8gc29tZXRoaW5nIGxlc3MgcHJlY2lzZSwgbGlrZSAxLCBhdCB0aGUgZXhwZW5zZSBvZiByZXNvbHV0aW9uLlwiXG4gIH0sXG4gIFwiaW50ZXJhY3Rpb25Nb2RlbFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiLi4uXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiSW50ZXJhY3RpdmUgRWxlbWVudHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiT2JqZWN0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRPRE8oa29uaWdzYmVyZyk6IGRvY3VtZW50IHRoaXNcIlxuICB9LFxuICBcInRpY2tlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiRHlncmFwaC5kYXRlVGlja2VyIG9yIER5Z3JhcGgubnVtZXJpY1RpY2tzXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKG1pbiwgbWF4LCBwaXhlbHMsIG9wdHMsIGR5Z3JhcGgsIHZhbHMpIC0+IFt7djogLi4uLCBsYWJlbDogLi4ufSwgLi4uXVwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbIFwibWluXCIgLCBcIlwiIF0sXG4gICAgICBbIFwibWF4XCIgLCBcIlwiIF0sXG4gICAgICBbIFwicGl4ZWxzXCIgLCBcIlwiIF0sXG4gICAgICBbIFwib3B0c1wiICwgXCJcIiBdLFxuICAgICAgWyBcImR5Z3JhcGhcIiAsIFwidGhlIHJlZmVyZW5jZSBncmFwaFwiIF0sXG4gICAgICBbIFwidmFsc1wiICwgXCJcIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhpcyBsZXRzIHlvdSBzcGVjaWZ5IGFuIGFyYml0cmFyeSBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aWNrIG1hcmtzIG9uIGFuIGF4aXMuIFRoZSB0aWNrIG1hcmtzIGFyZSBhbiBhcnJheSBvZiAodmFsdWUsIGxhYmVsKSBwYWlycy4gVGhlIGJ1aWx0LWluIGZ1bmN0aW9ucyBnbyB0byBncmVhdCBsZW5ndGhzIHRvIGNob29zZSBnb29kIHRpY2sgbWFya3Mgc28sIGlmIHlvdSBzZXQgdGhpcyBvcHRpb24sIHlvdSdsbCBtb3N0IGxpa2VseSB3YW50IHRvIGNhbGwgb25lIG9mIHRoZW0gYW5kIG1vZGlmeSB0aGUgcmVzdWx0LiBTZWUgZHlncmFwaC10aWNrZXJzLmpzIGZvciBhbiBleHRlbnNpdmUgZGlzY3Vzc2lvbi4gVGhpcyBpcyBzZXQgb24gYSA8YSBocmVmPSdwZXItYXhpcy5odG1sJz5wZXItYXhpczwvYT4gYmFzaXMuXCJcbiAgfSxcbiAgXCJ4QXhpc0hlaWdodFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiKG51bGwpXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSGVpZ2h0LCBpbiBwaXhlbHMsIG9mIHRoZSB4LWF4aXMuIElmIG5vdCBzZXQgZXhwbGljaXRseSwgdGhpcyBpcyBjb21wdXRlZCBiYXNlZCBvbiBheGlzTGFiZWxGb250U2l6ZSBhbmQgYXhpc1RpY2tTaXplLlwiXG4gIH0sXG4gIFwic2hvd0xhYmVsc09uSGlnaGxpZ2h0XCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJ0cnVlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiSW50ZXJhY3RpdmUgRWxlbWVudHNcIiwgXCJMZWdlbmRcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGV0aGVyIHRvIHNob3cgdGhlIGxlZ2VuZCB1cG9uIG1vdXNlb3Zlci5cIlxuICB9LFxuICBcImF4aXNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIihub25lKVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2V0IHRvIGVpdGhlciAneTEnIG9yICd5MicgdG8gYXNzaWduIGEgc2VyaWVzIHRvIGEgeS1heGlzIChwcmltYXJ5IG9yIHNlY29uZGFyeSkuIE11c3QgYmUgc2V0IHBlci1zZXJpZXMuXCJcbiAgfSxcbiAgXCJwaXhlbHNQZXJMYWJlbFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiNzAgKHgtYXhpcykgb3IgMzAgKHktYXhlcylcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIiwgXCJHcmlkXCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTnVtYmVyIG9mIHBpeGVscyB0byByZXF1aXJlIGJldHdlZW4gZWFjaCB4LSBhbmQgeS1sYWJlbC4gTGFyZ2VyIHZhbHVlcyB3aWxsIHlpZWxkIGEgc3BhcnNlciBheGlzIHdpdGggZmV3ZXIgdGlja3MuIFRoaXMgaXMgc2V0IG9uIGEgPGEgaHJlZj0ncGVyLWF4aXMuaHRtbCc+cGVyLWF4aXM8L2E+IGJhc2lzLlwiXG4gIH0sXG4gIFwibGFiZWxzRGl2XCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiTGVnZW5kXCJdLFxuICAgIFwidHlwZVwiOiBcIkRPTSBlbGVtZW50IG9yIHN0cmluZ1wiLFxuICAgIFwiZXhhbXBsZVwiOiBcIjxjb2RlIHN0eWxlPSdmb250LXNpemU6IHNtYWxsJz5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9vJyk8L2NvZGU+b3I8Y29kZT4nZm9vJ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTaG93IGRhdGEgbGFiZWxzIGluIGFuIGV4dGVybmFsIGRpdiwgcmF0aGVyIHRoYW4gb24gdGhlIGdyYXBoLiAgVGhpcyB2YWx1ZSBjYW4gZWl0aGVyIGJlIGEgZGl2IGVsZW1lbnQgb3IgYSBkaXYgaWQuXCJcbiAgfSxcbiAgXCJmcmFjdGlvbnNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ1NWIHBhcnNpbmdcIiwgXCJFcnJvciBCYXJzXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hlbiBzZXQsIGF0dGVtcHQgdG8gcGFyc2UgZWFjaCBjZWxsIGluIHRoZSBDU1YgZmlsZSBhcyBcXFwiYS9iXFxcIiwgd2hlcmUgYSBhbmQgYiBhcmUgaW50ZWdlcnMuIFRoZSByYXRpbyB3aWxsIGJlIHBsb3R0ZWQuIFRoaXMgYWxsb3dzIGNvbXB1dGF0aW9uIG9mIFdpbHNvbiBjb25maWRlbmNlIGludGVydmFscyAoc2VlIGJlbG93KS5cIlxuICB9LFxuICBcImxvZ3NjYWxlXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoZW4gc2V0IGZvciB0aGUgeS1heGlzIG9yIHgtYXhpcywgdGhlIGdyYXBoIHNob3dzIHRoYXQgYXhpcyBpbiBsb2cgc2NhbGUuIEFueSB2YWx1ZXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHplcm8gYXJlIG5vdCBkaXNwbGF5ZWQuIFNob3dpbmcgbG9nIHNjYWxlIHdpdGggcmFuZ2VzIHRoYXQgZ28gYmVsb3cgemVybyB3aWxsIHJlc3VsdCBpbiBhbiB1bnZpZXdhYmxlIGdyYXBoLlxcblxcbiBOb3QgY29tcGF0aWJsZSB3aXRoIHNob3daZXJvLiBjb25uZWN0U2VwYXJhdGVkUG9pbnRzIGlzIGlnbm9yZWQuIFRoaXMgaXMgaWdub3JlZCBmb3IgZGF0ZS1iYXNlZCB4LWF4ZXMuXCJcbiAgfSxcbiAgXCJzdHJva2VXaWR0aFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMS4wXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICBcImV4YW1wbGVcIjogXCIwLjUsIDIuMFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgd2lkdGggb2YgdGhlIGxpbmVzIGNvbm5lY3RpbmcgZGF0YSBwb2ludHMuIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5jcmVhc2UgdGhlIGNvbnRyYXN0IG9yIHNvbWUgZ3JhcGhzLlwiXG4gIH0sXG4gIFwic3Ryb2tlUGF0dGVyblwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImFycmF5PGludGVnZXI+XCIsXG4gICAgXCJleGFtcGxlXCI6IFwiWzEwLCAyLCA1LCAyXVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIGN1c3RvbSBwYXR0ZXJuIGFycmF5IHdoZXJlIHRoZSBldmVuIGluZGV4IGlzIGEgZHJhdyBhbmQgb2RkIGlzIGEgc3BhY2UgaW4gcGl4ZWxzLiBJZiBudWxsIHRoZW4gaXQgZHJhd3MgYSBzb2xpZCBsaW5lLiBUaGUgYXJyYXkgc2hvdWxkIGhhdmUgYSBldmVuIGxlbmd0aCBhcyBhbnkgb2RkIGxlbmd0aGVkIGFycmF5IGNvdWxkIGJlIGV4cHJlc3NlZCBhcyBhIHNtYWxsZXIgZXZlbiBsZW5ndGggYXJyYXkuIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgZGFzaGVkIGxpbmVzLlwiXG4gIH0sXG4gIFwic3Ryb2tlQm9yZGVyV2lkdGhcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIExpbmUgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZXhhbXBsZVwiOiBcIjEuMFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJEcmF3IGEgYm9yZGVyIGFyb3VuZCBncmFwaCBsaW5lcyB0byBtYWtlIGNyb3NzaW5nIGxpbmVzIG1vcmUgZWFzaWx5IGRpc3Rpbmd1aXNoYWJsZS4gVXNlZnVsIGZvciBncmFwaHMgd2l0aCBtYW55IGxpbmVzLlwiXG4gIH0sXG4gIFwic3Ryb2tlQm9yZGVyQ29sb3JcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIndoaXRlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJleGFtcGxlXCI6IFwicmVkLCAjY2NmZmRkXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkNvbG9yIGZvciB0aGUgbGluZSBib3JkZXIgdXNlZCBpZiBzdHJva2VCb3JkZXJXaWR0aCBpcyBzZXQuXCJcbiAgfSxcbiAgXCJ3aWxzb25JbnRlcnZhbFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwidHJ1ZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkVycm9yIEJhcnNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJVc2UgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgXFxcImZyYWN0aW9uc1xcXCIgb3B0aW9uLiBJbnN0ZWFkIG9mIHBsb3R0aW5nICsvLSBOIHN0YW5kYXJkIGRldmlhdGlvbnMsIGR5Z3JhcGhzIHdpbGwgY29tcHV0ZSBhIFdpbHNvbiBjb25maWRlbmNlIGludGVydmFsIGFuZCBwbG90IHRoYXQuIFRoaXMgaGFzIG1vcmUgcmVhc29uYWJsZSBiZWhhdmlvciBmb3IgcmF0aW9zIGNsb3NlIHRvIDAgb3IgMS5cIlxuICB9LFxuICBcImZpbGxHcmFwaFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIExpbmUgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlNob3VsZCB0aGUgYXJlYSB1bmRlcm5lYXRoIHRoZSBncmFwaCBiZSBmaWxsZWQ/IFRoaXMgb3B0aW9uIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggZXJyb3IgYmFycy4gVGhpcyBtYXkgYmUgc2V0IG9uIGEgPGEgaHJlZj0ncGVyLWF4aXMuaHRtbCc+cGVyLXNlcmllczwvYT4gYmFzaXMuXCJcbiAgfSxcbiAgXCJoaWdobGlnaHRDaXJjbGVTaXplXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIzXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiSW50ZXJhY3RpdmUgRWxlbWVudHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgc2l6ZSBpbiBwaXhlbHMgb2YgdGhlIGRvdCBkcmF3biBvdmVyIGhpZ2hsaWdodGVkIHBvaW50cy5cIlxuICB9LFxuICBcImdyaWRMaW5lQ29sb3JcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcInJnYigxMjgsMTI4LDEyOClcIixcbiAgICBcImxhYmVsc1wiOiBbXCJHcmlkXCJdLFxuICAgIFwidHlwZVwiOiBcInJlZCwgYmx1ZVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgY29sb3Igb2YgdGhlIGdyaWRsaW5lcy4gVGhpcyBtYXkgYmUgc2V0IG9uIGEgcGVyLWF4aXMgYmFzaXMgdG8gZGVmaW5lIGVhY2ggYXhpcycgZ3JpZCBzZXBhcmF0ZWx5LlwiXG4gIH0sXG4gIFwiZ3JpZExpbmVQYXR0ZXJuXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiR3JpZFwiXSxcbiAgICBcInR5cGVcIjogXCJhcnJheTxpbnRlZ2VyPlwiLFxuICAgIFwiZXhhbXBsZVwiOiBcIlsxMCwgMiwgNSwgMl1cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBjdXN0b20gcGF0dGVybiBhcnJheSB3aGVyZSB0aGUgZXZlbiBpbmRleCBpcyBhIGRyYXcgYW5kIG9kZCBpcyBhIHNwYWNlIGluIHBpeGVscy4gSWYgbnVsbCB0aGVuIGl0IGRyYXdzIGEgc29saWQgbGluZS4gVGhlIGFycmF5IHNob3VsZCBoYXZlIGEgZXZlbiBsZW5ndGggYXMgYW55IG9kZCBsZW5ndGhlZCBhcnJheSBjb3VsZCBiZSBleHByZXNzZWQgYXMgYSBzbWFsbGVyIGV2ZW4gbGVuZ3RoIGFycmF5LiBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGRhc2hlZCBncmlkbGluZXMuXCJcbiAgfSxcbiAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJbdHJ1ZSwgdHJ1ZSwgLi4uXVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcIkFycmF5IG9mIGJvb2xlYW5zXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoaWNoIHNlcmllcyBzaG91bGQgaW5pdGlhbGx5IGJlIHZpc2libGU/IE9uY2UgdGhlIER5Z3JhcGggaGFzIGJlZW4gY29uc3RydWN0ZWQsIHlvdSBjYW4gYWNjZXNzIGFuZCBtb2RpZnkgdGhlIHZpc2liaWxpdHkgb2YgZWFjaCBzZXJpZXMgdXNpbmcgdGhlIDxjb2RlPnZpc2liaWxpdHk8L2NvZGU+IGFuZCA8Y29kZT5zZXRWaXNpYmlsaXR5PC9jb2RlPiBtZXRob2RzLlwiXG4gIH0sXG4gIFwidmFsdWVSYW5nZVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiRnVsbCByYW5nZSBvZiB0aGUgaW5wdXQgaXMgc2hvd25cIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiQXJyYXkgb2YgdHdvIG51bWJlcnNcIixcbiAgICBcImV4YW1wbGVcIjogXCJbMTAsIDExMF1cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRXhwbGljaXRseSBzZXQgdGhlIHZlcnRpY2FsIHJhbmdlIG9mIHRoZSBncmFwaCB0byBbbG93LCBoaWdoXS4gVGhpcyBtYXkgYmUgc2V0IG9uIGEgcGVyLWF4aXMgYmFzaXMgdG8gZGVmaW5lIGVhY2ggeS1heGlzIHNlcGFyYXRlbHkuIElmIGVpdGhlciBsaW1pdCBpcyB1bnNwZWNpZmllZCwgaXQgd2lsbCBiZSBjYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgKGUuZy4gW251bGwsIDMwXSB0byBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZSBqdXN0IHRoZSBsb3dlciBib3VuZClcIlxuICB9LFxuICBcImNvbG9yU2F0dXJhdGlvblwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMS4wXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBTZXJpZXMgQ29sb3JzXCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0ICgwLjAgLSAxLjApXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIDxzdHJvbmc+Y29sb3JzPC9zdHJvbmc+IGlzIG5vdCBzcGVjaWZpZWQsIHNhdHVyYXRpb24gb2YgdGhlIGF1dG9tYXRpY2FsbHktZ2VuZXJhdGVkIGRhdGEgc2VyaWVzIGNvbG9ycy5cIlxuICB9LFxuICBcImhpZGVPdmVybGF5T25Nb3VzZU91dFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwidHJ1ZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkludGVyYWN0aXZlIEVsZW1lbnRzXCIsIFwiTGVnZW5kXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hldGhlciB0byBoaWRlIHRoZSBsZWdlbmQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBjaGFydCBhcmVhLlwiXG4gIH0sXG4gIFwibGVnZW5kXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJvbm1vdXNlb3ZlclwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkxlZ2VuZFwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hlbiB0byBkaXNwbGF5IHRoZSBsZWdlbmQuIEJ5IGRlZmF1bHQsIGl0IG9ubHkgYXBwZWFycyB3aGVuIGEgdXNlciBtb3VzZXMgb3ZlciB0aGUgY2hhcnQuIFNldCBpdCB0byBcXFwiYWx3YXlzXFxcIiB0byBhbHdheXMgZGlzcGxheSBhIGxlZ2VuZCBvZiBzb21lIHNvcnQuIFdoZW4gc2V0IHRvIFxcXCJmb2xsb3dcXFwiLCBsZWdlbmQgZm9sbG93cyBoaWdobGlnaHRlZCBwb2ludHMuXCJcbiAgfSxcbiAgXCJsZWdlbmRGb3JtYXR0ZXJcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJMZWdlbmRcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oZGF0YSk6IHN0cmluZ1wiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIFsgXCJkYXRhXCIsIFwiQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHNlbGVjdGlvbiAob3IgbGFjayBvZiBhIHNlbGVjdGlvbikuIFRoaXMgaW5jbHVkZXMgZm9ybWF0dGVkIHZhbHVlcyBhbmQgc2VyaWVzIGluZm9ybWF0aW9uLiBTZWUgPGEgaHJlZj1cXFwiaHR0cHM6Ly9naXRodWIuY29tL2RhbnZrL2R5Z3JhcGhzL3B1bGwvNjgzXFxcIj5oZXJlPC9hPiBmb3Igc2FtcGxlIHZhbHVlcy5cIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2V0IHRoaXMgdG8gc3VwcGx5IGEgY3VzdG9tIGZvcm1hdHRlciBmb3IgdGhlIGxlZ2VuZC4gU2VlIDxhIGhyZWY9XFxcImh0dHBzOi8vZ2l0aHViLmNvbS9kYW52ay9keWdyYXBocy9wdWxsLzY4M1xcXCI+dGhpcyBjb21tZW50PC9hPiBhbmQgdGhlIDxhIGhyZWY9XFxcInRlc3RzL2xlZ2VuZC1mb3JtYXR0ZXIuaHRtbFxcXCI+bGVnZW5kRm9ybWF0dGVyIGRlbW88L2E+IGZvciB1c2FnZS5cIlxuICB9LFxuICBcImxhYmVsc1Nob3daZXJvVmFsdWVzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJ0cnVlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiTGVnZW5kXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2hvdyB6ZXJvIHZhbHVlIGxhYmVscyBpbiB0aGUgbGFiZWxzRGl2LlwiXG4gIH0sXG4gIFwic3RlcFBsb3RcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIHNldCwgZGlzcGxheSB0aGUgZ3JhcGggYXMgYSBzdGVwIHBsb3QgaW5zdGVhZCBvZiBhIGxpbmUgcGxvdC4gVGhpcyBvcHRpb24gbWF5IGVpdGhlciBiZSBzZXQgZm9yIHRoZSB3aG9sZSBncmFwaCBvciBmb3Igc2luZ2xlIHNlcmllcy5cIlxuICB9LFxuICBcImxhYmVsc1VUQ1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJWYWx1ZSBkaXNwbGF5L2Zvcm1hdHRpbmdcIiwgXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTaG93IGRhdGUvdGltZSBsYWJlbHMgYWNjb3JkaW5nIHRvIFVUQyAoaW5zdGVhZCBvZiBsb2NhbCB0aW1lKS5cIlxuICB9LFxuICBcImxhYmVsc0tNQlwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJWYWx1ZSBkaXNwbGF5L2Zvcm1hdHRpbmdcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTaG93IEsvTS9CIGZvciB0aG91c2FuZHMvbWlsbGlvbnMvYmlsbGlvbnMgb24geS1heGlzLlwiXG4gIH0sXG4gIFwicmlnaHRHYXBcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjVcIixcbiAgICBcImxhYmVsc1wiOiBbXCJPdmVyYWxsIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJOdW1iZXIgb2YgcGl4ZWxzIHRvIGxlYXZlIGJsYW5rIGF0IHRoZSByaWdodCBlZGdlIG9mIHRoZSBEeWdyYXBoLiBUaGlzIG1ha2VzIGl0IGVhc2llciB0byBoaWdobGlnaHQgdGhlIHJpZ2h0LW1vc3QgZGF0YSBwb2ludC5cIlxuICB9LFxuICBcImRyYXdBeGVzQXRaZXJvXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoZW4gc2V0LCBkcmF3IHRoZSBYIGF4aXMgYXQgdGhlIFk9MCBwb3NpdGlvbiBhbmQgdGhlIFkgYXhpcyBhdCB0aGUgWD0wIHBvc2l0aW9uIGlmIHRob3NlIHBvc2l0aW9ucyBhcmUgaW5zaWRlIHRoZSBncmFwaCdzIHZpc2libGUgYXJlYS4gT3RoZXJ3aXNlLCBkcmF3IHRoZSBheGVzIGF0IHRoZSBib3R0b20gb3IgbGVmdCBncmFwaCBlZGdlIGFzIHVzdWFsLlwiXG4gIH0sXG4gIFwieFJhbmdlUGFkXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIwXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkFkZCB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiBleHRyYSBzcGFjZSAoaW4gcGl4ZWxzKSBhcm91bmQgdGhlIFgtYXhpcyB2YWx1ZSByYW5nZSB0byBlbnN1cmUgcG9pbnRzIGF0IHRoZSBlZGdlcyByZW1haW4gdmlzaWJsZS5cIlxuICB9LFxuICBcInlSYW5nZVBhZFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiBzZXQsIGFkZCB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiBleHRyYSBzcGFjZSAoaW4gcGl4ZWxzKSBhcm91bmQgdGhlIFktYXhpcyB2YWx1ZSByYW5nZSB0byBlbnN1cmUgcG9pbnRzIGF0IHRoZSBlZGdlcyByZW1haW4gdmlzaWJsZS4gSWYgdW5zZXQsIHVzZSB0aGUgdHJhZGl0aW9uYWwgWSBwYWRkaW5nIGFsZ29yaXRobS5cIlxuICB9LFxuICBcImF4aXNMYWJlbEZvcm1hdHRlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiRGVwZW5kcyBvbiB0aGUgZGF0YSB0eXBlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKG51bWJlciBvciBEYXRlLCBncmFudWxhcml0eSwgb3B0cywgZHlncmFwaClcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcIm51bWJlciBvciBkYXRlXCIgLCBcIkVpdGhlciBhIG51bWJlciAoZm9yIGEgbnVtZXJpYyBheGlzKSBvciBhIERhdGUgb2JqZWN0IChmb3IgYSBkYXRlIGF4aXMpXCIgXSxcbiAgICAgIFsgXCJncmFudWxhcml0eVwiICwgXCJzcGVjaWZpZXMgaG93IGZpbmUtZ3JhaW5lZCB0aGUgYXhpcyBpcy4gRm9yIGRhdGUgYXhlcywgdGhpcyBpcyBhIHJlZmVyZW5jZSB0byB0aGUgdGltZSBncmFudWxhcml0eSBlbnVtZXJhdGlvbiwgZGVmaW5lZCBpbiBkeWdyYXBoLXRpY2tlcnMuanMsIGUuZy4gRHlncmFwaC5XRUVLTFkuXCIgXSxcbiAgICAgIFsgXCJvcHRzXCIgLCBcImEgZnVuY3Rpb24gd2hpY2ggcHJvdmlkZXMgYWNjZXNzIHRvIHZhcmlvdXMgb3B0aW9ucyBvbiB0aGUgZHlncmFwaCwgZS5nLiBvcHRzKCdsYWJlbHNLTUInKS5cIiBdLFxuICAgICAgWyBcImR5Z3JhcGhcIiAsIFwidGhlIHJlZmVyZW5jZWQgZ3JhcGhcIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRnVuY3Rpb24gdG8gY2FsbCB0byBmb3JtYXQgdGhlIHRpY2sgdmFsdWVzIHRoYXQgYXBwZWFyIGFsb25nIGFuIGF4aXMuIFRoaXMgaXMgdXN1YWxseSBzZXQgb24gYSA8YSBocmVmPSdwZXItYXhpcy5odG1sJz5wZXItYXhpczwvYT4gYmFzaXMuXCJcbiAgfSxcbiAgXCJjbGlja0NhbGxiYWNrXCI6IHtcbiAgICBcInNuaXBwZXRcIjogXCJmdW5jdGlvbihlLCBkYXRlX21pbGxpcyl7PGJyPiZuYnNwOyZuYnNwO2FsZXJ0KG5ldyBEYXRlKGRhdGVfbWlsbGlzKSk7PGJyPn1cIixcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ2FsbGJhY2tzXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGUsIHgsIHBvaW50cylcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcImVcIiAsIFwiVGhlIGV2ZW50IG9iamVjdCBmb3IgdGhlIGNsaWNrXCIgXSxcbiAgICAgIFsgXCJ4XCIgLCBcIlRoZSB4IHZhbHVlIHRoYXQgd2FzIGNsaWNrZWQgKGZvciBkYXRlcywgdGhpcyBpcyBtaWxsaXNlY29uZHMgc2luY2UgZXBvY2gpXCIgXSxcbiAgICAgIFsgXCJwb2ludHNcIiAsIFwiVGhlIGNsb3Nlc3QgcG9pbnRzIGFsb25nIHRoYXQgZGF0ZS4gU2VlIDxhIGhyZWY9JyNwb2ludF9wcm9wZXJ0aWVzJz5Qb2ludCBwcm9wZXJ0aWVzPC9hPiBmb3IgZGV0YWlscy5cIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGNhbnZhcyBpcyBjbGlja2VkLlwiXG4gIH0sXG4gIFwibGFiZWxzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJbXFxcIlhcXFwiLCBcXFwiWTFcXFwiLCBcXFwiWTJcXFwiLCAuLi5dKlwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkxlZ2VuZFwiXSxcbiAgICBcInR5cGVcIjogXCJhcnJheTxzdHJpbmc+XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgbmFtZSBmb3IgZWFjaCBkYXRhIHNlcmllcywgaW5jbHVkaW5nIHRoZSBpbmRlcGVuZGVudCAoWCkgc2VyaWVzLiBGb3IgQ1NWIGZpbGVzIGFuZCBEYXRhVGFibGUgb2JqZWN0aW9ucywgdGhpcyBpcyBkZXRlcm1pbmVkIGJ5IGNvbnRleHQuIEZvciByYXcgZGF0YSwgdGhpcyBtdXN0IGJlIHNwZWNpZmllZC4gSWYgaXQgaXMgbm90LCBkZWZhdWx0IHZhbHVlcyBhcmUgc3VwcGxpZWQgYW5kIGEgd2FybmluZyBpcyBsb2dnZWQuXCJcbiAgfSxcbiAgXCJkYXRlV2luZG93XCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJGdWxsIHJhbmdlIG9mIHRoZSBpbnB1dCBpcyBzaG93blwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJBcnJheSBvZiB0d28gbnVtYmVyc1wiLFxuICAgIFwiZXhhbXBsZVwiOiBcIls8YnI+Jm5ic3A7Jm5ic3A7RGF0ZS5wYXJzZSgnMjAwNi0wMS0wMScpLDxicj4mbmJzcDsmbmJzcDsobmV3IERhdGUoKSkudmFsdWVPZigpPGJyPl1cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSW5pdGlhbGx5IHpvb20gaW4gb24gYSBzZWN0aW9uIG9mIHRoZSBncmFwaC4gSXMgb2YgdGhlIGZvcm0gW2VhcmxpZXN0LCBsYXRlc3RdLCB3aGVyZSBlYXJsaWVzdC9sYXRlc3QgYXJlIG1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaC4gSWYgdGhlIGRhdGEgZm9yIHRoZSB4LWF4aXMgaXMgbnVtZXJpYywgdGhlIHZhbHVlcyBpbiBkYXRlV2luZG93IG11c3QgYWxzbyBiZSBudW1iZXJzLlwiXG4gIH0sXG4gIFwic2hvd1JvbGxlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJJbnRlcmFjdGl2ZSBFbGVtZW50c1wiLCBcIlJvbGxpbmcgQXZlcmFnZXNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiB0aGUgcm9sbGluZyBhdmVyYWdlIHBlcmlvZCB0ZXh0IGJveCBzaG91bGQgYmUgc2hvd24uXCJcbiAgfSxcbiAgXCJzaWdtYVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMi4wXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRXJyb3IgQmFyc1wiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIGVycm9yQmFycyBpcyBzZXQsIHNoYWRlIHRoaXMgbWFueSBzdGFuZGFyZCBkZXZpYXRpb25zIGFib3ZlL2JlbG93IGVhY2ggcG9pbnQuXCJcbiAgfSxcbiAgXCJjdXN0b21CYXJzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNTViBwYXJzaW5nXCIsIFwiRXJyb3IgQmFyc1wiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoZW4gc2V0LCBwYXJzZSBlYWNoIENTViBjZWxsIGFzIFxcXCJsb3c7bWlkZGxlO2hpZ2hcXFwiLiBFcnJvciBiYXJzIHdpbGwgYmUgZHJhd24gZm9yIGVhY2ggcG9pbnQgYmV0d2VlbiBsb3cgYW5kIGhpZ2gsIHdpdGggdGhlIHNlcmllcyBpdHNlbGYgZ29pbmcgdGhyb3VnaCBtaWRkbGUuXCJcbiAgfSxcbiAgXCJjb2xvclZhbHVlXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIxLjBcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIFNlcmllcyBDb2xvcnNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZmxvYXQgKDAuMCAtIDEuMClcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgY29sb3JzIGlzIG5vdCBzcGVjaWZpZWQsIHZhbHVlIG9mIHRoZSBkYXRhIHNlcmllcyBjb2xvcnMsIGFzIGluIGh1ZS9zYXR1cmF0aW9uL3ZhbHVlLiAoMC4wLTEuMCwgZGVmYXVsdCAwLjUpXCJcbiAgfSxcbiAgXCJlcnJvckJhcnNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ1NWIHBhcnNpbmdcIiwgXCJFcnJvciBCYXJzXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRG9lcyB0aGUgZGF0YSBjb250YWluIHN0YW5kYXJkIGRldmlhdGlvbnM/IFNldHRpbmcgdGhpcyB0byB0cnVlIGFsdGVycyB0aGUgaW5wdXQgZm9ybWF0IChzZWUgYWJvdmUpLlwiXG4gIH0sXG4gIFwiZGlzcGxheUFubm90YXRpb25zXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkFubm90YXRpb25zXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiT25seSBhcHBsaWVzIHdoZW4gRHlncmFwaHMgaXMgdXNlZCBhcyBhIEdWaXogY2hhcnQuIENhdXNlcyBzdHJpbmcgY29sdW1ucyBmb2xsb3dpbmcgYSBkYXRhIHNlcmllcyB0byBiZSBpbnRlcnByZXRlZCBhcyBhbm5vdGF0aW9ucyBvbiBwb2ludHMgaW4gdGhhdCBzZXJpZXMuIFRoaXMgaXMgdGhlIHNhbWUgZm9ybWF0IHVzZWQgYnkgR29vZ2xlJ3MgQW5ub3RhdGVkVGltZUxpbmUgY2hhcnQuXCJcbiAgfSxcbiAgXCJwYW5FZGdlRnJhY3Rpb25cIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIiwgXCJJbnRlcmFjdGl2ZSBFbGVtZW50c1wiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgZmFydGhlc3QgYSBncmFwaCBtYXkgYmUgcGFubmVkLCBpbiBwZXJjZW50IG9mIHRoZSBkaXNwbGF5LiBGb3IgZXhhbXBsZSwgYSB2YWx1ZSBvZiAwLjEgbWVhbnMgdGhhdCB0aGUgZ3JhcGggY2FuIG9ubHkgYmUgcGFubmVkIDEwJSBwYXNzZWQgdGhlIGVkZ2VzIG9mIHRoZSBkaXNwbGF5ZWQgdmFsdWVzLiBudWxsIG1lYW5zIG5vIGJvdW5kcy5cIlxuICB9LFxuICBcInRpdGxlXCI6IHtcbiAgICBcImxhYmVsc1wiOiBbXCJDaGFydCBsYWJlbHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUZXh0IHRvIGRpc3BsYXkgYWJvdmUgdGhlIGNoYXJ0LiBZb3UgY2FuIHN1cHBseSBhbnkgSFRNTCBmb3IgdGhpcyB2YWx1ZSwgbm90IGp1c3QgdGV4dC4gSWYgeW91IHdpc2ggdG8gc3R5bGUgaXQgdXNpbmcgQ1NTLCB1c2UgdGhlICdkeWdyYXBoLWxhYmVsJyBvciAnZHlncmFwaC10aXRsZScgY2xhc3Nlcy5cIlxuICB9LFxuICBcInRpdGxlSGVpZ2h0XCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIxOFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNoYXJ0IGxhYmVsc1wiXSxcbiAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkhlaWdodCBvZiB0aGUgY2hhcnQgdGl0bGUsIGluIHBpeGVscy4gVGhpcyBhbHNvIGNvbnRyb2xzIHRoZSBkZWZhdWx0IGZvbnQgc2l6ZSBvZiB0aGUgdGl0bGUuIElmIHlvdSBzdHlsZSB0aGUgdGl0bGUgb24geW91ciBvd24sIHRoaXMgY29udHJvbHMgaG93IG11Y2ggc3BhY2UgaXMgc2V0IGFzaWRlIGFib3ZlIHRoZSBjaGFydCBmb3IgdGhlIHRpdGxlJ3MgZGl2LlwiXG4gIH0sXG4gIFwieGxhYmVsXCI6IHtcbiAgICBcImxhYmVsc1wiOiBbXCJDaGFydCBsYWJlbHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUZXh0IHRvIGRpc3BsYXkgYmVsb3cgdGhlIGNoYXJ0J3MgeC1heGlzLiBZb3UgY2FuIHN1cHBseSBhbnkgSFRNTCBmb3IgdGhpcyB2YWx1ZSwgbm90IGp1c3QgdGV4dC4gSWYgeW91IHdpc2ggdG8gc3R5bGUgaXQgdXNpbmcgQ1NTLCB1c2UgdGhlICdkeWdyYXBoLWxhYmVsJyBvciAnZHlncmFwaC14bGFiZWwnIGNsYXNzZXMuXCJcbiAgfSxcbiAgXCJ4TGFiZWxIZWlnaHRcIjoge1xuICAgIFwibGFiZWxzXCI6IFtcIkNoYXJ0IGxhYmVsc1wiXSxcbiAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwiMThcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSGVpZ2h0IG9mIHRoZSB4LWF4aXMgbGFiZWwsIGluIHBpeGVscy4gVGhpcyBhbHNvIGNvbnRyb2xzIHRoZSBkZWZhdWx0IGZvbnQgc2l6ZSBvZiB0aGUgeC1heGlzIGxhYmVsLiBJZiB5b3Ugc3R5bGUgdGhlIGxhYmVsIG9uIHlvdXIgb3duLCB0aGlzIGNvbnRyb2xzIGhvdyBtdWNoIHNwYWNlIGlzIHNldCBhc2lkZSBiZWxvdyB0aGUgY2hhcnQgZm9yIHRoZSB4LWF4aXMgbGFiZWwncyBkaXYuXCJcbiAgfSxcbiAgXCJ5bGFiZWxcIjoge1xuICAgIFwibGFiZWxzXCI6IFtcIkNoYXJ0IGxhYmVsc1wiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRleHQgdG8gZGlzcGxheSB0byB0aGUgbGVmdCBvZiB0aGUgY2hhcnQncyB5LWF4aXMuIFlvdSBjYW4gc3VwcGx5IGFueSBIVE1MIGZvciB0aGlzIHZhbHVlLCBub3QganVzdCB0ZXh0LiBJZiB5b3Ugd2lzaCB0byBzdHlsZSBpdCB1c2luZyBDU1MsIHVzZSB0aGUgJ2R5Z3JhcGgtbGFiZWwnIG9yICdkeWdyYXBoLXlsYWJlbCcgY2xhc3Nlcy4gVGhlIHRleHQgd2lsbCBiZSByb3RhdGVkIDkwIGRlZ3JlZXMgYnkgZGVmYXVsdCwgc28gQ1NTIHJ1bGVzIG1heSBiZWhhdmUgaW4gdW5pbnR1aXRpdmUgd2F5cy4gTm8gYWRkaXRpb25hbCBzcGFjZSBpcyBzZXQgYXNpZGUgZm9yIGEgeS1heGlzIGxhYmVsLiBJZiB5b3UgbmVlZCBtb3JlIHNwYWNlLCBpbmNyZWFzZSB0aGUgd2lkdGggb2YgdGhlIHktYXhpcyB0aWNrIGxhYmVscyB1c2luZyB0aGUgeUF4aXNMYWJlbFdpZHRoIG9wdGlvbi4gSWYgeW91IG5lZWQgYSB3aWRlciBkaXYgZm9yIHRoZSB5LWF4aXMgbGFiZWwsIGVpdGhlciBzdHlsZSBpdCB0aGF0IHdheSB3aXRoIENTUyAoYnV0IHJlbWVtYmVyIHRoYXQgaXQncyByb3RhdGVkLCBzbyB3aWR0aCBpcyBjb250cm9sbGVkIGJ5IHRoZSAnaGVpZ2h0JyBwcm9wZXJ0eSkgb3Igc2V0IHRoZSB5TGFiZWxXaWR0aCBvcHRpb24uXCJcbiAgfSxcbiAgXCJ5MmxhYmVsXCI6IHtcbiAgICBcImxhYmVsc1wiOiBbXCJDaGFydCBsYWJlbHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUZXh0IHRvIGRpc3BsYXkgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjaGFydCdzIHNlY29uZGFyeSB5LWF4aXMuIFRoaXMgbGFiZWwgaXMgb25seSBkaXNwbGF5ZWQgaWYgYSBzZWNvbmRhcnkgeS1heGlzIGlzIHByZXNlbnQuIFNlZSA8YSBocmVmPSdodHRwOi8vZHlncmFwaHMuY29tL3Rlc3RzL3R3by1heGVzLmh0bWwnPnRoaXMgdGVzdDwvYT4gZm9yIGFuIGV4YW1wbGUgb2YgaG93IHRvIGRvIHRoaXMuIFRoZSBjb21tZW50cyBmb3IgdGhlICd5bGFiZWwnIG9wdGlvbiBnZW5lcmFsbHkgYXBwbHkgaGVyZSBhcyB3ZWxsLiBUaGlzIGxhYmVsIGdldHMgYSAnZHlncmFwaC15MmxhYmVsJyBpbnN0ZWFkIG9mIGEgJ2R5Z3JhcGgteWxhYmVsJyBjbGFzcy5cIlxuICB9LFxuICBcInlMYWJlbFdpZHRoXCI6IHtcbiAgICBcImxhYmVsc1wiOiBbXCJDaGFydCBsYWJlbHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIjE4XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldpZHRoIG9mIHRoZSBkaXYgd2hpY2ggY29udGFpbnMgdGhlIHktYXhpcyBsYWJlbC4gU2luY2UgdGhlIHktYXhpcyBsYWJlbCBhcHBlYXJzIHJvdGF0ZWQgOTAgZGVncmVlcywgdGhpcyBhY3R1YWxseSBhZmZlY3RzIHRoZSBoZWlnaHQgb2YgaXRzIGRpdi5cIlxuICB9LFxuICBcImRyYXdHcmlkXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJ0cnVlIGZvciB4IGFuZCB5LCBmYWxzZSBmb3IgeTJcIixcbiAgICBcImxhYmVsc1wiOiBbXCJHcmlkXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCIgOiBcIldoZXRoZXIgdG8gZGlzcGxheSBncmlkbGluZXMgaW4gdGhlIGNoYXJ0LiBUaGlzIG1heSBiZSBzZXQgb24gYSBwZXItYXhpcyBiYXNpcyB0byBkZWZpbmUgdGhlIHZpc2liaWxpdHkgb2YgZWFjaCBheGlzJyBncmlkIHNlcGFyYXRlbHkuXCJcbiAgfSxcbiAgXCJpbmRlcGVuZGVudFRpY2tzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJ0cnVlIGZvciB5LCBmYWxzZSBmb3IgeTJcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIiwgXCJHcmlkXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCIgOiBcIk9ubHkgdmFsaWQgZm9yIHkgYW5kIHkyLCBoYXMgbm8gZWZmZWN0IG9uIHg6IFRoaXMgb3B0aW9uIGRlZmluZXMgd2hldGhlciB0aGUgeSBheGVzIHNob3VsZCBhbGlnbiB0aGVpciB0aWNrcyBvciBpZiB0aGV5IHNob3VsZCBiZSBpbmRlcGVuZGVudC4gUG9zc2libGUgY29tYmluYXRpb25zOiAxLikgeT10cnVlLCB5Mj1mYWxzZSAoZGVmYXVsdCk6IHkgaXMgdGhlIHByaW1hcnkgYXhpcyBhbmQgdGhlIHkyIHRpY2tzIGFyZSBhbGlnbmVkIHRvIHRoZSB0aGUgb25lcyBvZiB5LiAob25seSAxIGdyaWQpIDIuKSB5PWZhbHNlLCB5Mj10cnVlOiB5MiBpcyB0aGUgcHJpbWFyeSBheGlzIGFuZCB0aGUgeSB0aWNrcyBhcmUgYWxpZ25lZCB0byB0aGUgdGhlIG9uZXMgb2YgeTIuIChvbmx5IDEgZ3JpZCkgMy4pIHk9dHJ1ZSwgeTI9dHJ1ZTogQm90aCBheGlzIGFyZSBpbmRlcGVuZGVudCBhbmQgaGF2ZSB0aGVpciBvd24gdGlja3MuICgyIGdyaWRzKSA0LikgeT1mYWxzZSwgeTI9ZmFsc2U6IEludmFsaWQgY29uZmlndXJhdGlvbiBjYXVzZXMgYW4gZXJyb3IuXCJcbiAgfSxcbiAgXCJkcmF3QXhpc1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwidHJ1ZSBmb3IgeCBhbmQgeSwgZmFsc2UgZm9yIHkyXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCIgOiBcIldoZXRoZXIgdG8gZHJhdyB0aGUgc3BlY2lmaWVkIGF4aXMuIFRoaXMgbWF5IGJlIHNldCBvbiBhIHBlci1heGlzIGJhc2lzIHRvIGRlZmluZSB0aGUgdmlzaWJpbGl0eSBvZiBlYWNoIGF4aXMgc2VwYXJhdGVseS4gU2V0dGluZyB0aGlzIHRvIGZhbHNlIGFsc28gcHJldmVudHMgYXhpcyB0aWNrcyBmcm9tIGJlaW5nIGRyYXduIGFuZCByZWNsYWltcyB0aGUgc3BhY2UgZm9yIHRoZSBjaGFydCBncmlkL2xpbmVzLlwiXG4gIH0sXG4gIFwiZ3JpZExpbmVXaWR0aFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMC4zXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiR3JpZFwiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIiA6IFwiVGhpY2tuZXNzIChpbiBwaXhlbHMpIG9mIHRoZSBncmlkbGluZXMgZHJhd24gdW5kZXIgdGhlIGNoYXJ0LiBUaGUgdmVydGljYWwvaG9yaXpvbnRhbCBncmlkbGluZXMgY2FuIGJlIHR1cm5lZCBvZmYgZW50aXJlbHkgYnkgdXNpbmcgdGhlIGRyYXdHcmlkIG9wdGlvbi4gVGhpcyBtYXkgYmUgc2V0IG9uIGEgcGVyLWF4aXMgYmFzaXMgdG8gZGVmaW5lIGVhY2ggYXhpcycgZ3JpZCBzZXBhcmF0ZWx5LlwiXG4gIH0sXG4gIFwiYXhpc0xpbmVXaWR0aFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMC4zXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiIDogXCJUaGlja25lc3MgKGluIHBpeGVscykgb2YgdGhlIHgtIGFuZCB5LWF4aXMgbGluZXMuXCJcbiAgfSxcbiAgXCJheGlzTGluZUNvbG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJibGFja1wiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCIgOiBcIkNvbG9yIG9mIHRoZSB4LSBhbmQgeS1heGlzIGxpbmVzLiBBY2NlcHRzIGFueSB2YWx1ZSB3aGljaCB0aGUgSFRNTCBjYW52YXMgc3Ryb2tlU3R5bGUgYXR0cmlidXRlIHVuZGVyc3RhbmRzLCBlLmcuICdibGFjaycgb3IgJ3JnYigwLCAxMDAsIDI1NSknLlwiXG4gIH0sXG4gIFwiZmlsbEFscGhhXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIwLjE1XCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRXJyb3IgQmFyc1wiLCBcIkRhdGEgU2VyaWVzIENvbG9yc1wiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdCAoMC4wIC0gMS4wKVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIiA6IFwiRXJyb3IgYmFycyAob3IgY3VzdG9tIGJhcnMpIGZvciBlYWNoIHNlcmllcyBhcmUgZHJhd24gaW4gdGhlIHNhbWUgY29sb3IgYXMgdGhlIHNlcmllcywgYnV0IHdpdGggcGFydGlhbCB0cmFuc3BhcmVuY3kuIFRoaXMgc2V0cyB0aGUgdHJhbnNwYXJlbmN5LiBBIHZhbHVlIG9mIDAuMCBtZWFucyB0aGF0IHRoZSBlcnJvciBiYXJzIHdpbGwgbm90IGJlIGRyYXduLCB3aGVyZWFzIGEgdmFsdWUgb2YgMS4wIG1lYW5zIHRoYXQgdGhlIGVycm9yIGJhcnMgd2lsbCBiZSBhcyBkYXJrIGFzIHRoZSBsaW5lIGZvciB0aGUgc2VyaWVzIGl0c2VsZi4gVGhpcyBjYW4gYmUgdXNlZCB0byBwcm9kdWNlIGNoYXJ0IGxpbmVzIHdob3NlIHRoaWNrbmVzcyB2YXJpZXMgYXQgZWFjaCBwb2ludC5cIlxuICB9LFxuICBcImF4aXNMYWJlbFdpZHRoXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCI1MCAoeS1heGlzKSwgNjAgKHgtYXhpcylcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIiwgXCJDaGFydCBsYWJlbHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIiA6IFwiV2lkdGggKGluIHBpeGVscykgb2YgdGhlIGNvbnRhaW5pbmcgZGl2cyBmb3IgeC0gYW5kIHktYXhpcyBsYWJlbHMuIEZvciB0aGUgeS1heGlzLCB0aGlzIGFsc28gY29udHJvbHMgdGhlIHdpZHRoIG9mIHRoZSB5LWF4aXMuIE5vdGUgdGhhdCBmb3IgdGhlIHgtYXhpcywgdGhpcyBpcyBpbmRlcGVuZGVudCBmcm9tIHBpeGVsc1BlckxhYmVsLCB3aGljaCBjb250cm9scyB0aGUgc3BhY2luZyBiZXR3ZWVuIGxhYmVscy5cIlxuICB9LFxuICBcInNpZ0ZpZ3NcIiA6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiVmFsdWUgZGlzcGxheS9mb3JtYXR0aW5nXCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQnkgZGVmYXVsdCwgZHlncmFwaHMgZGlzcGxheXMgbnVtYmVycyB3aXRoIGEgZml4ZWQgbnVtYmVyIG9mIGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gSWYgeW91J2QgcHJlZmVyIHRvIGhhdmUgYSBmaXhlZCBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZmlndXJlcywgc2V0IHRoaXMgb3B0aW9uIHRvIHRoYXQgbnVtYmVyIG9mIHNpZyBmaWdzLiBBIHZhbHVlIG9mIDIsIGZvciBpbnN0YW5jZSwgd291bGQgY2F1c2UgMSB0byBiZSBkaXNwbGF5IGFzIDEuMCBhbmQgMTIzNCB0byBiZSBkaXNwbGF5ZWQgYXMgMS4yM2UrMy5cIlxuICB9LFxuICBcImRpZ2l0c0FmdGVyRGVjaW1hbFwiIDoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjJcIixcbiAgICBcImxhYmVsc1wiOiBbXCJWYWx1ZSBkaXNwbGF5L2Zvcm1hdHRpbmdcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJVbmxlc3MgaXQncyBydW4gaW4gc2NpZW50aWZpYyBtb2RlIChzZWUgdGhlIDxjb2RlPnNpZ0ZpZ3M8L2NvZGU+IG9wdGlvbiksIGR5Z3JhcGhzIGRpc3BsYXlzIG51bWJlcnMgd2l0aCA8Y29kZT5kaWdpdHNBZnRlckRlY2ltYWw8L2NvZGU+IGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gVHJhaWxpbmcgemVyb3MgYXJlIG5vdCBkaXNwbGF5ZWQsIHNvIHdpdGggYSB2YWx1ZSBvZiAyIHlvdSdsbCBnZXQgJzAnLCAnMC4xJywgJzAuMTInLCAnMTIzLjQ1JyBidXQgbm90ICcxMjMuNDU2JyAoaXQgd2lsbCBiZSByb3VuZGVkIHRvICcxMjMuNDYnKS4gTnVtYmVycyB3aXRoIGFic29sdXRlIHZhbHVlIGxlc3MgdGhhbiAwLjFeZGlnaXRzQWZ0ZXJEZWNpbWFsIChpLmUuIHRob3NlIHdoaWNoIHdvdWxkIHNob3cgdXAgYXMgJzAuMDAnKSB3aWxsIGJlIGRpc3BsYXllZCBpbiBzY2llbnRpZmljIG5vdGF0aW9uLlwiXG4gIH0sXG4gIFwibWF4TnVtYmVyV2lkdGhcIiA6IHtcbiAgICBcImRlZmF1bHRcIjogXCI2XCIsXG4gICAgXCJsYWJlbHNcIjogW1wiVmFsdWUgZGlzcGxheS9mb3JtYXR0aW5nXCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hlbiBkaXNwbGF5aW5nIG51bWJlcnMgaW4gbm9ybWFsIChub3Qgc2NpZW50aWZpYykgbW9kZSwgbGFyZ2UgbnVtYmVycyB3aWxsIGJlIGRpc3BsYXllZCB3aXRoIG1hbnkgdHJhaWxpbmcgemVyb3MgKGUuZy4gMTAwMDAwMDAwIGluc3RlYWQgb2YgMWU5KS4gVGhpcyBjYW4gbGVhZCB0byB1bndpZWxkeSB5LWF4aXMgbGFiZWxzLiBJZiB0aGVyZSBhcmUgbW9yZSB0aGFuIDxjb2RlPm1heE51bWJlcldpZHRoPC9jb2RlPiBkaWdpdHMgdG8gdGhlIGxlZnQgb2YgdGhlIGRlY2ltYWwgaW4gYSBudW1iZXIsIGR5Z3JhcGhzIHdpbGwgc3dpdGNoIHRvIHNjaWVudGlmaWMgbm90YXRpb24sIGV2ZW4gd2hlbiBub3Qgb3BlcmF0aW5nIGluIHNjaWVudGlmaWMgbW9kZS4gSWYgeW91J2QgbGlrZSB0byBzZWUgYWxsIHRob3NlIGRpZ2l0cywgc2V0IHRoaXMgdG8gc29tZXRoaW5nIGxhcmdlLCBsaWtlIDIwIG9yIDMwLlwiXG4gIH0sXG4gIFwiZmlsZVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiKHNldCB3aGVuIGNvbnN0cnVjdGVkKVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGFcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nIChVUkwgb2YgQ1NWIG9yIENTViksIEdWaXogRGF0YVRhYmxlIG9yIDJEIEFycmF5XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlNldHMgdGhlIGRhdGEgYmVpbmcgZGlzcGxheWVkIGluIHRoZSBjaGFydC4gVGhpcyBjYW4gb25seSBiZSBzZXQgd2hlbiBjYWxsaW5nIHVwZGF0ZU9wdGlvbnM7IGl0IGNhbm5vdCBiZSBzZXQgZnJvbSB0aGUgY29uc3RydWN0b3IuIEZvciBhIGZ1bGwgZGVzY3JpcHRpb24gb2YgdmFsaWQgZGF0YSBmb3JtYXRzLCBzZWUgdGhlIDxhIGhyZWY9J2h0dHA6Ly9keWdyYXBocy5jb20vZGF0YS5odG1sJz5EYXRhIEZvcm1hdHM8L2E+IHBhZ2UuXCJcbiAgfSxcbiAgXCJ0aW1pbmdOYW1lXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogWyBcIkRlYnVnZ2luZ1wiLCBcIkRlcHJlY2F0ZWRcIiBdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTZXQgdGhpcyBvcHRpb24gdG8gbG9nIHRpbWluZyBpbmZvcm1hdGlvbi4gVGhlIHZhbHVlIG9mIHRoZSBvcHRpb24gd2lsbCBiZSBsb2dnZWQgYWxvbmcgd2l0aCB0aGUgdGltaW1nLCBzbyB0aGF0IHlvdSBjYW4gZGlzdGluZ3Vpc2ggbXVsdGlwbGUgZHlncmFwaHMgb24gdGhlIHNhbWUgcGFnZS5cIlxuICB9LFxuICBcInNob3dSYW5nZVNlbGVjdG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2hvdyBvciBoaWRlIHRoZSByYW5nZSBzZWxlY3RvciB3aWRnZXQuXCJcbiAgfSxcbiAgXCJyYW5nZVNlbGVjdG9ySGVpZ2h0XCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCI0MFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSGVpZ2h0LCBpbiBwaXhlbHMsIG9mIHRoZSByYW5nZSBzZWxlY3RvciB3aWRnZXQuIFRoaXMgb3B0aW9uIGNhbiBvbmx5IGJlIHNwZWNpZmllZCBhdCBEeWdyYXBoIGNyZWF0aW9uIHRpbWUuXCJcbiAgfSxcbiAgXCJyYW5nZVNlbGVjdG9yUGxvdFN0cm9rZUNvbG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIjODA4RkFCXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiUmFuZ2UgU2VsZWN0b3JcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSByYW5nZSBzZWxlY3RvciBtaW5pIHBsb3Qgc3Ryb2tlIGNvbG9yLiBUaGlzIGNhbiBiZSBvZiB0aGUgZm9ybSBcXFwiI0FBQkJDQ1xcXCIgb3IgXFxcInJnYigyNTUsMTAwLDIwMClcXFwiIG9yIFxcXCJ5ZWxsb3dcXFwiLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBudWxsIG9yIFxcXCJcXFwiIHRvIHR1cm4gb2ZmIHN0cm9rZS5cIlxuICB9LFxuICBcInJhbmdlU2VsZWN0b3JQbG90RmlsbENvbG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIjQTdCMUM0XCIsXG4gICAgXCJsYWJlbHNcIjogW1wiUmFuZ2UgU2VsZWN0b3JcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSByYW5nZSBzZWxlY3RvciBtaW5pIHBsb3QgZmlsbCBjb2xvci4gVGhpcyBjYW4gYmUgb2YgdGhlIGZvcm0gXFxcIiNBQUJCQ0NcXFwiIG9yIFxcXCJyZ2IoMjU1LDEwMCwyMDApXFxcIiBvciBcXFwieWVsbG93XFxcIi4gWW91IGNhbiBhbHNvIHNwZWNpZnkgbnVsbCBvciBcXFwiXFxcIiB0byB0dXJuIG9mZiBmaWxsLlwiXG4gIH0sXG4gIFwicmFuZ2VTZWxlY3RvclBsb3RGaWxsR3JhZGllbnRDb2xvclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwid2hpdGVcIixcbiAgICBcImxhYmVsc1wiOiBbXCJSYW5nZSBTZWxlY3RvclwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHRvcCBjb2xvciBmb3IgdGhlIHJhbmdlIHNlbGVjdG9yIG1pbmkgcGxvdCBmaWxsIGNvbG9yIGdyYWRpZW50LiBUaGlzIGNhbiBiZSBvZiB0aGUgZm9ybSBcXFwiI0FBQkJDQ1xcXCIgb3IgXFxcInJnYigyNTUsMTAwLDIwMClcXFwiIG9yIFxcXCJyZ2JhKDI1NSwxMDAsMjAwLDQyKVxcXCIgb3IgXFxcInllbGxvd1xcXCIuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IG51bGwgb3IgXFxcIlxcXCIgdG8gZGlzYWJsZSB0aGUgZ3JhZGllbnQgYW5kIGZpbGwgd2l0aCBvbmUgc2luZ2xlIGNvbG9yLlwiXG4gIH0sXG4gIFwicmFuZ2VTZWxlY3RvckJhY2tncm91bmRTdHJva2VDb2xvclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZ3JheVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgY29sb3Igb2YgdGhlIGxpbmVzIGJlbG93IGFuZCBvbiBib3RoIHNpZGVzIG9mIHRoZSByYW5nZSBzZWxlY3RvciBtaW5pIHBsb3QuIFRoaXMgY2FuIGJlIG9mIHRoZSBmb3JtIFxcXCIjQUFCQkNDXFxcIiBvciBcXFwicmdiKDI1NSwxMDAsMjAwKVxcXCIgb3IgXFxcInllbGxvd1xcXCIuXCJcbiAgfSxcbiAgXCJyYW5nZVNlbGVjdG9yQmFja2dyb3VuZExpbmVXaWR0aFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSB3aWR0aCBvZiB0aGUgbGluZXMgYmVsb3cgYW5kIG9uIGJvdGggc2lkZXMgb2YgdGhlIHJhbmdlIHNlbGVjdG9yIG1pbmkgcGxvdC5cIlxuICB9LFxuICBcInJhbmdlU2VsZWN0b3JQbG90TGluZVdpZHRoXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIxLjVcIixcbiAgICBcImxhYmVsc1wiOiBbXCJSYW5nZSBTZWxlY3RvclwiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgd2lkdGggb2YgdGhlIHJhbmdlIHNlbGVjdG9yIG1pbmkgcGxvdCBsaW5lLlwiXG4gIH0sXG4gIFwicmFuZ2VTZWxlY3RvckZvcmVncm91bmRTdHJva2VDb2xvclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiYmxhY2tcIixcbiAgICBcImxhYmVsc1wiOiBbXCJSYW5nZSBTZWxlY3RvclwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBsaW5lcyBpbiB0aGUgaW50ZXJhY3RpdmUgbGF5ZXIgb2YgdGhlIHJhbmdlIHNlbGVjdG9yLiBUaGlzIGNhbiBiZSBvZiB0aGUgZm9ybSBcXFwiI0FBQkJDQ1xcXCIgb3IgXFxcInJnYigyNTUsMTAwLDIwMClcXFwiIG9yIFxcXCJ5ZWxsb3dcXFwiLlwiXG4gIH0sXG4gIFwicmFuZ2VTZWxlY3RvckZvcmVncm91bmRMaW5lV2lkdGhcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjFcIixcbiAgICBcImxhYmVsc1wiOiBbXCJSYW5nZSBTZWxlY3RvclwiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgd2lkdGggdGhlIGxpbmVzIGluIHRoZSBpbnRlcmFjdGl2ZSBsYXllciBvZiB0aGUgcmFuZ2Ugc2VsZWN0b3IuXCJcbiAgfSxcbiAgXCJyYW5nZVNlbGVjdG9yQWxwaGFcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjAuNlwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0ICgwLjAgLSAxLjApXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSB0cmFuc3BhcmVuY3kgb2YgdGhlIHZlaWwgdGhhdCBpcyBkcmF3biBvdmVyIHRoZSB1bnNlbGVjdGVkIHBvcnRpb25zIG9mIHRoZSByYW5nZSBzZWxlY3RvciBtaW5pIHBsb3QuIEEgdmFsdWUgb2YgMCByZXByZXNlbnRzIGZ1bGwgdHJhbnNwYXJlbmN5IGFuZCB0aGUgdW5zZWxlY3RlZCBwb3J0aW9ucyBvZiB0aGUgbWluaSBwbG90IHdpbGwgYXBwZWFyIGFzIG5vcm1hbC4gQSB2YWx1ZSBvZiAxIHJlcHJlc2VudHMgZnVsbCBvcGFjaXR5IGFuZCB0aGUgdW5zZWxlY3RlZCBwb3J0aW9ucyBvZiB0aGUgbWluaSBwbG90IHdpbGwgYmUgaGlkZGVuLlwiXG4gIH0sXG4gIFwic2hvd0luUmFuZ2VTZWxlY3RvclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTWFyayB0aGlzIHNlcmllcyBmb3IgaW5jbHVzaW9uIGluIHRoZSByYW5nZSBzZWxlY3Rvci4gVGhlIG1pbmkgcGxvdCBjdXJ2ZSB3aWxsIGJlIGFuIGF2ZXJhZ2Ugb2YgYWxsIHN1Y2ggc2VyaWVzLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgZm9yIGFueSBzZXJpZXMsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGF2ZXJhZ2UgYWxsIHRoZSB2aXNpYmxlIHNlcmllcy4gU2V0dGluZyBpdCBmb3Igb25lIHNlcmllcyB3aWxsIHJlc3VsdCBpbiB0aGF0IHNlcmllcyBiZWluZyBjaGFydGVkIGFsb25lIGluIHRoZSByYW5nZSBzZWxlY3Rvci4gT25jZSBpdCdzIHNldCBmb3IgYSBzaW5nbGUgc2VyaWVzLCBpdCBuZWVkcyB0byBiZSBzZXQgZm9yIGFsbCBzZXJpZXMgd2hpY2ggc2hvdWxkIGJlIGluY2x1ZGVkIChyZWdhcmRsZXNzIG9mIHZpc2liaWxpdHkpLlwiXG4gIH0sXG4gIFwiYW5pbWF0ZWRab29tc1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJJbnRlcmFjdGl2ZSBFbGVtZW50c1wiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlNldCB0aGlzIG9wdGlvbiB0byBhbmltYXRlIHRoZSB0cmFuc2l0aW9uIGJldHdlZW4gem9vbSB3aW5kb3dzLiBBcHBsaWVzIHRvIHByb2dyYW1tYXRpYyBhbmQgaW50ZXJhY3RpdmUgem9vbXMuIE5vdGUgdGhhdCBpZiB5b3UgYWxzbyBzZXQgYSBkcmF3Q2FsbGJhY2ssIGl0IHdpbGwgYmUgY2FsbGVkIHNldmVyYWwgdGltZXMgb24gZWFjaCB6b29tLiBJZiB5b3Ugc2V0IGEgem9vbUNhbGxiYWNrLCBpdCB3aWxsIG9ubHkgYmUgY2FsbGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGUuXCJcbiAgfSxcbiAgXCJwbG90dGVyXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJbRHlncmFwaENhbnZhc1JlbmRlcmVyLlBsb3R0ZXJzLmZpbGxQbG90dGVyLCBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuUGxvdHRlcnMuZXJyb3JQbG90dGVyLCBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuUGxvdHRlcnMubGluZVBsb3R0ZXJdXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYXJyYXkgb3IgZnVuY3Rpb25cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBmdW5jdGlvbiAob3IgYXJyYXkgb2YgZnVuY3Rpb25zKSB3aGljaCBwbG90IGVhY2ggZGF0YSBzZXJpZXMgb24gdGhlIGNoYXJ0LiBUT0RPKGRhbnZrKTogbW9yZSBkZXRhaWxzISBNYXkgYmUgc2V0IHBlci1zZXJpZXMuXCJcbiAgfSxcbiAgXCJheGVzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ29uZmlndXJhdGlvblwiXSxcbiAgICBcInR5cGVcIjogXCJPYmplY3RcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRGVmaW5lcyBwZXItYXhpcyBvcHRpb25zLiBWYWxpZCBrZXlzIGFyZSAneCcsICd5JyBhbmQgJ3kyJy4gT25seSBzb21lIG9wdGlvbnMgbWF5IGJlIHNldCBvbiBhIHBlci1heGlzIGJhc2lzLiBJZiBhbiBvcHRpb24gbWF5IGJlIHNldCBpbiB0aGlzIHdheSwgaXQgd2lsbCBiZSBub3RlZCBvbiB0aGlzIHBhZ2UuIFNlZSBhbHNvIGRvY3VtZW50YXRpb24gb24gPGEgaHJlZj0naHR0cDovL2R5Z3JhcGhzLmNvbS9wZXItYXhpcy5odG1sJz5wZXItc2VyaWVzIGFuZCBwZXItYXhpcyBvcHRpb25zPC9hPi5cIlxuICB9LFxuICBcInNlcmllc1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlNlcmllc1wiXSxcbiAgICBcInR5cGVcIjogXCJPYmplY3RcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRGVmaW5lcyBwZXItc2VyaWVzIG9wdGlvbnMuIEl0cyBrZXlzIG1hdGNoIHRoZSB5LWF4aXMgbGFiZWwgbmFtZXMsIGFuZCB0aGUgdmFsdWVzIGFyZSBkaWN0aW9uYXJpZXMgdGhlbXNlbHZlcyB0aGF0IGNvbnRhaW4gb3B0aW9ucyBzcGVjaWZpYyB0byB0aGF0IHNlcmllcy5cIlxuICB9LFxuICBcInBsdWdpbnNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIltdXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ29uZmlndXJhdGlvblwiXSxcbiAgICBcInR5cGVcIjogXCJBcnJheTxwbHVnaW4+XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkRlZmluZXMgcGVyLWdyYXBoIHBsdWdpbnMuIFVzZWZ1bCBmb3IgcGVyLWdyYXBoIGN1c3RvbWl6YXRpb25cIlxuICB9LFxuICBcImRhdGFIYW5kbGVyXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIoZGVwZW5kcyBvbiBkYXRhKVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGFcIl0sXG4gICAgXCJ0eXBlXCI6IFwiRHlncmFwaC5EYXRhSGFuZGxlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJDdXN0b20gRGF0YUhhbmRsZXIuIFRoaXMgaXMgYW4gYWR2YW5jZWQgY3VzdG9taXphdGlvbi4gU2VlIGh0dHA6Ly9iaXQubHkvMTUxRTdBcS5cIlxuICB9XG59XG47ICAvLyA8L0pTT04+XG4vLyBOT1RFOiBpbiBhZGRpdGlvbiB0byBwYXJzaW5nIGFzIEpTLCB0aGlzIHNuaXBwZXQgaXMgZXhwZWN0ZWQgdG8gYmUgdmFsaWRcbi8vIEpTT04uIFRoaXMgYXNzdW1wdGlvbiBjYW5ub3QgYmUgY2hlY2tlZCBpbiBKUywgYnV0IGl0IHdpbGwgYmUgY2hlY2tlZCB3aGVuXG4vLyBkb2N1bWVudGF0aW9uIGlzIGdlbmVyYXRlZCBieSB0aGUgZ2VuZXJhdGUtZG9jdW1lbnRhdGlvbi5weSBzY3JpcHQuIEZvciB0aGVcbi8vIG1vc3QgcGFydCwgdGhpcyBqdXN0IG1lYW5zIHRoYXQgeW91IHNob3VsZCBhbHdheXMgdXNlIGRvdWJsZSBxdW90ZXMuXG5cbi8vIERvIGEgcXVpY2sgc2FuaXR5IGNoZWNrIG9uIHRoZSBvcHRpb25zIHJlZmVyZW5jZS5cbnZhciB3YXJuID0gZnVuY3Rpb24obXNnKSB7IGlmICh3aW5kb3cuY29uc29sZSkgd2luZG93LmNvbnNvbGUud2Fybihtc2cpOyB9O1xudmFyIGZsZHMgPSBbJ3R5cGUnLCAnZGVmYXVsdCcsICdkZXNjcmlwdGlvbiddO1xudmFyIHZhbGlkX2NhdHMgPSBbXG4gJ0Fubm90YXRpb25zJyxcbiAnQXhpcyBkaXNwbGF5JyxcbiAnQ2hhcnQgbGFiZWxzJyxcbiAnQ1NWIHBhcnNpbmcnLFxuICdDYWxsYmFja3MnLFxuICdEYXRhJyxcbiAnRGF0YSBMaW5lIGRpc3BsYXknLFxuICdEYXRhIFNlcmllcyBDb2xvcnMnLFxuICdFcnJvciBCYXJzJyxcbiAnR3JpZCcsXG4gJ0ludGVyYWN0aXZlIEVsZW1lbnRzJyxcbiAnUmFuZ2UgU2VsZWN0b3InLFxuICdMZWdlbmQnLFxuICdPdmVyYWxsIGRpc3BsYXknLFxuICdSb2xsaW5nIEF2ZXJhZ2VzJyxcbiAnU2VyaWVzJyxcbiAnVmFsdWUgZGlzcGxheS9mb3JtYXR0aW5nJyxcbiAnWm9vbWluZycsXG4gJ0RlYnVnZ2luZycsXG4gJ0NvbmZpZ3VyYXRpb24nLFxuICdEZXByZWNhdGVkJ1xuXTtcbnZhciBpO1xudmFyIGNhdHMgPSB7fTtcbmZvciAoaSA9IDA7IGkgPCB2YWxpZF9jYXRzLmxlbmd0aDsgaSsrKSBjYXRzW3ZhbGlkX2NhdHNbaV1dID0gdHJ1ZTtcblxuZm9yICh2YXIgayBpbiBPUFRJT05TX1JFRkVSRU5DRSkge1xuICBpZiAoIU9QVElPTlNfUkVGRVJFTkNFLmhhc093blByb3BlcnR5KGspKSBjb250aW51ZTtcbiAgdmFyIG9wID0gT1BUSU9OU19SRUZFUkVOQ0Vba107XG4gIGZvciAoaSA9IDA7IGkgPCBmbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFvcC5oYXNPd25Qcm9wZXJ0eShmbGRzW2ldKSkge1xuICAgICAgd2FybignT3B0aW9uICcgKyBrICsgJyBtaXNzaW5nIFwiJyArIGZsZHNbaV0gKyAnXCIgcHJvcGVydHknKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZihvcFtmbGRzW2ldXSkgIT0gJ3N0cmluZycpIHtcbiAgICAgIHdhcm4oayArICcuJyArIGZsZHNbaV0gKyAnIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcnKTtcbiAgICB9XG4gIH1cbiAgdmFyIGxhYmVscyA9IG9wLmxhYmVscztcbiAgaWYgKHR5cGVvZihsYWJlbHMpICE9PSAnb2JqZWN0Jykge1xuICAgIHdhcm4oJ09wdGlvbiBcIicgKyBrICsgJ1wiIGlzIG1pc3NpbmcgYSBcImxhYmVsc1wiOiBbLi4uXSBvcHRpb24nKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWNhdHMuaGFzT3duUHJvcGVydHkobGFiZWxzW2ldKSkge1xuICAgICAgICB3YXJuKCdPcHRpb24gXCInICsgayArICdcIiBoYXMgbGFiZWwgXCInICsgbGFiZWxzW2ldICtcbiAgICAgICAgICAgICAnXCIsIHdoaWNoIGlzIGludmFsaWQuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbn1cbn1cblxuZXhwb3J0IGRlZmF1bHQgT1BUSU9OU19SRUZFUkVOQ0U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLW9wdGlvbnMtcmVmZXJlbmNlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__ = __webpack_require__(0);\n/**\n * To create a \"drag\" interaction, you typically register a mousedown event\n * handler on the element where the drag begins. In that handler, you register a\n * mouseup handler on the window to determine when the mouse is released,\n * wherever that release happens. This works well, except when the user releases\n * the mouse over an off-domain iframe. In that case, the mouseup event is\n * handled by the iframe and never bubbles up to the window handler.\n *\n * To deal with this issue, we cover iframes with high z-index divs to make sure\n * they don't capture mouseup.\n *\n * Usage:\n * element.addEventListener('mousedown', function() {\n *   var tarper = new IFrameTarp();\n *   tarper.cover();\n *   var mouseUpHandler = function() {\n *     ...\n *     window.removeEventListener(mouseUpHandler);\n *     tarper.uncover();\n *   };\n *   window.addEventListener('mouseup', mouseUpHandler);\n * };\n *\n * @constructor\n */\n\n\nfunction IFrameTarp() {\n  /** @type {Array.<!HTMLDivElement>} */\n  this.tarps = [];\n};\n\n/**\n * Find all the iframes in the document and cover them with high z-index\n * transparent divs.\n */\nIFrameTarp.prototype.cover = function () {\n  var iframes = document.getElementsByTagName(\"iframe\");\n  for (var i = 0; i < iframes.length; i++) {\n    var iframe = iframes[i];\n    var pos = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"k\" /* findPos */](iframe),\n        x = pos.x,\n        y = pos.y,\n        width = iframe.offsetWidth,\n        height = iframe.offsetHeight;\n\n    var div = document.createElement(\"div\");\n    div.style.position = \"absolute\";\n    div.style.left = x + 'px';\n    div.style.top = y + 'px';\n    div.style.width = width + 'px';\n    div.style.height = height + 'px';\n    div.style.zIndex = 999;\n    document.body.appendChild(div);\n    this.tarps.push(div);\n  }\n};\n\n/**\n * Remove all the iframe covers. You should call this in a mouseup handler.\n */\nIFrameTarp.prototype.uncover = function () {\n  for (var i = 0; i < this.tarps.length; i++) {\n    this.tarps[i].parentNode.removeChild(this.tarps[i]);\n  }\n  this.tarps = [];\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (IFrameTarp);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9pZnJhbWUtdGFycC5qcz8xODQzIl0sIm5hbWVzIjpbIklGcmFtZVRhcnAiLCJ0YXJwcyIsInByb3RvdHlwZSIsImNvdmVyIiwiaWZyYW1lcyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpIiwibGVuZ3RoIiwiaWZyYW1lIiwicG9zIiwieCIsInkiLCJ3aWR0aCIsIm9mZnNldFdpZHRoIiwiaGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwiZGl2IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwicG9zaXRpb24iLCJsZWZ0IiwidG9wIiwiekluZGV4IiwiYm9keSIsImFwcGVuZENoaWxkIiwicHVzaCIsInVuY292ZXIiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7O0FBRUEsU0FBU0EsVUFBVCxHQUFzQjtBQUNwQjtBQUNBLE9BQUtDLEtBQUwsR0FBYSxFQUFiO0FBQ0Q7O0FBRUQ7Ozs7QUFJQUQsV0FBV0UsU0FBWCxDQUFxQkMsS0FBckIsR0FBNkIsWUFBVztBQUN0QyxNQUFJQyxVQUFVQyxTQUFTQyxvQkFBVCxDQUE4QixRQUE5QixDQUFkO0FBQ0EsT0FBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlILFFBQVFJLE1BQTVCLEVBQW9DRCxHQUFwQyxFQUF5QztBQUN2QyxRQUFJRSxTQUFTTCxRQUFRRyxDQUFSLENBQWI7QUFDQSxRQUFJRyxNQUFNLGdFQUFjRCxNQUFkLENBQVY7QUFBQSxRQUNJRSxJQUFJRCxJQUFJQyxDQURaO0FBQUEsUUFFSUMsSUFBSUYsSUFBSUUsQ0FGWjtBQUFBLFFBR0lDLFFBQVFKLE9BQU9LLFdBSG5CO0FBQUEsUUFJSUMsU0FBU04sT0FBT08sWUFKcEI7O0FBTUEsUUFBSUMsTUFBTVosU0FBU2EsYUFBVCxDQUF1QixLQUF2QixDQUFWO0FBQ0FELFFBQUlFLEtBQUosQ0FBVUMsUUFBVixHQUFxQixVQUFyQjtBQUNBSCxRQUFJRSxLQUFKLENBQVVFLElBQVYsR0FBaUJWLElBQUksSUFBckI7QUFDQU0sUUFBSUUsS0FBSixDQUFVRyxHQUFWLEdBQWdCVixJQUFJLElBQXBCO0FBQ0FLLFFBQUlFLEtBQUosQ0FBVU4sS0FBVixHQUFrQkEsUUFBUSxJQUExQjtBQUNBSSxRQUFJRSxLQUFKLENBQVVKLE1BQVYsR0FBbUJBLFNBQVMsSUFBNUI7QUFDQUUsUUFBSUUsS0FBSixDQUFVSSxNQUFWLEdBQW1CLEdBQW5CO0FBQ0FsQixhQUFTbUIsSUFBVCxDQUFjQyxXQUFkLENBQTBCUixHQUExQjtBQUNBLFNBQUtoQixLQUFMLENBQVd5QixJQUFYLENBQWdCVCxHQUFoQjtBQUNEO0FBQ0YsQ0FwQkQ7O0FBc0JBOzs7QUFHQWpCLFdBQVdFLFNBQVgsQ0FBcUJ5QixPQUFyQixHQUErQixZQUFXO0FBQ3hDLE9BQUssSUFBSXBCLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLTixLQUFMLENBQVdPLE1BQS9CLEVBQXVDRCxHQUF2QyxFQUE0QztBQUMxQyxTQUFLTixLQUFMLENBQVdNLENBQVgsRUFBY3FCLFVBQWQsQ0FBeUJDLFdBQXpCLENBQXFDLEtBQUs1QixLQUFMLENBQVdNLENBQVgsQ0FBckM7QUFDRDtBQUNELE9BQUtOLEtBQUwsR0FBYSxFQUFiO0FBQ0QsQ0FMRDs7QUFPQSx5REFBZUQsVUFBZiIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVG8gY3JlYXRlIGEgXCJkcmFnXCIgaW50ZXJhY3Rpb24sIHlvdSB0eXBpY2FsbHkgcmVnaXN0ZXIgYSBtb3VzZWRvd24gZXZlbnRcbiAqIGhhbmRsZXIgb24gdGhlIGVsZW1lbnQgd2hlcmUgdGhlIGRyYWcgYmVnaW5zLiBJbiB0aGF0IGhhbmRsZXIsIHlvdSByZWdpc3RlciBhXG4gKiBtb3VzZXVwIGhhbmRsZXIgb24gdGhlIHdpbmRvdyB0byBkZXRlcm1pbmUgd2hlbiB0aGUgbW91c2UgaXMgcmVsZWFzZWQsXG4gKiB3aGVyZXZlciB0aGF0IHJlbGVhc2UgaGFwcGVucy4gVGhpcyB3b3JrcyB3ZWxsLCBleGNlcHQgd2hlbiB0aGUgdXNlciByZWxlYXNlc1xuICogdGhlIG1vdXNlIG92ZXIgYW4gb2ZmLWRvbWFpbiBpZnJhbWUuIEluIHRoYXQgY2FzZSwgdGhlIG1vdXNldXAgZXZlbnQgaXNcbiAqIGhhbmRsZWQgYnkgdGhlIGlmcmFtZSBhbmQgbmV2ZXIgYnViYmxlcyB1cCB0byB0aGUgd2luZG93IGhhbmRsZXIuXG4gKlxuICogVG8gZGVhbCB3aXRoIHRoaXMgaXNzdWUsIHdlIGNvdmVyIGlmcmFtZXMgd2l0aCBoaWdoIHotaW5kZXggZGl2cyB0byBtYWtlIHN1cmVcbiAqIHRoZXkgZG9uJ3QgY2FwdHVyZSBtb3VzZXVwLlxuICpcbiAqIFVzYWdlOlxuICogZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbigpIHtcbiAqICAgdmFyIHRhcnBlciA9IG5ldyBJRnJhbWVUYXJwKCk7XG4gKiAgIHRhcnBlci5jb3ZlcigpO1xuICogICB2YXIgbW91c2VVcEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAqICAgICAuLi5cbiAqICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihtb3VzZVVwSGFuZGxlcik7XG4gKiAgICAgdGFycGVyLnVuY292ZXIoKTtcbiAqICAgfTtcbiAqICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZVVwSGFuZGxlcik7XG4gKiB9O1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2R5Z3JhcGgtdXRpbHMnO1xuXG5mdW5jdGlvbiBJRnJhbWVUYXJwKCkge1xuICAvKiogQHR5cGUge0FycmF5LjwhSFRNTERpdkVsZW1lbnQ+fSAqL1xuICB0aGlzLnRhcnBzID0gW107XG59O1xuXG4vKipcbiAqIEZpbmQgYWxsIHRoZSBpZnJhbWVzIGluIHRoZSBkb2N1bWVudCBhbmQgY292ZXIgdGhlbSB3aXRoIGhpZ2ggei1pbmRleFxuICogdHJhbnNwYXJlbnQgZGl2cy5cbiAqL1xuSUZyYW1lVGFycC5wcm90b3R5cGUuY292ZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlmcmFtZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlmcmFtZVwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlmcmFtZSA9IGlmcmFtZXNbaV07XG4gICAgdmFyIHBvcyA9IHV0aWxzLmZpbmRQb3MoaWZyYW1lKSxcbiAgICAgICAgeCA9IHBvcy54LFxuICAgICAgICB5ID0gcG9zLnksXG4gICAgICAgIHdpZHRoID0gaWZyYW1lLm9mZnNldFdpZHRoLFxuICAgICAgICBoZWlnaHQgPSBpZnJhbWUub2Zmc2V0SGVpZ2h0O1xuXG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGRpdi5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgZGl2LnN0eWxlLnRvcCA9IHkgKyAncHgnO1xuICAgIGRpdi5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICBkaXYuc3R5bGUuekluZGV4ID0gOTk5O1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICB0aGlzLnRhcnBzLnB1c2goZGl2KTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIHRoZSBpZnJhbWUgY292ZXJzLiBZb3Ugc2hvdWxkIGNhbGwgdGhpcyBpbiBhIG1vdXNldXAgaGFuZGxlci5cbiAqL1xuSUZyYW1lVGFycC5wcm90b3R5cGUudW5jb3ZlciA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGFycHMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnRhcnBzW2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy50YXJwc1tpXSk7XG4gIH1cbiAgdGhpcy50YXJwcyA9IFtdO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSUZyYW1lVGFycDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZHlncmFwaHMvc3JjL2lmcmFtZS10YXJwLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOlsiZyIsIkZ1bmN0aW9uIiwiZXZhbCIsImUiLCJ3aW5kb3ciLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBLElBQUlBLENBQUo7O0FBRUE7QUFDQUEsSUFBSyxZQUFXO0FBQ2YsUUFBTyxJQUFQO0FBQ0EsQ0FGRyxFQUFKOztBQUlBLElBQUk7QUFDSDtBQUNBQSxLQUFJQSxLQUFLQyxTQUFTLGFBQVQsR0FBTCxJQUFrQyxDQUFDLEdBQUVDLElBQUgsRUFBUyxNQUFULENBQXRDO0FBQ0EsQ0FIRCxDQUdFLE9BQU1DLENBQU4sRUFBUztBQUNWO0FBQ0EsS0FBRyxRQUFPQyxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQXJCLEVBQ0NKLElBQUlJLE1BQUo7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUFDLE9BQU9DLE9BQVAsR0FBaUJOLENBQWpCIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Component = __webpack_require__(30)(\n  /* script */\n  __webpack_require__(29),\n  /* template */\n  null,\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = \"c:\\\\dev\\\\vue-dygraphs\\\\src\\\\components\\\\Dygraphs.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key !== \"__esModule\"})) {console.error(\"named exports are not supported in *.vue files.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-06a2a9a8\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-06a2a9a8\", Component.options)\n  }\n})()}\n\nmodule.exports = Component.exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9EeWdyYXBocy52dWU/YmRiMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGlEQUFpRCxJQUFJOztBQUVwSTtBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0R5Z3JhcGhzLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgbnVsbCxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiYzpcXFxcZGV2XFxcXHZ1ZS1keWdyYXBoc1xcXFxzcmNcXFxcY29tcG9uZW50c1xcXFxEeWdyYXBocy52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleSAhPT0gXCJfX2VzTW9kdWxlXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTA2YTJhOWE4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMDZhMmE5YThcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvRHlncmFwaHMudnVlXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bars__ = __webpack_require__(1);\n/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler implementation for the custom bars option.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * @constructor\n * @extends Dygraph.DataHandlers.BarsHandler\n */\nvar CustomBarsHandler = function CustomBarsHandler() {};\n\nCustomBarsHandler.prototype = new __WEBPACK_IMPORTED_MODULE_0__bars__[\"a\" /* default */]();\n\n/** @inheritDoc */\nCustomBarsHandler.prototype.extractSeries = function (rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var x, y, point;\n  var logScale = options.get('logscale');\n  for (var j = 0; j < rawData.length; j++) {\n    x = rawData[j][0];\n    point = rawData[j][i];\n    if (logScale && point !== null) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point[0] <= 0 || point[1] <= 0 || point[2] <= 0) {\n        point = null;\n      }\n    }\n    // Extract to the unified data format.\n    if (point !== null) {\n      y = point[1];\n      if (y !== null && !isNaN(y)) {\n        series.push([x, y, [point[0], point[2]]]);\n      } else {\n        series.push([x, y, [y, y]]);\n      }\n    } else {\n      series.push([x, null, [null, null]]);\n    }\n  }\n  return series;\n};\n\n/** @inheritDoc */\nCustomBarsHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n  var y, low, high, mid, count, i, extremes;\n\n  low = 0;\n  mid = 0;\n  high = 0;\n  count = 0;\n  for (i = 0; i < originalData.length; i++) {\n    y = originalData[i][1];\n    extremes = originalData[i][2];\n    rollingData[i] = originalData[i];\n\n    if (y !== null && !isNaN(y)) {\n      low += extremes[0];\n      mid += y;\n      high += extremes[1];\n      count += 1;\n    }\n    if (i - rollPeriod >= 0) {\n      var prev = originalData[i - rollPeriod];\n      if (prev[1] !== null && !isNaN(prev[1])) {\n        low -= prev[2][0];\n        mid -= prev[1];\n        high -= prev[2][1];\n        count -= 1;\n      }\n    }\n    if (count) {\n      rollingData[i] = [originalData[i][0], 1.0 * mid / count, [1.0 * low / count, 1.0 * high / count]];\n    } else {\n      rollingData[i] = [originalData[i][0], null, [null, null]];\n    }\n  }\n\n  return rollingData;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (CustomBarsHandler);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9iYXJzLWN1c3RvbS5qcz8wZDFmIl0sIm5hbWVzIjpbIkN1c3RvbUJhcnNIYW5kbGVyIiwicHJvdG90eXBlIiwiZXh0cmFjdFNlcmllcyIsInJhd0RhdGEiLCJpIiwib3B0aW9ucyIsInNlcmllcyIsIngiLCJ5IiwicG9pbnQiLCJsb2dTY2FsZSIsImdldCIsImoiLCJsZW5ndGgiLCJpc05hTiIsInB1c2giLCJyb2xsaW5nQXZlcmFnZSIsIm9yaWdpbmFsRGF0YSIsInJvbGxQZXJpb2QiLCJNYXRoIiwibWluIiwicm9sbGluZ0RhdGEiLCJsb3ciLCJoaWdoIiwibWlkIiwiY291bnQiLCJleHRyZW1lcyIsInByZXYiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Ozs7OztBQU1BOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQSxJQUFJQSxvQkFBb0IsU0FBcEJBLGlCQUFvQixHQUFXLENBQ2xDLENBREQ7O0FBR0FBLGtCQUFrQkMsU0FBbEIsR0FBOEIsSUFBSSxzREFBSixFQUE5Qjs7QUFFQTtBQUNBRCxrQkFBa0JDLFNBQWxCLENBQTRCQyxhQUE1QixHQUE0QyxVQUFTQyxPQUFULEVBQWtCQyxDQUFsQixFQUFxQkMsT0FBckIsRUFBOEI7QUFDeEU7QUFDQSxNQUFJQyxTQUFTLEVBQWI7QUFDQSxNQUFJQyxDQUFKLEVBQU9DLENBQVAsRUFBVUMsS0FBVjtBQUNBLE1BQUlDLFdBQVdMLFFBQVFNLEdBQVIsQ0FBWSxVQUFaLENBQWY7QUFDQSxPQUFNLElBQUlDLElBQUksQ0FBZCxFQUFpQkEsSUFBSVQsUUFBUVUsTUFBN0IsRUFBcUNELEdBQXJDLEVBQTBDO0FBQ3hDTCxRQUFJSixRQUFRUyxDQUFSLEVBQVcsQ0FBWCxDQUFKO0FBQ0FILFlBQVFOLFFBQVFTLENBQVIsRUFBV1IsQ0FBWCxDQUFSO0FBQ0EsUUFBSU0sWUFBWUQsVUFBVSxJQUExQixFQUFnQztBQUM5QjtBQUNBO0FB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RixFQUFRLElBQVIsQ0FBNUIsQ0FBakI7QUFDRDtBQUNGOztBQUVELFNBQU9pQixXQUFQO0FBQ0QsQ0ExQ0Q7O0FBNENBLHlEQUFlckIsaUJBQWYiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMyBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGF0YUhhbmRsZXIgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBjdXN0b20gYmFycyBvcHRpb24uXG4gKiBAYXV0aG9yIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgQmFyc0hhbmRsZXIgZnJvbSAnLi9iYXJzJztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIER5Z3JhcGguRGF0YUhhbmRsZXJzLkJhcnNIYW5kbGVyXG4gKi9cbnZhciBDdXN0b21CYXJzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xufTtcblxuQ3VzdG9tQmFyc0hhbmRsZXIucHJvdG90eXBlID0gbmV3IEJhcnNIYW5kbGVyKCk7XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuQ3VzdG9tQmFyc0hhbmRsZXIucHJvdG90eXBlLmV4dHJhY3RTZXJpZXMgPSBmdW5jdGlvbihyYXdEYXRhLCBpLCBvcHRpb25zKSB7XG4gIC8vIFRPRE8oZGFudmspOiBwcmUtYWxsb2NhdGUgc2VyaWVzIGhlcmUuXG4gIHZhciBzZXJpZXMgPSBbXTtcbiAgdmFyIHgsIHksIHBvaW50O1xuICB2YXIgbG9nU2NhbGUgPSBvcHRpb25zLmdldCgnbG9nc2NhbGUnKTtcbiAgZm9yICggdmFyIGogPSAwOyBqIDwgcmF3RGF0YS5sZW5ndGg7IGorKykge1xuICAgIHggPSByYXdEYXRhW2pdWzBdO1xuICAgIHBvaW50ID0gcmF3RGF0YVtqXVtpXTtcbiAgICBpZiAobG9nU2NhbGUgJiYgcG9pbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIE9uIHRoZSBsb2cgc2NhbGUsIHBvaW50cyBsZXNzIHRoYW4gemVybyBkbyBub3QgZXhpc3QuXG4gICAgICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgZ2FwIGluIHRoZSBjaGFydC5cbiAgICAgIGlmIChwb2ludFswXSA8PSAwIHx8IHBvaW50WzFdIDw9IDAgfHwgcG9pbnRbMl0gPD0gMCkge1xuICAgICAgICBwb2ludCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEV4dHJhY3QgdG8gdGhlIHVuaWZpZWQgZGF0YSBmb3JtYXQuXG4gICAgaWYgKHBvaW50ICE9PSBudWxsKSB7XG4gICAgICB5ID0gcG9pbnRbMV07XG4gICAgICBpZiAoeSAhPT0gbnVsbCAmJiAhaXNOYU4oeSkpIHtcbiAgICAgICAgc2VyaWVzLnB1c2goWyB4LCB5LCBbIHBvaW50WzBdLCBwb2ludFsyXSBdIF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWVzLnB1c2goWyB4LCB5LCBbIHksIHkgXSBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWVzLnB1c2goWyB4LCBudWxsLCBbIG51bGwsIG51bGwgXSBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmllcztcbn07XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuQ3VzdG9tQmFyc0hhbmRsZXIucHJvdG90eXBlLnJvbGxpbmdBdmVyYWdlID1cbiAgICBmdW5jdGlvbihvcmlnaW5hbERhdGEsIHJvbGxQZXJpb2QsIG9wdGlvbnMpIHtcbiAgcm9sbFBlcmlvZCA9IE1hdGgubWluKHJvbGxQZXJpb2QsIG9yaWdpbmFsRGF0YS5sZW5ndGgpO1xuICB2YXIgcm9sbGluZ0RhdGEgPSBbXTtcbiAgdmFyIHksIGxvdywgaGlnaCwgbWlkLGNvdW50LCBpLCBleHRyZW1lcztcblxuICBsb3cgPSAwO1xuICBtaWQgPSAwO1xuICBoaWdoID0gMDtcbiAgY291bnQgPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgb3JpZ2luYWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgeSA9IG9yaWdpbmFsRGF0YVtpXVsxXTtcbiAgICBleHRyZW1lcyA9IG9yaWdpbmFsRGF0YVtpXVsyXTtcbiAgICByb2xsaW5nRGF0YVtpXSA9IG9yaWdpbmFsRGF0YVtpXTtcblxuICAgIGlmICh5ICE9PSBudWxsICYmICFpc05hTih5KSkge1xuICAgICAgbG93ICs9IGV4dHJlbWVzWzBdO1xuICAgICAgbWlkICs9IHk7XG4gICAgICBoaWdoICs9IGV4dHJlbWVzWzFdO1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgaWYgKGkgLSByb2xsUGVyaW9kID49IDApIHtcbiAgICAgIHZhciBwcmV2ID0gb3JpZ2luYWxEYXRhW2kgLSByb2xsUGVyaW9kXTtcbiAgICAgIGlmIChwcmV2WzFdICE9PSBudWxsICYmICFpc05hTihwcmV2WzFdKSkge1xuICAgICAgICBsb3cgLT0gcHJldlsyXVswXTtcbiAgICAgICAgbWlkIC09IHByZXZbMV07XG4gICAgICAgIGhpZ2ggLT0gcHJldlsyXVsxXTtcbiAgICAgICAgY291bnQgLT0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICByb2xsaW5nRGF0YVtpXSA9IFtcbiAgICAgICAgICBvcmlnaW5hbERhdGFbaV1bMF0sXG4gICAgICAgICAgMS4wICogbWlkIC8gY291bnQsIFxuICAgICAgICAgIFsgMS4wICogbG93IC8gY291bnQsXG4gICAgICAgICAgICAxLjAgKiBoaWdoIC8gY291bnQgXSBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByb2xsaW5nRGF0YVtpXSA9IFsgb3JpZ2luYWxEYXRhW2ldWzBdLCBudWxsLCBbIG51bGwsIG51bGwgXSBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb2xsaW5nRGF0YTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEN1c3RvbUJhcnNIYW5kbGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9keWdyYXBocy9zcmMvZGF0YWhhbmRsZXIvYmFycy1jdXN0b20uanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bars__ = __webpack_require__(1);\n/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler implementation for the error bars option.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * @constructor\n * @extends BarsHandler\n */\nvar ErrorBarsHandler = function ErrorBarsHandler() {};\n\nErrorBarsHandler.prototype = new __WEBPACK_IMPORTED_MODULE_0__bars__[\"a\" /* default */]();\n\n/** @inheritDoc */\nErrorBarsHandler.prototype.extractSeries = function (rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var x, y, variance, point;\n  var sigma = options.get(\"sigma\");\n  var logScale = options.get('logscale');\n  for (var j = 0; j < rawData.length; j++) {\n    x = rawData[j][0];\n    point = rawData[j][i];\n    if (logScale && point !== null) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point[0] <= 0 || point[0] - sigma * point[1] <= 0) {\n        point = null;\n      }\n    }\n    // Extract to the unified data format.\n    if (point !== null) {\n      y = point[0];\n      if (y !== null && !isNaN(y)) {\n        variance = sigma * point[1];\n        // preserve original error value in extras for further\n        // filtering\n        series.push([x, y, [y - variance, y + variance, point[1]]]);\n      } else {\n        series.push([x, y, [y, y, y]]);\n      }\n    } else {\n      series.push([x, null, [null, null, null]]);\n    }\n  }\n  return series;\n};\n\n/** @inheritDoc */\nErrorBarsHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n  var sigma = options.get(\"sigma\");\n\n  var i, j, y, v, sum, num_ok, stddev, variance, value;\n\n  // Calculate the rolling average for the first rollPeriod - 1 points\n  // where there is not enough data to roll over the full number of points\n  for (i = 0; i < originalData.length; i++) {\n    sum = 0;\n    variance = 0;\n    num_ok = 0;\n    for (j = Math.max(0, i - rollPeriod + 1); j < i + 1; j++) {\n      y = originalData[j][1];\n      if (y === null || isNaN(y)) continue;\n      num_ok++;\n      sum += y;\n      variance += Math.pow(originalData[j][2][2], 2);\n    }\n    if (num_ok) {\n      stddev = Math.sqrt(variance) / num_ok;\n      value = sum / num_ok;\n      rollingData[i] = [originalData[i][0], value, [value - sigma * stddev, value + sigma * stddev]];\n    } else {\n      // This explicitly preserves NaNs to aid with \"independent\n      // series\".\n      // See testRollingAveragePreservesNaNs.\n      v = rollPeriod == 1 ? originalData[i][1] : null;\n      rollingData[i] = [originalData[i][0], v, [v, v]];\n    }\n  }\n\n  return rollingData;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ErrorBarsHandler);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9iYXJzLWVycm9yLmpzP2E3N2UiXSwibmFtZXMiOlsiRXJyb3JCYXJzSGFuZGxlciIsInByb3RvdHlwZSIsImV4dHJhY3RTZXJpZXMiLCJyYXdEYXRhIiwiaSIsIm9wdGlvbnMiLCJzZXJpZXMiLCJ4IiwieSIsInZhcmlhbmNlIiwicG9pbnQiLCJzaWdtYSIsImdldCIsImxvZ1NjYWxlIiwiaiIsImxlbmd0aCIsImlzTmFOIiwicHVzaCIsInJvbGxpbmdBdmVyYWdlIiwib3JpZ2luYWxEYXRhIiwicm9sbFBlcmlvZCIsIk1hdGgiLCJtaW4iLCJyb2xsaW5nRGF0YSIsInYiLCJzdW0iLCJudW1fb2siLCJzdGRkZXYiLCJ2YWx1ZSIsIm1heCIsInBvdyIsInNxcnQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Ozs7OztBQU1BOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQSxJQUFJQSxtQkFBbUIsU0FBbkJBLGdCQUFtQixHQUFXLENBQ2pDLENBREQ7O0FBR0FBLGlCQUFpQkMsU0FBakIsR0FBNkIsSUFBSSxzREFBSixFQUE3Qjs7QUFFQTtBQUNBRCxpQkFBaUJDLFNBQWpCLENBQTJCQyxhQUEzQixHQUEyQyxVQUFTQyxPQUFULEVBQWtCQyxDQUFsQixFQUFxQkMsT0FBckIsRUFBOEI7QUFDdkU7QUFDQSxNQUFJQyxTQUFTLEVBQWI7QUFDQSxNQUFJQyxDQUFKLEVBQU9DLENBQVAsRUFBVUMsUUFBVixFQUFvQkMsS0FBcEI7QUFDQSxNQUFJQyxRQUFRTixRQUFRTyxHQUFSLENBQVksT0FBWixDQUFaO0FBQ0EsTUFBSUMsV0FBV1IsUUFBUU8sR0FBUixDQUFZLFVBQVosQ0FBZjtBQUNBLE9BQU0sSUFBSUUsSUFBSSxDQUFkLEVBQWlCQSxJQUFJWCxRQUFRWSxNQUE3QixFQUFxQ0QsR0FBckMsRUFBMEM7QUFDeENQLFFBQUlKLFFBQVFXLENBQVIsRUFBVyxDQUFYLENBQUo7QUFD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QUFmLEdBQW9CRCxhQUFhZixDQUFiLEVBQWdCLENBQWhCLENBQXBCLEdBQXlDLElBQTdDO0FBQ0FtQixrQkFBWW5CLENBQVosSUFBaUIsQ0FBRWUsYUFBYWYsQ0FBYixFQUFnQixDQUFoQixDQUFGLEVBQXNCb0IsQ0FBdEIsRUFBeUIsQ0FBRUEsQ0FBRixFQUFLQSxDQUFMLENBQXpCLENBQWpCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPRCxXQUFQO0FBQ0QsQ0FyQ0Q7O0FBdUNBLHlEQUFldkIsZ0JBQWYiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMyBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGF0YUhhbmRsZXIgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBlcnJvciBiYXJzIG9wdGlvbi5cbiAqIEBhdXRob3IgRGF2aWQgRWJlcmxlaW4gKGRhdmlkLmViZXJsZWluQGNoLnNhdXRlci1iYy5jb20pXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBCYXJzSGFuZGxlciBmcm9tICcuL2JhcnMnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQmFyc0hhbmRsZXJcbiAqL1xudmFyIEVycm9yQmFyc0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcbn07XG5cbkVycm9yQmFyc0hhbmRsZXIucHJvdG90eXBlID0gbmV3IEJhcnNIYW5kbGVyKCk7XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuRXJyb3JCYXJzSGFuZGxlci5wcm90b3R5cGUuZXh0cmFjdFNlcmllcyA9IGZ1bmN0aW9uKHJhd0RhdGEsIGksIG9wdGlvbnMpIHtcbiAgLy8gVE9ETyhkYW52ayk6IHByZS1hbGxvY2F0ZSBzZXJpZXMgaGVyZS5cbiAgdmFyIHNlcmllcyA9IFtdO1xuICB2YXIgeCwgeSwgdmFyaWFuY2UsIHBvaW50O1xuICB2YXIgc2lnbWEgPSBvcHRpb25zLmdldChcInNpZ21hXCIpO1xuICB2YXIgbG9nU2NhbGUgPSBvcHRpb25zLmdldCgnbG9nc2NhbGUnKTtcbiAgZm9yICggdmFyIGogPSAwOyBqIDwgcmF3RGF0YS5sZW5ndGg7IGorKykge1xuICAgIHggPSByYXdEYXRhW2pdWzBdO1xuICAgIHBvaW50ID0gcmF3RGF0YVtqXVtpXTtcbiAgICBpZiAobG9nU2NhbGUgJiYgcG9pbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIE9uIHRoZSBsb2cgc2NhbGUsIHBvaW50cyBsZXNzIHRoYW4gemVybyBkbyBub3QgZXhpc3QuXG4gICAgICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgZ2FwIGluIHRoZSBjaGFydC5cbiAgICAgIGlmIChwb2ludFswXSA8PSAwIHx8IHBvaW50WzBdIC0gc2lnbWEgKiBwb2ludFsxXSA8PSAwKSB7XG4gICAgICAgIHBvaW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRXh0cmFjdCB0byB0aGUgdW5pZmllZCBkYXRhIGZvcm1hdC5cbiAgICBpZiAocG9pbnQgIT09IG51bGwpIHtcbiAgICAgIHkgPSBwb2ludFswXTtcbiAgICAgIGlmICh5ICE9PSBudWxsICYmICFpc05hTih5KSkge1xuICAgICAgICB2YXJpYW5jZSA9IHNpZ21hICogcG9pbnRbMV07XG4gICAgICAgIC8vIHByZXNlcnZlIG9yaWdpbmFsIGVycm9yIHZhbHVlIGluIGV4dHJhcyBmb3IgZnVydGhlclxuICAgICAgICAvLyBmaWx0ZXJpbmdcbiAgICAgICAgc2VyaWVzLnB1c2goWyB4LCB5LCBbIHkgLSB2YXJpYW5jZSwgeSArIHZhcmlhbmNlLCBwb2ludFsxXSBdIF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWVzLnB1c2goWyB4LCB5LCBbIHksIHksIHkgXSBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWVzLnB1c2goWyB4LCBudWxsLCBbIG51bGwsIG51bGwsIG51bGwgXSBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmllcztcbn07XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuRXJyb3JCYXJzSGFuZGxlci5wcm90b3R5cGUucm9sbGluZ0F2ZXJhZ2UgPVxuICAgIGZ1bmN0aW9uKG9yaWdpbmFsRGF0YSwgcm9sbFBlcmlvZCwgb3B0aW9ucykge1xuICByb2xsUGVyaW9kID0gTWF0aC5taW4ocm9sbFBlcmlvZCwgb3JpZ2luYWxEYXRhLmxlbmd0aCk7XG4gIHZhciByb2xsaW5nRGF0YSA9IFtdO1xuICB2YXIgc2lnbWEgPSBvcHRpb25zLmdldChcInNpZ21hXCIpO1xuXG4gIHZhciBpLCBqLCB5LCB2LCBzdW0sIG51bV9vaywgc3RkZGV2LCB2YXJpYW5jZSwgdmFsdWU7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSByb2xsaW5nIGF2ZXJhZ2UgZm9yIHRoZSBmaXJzdCByb2xsUGVyaW9kIC0gMSBwb2ludHNcbiAgLy8gd2hlcmUgdGhlcmUgaXMgbm90IGVub3VnaCBkYXRhIHRvIHJvbGwgb3ZlciB0aGUgZnVsbCBudW1iZXIgb2YgcG9pbnRzXG4gIGZvciAoaSA9IDA7IGkgPCBvcmlnaW5hbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBzdW0gPSAwO1xuICAgIHZhcmlhbmNlID0gMDtcbiAgICBudW1fb2sgPSAwO1xuICAgIGZvciAoaiA9IE1hdGgubWF4KDAsIGkgLSByb2xsUGVyaW9kICsgMSk7IGogPCBpICsgMTsgaisrKSB7XG4gICAgICB5ID0gb3JpZ2luYWxEYXRhW2pdWzFdO1xuICAgICAgaWYgKHkgPT09IG51bGwgfHwgaXNOYU4oeSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgbnVtX29rKys7XG4gICAgICBzdW0gKz0geTtcbiAgICAgIHZhcmlhbmNlICs9IE1hdGgucG93KG9yaWdpbmFsRGF0YVtqXVsyXVsyXSwgMik7XG4gICAgfVxuICAgIGlmIChudW1fb2spIHtcbiAgICAgIHN0ZGRldiA9IE1hdGguc3FydCh2YXJpYW5jZSkgLyBudW1fb2s7XG4gICAgICB2YWx1ZSA9IHN1bSAvIG51bV9vaztcbiAgICAgIHJvbGxpbmdEYXRhW2ldID0gWyBvcmlnaW5hbERhdGFbaV1bMF0sIHZhbHVlLFxuICAgICAgICAgIFt2YWx1ZSAtIHNpZ21hICogc3RkZGV2LCB2YWx1ZSArIHNpZ21hICogc3RkZGV2XSBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGV4cGxpY2l0bHkgcHJlc2VydmVzIE5hTnMgdG8gYWlkIHdpdGggXCJpbmRlcGVuZGVudFxuICAgICAgLy8gc2VyaWVzXCIuXG4gICAgICAvLyBTZWUgdGVzdFJvbGxpbmdBdmVyYWdlUHJlc2VydmVzTmFOcy5cbiAgICAgIHYgPSAocm9sbFBlcmlvZCA9PSAxKSA/IG9yaWdpbmFsRGF0YVtpXVsxXSA6IG51bGw7XG4gICAgICByb2xsaW5nRGF0YVtpXSA9IFsgb3JpZ2luYWxEYXRhW2ldWzBdLCB2LCBbIHYsIHYgXSBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb2xsaW5nRGF0YTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVycm9yQmFyc0hhbmRsZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9iYXJzLWVycm9yLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bars__ = __webpack_require__(1);\n/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler implementation for the combination \n * of error bars and fractions options.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * @constructor\n * @extends Dygraph.DataHandlers.BarsHandler\n */\nvar FractionsBarsHandler = function FractionsBarsHandler() {};\n\nFractionsBarsHandler.prototype = new __WEBPACK_IMPORTED_MODULE_0__bars__[\"a\" /* default */]();\n\n/** @inheritDoc */\nFractionsBarsHandler.prototype.extractSeries = function (rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var x, y, point, num, den, value, stddev, variance;\n  var mult = 100.0;\n  var sigma = options.get(\"sigma\");\n  var logScale = options.get('logscale');\n  for (var j = 0; j < rawData.length; j++) {\n    x = rawData[j][0];\n    point = rawData[j][i];\n    if (logScale && point !== null) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point[0] <= 0 || point[1] <= 0) {\n        point = null;\n      }\n    }\n    // Extract to the unified data format.\n    if (point !== null) {\n      num = point[0];\n      den = point[1];\n      if (num !== null && !isNaN(num)) {\n        value = den ? num / den : 0.0;\n        stddev = den ? sigma * Math.sqrt(value * (1 - value) / den) : 1.0;\n        variance = mult * stddev;\n        y = mult * value;\n        // preserve original values in extras for further filtering\n        series.push([x, y, [y - variance, y + variance, num, den]]);\n      } else {\n        series.push([x, num, [num, num, num, den]]);\n      }\n    } else {\n      series.push([x, null, [null, null, null, null]]);\n    }\n  }\n  return series;\n};\n\n/** @inheritDoc */\nFractionsBarsHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n  var sigma = options.get(\"sigma\");\n  var wilsonInterval = options.get(\"wilsonInterval\");\n\n  var low, high, i, stddev;\n  var num = 0;\n  var den = 0; // numerator/denominator\n  var mult = 100.0;\n  for (i = 0; i < originalData.length; i++) {\n    num += originalData[i][2][2];\n    den += originalData[i][2][3];\n    if (i - rollPeriod >= 0) {\n      num -= originalData[i - rollPeriod][2][2];\n      den -= originalData[i - rollPeriod][2][3];\n    }\n\n    var date = originalData[i][0];\n    var value = den ? num / den : 0.0;\n    if (wilsonInterval) {\n      // For more details on this confidence interval, see:\n      // http://en.wikipedia.org/wiki/Binomial_confidence_interval\n      if (den) {\n        var p = value < 0 ? 0 : value,\n            n = den;\n        var pm = sigma * Math.sqrt(p * (1 - p) / n + sigma * sigma / (4 * n * n));\n        var denom = 1 + sigma * sigma / den;\n        low = (p + sigma * sigma / (2 * den) - pm) / denom;\n        high = (p + sigma * sigma / (2 * den) + pm) / denom;\n        rollingData[i] = [date, p * mult, [low * mult, high * mult]];\n      } else {\n        rollingData[i] = [date, 0, [0, 0]];\n      }\n    } else {\n      stddev = den ? sigma * Math.sqrt(value * (1 - value) / den) : 1.0;\n      rollingData[i] = [date, mult * value, [mult * (value - stddev), mult * (value + stddev)]];\n    }\n  }\n\n  return rollingData;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (FractionsBarsHandler);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9iYXJzLWZyYWN0aW9ucy5qcz8yODdiIl0sIm5hbWVzIjpbIkZyYWN0aW9uc0JhcnNIYW5kbGVyIiwicHJvdG90eXBlIiwiZXh0cmFjdFNlcmllcyIsInJhd0RhdGEiLCJpIiwib3B0aW9ucyIsInNlcmllcyIsIngiLCJ5IiwicG9pbnQiLCJudW0iLCJkZW4iLCJ2YWx1ZSIsInN0ZGRldiIsInZhcmlhbmNlIiwibXVsdCIsInNpZ21hIiwiZ2V0IiwibG9nU2NhbGUiLCJqIiwibGVuZ3RoIiwiaXNOYU4iLCJNYXRoIiwic3FydCIsInB1c2giLCJyb2xsaW5nQXZlcmFnZSIsIm9yaWdpbmFsRGF0YSIsInJvbGxQZXJpb2QiLCJtaW4iLCJyb2xsaW5nRGF0YSIsIndpbHNvbkludGVydmFsIiwibG93IiwiaGlnaCIsImRhdGUiLCJwIiwibiIsInBtIiwiZGVub20iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUEsSUFBSUEsdUJBQXVCLFNBQXZCQSxvQkFBdUIsR0FBVyxDQUNyQyxDQUREOztBQUdBQSxxQkFBcUJDLFNBQXJCLEdBQWlDLElBQUksc0RBQUosRUFBakM7O0FBRUE7QUFDQUQscUJBQXFCQyxTQUFyQixDQUErQkMsYUFBL0IsR0FBK0MsVUFBU0MsT0FBVCxFQUFrQkMsQ0FBbEIsRUFBcUJDLE9BQXJCLEVBQThCO0FBQzNFO0FBQ0EsTUFBSUMsU0FBUyxFQUFiO0FBQ0EsTUFBSUMsQ0FBSixFQUFPQyxDQUFQLEVBQVVDLEtBQVYsRUFBaUJDLEdBQWpCLEVBQXNCQyxHQUF0QixFQUEyQkMsS0FBM0IsRUFBa0NDLE1BQWxDLEVBQTBDQyxRQUExQztBQUNBLE1BQUlDLE9BQU8sS0FBWDtBQUNBLE1BQUlDLFFBQVFYLFFBQVFZLEdBQVIsQ0FBWSxPQUFaLENBQVo7QUFDQSxNQUFJQyxXQUFXYixRQUFRWSxHQUFS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QUYsRUFBUWxCLE9BQU9ILEtBQWYsRUFDRSxDQUFFRyxRQUFRSCxRQUFRQyxNQUFoQixDQUFGLEVBQTJCRSxRQUFRSCxRQUFRQyxNQUFoQixDQUEzQixDQURGLENBQWpCO0FBRUQ7QUFDRjs7QUFFRCxTQUFPZ0IsV0FBUDtBQUNELENBM0NEOztBQTZDQSx5REFBZTdCLG9CQUFmIiwiZmlsZSI6IjE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTMgRGF2aWQgRWJlcmxlaW4gKGRhdmlkLmViZXJsZWluQGNoLnNhdXRlci1iYy5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERhdGFIYW5kbGVyIGltcGxlbWVudGF0aW9uIGZvciB0aGUgY29tYmluYXRpb24gXG4gKiBvZiBlcnJvciBiYXJzIGFuZCBmcmFjdGlvbnMgb3B0aW9ucy5cbiAqIEBhdXRob3IgRGF2aWQgRWJlcmxlaW4gKGRhdmlkLmViZXJsZWluQGNoLnNhdXRlci1iYy5jb20pXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBCYXJzSGFuZGxlciBmcm9tICcuL2JhcnMnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRHlncmFwaC5EYXRhSGFuZGxlcnMuQmFyc0hhbmRsZXJcbiAqL1xudmFyIEZyYWN0aW9uc0JhcnNIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG59O1xuXG5GcmFjdGlvbnNCYXJzSGFuZGxlci5wcm90b3R5cGUgPSBuZXcgQmFyc0hhbmRsZXIoKTtcblxuLyoqIEBpbmhlcml0RG9jICovXG5GcmFjdGlvbnNCYXJzSGFuZGxlci5wcm90b3R5cGUuZXh0cmFjdFNlcmllcyA9IGZ1bmN0aW9uKHJhd0RhdGEsIGksIG9wdGlvbnMpIHtcbiAgLy8gVE9ETyhkYW52ayk6IHByZS1hbGxvY2F0ZSBzZXJpZXMgaGVyZS5cbiAgdmFyIHNlcmllcyA9IFtdO1xuICB2YXIgeCwgeSwgcG9pbnQsIG51bSwgZGVuLCB2YWx1ZSwgc3RkZGV2LCB2YXJpYW5jZTtcbiAgdmFyIG11bHQgPSAxMDAuMDtcbiAgdmFyIHNpZ21hID0gb3B0aW9ucy5nZXQoXCJzaWdtYVwiKTtcbiAgdmFyIGxvZ1NjYWxlID0gb3B0aW9ucy5nZXQoJ2xvZ3NjYWxlJyk7XG4gIGZvciAoIHZhciBqID0gMDsgaiA8IHJhd0RhdGEubGVuZ3RoOyBqKyspIHtcbiAgICB4ID0gcmF3RGF0YVtqXVswXTtcbiAgICBwb2ludCA9IHJhd0RhdGFbal1baV07XG4gICAgaWYgKGxvZ1NjYWxlICYmIHBvaW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBPbiB0aGUgbG9nIHNjYWxlLCBwb2ludHMgbGVzcyB0aGFuIHplcm8gZG8gbm90IGV4aXN0LlxuICAgICAgLy8gVGhpcyB3aWxsIGNyZWF0ZSBhIGdhcCBpbiB0aGUgY2hhcnQuXG4gICAgICBpZiAocG9pbnRbMF0gPD0gMCB8fCBwb2ludFsxXSA8PSAwKSB7XG4gICAgICAgIHBvaW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRXh0cmFjdCB0byB0aGUgdW5pZmllZCBkYXRhIGZvcm1hdC5cbiAgICBpZiAocG9pbnQgIT09IG51bGwpIHtcbiAgICAgIG51bSA9IHBvaW50WzBdO1xuICAgICAgZGVuID0gcG9pbnRbMV07XG4gICAgICBpZiAobnVtICE9PSBudWxsICYmICFpc05hTihudW0pKSB7XG4gICAgICAgIHZhbHVlID0gZGVuID8gbnVtIC8gZGVuIDogMC4wO1xuICAgICAgICBzdGRkZXYgPSBkZW4gPyBzaWdtYSAqIE1hdGguc3FydCh2YWx1ZSAqICgxIC0gdmFsdWUpIC8gZGVuKSA6IDEuMDtcbiAgICAgICAgdmFyaWFuY2UgPSBtdWx0ICogc3RkZGV2O1xuICAgICAgICB5ID0gbXVsdCAqIHZhbHVlO1xuICAgICAgICAvLyBwcmVzZXJ2ZSBvcmlnaW5hbCB2YWx1ZXMgaW4gZXh0cmFzIGZvciBmdXJ0aGVyIGZpbHRlcmluZ1xuICAgICAgICBzZXJpZXMucHVzaChbIHgsIHksIFsgeSAtIHZhcmlhbmNlLCB5ICsgdmFyaWFuY2UsIG51bSwgZGVuIF0gXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpZXMucHVzaChbIHgsIG51bSwgWyBudW0sIG51bSwgbnVtLCBkZW4gXSBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWVzLnB1c2goWyB4LCBudWxsLCBbIG51bGwsIG51bGwsIG51bGwsIG51bGwgXSBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmllcztcbn07XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuRnJhY3Rpb25zQmFyc0hhbmRsZXIucHJvdG90eXBlLnJvbGxpbmdBdmVyYWdlID1cbiAgICBmdW5jdGlvbihvcmlnaW5hbERhdGEsIHJvbGxQZXJpb2QsIG9wdGlvbnMpIHtcbiAgcm9sbFBlcmlvZCA9IE1hdGgubWluKHJvbGxQZXJpb2QsIG9yaWdpbmFsRGF0YS5sZW5ndGgpO1xuICB2YXIgcm9sbGluZ0RhdGEgPSBbXTtcbiAgdmFyIHNpZ21hID0gb3B0aW9ucy5nZXQoXCJzaWdtYVwiKTtcbiAgdmFyIHdpbHNvbkludGVydmFsID0gb3B0aW9ucy5nZXQoXCJ3aWxzb25JbnRlcnZhbFwiKTtcblxuICB2YXIgbG93LCBoaWdoLCBpLCBzdGRkZXY7XG4gIHZhciBudW0gPSAwO1xuICB2YXIgZGVuID0gMDsgLy8gbnVtZXJhdG9yL2Rlbm9taW5hdG9yXG4gIHZhciBtdWx0ID0gMTAwLjA7XG4gIGZvciAoaSA9IDA7IGkgPCBvcmlnaW5hbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBudW0gKz0gb3JpZ2luYWxEYXRhW2ldWzJdWzJdO1xuICAgIGRlbiArPSBvcmlnaW5hbERhdGFbaV1bMl1bM107XG4gICAgaWYgKGkgLSByb2xsUGVyaW9kID49IDApIHtcbiAgICAgIG51bSAtPSBvcmlnaW5hbERhdGFbaSAtIHJvbGxQZXJpb2RdWzJdWzJdO1xuICAgICAgZGVuIC09IG9yaWdpbmFsRGF0YVtpIC0gcm9sbFBlcmlvZF1bMl1bM107XG4gICAgfVxuXG4gICAgdmFyIGRhdGUgPSBvcmlnaW5hbERhdGFbaV1bMF07XG4gICAgdmFyIHZhbHVlID0gZGVuID8gbnVtIC8gZGVuIDogMC4wO1xuICAgIGlmICh3aWxzb25JbnRlcnZhbCkge1xuICAgICAgLy8gRm9yIG1vcmUgZGV0YWlscyBvbiB0aGlzIGNvbmZpZGVuY2UgaW50ZXJ2YWwsIHNlZTpcbiAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmlub21pYWxfY29uZmlkZW5jZV9pbnRlcnZhbFxuICAgICAgaWYgKGRlbikge1xuICAgICAgICB2YXIgcCA9IHZhbHVlIDwgMCA/IDAgOiB2YWx1ZSwgbiA9IGRlbjtcbiAgICAgICAgdmFyIHBtID0gc2lnbWEgKiBNYXRoLnNxcnQocCAqICgxIC0gcCkgLyBuICsgc2lnbWEgKiBzaWdtYSAvICg0ICogbiAqIG4pKTtcbiAgICAgICAgdmFyIGRlbm9tID0gMSArIHNpZ21hICogc2lnbWEgLyBkZW47XG4gICAgICAgIGxvdyA9IChwICsgc2lnbWEgKiBzaWdtYSAvICgyICogZGVuKSAtIHBtKSAvIGRlbm9tO1xuICAgICAgICBoaWdoID0gKHAgKyBzaWdtYSAqIHNpZ21hIC8gKDIgKiBkZW4pICsgcG0pIC8gZGVub207XG4gICAgICAgIHJvbGxpbmdEYXRhW2ldID0gWyBkYXRlLCBwICogbXVsdCxcbiAgICAgICAgICAgIFsgbG93ICogbXVsdCwgaGlnaCAqIG11bHQgXSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9sbGluZ0RhdGFbaV0gPSBbIGRhdGUsIDAsIFsgMCwgMCBdIF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ZGRldiA9IGRlbiA/IHNpZ21hICogTWF0aC5zcXJ0KHZhbHVlICogKDEgLSB2YWx1ZSkgLyBkZW4pIDogMS4wO1xuICAgICAgcm9sbGluZ0RhdGFbaV0gPSBbIGRhdGUsIG11bHQgKiB2YWx1ZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgWyBtdWx0ICogKHZhbHVlIC0gc3RkZGV2KSwgbXVsdCAqICh2YWx1ZSArIHN0ZGRldikgXSBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb2xsaW5nRGF0YTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZyYWN0aW9uc0JhcnNIYW5kbGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9keWdyYXBocy9zcmMvZGF0YWhhbmRsZXIvYmFycy1mcmFjdGlvbnMuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__datahandler__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__default__ = __webpack_require__(8);\n/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler implementation for the fractions option.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\n\n\n\n\n/**\n * @extends DefaultHandler\n * @constructor\n */\nvar DefaultFractionHandler = function DefaultFractionHandler() {};\n\nDefaultFractionHandler.prototype = new __WEBPACK_IMPORTED_MODULE_1__default__[\"a\" /* default */]();\n\nDefaultFractionHandler.prototype.extractSeries = function (rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var x, y, point, num, den, value;\n  var mult = 100.0;\n  var logScale = options.get('logscale');\n  for (var j = 0; j < rawData.length; j++) {\n    x = rawData[j][0];\n    point = rawData[j][i];\n    if (logScale && point !== null) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point[0] <= 0 || point[1] <= 0) {\n        point = null;\n      }\n    }\n    // Extract to the unified data format.\n    if (point !== null) {\n      num = point[0];\n      den = point[1];\n      if (num !== null && !isNaN(num)) {\n        value = den ? num / den : 0.0;\n        y = mult * value;\n        // preserve original values in extras for further filtering\n        series.push([x, y, [num, den]]);\n      } else {\n        series.push([x, num, [num, den]]);\n      }\n    } else {\n      series.push([x, null, [null, null]]);\n    }\n  }\n  return series;\n};\n\nDefaultFractionHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n\n  var i;\n  var num = 0;\n  var den = 0; // numerator/denominator\n  var mult = 100.0;\n  for (i = 0; i < originalData.length; i++) {\n    num += originalData[i][2][0];\n    den += originalData[i][2][1];\n    if (i - rollPeriod >= 0) {\n      num -= originalData[i - rollPeriod][2][0];\n      den -= originalData[i - rollPeriod][2][1];\n    }\n\n    var date = originalData[i][0];\n    var value = den ? num / den : 0.0;\n    rollingData[i] = [date, mult * value];\n  }\n\n  return rollingData;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DefaultFractionHandler);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9kZWZhdWx0LWZyYWN0aW9ucy5qcz8yMDg0Il0sIm5hbWVzIjpbIkRlZmF1bHRGcmFjdGlvbkhhbmRsZXIiLCJwcm90b3R5cGUiLCJleHRyYWN0U2VyaWVzIiwicmF3RGF0YSIsImkiLCJvcHRpb25zIiwic2VyaWVzIiwieCIsInkiLCJwb2ludCIsIm51bSIsImRlbiIsInZhbHVlIiwibXVsdCIsImxvZ1NjYWxlIiwiZ2V0IiwiaiIsImxlbmd0aCIsImlzTmFOIiwicHVzaCIsInJvbGxpbmdBdmVyYWdlIiwib3JpZ2luYWxEYXRhIiwicm9sbFBlcmlvZCIsIk1hdGgiLCJtaW4iLCJyb2xsaW5nRGF0YSIsImRhdGUiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUFBOzs7Ozs7QUFNQTs7Ozs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7QUFJQSxJQUFJQSx5QkFBeUIsU0FBekJBLHNCQUF5QixHQUFXLENBQ3ZDLENBREQ7O0FBR0FBLHVCQUF1QkMsU0FBdkIsR0FBbUMsSUFBSSx5REFBSixFQUFuQzs7QUFFQUQsdUJBQXVCQyxTQUF2QixDQUFpQ0MsYUFBakMsR0FBaUQsVUFBU0MsT0FBVCxFQUFrQkMsQ0FBbEIsRUFBcUJDLE9BQXJCLEVBQThCO0FBQzdFO0FBQ0EsTUFBSUMsU0FBUyxFQUFiO0FBQ0EsTUFBSUMsQ0FBSixFQUFPQyxDQUFQLEVBQVVDLEtBQVYsRUFBaUJDLEdBQWpCLEVBQXNCQyxHQUF0QixFQUEyQkMsS0FBM0I7QUFDQSxNQUFJQyxPQUFPLEtBQVg7QUFDQSxNQUFJQyxXQUFXVCxRQUFRVSxHQUFSLENBQVksVUFBWixDQUFmO0FBQ0EsT0FBTSxJQUFJQyxJQUFJLENBQWQsRUFBaUJBLElBQUliLFFBQVFjLE1BQTdCLEVBQXFDRCxHQUFyQyxFQUEwQztBQUN4Q1QsUUFBSUosUUFBUWEsQ0FBUixFQUFXLENBQVgsQ0FBSjtBQUNBUCxZQUFRTixRQUFRYSxDQUFSLEVBQVdaLENBQVgsQ0FBUjtBQUNBLFFBQUlVLFlBQVlMLFVBQVUsSUFBMUIsRUFBZ0M7QUFDOUI7QUFDQTtBQUNBLFVBQUlBLE1BQU0sQ0FBTixLQUFZLENBQVosSUFBaUJBLE1BQU0sQ0FBTixLQUFZLENBQWpDLEVBQW9DO0FBQ2xDQSxnQkFBUSxJQUFSO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsUUFBSUEsVUFBVSxJQUFkLEVBQW9CO0FBQ2xCQyxZQUFNRCxNQUFNLENBQU4sQ0FBTjtBQUNBRSxZQUFNRixNQUFNLENBQU4sQ0FBTjtBQUNBLFVBQUlDLFFBQVEsSUFBUixJQUFnQixDQUFDUSxNQUFNUixHQUFOLENBQXJCLEVBQWlDO0FBQy9CRSxnQkFBUUQsTUFBTUQsTUFBTUMsR0FBWixHQUFrQixHQUExQjtBQUNBSCxZQUFJSyxPQUFPRCxLQUFYO0FBQ0E7QUFDQU4sZUFBT2EsSUFBUCxDQUFZLENBQUVaLENBQUYsRUFBS0MsQ0FBTCxFQUFRLENBQUVFLEdBQUYsRUFBT0MsR0FBUCxDQUFSLENBQVo7QUFDRCxPQUxELE1BS087QUFDTEwsZUFBT2EsSUFBUCxDQUFZLENBQUVaLENBQUYsRUFBS0csR0FBTCxFQUFVLENBQUVBLEdBQUYsRUFBT0MsR0FBUCxDQUFWLENBQVo7QUFDRDtBQUNGLEtBWEQsTUFXTztBQUNMTCxhQUFPYSxJQUFQLENBQVksQ0FBRVosQ0FBRixFQUFLLElBQUwsRUFBVyxDQUFFLElBQUYsRUFBUSxJQUFSLENBQVgsQ0FBWjtBQUNEO0FBQ0Y7QUFDRCxTQUFPRCxNQUFQO0FBQ0QsQ0FqQ0Q7O0FBbUNBTix1QkFBdUJDLFNBQXZCLENBQWlDbUIsY0FBakMsR0FBa0QsVUFBU0MsWUFBVCxFQUF1QkMsVUFBdkIsRUFDOUNqQixPQUQ4QyxFQUNyQztBQUNYaUIsZUFBYUMsS0FBS0MsR0FBTCxDQUFTRixVQUFULEVBQXFCRCxhQUFhSixNQUFsQyxDQUFiO0FBQ0EsTUFBSVEsY0FBYyxFQUFsQjs7QUFFQSxNQUFJckIsQ0FBSjtBQUNBLE1BQUlNLE1BQU0sQ0FBVjtBQUNBLE1BQUlDLE1BQU0sQ0FBVixDQU5XLENBTUU7QUFDYixNQUFJRSxPQUFPLEtBQVg7QUFDQSxPQUFLVCxJQUFJLENBQVQsRUFBWUEsSUFBSWlCLGFBQWFKLE1BQTdCLEVBQXFDYixHQUFyQyxFQUEwQztBQUN4Q00sV0FBT1csYUFBYWpCLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsQ0FBUDtBQUNBTyxXQUFPVSxhQUFhakIsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixDQUFQO0FBQ0EsUUFBSUEsSUFBSWtCLFVBQUosSUFBa0IsQ0FBdEIsRUFBeUI7QUFDdkJaLGFBQU9XLGFBQWFqQixJQUFJa0IsVUFBakIsRUFBNkIsQ0FBN0IsRUFBZ0MsQ0FBaEMsQ0FBUDtBQUNBWCxhQUFPVSxhQUFhakIsSUFBSWtCLFVBQWpCLEVBQTZCLENBQTdCLEVBQWdDLENBQWhDLENBQVA7QUFDRDs7QUFFRCxRQUFJSSxPQUFPTCxhQUFhakIsQ0FBYixFQUFnQixDQUFoQixDQUFYO0FBQ0EsUUFBSVEsUUFBUUQsTUFBTUQsTUFBTUMsR0FBWixHQUFrQixHQUE5QjtBQUNBYyxnQkFBWXJCLENBQVosSUFBaUIsQ0FBRXNCLElBQUYsRUFBUWIsT0FBT0QsS0FBZixDQUFqQjtBQUNEOztBQUVELFNBQU9hLFdBQVA7QUFDRCxDQXZCRDs7QUF5QkEseURBQWV6QixzQkFBZiIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEzIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEYXRhSGFuZGxlciBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIGZyYWN0aW9ucyBvcHRpb24uXG4gKiBAYXV0aG9yIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRHlncmFwaERhdGFIYW5kbGVyIGZyb20gJy4vZGF0YWhhbmRsZXInO1xuaW1wb3J0IERlZmF1bHRIYW5kbGVyIGZyb20gJy4vZGVmYXVsdCc7XG5cbi8qKlxuICogQGV4dGVuZHMgRGVmYXVsdEhhbmRsZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRGVmYXVsdEZyYWN0aW9uSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xufTtcbiAgXG5EZWZhdWx0RnJhY3Rpb25IYW5kbGVyLnByb3RvdHlwZSA9IG5ldyBEZWZhdWx0SGFuZGxlcigpO1xuXG5EZWZhdWx0RnJhY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5leHRyYWN0U2VyaWVzID0gZnVuY3Rpb24ocmF3RGF0YSwgaSwgb3B0aW9ucykge1xuICAvLyBUT0RPKGRhbnZrKTogcHJlLWFsbG9jYXRlIHNlcmllcyBoZXJlLlxuICB2YXIgc2VyaWVzID0gW107XG4gIHZhciB4LCB5LCBwb2ludCwgbnVtLCBkZW4sIHZhbHVlO1xuICB2YXIgbXVsdCA9IDEwMC4wO1xuICB2YXIgbG9nU2NhbGUgPSBvcHRpb25zLmdldCgnbG9nc2NhbGUnKTtcbiAgZm9yICggdmFyIGogPSAwOyBqIDwgcmF3RGF0YS5sZW5ndGg7IGorKykge1xuICAgIHggPSByYXdEYXRhW2pdWzBdO1xuICAgIHBvaW50ID0gcmF3RGF0YVtqXVtpXTtcbiAgICBpZiAobG9nU2NhbGUgJiYgcG9pbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIE9uIHRoZSBsb2cgc2NhbGUsIHBvaW50cyBsZXNzIHRoYW4gemVybyBkbyBub3QgZXhpc3QuXG4gICAgICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgZ2FwIGluIHRoZSBjaGFydC5cbiAgICAgIGlmIChwb2ludFswXSA8PSAwIHx8IHBvaW50WzFdIDw9IDApIHtcbiAgICAgICAgcG9pbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBFeHRyYWN0IHRvIHRoZSB1bmlmaWVkIGRhdGEgZm9ybWF0LlxuICAgIGlmIChwb2ludCAhPT0gbnVsbCkge1xuICAgICAgbnVtID0gcG9pbnRbMF07XG4gICAgICBkZW4gPSBwb2ludFsxXTtcbiAgICAgIGlmIChudW0gIT09IG51bGwgJiYgIWlzTmFOKG51bSkpIHtcbiAgICAgICAgdmFsdWUgPSBkZW4gPyBudW0gLyBkZW4gOiAwLjA7XG4gICAgICAgIHkgPSBtdWx0ICogdmFsdWU7XG4gICAgICAgIC8vIHByZXNlcnZlIG9yaWdpbmFsIHZhbHVlcyBpbiBleHRyYXMgZm9yIGZ1cnRoZXIgZmlsdGVyaW5nXG4gICAgICAgIHNlcmllcy5wdXNoKFsgeCwgeSwgWyBudW0sIGRlbiBdIF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWVzLnB1c2goWyB4LCBudW0sIFsgbnVtLCBkZW4gXSBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWVzLnB1c2goWyB4LCBudWxsLCBbIG51bGwsIG51bGwgXSBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmllcztcbn07XG5cbkRlZmF1bHRGcmFjdGlvbkhhbmRsZXIucHJvdG90eXBlLnJvbGxpbmdBdmVyYWdlID0gZnVuY3Rpb24ob3JpZ2luYWxEYXRhLCByb2xsUGVyaW9kLFxuICAgIG9wdGlvbnMpIHtcbiAgcm9sbFBlcmlvZCA9IE1hdGgubWluKHJvbGxQZXJpb2QsIG9yaWdpbmFsRGF0YS5sZW5ndGgpO1xuICB2YXIgcm9sbGluZ0RhdGEgPSBbXTtcblxuICB2YXIgaTtcbiAgdmFyIG51bSA9IDA7XG4gIHZhciBkZW4gPSAwOyAvLyBudW1lcmF0b3IvZGVub21pbmF0b3JcbiAgdmFyIG11bHQgPSAxMDAuMDtcbiAgZm9yIChpID0gMDsgaSA8IG9yaWdpbmFsRGF0YS5sZW5ndGg7IGkrKykge1xuICAgIG51bSArPSBvcmlnaW5hbERhdGFbaV1bMl1bMF07XG4gICAgZGVuICs9IG9yaWdpbmFsRGF0YVtpXVsyXVsxXTtcbiAgICBpZiAoaSAtIHJvbGxQZXJpb2QgPj0gMCkge1xuICAgICAgbnVtIC09IG9yaWdpbmFsRGF0YVtpIC0gcm9sbFBlcmlvZF1bMl1bMF07XG4gICAgICBkZW4gLT0gb3JpZ2luYWxEYXRhW2kgLSByb2xsUGVyaW9kXVsyXVsxXTtcbiAgICB9XG5cbiAgICB2YXIgZGF0ZSA9IG9yaWdpbmFsRGF0YVtpXVswXTtcbiAgICB2YXIgdmFsdWUgPSBkZW4gPyBudW0gLyBkZW4gOiAwLjA7XG4gICAgcm9sbGluZ0RhdGFbaV0gPSBbIGRhdGUsIG11bHQgKiB2YWx1ZSBdO1xuICB9XG5cbiAgcmV0dXJuIHJvbGxpbmdEYXRhO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRGVmYXVsdEZyYWN0aW9uSGFuZGxlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZHlncmFwaHMvc3JjL2RhdGFoYW5kbGVyL2RlZmF1bHQtZnJhY3Rpb25zLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph__ = __webpack_require__(5);\n/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview A wrapper around the Dygraph class which implements the\n * interface for a GViz (aka Google Visualization API) visualization.\n * It is designed to be a drop-in replacement for Google's AnnotatedTimeline,\n * so the documentation at\n * http://code.google.com/apis/chart/interactive/docs/gallery/annotatedtimeline.html\n * translates over directly.\n *\n * For a full demo, see:\n * - http://dygraphs.com/tests/gviz.html\n * - http://dygraphs.com/tests/annotation-gviz.html\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * A wrapper around Dygraph that implements the gviz API.\n * @param {!HTMLDivElement} container The DOM object the visualization should\n *     live in.\n * @constructor\n */\nvar GVizChart = function GVizChart(container) {\n  this.container = container;\n};\n\n/**\n * @param {GVizDataTable} data\n * @param {Object.<*>} options\n */\nGVizChart.prototype.draw = function (data, options) {\n  // Clear out any existing dygraph.\n  // TODO(danvk): would it make more sense to simply redraw using the current\n  // date_graph object?\n  this.container.innerHTML = '';\n  if (typeof this.date_graph != 'undefined') {\n    this.date_graph.destroy();\n  }\n\n  this.date_graph = new __WEBPACK_IMPORTED_MODULE_0__dygraph__[\"a\" /* default */](this.container, data, options);\n};\n\n/**\n * Google charts compatible setSelection\n * Only row selection is supported, all points in the row will be highlighted\n * @param {Array.<{row:number}>} selection_array array of the selected cells\n * @public\n */\nGVizChart.prototype.setSelection = function (selection_array) {\n  var row = false;\n  if (selection_array.length) {\n    row = selection_array[0].row;\n  }\n  this.date_graph.setSelection(row);\n};\n\n/**\n * Google charts compatible getSelection implementation\n * @return {Array.<{row:number,column:number}>} array of the selected cells\n * @public\n */\nGVizChart.prototype.getSelection = function () {\n  var selection = [];\n\n  var row = this.date_graph.getSelection();\n\n  if (row < 0) return selection;\n\n  var points = this.date_graph.layout_.points;\n  for (var setIdx = 0; setIdx < points.length; ++setIdx) {\n    selection.push({ row: row, column: setIdx + 1 });\n  }\n\n  return selection;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (GVizChart);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLWd2aXouanM/MTYwNSJdLCJuYW1lcyI6WyJHVml6Q2hhcnQiLCJjb250YWluZXIiLCJwcm90b3R5cGUiLCJkcmF3IiwiZGF0YSIsIm9wdGlvbnMiLCJpbm5lckhUTUwiLCJkYXRlX2dyYXBoIiwiZGVzdHJveSIsInNldFNlbGVjdGlvbiIsInNlbGVjdGlvbl9hcnJheSIsInJvdyIsImxlbmd0aCIsImdldFNlbGVjdGlvbiIsInNlbGVjdGlvbiIsInBvaW50cyIsImxheW91dF8iLCJzZXRJZHgiLCJwdXNoIiwiY29sdW1uIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOzs7Ozs7QUFNQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7OztBQU1BLElBQUlBLFlBQVksU0FBWkEsU0FBWSxDQUFTQyxTQUFULEVBQW9CO0FBQ2xDLE9BQUtBLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0QsQ0FGRDs7QUFJQTs7OztBQUlBRCxVQUFVRSxTQUFWLENBQW9CQyxJQUFwQixHQUEyQixVQUFTQyxJQUFULEVBQWVDLE9BQWYsRUFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsT0FBS0osU0FBTCxDQUFlSyxTQUFmLEdBQTJCLEVBQTNCO0FBQ0EsTUFBSSxPQUFPLEtBQUtDLFVBQVosSUFBMkIsV0FBL0IsRUFBNEM7QUFDMUMsU0FBS0EsVUFBTCxDQUFnQkMsT0FBaEI7QUFDRDs7QUFFRCxPQUFLRCxVQUFMLEdBQWtCLElBQUkseURBQUosQ0FBWSxLQUFLTixTQUFqQixFQUE0QkcsSUFBNUIsRUFBa0NDLE9BQWxDLENBQWxCO0FBQ0QsQ0FWRDs7QUFZQTs7Ozs7O0FBTUFMLFVBQVVFLFNBQVYsQ0FBb0JPLFlBQXBCLEdBQW1DLFVBQVNDLGVBQVQsRUFBMEI7QUFDM0QsTUFBSUMsTUFBTSxLQUFWO0FBQ0EsTUFBSUQsZ0JBQWdCRSxNQUFwQixFQUE0QjtBQUMxQkQsVUFBTUQsZ0JBQWdCLENBQWhCLEVBQW1CQyxHQUF6QjtBQUNEO0FBQ0QsT0FBS0osVUFBTCxDQUFnQkUsWUFBaEIsQ0FBNkJFLEdBQTdCO0FBQ0QsQ0FORDs7QUFRQTs7Ozs7QUFLQVgsVUFBVUUsU0FBVixDQUFvQlcsWUFBcEIsR0FBbUMsWUFBVztBQUM1QyxNQUFJQyxZQUFZLEVBQWhCOztBQUVBLE1BQUlILE1BQU0sS0FBS0osVUFBTCxDQUFnQk0sWUFBaEIsRUFBVjs7QUFFQSxNQUFJRixNQUFNLENBQVYsRUFBYSxPQUFPRyxTQUFQOztBQUViLE1BQUlDLFNBQVMsS0FBS1IsVUFBTCxDQUFnQlMsT0FBaEIsQ0FBd0JELE1BQXJDO0FBQ0EsT0FBSyxJQUFJRSxTQUFTLENBQWxCLEVBQXFCQSxTQUFTRixPQUFPSCxNQUFyQyxFQUE2QyxFQUFFSyxNQUEvQyxFQUF1RDtBQUNyREgsY0FBVUksSUFBVixDQUFlLEVBQUNQLEtBQUtBLEdBQU4sRUFBV1EsUUFBUUYsU0FBUyxDQUE1QixFQUFmO0FBQ0Q7O0FBRUQsU0FBT0gsU0FBUDtBQUNELENBYkQ7O0FBZUEseURBQWVkLFNBQWYiLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMSBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBBIHdyYXBwZXIgYXJvdW5kIHRoZSBEeWdyYXBoIGNsYXNzIHdoaWNoIGltcGxlbWVudHMgdGhlXG4gKiBpbnRlcmZhY2UgZm9yIGEgR1ZpeiAoYWthIEdvb2dsZSBWaXN1YWxpemF0aW9uIEFQSSkgdmlzdWFsaXphdGlvbi5cbiAqIEl0IGlzIGRlc2lnbmVkIHRvIGJlIGEgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgR29vZ2xlJ3MgQW5ub3RhdGVkVGltZWxpbmUsXG4gKiBzbyB0aGUgZG9jdW1lbnRhdGlvbiBhdFxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9hcGlzL2NoYXJ0L2ludGVyYWN0aXZlL2RvY3MvZ2FsbGVyeS9hbm5vdGF0ZWR0aW1lbGluZS5odG1sXG4gKiB0cmFuc2xhdGVzIG92ZXIgZGlyZWN0bHkuXG4gKlxuICogRm9yIGEgZnVsbCBkZW1vLCBzZWU6XG4gKiAtIGh0dHA6Ly9keWdyYXBocy5jb20vdGVzdHMvZ3Zpei5odG1sXG4gKiAtIGh0dHA6Ly9keWdyYXBocy5jb20vdGVzdHMvYW5ub3RhdGlvbi1ndml6Lmh0bWxcbiAqL1xuXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IER5Z3JhcGggZnJvbSAnLi9keWdyYXBoJztcblxuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIER5Z3JhcGggdGhhdCBpbXBsZW1lbnRzIHRoZSBndml6IEFQSS5cbiAqIEBwYXJhbSB7IUhUTUxEaXZFbGVtZW50fSBjb250YWluZXIgVGhlIERPTSBvYmplY3QgdGhlIHZpc3VhbGl6YXRpb24gc2hvdWxkXG4gKiAgICAgbGl2ZSBpbi5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgR1ZpekNoYXJ0ID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0dWaXpEYXRhVGFibGV9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0LjwqPn0gb3B0aW9uc1xuICovXG5HVml6Q2hhcnQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XG4gIC8vIENsZWFyIG91dCBhbnkgZXhpc3RpbmcgZHlncmFwaC5cbiAgLy8gVE9ETyhkYW52ayk6IHdvdWxkIGl0IG1ha2UgbW9yZSBzZW5zZSB0byBzaW1wbHkgcmVkcmF3IHVzaW5nIHRoZSBjdXJyZW50XG4gIC8vIGRhdGVfZ3JhcGggb2JqZWN0P1xuICB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgaWYgKHR5cGVvZih0aGlzLmRhdGVfZ3JhcGgpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5kYXRlX2dyYXBoLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHRoaXMuZGF0ZV9ncmFwaCA9IG5ldyBEeWdyYXBoKHRoaXMuY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogR29vZ2xlIGNoYXJ0cyBjb21wYXRpYmxlIHNldFNlbGVjdGlvblxuICogT25seSByb3cgc2VsZWN0aW9uIGlzIHN1cHBvcnRlZCwgYWxsIHBvaW50cyBpbiB0aGUgcm93IHdpbGwgYmUgaGlnaGxpZ2h0ZWRcbiAqIEBwYXJhbSB7QXJyYXkuPHtyb3c6bnVtYmVyfT59IHNlbGVjdGlvbl9hcnJheSBhcnJheSBvZiB0aGUgc2VsZWN0ZWQgY2VsbHNcbiAqIEBwdWJsaWNcbiAqL1xuR1ZpekNoYXJ0LnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbihzZWxlY3Rpb25fYXJyYXkpIHtcbiAgdmFyIHJvdyA9IGZhbHNlO1xuICBpZiAoc2VsZWN0aW9uX2FycmF5Lmxlbmd0aCkge1xuICAgIHJvdyA9IHNlbGVjdGlvbl9hcnJheVswXS5yb3c7XG4gIH1cbiAgdGhpcy5kYXRlX2dyYXBoLnNldFNlbGVjdGlvbihyb3cpO1xufTtcblxuLyoqXG4gKiBHb29nbGUgY2hhcnRzIGNvbXBhdGlibGUgZ2V0U2VsZWN0aW9uIGltcGxlbWVudGF0aW9uXG4gKiBAcmV0dXJuIHtBcnJheS48e3JvdzpudW1iZXIsY29sdW1uOm51bWJlcn0+fSBhcnJheSBvZiB0aGUgc2VsZWN0ZWQgY2VsbHNcbiAqIEBwdWJsaWNcbiAqL1xuR1ZpekNoYXJ0LnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IFtdO1xuXG4gIHZhciByb3cgPSB0aGlzLmRhdGVfZ3JhcGguZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKHJvdyA8IDApIHJldHVybiBzZWxlY3Rpb247XG5cbiAgdmFyIHBvaW50cyA9IHRoaXMuZGF0ZV9ncmFwaC5sYXlvdXRfLnBvaW50cztcbiAgZm9yICh2YXIgc2V0SWR4ID0gMDsgc2V0SWR4IDwgcG9pbnRzLmxlbmd0aDsgKytzZXRJZHgpIHtcbiAgICBzZWxlY3Rpb24ucHVzaCh7cm93OiByb3csIGNvbHVtbjogc2V0SWR4ICsgMX0pO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdWaXpDaGFydDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZHlncmFwaHMvc3JjL2R5Z3JhcGgtZ3Zpei5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dygraph_default_attrs__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__dygraph_options_reference__ = __webpack_require__(12);\n/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DygraphOptions is responsible for parsing and returning\n * information about options.\n */\n\n// TODO: remove this jshint directive & fix the warnings.\n/*jshint sub:true */\n\n\n\n\n\n\n/*\n * Interesting member variables: (REMOVING THIS LIST AS I CLOSURIZE)\n * global_ - global attributes (common among all graphs, AIUI)\n * user - attributes set by the user\n * series_ - { seriesName -> { idx, yAxis, options }}\n */\n\n/**\n * This parses attributes into an object that can be easily queried.\n *\n * It doesn't necessarily mean that all options are available, specifically\n * if labels are not yet available, since those drive details of the per-series\n * and per-axis options.\n *\n * @param {Dygraph} dygraph The chart to which these options belong.\n * @constructor\n */\nvar DygraphOptions = function DygraphOptions(dygraph) {\n  /**\n   * The dygraph.\n   * @type {!Dygraph}\n   */\n  this.dygraph_ = dygraph;\n\n  /**\n   * Array of axis index to { series : [ series names ] , options : { axis-specific options. }\n   * @type {Array.<{series : Array.<string>, options : Object}>} @private\n   */\n  this.yAxes_ = [];\n\n  /**\n   * Contains x-axis specific options, which are stored in the options key.\n   * This matches the yAxes_ object structure (by being a dictionary with an\n   * options element) allowing for shared code.\n   * @type {options: Object} @private\n   */\n  this.xAxis_ = {};\n  this.series_ = {};\n\n  // Once these two objects are initialized, you can call get();\n  this.global_ = this.dygraph_.attrs_;\n  this.user_ = this.dygraph_.user_attrs_ || {};\n\n  /**\n   * A list of series in columnar order.\n   * @type {Array.<string>}\n   */\n  this.labels_ = [];\n\n  this.highlightSeries_ = this.get(\"highlightSeriesOpts\") || {};\n  this.reparseSeries();\n};\n\n/**\n * Not optimal, but does the trick when you're only using two axes.\n * If we move to more axes, this can just become a function.\n *\n * @type {Object.<number>}\n * @private\n */\nDygraphOptions.AXIS_STRING_MAPPINGS_ = {\n  'y': 0,\n  'Y': 0,\n  'y1': 0,\n  'Y1': 0,\n  'y2': 1,\n  'Y2': 1\n};\n\n/**\n * @param {string|number} axis\n * @private\n */\nDygraphOptions.axisToIndex_ = function (axis) {\n  if (typeof axis == \"string\") {\n    if (DygraphOptions.AXIS_STRING_MAPPINGS_.hasOwnProperty(axis)) {\n      return DygraphOptions.AXIS_STRING_MAPPINGS_[axis];\n    }\n    throw \"Unknown axis : \" + axis;\n  }\n  if (typeof axis == \"number\") {\n    if (axis === 0 || axis === 1) {\n      return axis;\n    }\n    throw \"Dygraphs only supports two y-axes, indexed from 0-1.\";\n  }\n  if (axis) {\n    throw \"Unknown axis : \" + axis;\n  }\n  // No axis specification means axis 0.\n  return 0;\n};\n\n/**\n * Reparses options that are all related to series. This typically occurs when\n * options are either updated, or source data has been made available.\n *\n * TODO(konigsberg): The method name is kind of weak; fix.\n */\nDygraphOptions.prototype.reparseSeries = function () {\n  var labels = this.get(\"labels\");\n  if (!labels) {\n    return; // -- can't do more for now, will parse after getting the labels.\n  }\n\n  this.labels_ = labels.slice(1);\n\n  this.yAxes_ = [{ series: [], options: {} }]; // Always one axis at least.\n  this.xAxis_ = { options: {} };\n  this.series_ = {};\n\n  // Series are specified in the series element:\n  //\n  // {\n  //   labels: [ \"X\", \"foo\", \"bar\" ],\n  //   pointSize: 3,\n  //   series : {\n  //     foo : {}, // options for foo\n  //     bar : {} // options for bar\n  //   }\n  // }\n  //\n  // So, if series is found, it's expected to contain per-series data, otherwise set a\n  // default.\n  var seriesDict = this.user_.series || {};\n  for (var idx = 0; idx < this.labels_.length; idx++) {\n    var seriesName = this.labels_[idx];\n    var optionsForSeries = seriesDict[seriesName] || {};\n    var yAxis = DygraphOptions.axisToIndex_(optionsForSeries[\"axis\"]);\n\n    this.series_[seriesName] = {\n      idx: idx,\n      yAxis: yAxis,\n      options: optionsForSeries };\n\n    if (!this.yAxes_[yAxis]) {\n      this.yAxes_[yAxis] = { series: [seriesName], options: {} };\n    } else {\n      this.yAxes_[yAxis].series.push(seriesName);\n    }\n  }\n\n  var axis_opts = this.user_[\"axes\"] || {};\n  __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"a\" /* update */](this.yAxes_[0].options, axis_opts[\"y\"] || {});\n  if (this.yAxes_.length > 1) {\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"a\" /* update */](this.yAxes_[1].options, axis_opts[\"y2\"] || {});\n  }\n  __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"a\" /* update */](this.xAxis_.options, axis_opts[\"x\"] || {});\n\n  // For \"production\" code, this gets removed by uglifyjs.\n  if (typeof process !== 'undefined') {\n    if (process.env.NODE_ENV != 'production') {\n      this.validateOptions_();\n    }\n  }\n};\n\n/**\n * Get a global value.\n *\n * @param {string} name the name of the option.\n */\nDygraphOptions.prototype.get = function (name) {\n  var result = this.getGlobalUser_(name);\n  if (result !== null) {\n    return result;\n  }\n  return this.getGlobalDefault_(name);\n};\n\nDygraphOptions.prototype.getGlobalUser_ = function (name) {\n  if (this.user_.hasOwnProperty(name)) {\n    return this.user_[name];\n  }\n  return null;\n};\n\nDygraphOptions.prototype.getGlobalDefault_ = function (name) {\n  if (this.global_.hasOwnProperty(name)) {\n    return this.global_[name];\n  }\n  if (__WEBPACK_IMPORTED_MODULE_1__dygraph_default_attrs__[\"a\" /* default */].hasOwnProperty(name)) {\n    return __WEBPACK_IMPORTED_MODULE_1__dygraph_default_attrs__[\"a\" /* default */][name];\n  }\n  return null;\n};\n\n/**\n * Get a value for a specific axis. If there is no specific value for the axis,\n * the global value is returned.\n *\n * @param {string} name the name of the option.\n * @param {string|number} axis the axis to search. Can be the string representation\n * (\"y\", \"y2\") or the axis number (0, 1).\n */\nDygraphOptions.prototype.getForAxis = function (name, axis) {\n  var axisIdx;\n  var axisString;\n\n  // Since axis can be a number or a string, straighten everything out here.\n  if (typeof axis == 'number') {\n    axisIdx = axis;\n    axisString = axisIdx === 0 ? \"y\" : \"y2\";\n  } else {\n    if (axis == \"y1\") {\n      axis = \"y\";\n    } // Standardize on 'y'. Is this bad? I think so.\n    if (axis == \"y\") {\n      axisIdx = 0;\n    } else if (axis == \"y2\") {\n      axisIdx = 1;\n    } else if (axis == \"x\") {\n      axisIdx = -1; // simply a placeholder for below.\n    } else {\n      throw \"Unknown axis \" + axis;\n    }\n    axisString = axis;\n  }\n\n  var userAxis = axisIdx == -1 ? this.xAxis_ : this.yAxes_[axisIdx];\n\n  // Search the user-specified axis option first.\n  if (userAxis) {\n    // This condition could be removed if we always set up this.yAxes_ for y2.\n    var axisOptions = userAxis.options;\n    if (axisOptions.hasOwnProperty(name)) {\n      return axisOptions[name];\n    }\n  }\n\n  // User-specified global options second.\n  // But, hack, ignore globally-specified 'logscale' for 'x' axis declaration.\n  if (!(axis === 'x' && name === 'logscale')) {\n    var result = this.getGlobalUser_(name);\n    if (result !== null) {\n      return result;\n    }\n  }\n  // Default axis options third.\n  var defaultAxisOptions = __WEBPACK_IMPORTED_MODULE_1__dygraph_default_attrs__[\"a\" /* default */].axes[axisString];\n  if (defaultAxisOptions.hasOwnProperty(name)) {\n    return defaultAxisOptions[name];\n  }\n\n  // Default global options last.\n  return this.getGlobalDefault_(name);\n};\n\n/**\n * Get a value for a specific series. If there is no specific value for the series,\n * the value for the axis is returned (and afterwards, the global value.)\n *\n * @param {string} name the name of the option.\n * @param {string} series the series to search.\n */\nDygraphOptions.prototype.getForSeries = function (name, series) {\n  // Honors indexes as series.\n  if (series === this.dygraph_.getHighlightSeries()) {\n    if (this.highlightSeries_.hasOwnProperty(name)) {\n      return this.highlightSeries_[name];\n    }\n  }\n\n  if (!this.series_.hasOwnProperty(series)) {\n    throw \"Unknown series: \" + series;\n  }\n\n  var seriesObj = this.series_[series];\n  var seriesOptions = seriesObj[\"options\"];\n  if (seriesOptions.hasOwnProperty(name)) {\n    return seriesOptions[name];\n  }\n\n  return this.getForAxis(name, seriesObj[\"yAxis\"]);\n};\n\n/**\n * Returns the number of y-axes on the chart.\n * @return {number} the number of axes.\n */\nDygraphOptions.prototype.numAxes = function () {\n  return this.yAxes_.length;\n};\n\n/**\n * Return the y-axis for a given series, specified by name.\n */\nDygraphOptions.prototype.axisForSeries = function (series) {\n  return this.series_[series].yAxis;\n};\n\n/**\n * Returns the options for the specified axis.\n */\n// TODO(konigsberg): this is y-axis specific. Support the x axis.\nDygraphOptions.prototype.axisOptions = function (yAxis) {\n  return this.yAxes_[yAxis].options;\n};\n\n/**\n * Return the series associated with an axis.\n */\nDygraphOptions.prototype.seriesForAxis = function (yAxis) {\n  return this.yAxes_[yAxis].series;\n};\n\n/**\n * Return the list of all series, in their columnar order.\n */\nDygraphOptions.prototype.seriesNames = function () {\n  return this.labels_;\n};\n\n// For \"production\" code, this gets removed by uglifyjs.\nif (typeof process !== 'undefined') {\n  if (process.env.NODE_ENV != 'production') {\n\n    /**\n     * Validate all options.\n     * This requires OPTIONS_REFERENCE, which is only available in debug builds.\n     * @private\n     */\n    DygraphOptions.prototype.validateOptions_ = function () {\n      if (typeof __WEBPACK_IMPORTED_MODULE_2__dygraph_options_reference__[\"a\" /* default */] === 'undefined') {\n        throw 'Called validateOptions_ in prod build.';\n      }\n\n      var that = this;\n      var validateOption = function validateOption(optionName) {\n        if (!__WEBPACK_IMPORTED_MODULE_2__dygraph_options_reference__[\"a\" /* default */][optionName]) {\n          that.warnInvalidOption_(optionName);\n        }\n      };\n\n      var optionsDicts = [this.xAxis_.options, this.yAxes_[0].options, this.yAxes_[1] && this.yAxes_[1].options, this.global_, this.user_, this.highlightSeries_];\n      var names = this.seriesNames();\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        if (this.series_.hasOwnProperty(name)) {\n          optionsDicts.push(this.series_[name].options);\n        }\n      }\n      for (var i = 0; i < optionsDicts.length; i++) {\n        var dict = optionsDicts[i];\n        if (!dict) continue;\n        for (var optionName in dict) {\n          if (dict.hasOwnProperty(optionName)) {\n            validateOption(optionName);\n          }\n        }\n      }\n    };\n\n    var WARNINGS = {}; // Only show any particular warning once.\n\n    /**\n     * Logs a warning about invalid options.\n     * TODO: make this throw for testing\n     * @private\n     */\n    DygraphOptions.prototype.warnInvalidOption_ = function (optionName) {\n      if (!WARNINGS[optionName]) {\n        WARNINGS[optionName] = true;\n        var isSeries = this.labels_.indexOf(optionName) >= 0;\n        if (isSeries) {\n          console.warn('Use new-style per-series options (saw ' + optionName + ' as top-level options key). See http://bit.ly/1tceaJs');\n        } else {\n          console.warn('Unknown option ' + optionName + ' (full list of options at dygraphs.com/options.html');\n        }\n        throw \"invalid option \" + optionName;\n      }\n    };\n\n    // Reset list of previously-shown warnings. Used for testing.\n    DygraphOptions.resetWarnings_ = function () {\n      WARNINGS = {};\n    };\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DygraphOptions);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(6)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLW9wdGlvbnMuanM/OTFlYiJdLCJuYW1lcyI6WyJEeWdyYXBoT3B0aW9ucyIsImR5Z3JhcGgiLCJkeWdyYXBoXyIsInlBeGVzXyIsInhBeGlzXyIsInNlcmllc18iLCJnbG9iYWxfIiwiYXR0cnNfIiwidXNlcl8iLCJ1c2VyX2F0dHJzXyIsImxhYmVsc18iLCJoaWdobGlnaHRTZXJpZXNfIiwiZ2V0IiwicmVwYXJzZVNlcmllcyIsIkFYSVNfU1RSSU5HX01BUFBJTkdTXyIsImF4aXNUb0luZGV4XyIsImF4aXMiLCJoYXNPd25Qcm9wZXJ0eSIsInByb3RvdHlwZSIsImxhYmVscyIsInNsaWNlIiwic2VyaWVzIiwib3B0aW9ucyIsInNlcmllc0RpY3QiLCJpZHgiLCJsZW5ndGgiLCJzZXJpZXNOYW1lIiwib3B0aW9uc0ZvclNlcmllcyIsInlBeGlzIiwicHVzaCIsImF4aXNfb3B0cyIsInV0aWxzIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwidmFsaWRhdGVPcHRpb25zXyIsIm5hbWUiLCJyZXN1bHQiLCJnZXRHbG9iYWxVc2VyXyIsImdldEdsb2JhbERlZmF1bHRfIiwiREVGQVVMVF9BVFRSUyIsImdldEZvckF4aXMiLCJheGlzSWR4IiwiYXhpc1N0cmluZyIsInVzZXJBeGlzIiwiYXhpc09wdGlvbnMiLCJkZWZhdWx0QXhpc09wdGlvbnMiLCJheGVzIiwiZ2V0Rm9yU2VyaWVzIiwiZ2V0SGlnaGxpZ2h0U2VyaWVzIiwic2VyaWVzT2JqIiwic2VyaWVzT3B0aW9ucyIsIm51bUF4ZXMiLCJheGlzRm9yU2VyaWVzIiwic2VyaWVzRm9yQXhpcyIsInNlcmllc05hbWVzIiwidGhhdCIsInZhbGlkYXRlT3B0aW9uIiwib3B0aW9uTmFtZSIsIk9QVElPTlNfUkVGRVJFTkNFIiwid2FybkludmFsaWRPcHRpb25fIiwib3B0aW9uc0RpY3RzIiwibmFtZXMiLCJpIiwiZGljdCIsIldBUk5JTkdTIiwi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QWdDLFlBQVc7QUFDekNMLGlCQUFXLEVBQVg7QUFDRCxLQUZEO0FBSUM7QUFDQTs7QUFFRCx5REFBZWpFLGNBQWYsRSIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDExIERhbiBWYW5kZXJrYW0gKGRhbnZka0BnbWFpbC5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IER5Z3JhcGhPcHRpb25zIGlzIHJlc3BvbnNpYmxlIGZvciBwYXJzaW5nIGFuZCByZXR1cm5pbmdcbiAqIGluZm9ybWF0aW9uIGFib3V0IG9wdGlvbnMuXG4gKi9cblxuLy8gVE9ETzogcmVtb3ZlIHRoaXMganNoaW50IGRpcmVjdGl2ZSAmIGZpeCB0aGUgd2FybmluZ3MuXG4vKmpzaGludCBzdWI6dHJ1ZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vZHlncmFwaC11dGlscyc7XG5pbXBvcnQgREVGQVVMVF9BVFRSUyBmcm9tICcuL2R5Z3JhcGgtZGVmYXVsdC1hdHRycyc7XG5pbXBvcnQgT1BUSU9OU19SRUZFUkVOQ0UgZnJvbSAnLi9keWdyYXBoLW9wdGlvbnMtcmVmZXJlbmNlJztcblxuLypcbiAqIEludGVyZXN0aW5nIG1lbWJlciB2YXJpYWJsZXM6IChSRU1PVklORyBUSElTIExJU1QgQVMgSSBDTE9TVVJJWkUpXG4gKiBnbG9iYWxfIC0gZ2xvYmFsIGF0dHJpYnV0ZXMgKGNvbW1vbiBhbW9uZyBhbGwgZ3JhcGhzLCBBSVVJKVxuICogdXNlciAtIGF0dHJpYnV0ZXMgc2V0IGJ5IHRoZSB1c2VyXG4gKiBzZXJpZXNfIC0geyBzZXJpZXNOYW1lIC0+IHsgaWR4LCB5QXhpcywgb3B0aW9ucyB9fVxuICovXG5cbi8qKlxuICogVGhpcyBwYXJzZXMgYXR0cmlidXRlcyBpbnRvIGFuIG9iamVjdCB0aGF0IGNhbiBiZSBlYXNpbHkgcXVlcmllZC5cbiAqXG4gKiBJdCBkb2Vzbid0IG5lY2Vzc2FyaWx5IG1lYW4gdGhhdCBhbGwgb3B0aW9ucyBhcmUgYXZhaWxhYmxlLCBzcGVjaWZpY2FsbHlcbiAqIGlmIGxhYmVscyBhcmUgbm90IHlldCBhdmFpbGFibGUsIHNpbmNlIHRob3NlIGRyaXZlIGRldGFpbHMgb2YgdGhlIHBlci1zZXJpZXNcbiAqIGFuZCBwZXItYXhpcyBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7RHlncmFwaH0gZHlncmFwaCBUaGUgY2hhcnQgdG8gd2hpY2ggdGhlc2Ugb3B0aW9ucyBiZWxvbmcuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIER5Z3JhcGhPcHRpb25zID0gZnVuY3Rpb24oZHlncmFwaCkge1xuICAvKipcbiAgICogVGhlIGR5Z3JhcGguXG4gICAqIEB0eXBlIHshRHlncmFwaH1cbiAgICovXG4gIHRoaXMuZHlncmFwaF8gPSBkeWdyYXBoO1xuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBheGlzIGluZGV4IHRvIHsgc2VyaWVzIDogWyBzZXJpZXMgbmFtZXMgXSAsIG9wdGlvbnMgOiB7IGF4aXMtc3BlY2lmaWMgb3B0aW9ucy4gfVxuICAgKiBAdHlwZSB7QXJyYXkuPHtzZXJpZXMgOiBBcnJheS48c3RyaW5nPiwgb3B0aW9ucyA6IE9iamVjdH0+fSBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy55QXhlc18gPSBbXTtcblxuICAvKipcbiAgICogQ29udGFpbnMgeC1heGlzIHNwZWNpZmljIG9wdGlvbnMsIHdoaWNoIGFyZSBzdG9yZWQgaW4gdGhlIG9wdGlvbnMga2V5LlxuICAgKiBUaGlzIG1hdGNoZXMgdGhlIHlBeGVzXyBvYmplY3Qgc3RydWN0dXJlIChieSBiZWluZyBhIGRpY3Rpb25hcnkgd2l0aCBhblxuICAgKiBvcHRpb25zIGVsZW1lbnQpIGFsbG93aW5nIGZvciBzaGFyZWQgY29kZS5cbiAgICogQHR5cGUge29wdGlvbnM6IE9iamVjdH0gQHByaXZhdGVcbiAgICovXG4gIHRoaXMueEF4aXNfID0ge307XG4gIHRoaXMuc2VyaWVzXyA9IHt9O1xuXG4gIC8vIE9uY2UgdGhlc2UgdHdvIG9iamVjdHMgYXJlIGluaXRpYWxpemVkLCB5b3UgY2FuIGNhbGwgZ2V0KCk7XG4gIHRoaXMuZ2xvYmFsXyA9IHRoaXMuZHlncmFwaF8uYXR0cnNfO1xuICB0aGlzLnVzZXJfID0gdGhpcy5keWdyYXBoXy51c2VyX2F0dHJzXyB8fCB7fTtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIHNlcmllcyBpbiBjb2x1bW5hciBvcmRlci5cbiAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgKi9cbiAgdGhpcy5sYWJlbHNfID0gW107XG5cbiAgdGhpcy5oaWdobGlnaHRTZXJpZXNfID0gdGhpcy5nZXQoXCJoaWdobGlnaHRTZXJpZXNPcHRzXCIpIHx8IHt9O1xuICB0aGlzLnJlcGFyc2VTZXJpZXMoKTtcbn07XG5cbi8qKlxuICogTm90IG9wdGltYWwsIGJ1dCBkb2VzIHRoZSB0cmljayB3aGVuIHlvdSdyZSBvbmx5IHVzaW5nIHR3byBheGVzLlxuICogSWYgd2UgbW92ZSB0byBtb3JlIGF4ZXMsIHRoaXMgY2FuIGp1c3QgYmVjb21lIGEgZnVuY3Rpb24uXG4gKlxuICogQHR5cGUge09iamVjdC48bnVtYmVyPn1cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhPcHRpb25zLkFYSVNfU1RSSU5HX01BUFBJTkdTXyA9IHtcbiAgJ3knIDogMCxcbiAgJ1knIDogMCxcbiAgJ3kxJyA6IDAsXG4gICdZMScgOiAwLFxuICAneTInIDogMSxcbiAgJ1kyJyA6IDFcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBheGlzXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoT3B0aW9ucy5heGlzVG9JbmRleF8gPSBmdW5jdGlvbihheGlzKSB7XG4gIGlmICh0eXBlb2YoYXhpcykgPT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChEeWdyYXBoT3B0aW9ucy5BWElTX1NUUklOR19NQVBQSU5HU18uaGFzT3duUHJvcGVydHkoYXhpcykpIHtcbiAgICAgIHJldHVybiBEeWdyYXBoT3B0aW9ucy5BWElTX1NUUklOR19NQVBQSU5HU19bYXhpc107XG4gICAgfVxuICAgIHRocm93IFwiVW5rbm93biBheGlzIDogXCIgKyBheGlzO1xuICB9XG4gIGlmICh0eXBlb2YoYXhpcykgPT0gXCJudW1iZXJcIikge1xuICAgIGlmIChheGlzID09PSAwIHx8IGF4aXMgPT09IDEpIHtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH1cbiAgICB0aHJvdyBcIkR5Z3JhcGhzIG9ubHkgc3VwcG9ydHMgdHdvIHktYXhlcywgaW5kZXhlZCBmcm9tIDAtMS5cIjtcbiAgfVxuICBpZiAoYXhpcykge1xuICAgIHRocm93IFwiVW5rbm93biBheGlzIDogXCIgKyBheGlzO1xuICB9XG4gIC8vIE5vIGF4aXMgc3BlY2lmaWNhdGlvbiBtZWFucyBheGlzIDAuXG4gIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBSZXBhcnNlcyBvcHRpb25zIHRoYXQgYXJlIGFsbCByZWxhdGVkIHRvIHNlcmllcy4gVGhpcyB0eXBpY2FsbHkgb2NjdXJzIHdoZW5cbiAqIG9wdGlvbnMgYXJlIGVpdGhlciB1cGRhdGVkLCBvciBzb3VyY2UgZGF0YSBoYXMgYmVlbiBtYWRlIGF2YWlsYWJsZS5cbiAqXG4gKiBUT0RPKGtvbmlnc2JlcmcpOiBUaGUgbWV0aG9kIG5hbWUgaXMga2luZCBvZiB3ZWFrOyBmaXguXG4gKi9cbkR5Z3JhcGhPcHRpb25zLnByb3RvdHlwZS5yZXBhcnNlU2VyaWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsYWJlbHMgPSB0aGlzLmdldChcImxhYmVsc1wiKTtcbiAgaWYgKCFsYWJlbHMpIHtcbiAgICByZXR1cm47IC8vIC0tIGNhbid0IGRvIG1vcmUgZm9yIG5vdywgd2lsbCBwYXJzZSBhZnRlciBnZXR0aW5nIHRoZSBsYWJlbHMuXG4gIH1cblxuICB0aGlzLmxhYmVsc18gPSBsYWJlbHMuc2xpY2UoMSk7XG5cbiAgdGhpcy55QXhlc18gPSBbIHsgc2VyaWVzIDogW10sIG9wdGlvbnMgOiB7fX0gXTsgLy8gQWx3YXlzIG9uZSBheGlzIGF0IGxlYXN0LlxuICB0aGlzLnhBeGlzXyA9IHsgb3B0aW9ucyA6IHt9IH07XG4gIHRoaXMuc2VyaWVzXyA9IHt9O1xuXG4gIC8vIFNlcmllcyBhcmUgc3BlY2lmaWVkIGluIHRoZSBzZXJpZXMgZWxlbWVudDpcbiAgLy9cbiAgLy8ge1xuICAvLyAgIGxhYmVsczogWyBcIlhcIiwgXCJmb29cIiwgXCJiYXJcIiBdLFxuICAvLyAgIHBvaW50U2l6ZTogMyxcbiAgLy8gICBzZXJpZXMgOiB7XG4gIC8vICAgICBmb28gOiB7fSwgLy8gb3B0aW9ucyBmb3IgZm9vXG4gIC8vICAgICBiYXIgOiB7fSAvLyBvcHRpb25zIGZvciBiYXJcbiAgLy8gICB9XG4gIC8vIH1cbiAgLy9cbiAgLy8gU28sIGlmIHNlcmllcyBpcyBmb3VuZCwgaXQncyBleHBlY3RlZCB0byBjb250YWluIHBlci1zZXJpZXMgZGF0YSwgb3RoZXJ3aXNlIHNldCBhXG4gIC8vIGRlZmF1bHQuXG4gIHZhciBzZXJpZXNEaWN0ID0gdGhpcy51c2VyXy5zZXJpZXMgfHwge307XG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHRoaXMubGFiZWxzXy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdmFyIHNlcmllc05hbWUgPSB0aGlzLmxhYmVsc19baWR4XTtcbiAgICB2YXIgb3B0aW9uc0ZvclNlcmllcyA9IHNlcmllc0RpY3Rbc2VyaWVzTmFtZV0gfHwge307XG4gICAgdmFyIHlBeGlzID0gRHlncmFwaE9wdGlvbnMuYXhpc1RvSW5kZXhfKG9wdGlvbnNGb3JTZXJpZXNbXCJheGlzXCJdKTtcblxuICAgIHRoaXMuc2VyaWVzX1tzZXJpZXNOYW1lXSA9IHtcbiAgICAgIGlkeDogaWR4LFxuICAgICAgeUF4aXM6IHlBeGlzLFxuICAgICAgb3B0aW9ucyA6IG9wdGlvbnNGb3JTZXJpZXMgfTtcblxuICAgIGlmICghdGhpcy55QXhlc19beUF4aXNdKSB7XG4gICAgICB0aGlzLnlBeGVzX1t5QXhpc10gPSAgeyBzZXJpZXMgOiBbIHNlcmllc05hbWUgXSwgb3B0aW9ucyA6IHt9IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueUF4ZXNfW3lBeGlzXS5zZXJpZXMucHVzaChzZXJpZXNOYW1lKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXhpc19vcHRzID0gdGhpcy51c2VyX1tcImF4ZXNcIl0gfHwge307XG4gIHV0aWxzLnVwZGF0ZSh0aGlzLnlBeGVzX1swXS5vcHRpb25zLCBheGlzX29wdHNbXCJ5XCJdIHx8IHt9KTtcbiAgaWYgKHRoaXMueUF4ZXNfLmxlbmd0aCA+IDEpIHtcbiAgICB1dGlscy51cGRhdGUodGhpcy55QXhlc19bMV0ub3B0aW9ucywgYXhpc19vcHRzW1wieTJcIl0gfHwge30pO1xuICB9XG4gIHV0aWxzLnVwZGF0ZSh0aGlzLnhBeGlzXy5vcHRpb25zLCBheGlzX29wdHNbXCJ4XCJdIHx8IHt9KTtcblxuICAvLyBGb3IgXCJwcm9kdWN0aW9uXCIgY29kZSwgdGhpcyBnZXRzIHJlbW92ZWQgYnkgdWdsaWZ5anMuXG4gIGlmICh0eXBlb2YocHJvY2VzcykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhpcy52YWxpZGF0ZU9wdGlvbnNfKCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdldCBhIGdsb2JhbCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgb3B0aW9uLlxuICovXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5nZXRHbG9iYWxVc2VyXyhuYW1lKTtcbiAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZ2V0R2xvYmFsRGVmYXVsdF8obmFtZSk7XG59O1xuXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUuZ2V0R2xvYmFsVXNlcl8gPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICh0aGlzLnVzZXJfLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlcl9bbmFtZV07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUuZ2V0R2xvYmFsRGVmYXVsdF8gPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICh0aGlzLmdsb2JhbF8uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gdGhpcy5nbG9iYWxfW25hbWVdO1xuICB9XG4gIGlmIChERUZBVUxUX0FUVFJTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIERFRkFVTFRfQVRUUlNbbmFtZV07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEdldCBhIHZhbHVlIGZvciBhIHNwZWNpZmljIGF4aXMuIElmIHRoZXJlIGlzIG5vIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgYXhpcyxcbiAqIHRoZSBnbG9iYWwgdmFsdWUgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIG9wdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gYXhpcyB0aGUgYXhpcyB0byBzZWFyY2guIENhbiBiZSB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiAoXCJ5XCIsIFwieTJcIikgb3IgdGhlIGF4aXMgbnVtYmVyICgwLCAxKS5cbiAqL1xuRHlncmFwaE9wdGlvbnMucHJvdG90eXBlLmdldEZvckF4aXMgPSBmdW5jdGlvbihuYW1lLCBheGlzKSB7XG4gIHZhciBheGlzSWR4O1xuICB2YXIgYXhpc1N0cmluZztcblxuICAvLyBTaW5jZSBheGlzIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZywgc3RyYWlnaHRlbiBldmVyeXRoaW5nIG91dCBoZXJlLlxuICBpZiAodHlwZW9mKGF4aXMpID09ICdudW1iZXInKSB7XG4gICAgYXhpc0lkeCA9IGF4aXM7XG4gICAgYXhpc1N0cmluZyA9IGF4aXNJZHggPT09IDAgPyBcInlcIiA6IFwieTJcIjtcbiAgfSBlbHNlIHtcbiAgICBpZiAoYXhpcyA9PSBcInkxXCIpIHsgYXhpcyA9IFwieVwiOyB9IC8vIFN0YW5kYXJkaXplIG9uICd5Jy4gSXMgdGhpcyBiYWQ/IEkgdGhpbmsgc28uXG4gICAgaWYgKGF4aXMgPT0gXCJ5XCIpIHtcbiAgICAgIGF4aXNJZHggPSAwO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PSBcInkyXCIpIHtcbiAgICAgIGF4aXNJZHggPSAxO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PSBcInhcIikge1xuICAgICAgYXhpc0lkeCA9IC0xOyAvLyBzaW1wbHkgYSBwbGFjZWhvbGRlciBmb3IgYmVsb3cuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IFwiVW5rbm93biBheGlzIFwiICsgYXhpcztcbiAgICB9XG4gICAgYXhpc1N0cmluZyA9IGF4aXM7XG4gIH1cblxuICB2YXIgdXNlckF4aXMgPSAoYXhpc0lkeCA9PSAtMSkgPyB0aGlzLnhBeGlzXyA6IHRoaXMueUF4ZXNfW2F4aXNJZHhdO1xuXG4gIC8vIFNlYXJjaCB0aGUgdXNlci1zcGVjaWZpZWQgYXhpcyBvcHRpb24gZmlyc3QuXG4gIGlmICh1c2VyQXhpcykgeyAvLyBUaGlzIGNvbmRpdGlvbiBjb3VsZCBiZSByZW1vdmVkIGlmIHdlIGFsd2F5cyBzZXQgdXAgdGhpcy55QXhlc18gZm9yIHkyLlxuICAgIHZhciBheGlzT3B0aW9ucyA9IHVzZXJBeGlzLm9wdGlvbnM7XG4gICAgaWYgKGF4aXNPcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gYXhpc09wdGlvbnNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlci1zcGVjaWZpZWQgZ2xvYmFsIG9wdGlvbnMgc2Vjb25kLlxuICAvLyBCdXQsIGhhY2ssIGlnbm9yZSBnbG9iYWxseS1zcGVjaWZpZWQgJ2xvZ3NjYWxlJyBmb3IgJ3gnIGF4aXMgZGVjbGFyYXRpb24uXG4gIGlmICghKGF4aXMgPT09ICd4JyAmJiBuYW1lID09PSAnbG9nc2NhbGUnKSkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmdldEdsb2JhbFVzZXJfKG5hbWUpO1xuICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIC8vIERlZmF1bHQgYXhpcyBvcHRpb25zIHRoaXJkLlxuICB2YXIgZGVmYXVsdEF4aXNPcHRpb25zID0gREVGQVVMVF9BVFRSUy5heGVzW2F4aXNTdHJpbmddO1xuICBpZiAoZGVmYXVsdEF4aXNPcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRBeGlzT3B0aW9uc1tuYW1lXTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgZ2xvYmFsIG9wdGlvbnMgbGFzdC5cbiAgcmV0dXJuIHRoaXMuZ2V0R2xvYmFsRGVmYXVsdF8obmFtZSk7XG59O1xuXG4vKipcbiAqIEdldCBhIHZhbHVlIGZvciBhIHNwZWNpZmljIHNlcmllcy4gSWYgdGhlcmUgaXMgbm8gc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBzZXJpZXMsXG4gKiB0aGUgdmFsdWUgZm9yIHRoZSBheGlzIGlzIHJldHVybmVkIChhbmQgYWZ0ZXJ3YXJkcywgdGhlIGdsb2JhbCB2YWx1ZS4pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIG9wdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZXJpZXMgdGhlIHNlcmllcyB0byBzZWFyY2guXG4gKi9cbkR5Z3JhcGhPcHRpb25zLnByb3RvdHlwZS5nZXRGb3JTZXJpZXMgPSBmdW5jdGlvbihuYW1lLCBzZXJpZXMpIHtcbiAgLy8gSG9ub3JzIGluZGV4ZXMgYXMgc2VyaWVzLlxuICBpZiAoc2VyaWVzID09PSB0aGlzLmR5Z3JhcGhfLmdldEhpZ2hsaWdodFNlcmllcygpKSB7XG4gICAgaWYgKHRoaXMuaGlnaGxpZ2h0U2VyaWVzXy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGlnaGxpZ2h0U2VyaWVzX1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRoaXMuc2VyaWVzXy5oYXNPd25Qcm9wZXJ0eShzZXJpZXMpKSB7XG4gICAgdGhyb3cgXCJVbmtub3duIHNlcmllczogXCIgKyBzZXJpZXM7XG4gIH1cblxuICB2YXIgc2VyaWVzT2JqID0gdGhpcy5zZXJpZXNfW3Nlcmllc107XG4gIHZhciBzZXJpZXNPcHRpb25zID0gc2VyaWVzT2JqW1wib3B0aW9uc1wiXTtcbiAgaWYgKHNlcmllc09wdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gc2VyaWVzT3B0aW9uc1tuYW1lXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmdldEZvckF4aXMobmFtZSwgc2VyaWVzT2JqW1wieUF4aXNcIl0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgeS1heGVzIG9uIHRoZSBjaGFydC5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIG51bWJlciBvZiBheGVzLlxuICovXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUubnVtQXhlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy55QXhlc18ubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHktYXhpcyBmb3IgYSBnaXZlbiBzZXJpZXMsIHNwZWNpZmllZCBieSBuYW1lLlxuICovXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUuYXhpc0ZvclNlcmllcyA9IGZ1bmN0aW9uKHNlcmllcykge1xuICByZXR1cm4gdGhpcy5zZXJpZXNfW3Nlcmllc10ueUF4aXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9wdGlvbnMgZm9yIHRoZSBzcGVjaWZpZWQgYXhpcy5cbiAqL1xuLy8gVE9ETyhrb25pZ3NiZXJnKTogdGhpcyBpcyB5LWF4aXMgc3BlY2lmaWMuIFN1cHBvcnQgdGhlIHggYXhpcy5cbkR5Z3JhcGhPcHRpb25zLnByb3RvdHlwZS5heGlzT3B0aW9ucyA9IGZ1bmN0aW9uKHlBeGlzKSB7XG4gIHJldHVybiB0aGlzLnlBeGVzX1t5QXhpc10ub3B0aW9ucztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzZXJpZXMgYXNzb2NpYXRlZCB3aXRoIGFuIGF4aXMuXG4gKi9cbkR5Z3JhcGhPcHRpb25zLnByb3RvdHlwZS5zZXJpZXNGb3JBeGlzID0gZnVuY3Rpb24oeUF4aXMpIHtcbiAgcmV0dXJuIHRoaXMueUF4ZXNfW3lBeGlzXS5zZXJpZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdCBvZiBhbGwgc2VyaWVzLCBpbiB0aGVpciBjb2x1bW5hciBvcmRlci5cbiAqL1xuRHlncmFwaE9wdGlvbnMucHJvdG90eXBlLnNlcmllc05hbWVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmxhYmVsc187XG59O1xuXG4vLyBGb3IgXCJwcm9kdWN0aW9uXCIgY29kZSwgdGhpcyBnZXRzIHJlbW92ZWQgYnkgdWdsaWZ5anMuXG5pZiAodHlwZW9mKHByb2Nlc3MpICE9PSAndW5kZWZpbmVkJykge1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9ICdwcm9kdWN0aW9uJykge1xuXG4vKipcbiAqIFZhbGlkYXRlIGFsbCBvcHRpb25zLlxuICogVGhpcyByZXF1aXJlcyBPUFRJT05TX1JFRkVSRU5DRSwgd2hpY2ggaXMgb25seSBhdmFpbGFibGUgaW4gZGVidWcgYnVpbGRzLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaE9wdGlvbnMucHJvdG90eXBlLnZhbGlkYXRlT3B0aW9uc18gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiBPUFRJT05TX1JFRkVSRU5DRSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyAnQ2FsbGVkIHZhbGlkYXRlT3B0aW9uc18gaW4gcHJvZCBidWlsZC4nO1xuICB9XG5cbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB2YXIgdmFsaWRhdGVPcHRpb24gPSBmdW5jdGlvbihvcHRpb25OYW1lKSB7XG4gICAgaWYgKCFPUFRJT05TX1JFRkVSRU5DRVtvcHRpb25OYW1lXSkge1xuICAgICAgdGhhdC53YXJuSW52YWxpZE9wdGlvbl8ob3B0aW9uTmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBvcHRpb25zRGljdHMgPSBbdGhpcy54QXhpc18ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnlBeGVzX1swXS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMueUF4ZXNfWzFdICYmIHRoaXMueUF4ZXNfWzFdLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxfLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlcl8sXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRTZXJpZXNfXTtcbiAgdmFyIG5hbWVzID0gdGhpcy5zZXJpZXNOYW1lcygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICBpZiAodGhpcy5zZXJpZXNfLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBvcHRpb25zRGljdHMucHVzaCh0aGlzLnNlcmllc19bbmFtZV0ub3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9uc0RpY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpY3QgPSBvcHRpb25zRGljdHNbaV07XG4gICAgaWYgKCFkaWN0KSBjb250aW51ZTtcbiAgICBmb3IgKHZhciBvcHRpb25OYW1lIGluIGRpY3QpIHtcbiAgICAgIGlmIChkaWN0Lmhhc093blByb3BlcnR5KG9wdGlvbk5hbWUpKSB7XG4gICAgICAgIHZhbGlkYXRlT3B0aW9uKG9wdGlvbk5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIFdBUk5JTkdTID0ge307ICAvLyBPbmx5IHNob3cgYW55IHBhcnRpY3VsYXIgd2FybmluZyBvbmNlLlxuXG4vKipcbiAqIExvZ3MgYSB3YXJuaW5nIGFib3V0IGludmFsaWQgb3B0aW9ucy5cbiAqIFRPRE86IG1ha2UgdGhpcyB0aHJvdyBmb3IgdGVzdGluZ1xuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaE9wdGlvbnMucHJvdG90eXBlLndhcm5JbnZhbGlkT3B0aW9uXyA9IGZ1bmN0aW9uKG9wdGlvbk5hbWUpIHtcbiAgaWYgKCFXQVJOSU5HU1tvcHRpb25OYW1lXSkge1xuICAgIFdBUk5JTkdTW29wdGlvbk5hbWVdID0gdHJ1ZTtcbiAgICB2YXIgaXNTZXJpZXMgPSAodGhpcy5sYWJlbHNfLmluZGV4T2Yob3B0aW9uTmFtZSkgPj0gMCk7XG4gICAgaWYgKGlzU2VyaWVzKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1VzZSBuZXctc3R5bGUgcGVyLXNlcmllcyBvcHRpb25zIChzYXcgJyArIG9wdGlvbk5hbWUgKyAnIGFzIHRvcC1sZXZlbCBvcHRpb25zIGtleSkuIFNlZSBodHRwOi8vYml0Lmx5LzF0Y2VhSnMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdVbmtub3duIG9wdGlvbiAnICsgb3B0aW9uTmFtZSArICcgKGZ1bGwgbGlzdCBvZiBvcHRpb25zIGF0IGR5Z3JhcGhzLmNvbS9vcHRpb25zLmh0bWwnKTtcbiAgICB9XG4gICAgdGhyb3cgXCJpbnZhbGlkIG9wdGlvbiBcIiArIG9wdGlvbk5hbWU7XG4gIH1cbn07XG5cbi8vIFJlc2V0IGxpc3Qgb2YgcHJldmlvdXNseS1zaG93biB3YXJuaW5ncy4gVXNlZCBmb3IgdGVzdGluZy5cbkR5Z3JhcGhPcHRpb25zLnJlc2V0V2FybmluZ3NfID0gZnVuY3Rpb24oKSB7XG4gIFdBUk5JTkdTID0ge307XG59O1xuXG59XG59XG5cbmV4cG9ydCBkZWZhdWx0IER5Z3JhcGhPcHRpb25zO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9keWdyYXBocy9zcmMvZHlncmFwaC1vcHRpb25zLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///21\n");

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/*global Dygraph:false */\n\n\n\n/**\nCurrent bits of jankiness:\n- Uses dygraph.layout_ to get the parsed annotations.\n- Uses dygraph.plotter_.area\n\nIt would be nice if the plugin didn't require so much special support inside\nthe core dygraphs classes, but annotations involve quite a bit of parsing and\nlayout.\n\nTODO(danvk): cache DOM elements.\n*/\n\nvar annotations = function annotations() {\n  this.annotations_ = [];\n};\n\nannotations.prototype.toString = function () {\n  return \"Annotations Plugin\";\n};\n\nannotations.prototype.activate = function (g) {\n  return {\n    clearChart: this.clearChart,\n    didDrawChart: this.didDrawChart\n  };\n};\n\nannotations.prototype.detachLabels = function () {\n  for (var i = 0; i < this.annotations_.length; i++) {\n    var a = this.annotations_[i];\n    if (a.parentNode) a.parentNode.removeChild(a);\n    this.annotations_[i] = null;\n  }\n  this.annotations_ = [];\n};\n\nannotations.prototype.clearChart = function (e) {\n  this.detachLabels();\n};\n\nannotations.prototype.didDrawChart = function (e) {\n  var g = e.dygraph;\n\n  // Early out in the (common) case of zero annotations.\n  var points = g.layout_.annotated_points;\n  if (!points || points.length === 0) return;\n\n  var containerDiv = e.canvas.parentNode;\n\n  var bindEvt = function bindEvt(eventName, classEventName, pt) {\n    return function (annotation_event) {\n      var a = pt.annotation;\n      if (a.hasOwnProperty(eventName)) {\n        a[eventName](a, pt, g, annotation_event);\n      } else if (g.getOption(classEventName)) {\n        g.getOption(classEventName)(a, pt, g, annotation_event);\n      }\n    };\n  };\n\n  // Add the annotations one-by-one.\n  var area = e.dygraph.getArea();\n\n  // x-coord to sum of previous annotation's heights (used for stacking).\n  var xToUsedHeight = {};\n\n  for (var i = 0; i < points.length; i++) {\n    var p = points[i];\n    if (p.canvasx < area.x || p.canvasx > area.x + area.w || p.canvasy < area.y || p.canvasy > area.y + area.h) {\n      continue;\n    }\n\n    var a = p.annotation;\n    var tick_height = 6;\n    if (a.hasOwnProperty(\"tickHeight\")) {\n      tick_height = a.tickHeight;\n    }\n\n    // TODO: deprecate axisLabelFontSize in favor of CSS\n    var div = document.createElement(\"div\");\n    div.style['fontSize'] = g.getOption('axisLabelFontSize') + \"px\";\n    var className = 'dygraph-annotation';\n    if (!a.hasOwnProperty('icon')) {\n      // camelCase class names are deprecated.\n      className += ' dygraphDefaultAnnotation dygraph-default-annotation';\n    }\n    if (a.hasOwnProperty('cssClass')) {\n      className += \" \" + a.cssClass;\n    }\n    div.className = className;\n\n    var width = a.hasOwnProperty('width') ? a.width : 16;\n    var height = a.hasOwnProperty('height') ? a.height : 16;\n    if (a.hasOwnProperty('icon')) {\n      var img = document.createElement(\"img\");\n      img.src = a.icon;\n      img.width = width;\n      img.height = height;\n      div.appendChild(img);\n    } else if (p.annotation.hasOwnProperty('shortText')) {\n      div.appendChild(document.createTextNode(p.annotation.shortText));\n    }\n    var left = p.canvasx - width / 2;\n    div.style.left = left + \"px\";\n    var divTop = 0;\n    if (a.attachAtBottom) {\n      var y = area.y + area.h - height - tick_height;\n      if (xToUsedHeight[left]) {\n        y -= xToUsedHeight[left];\n      } else {\n        xToUsedHeight[left] = 0;\n      }\n      xToUsedHeight[left] += tick_height + height;\n      divTop = y;\n    } else {\n      divTop = p.canvasy - height - tick_height;\n    }\n    div.style.top = divTop + \"px\";\n    div.style.width = width + \"px\";\n    div.style.height = height + \"px\";\n    div.title = p.annotation.text;\n    div.style.color = g.colorsMap_[p.name];\n    div.style.borderColor = g.colorsMap_[p.name];\n    a.div = div;\n\n    g.addAndTrackEvent(div, 'click', bindEvt('clickHandler', 'annotationClickHandler', p, this));\n    g.addAndTrackEvent(div, 'mouseover', bindEvt('mouseOverHandler', 'annotationMouseOverHandler', p, this));\n    g.addAndTrackEvent(div, 'mouseout', bindEvt('mouseOutHandler', 'annotationMouseOutHandler', p, this));\n    g.addAndTrackEvent(div, 'dblclick', bindEvt('dblClickHandler', 'annotationDblClickHandler', p, this));\n\n    containerDiv.appendChild(div);\n    this.annotations_.push(div);\n\n    var ctx = e.drawingContext;\n    ctx.save();\n    ctx.strokeStyle = a.hasOwnProperty('tickColor') ? a.tickColor : g.colorsMap_[p.name];\n    ctx.lineWidth = a.hasOwnProperty('tickWidth') ? a.tickWidth : g.getOption('strokeWidth');\n    ctx.beginPath();\n    if (!a.attachAtBottom) {\n      ctx.moveTo(p.canvasx, p.canvasy);\n      ctx.lineTo(p.canvasx, p.canvasy - 2 - tick_height);\n    } else {\n      var y = divTop + height;\n      ctx.moveTo(p.canvasx, y);\n      ctx.lineTo(p.canvasx, y + tick_height);\n    }\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n  }\n};\n\nannotations.prototype.destroy = function () {\n  this.detachLabels();\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (annotations);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL2Fubm90YXRpb25zLmpzPzY1ZTYiXSwibmFtZXMiOlsiYW5ub3RhdGlvbnMiLCJhbm5vdGF0aW9uc18iLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImFjdGl2YXRlIiwiZyIsImNsZWFyQ2hhcnQiLCJkaWREcmF3Q2hhcnQiLCJkZXRhY2hMYWJlbHMiLCJpIiwibGVuZ3RoIiwiYSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImUiLCJkeWdyYXBoIiwicG9pbnRzIiwibGF5b3V0XyIsImFubm90YXRlZF9wb2ludHMiLCJjb250YWluZXJEaXYiLCJjYW52YXMiLCJiaW5kRXZ0IiwiZXZlbnROYW1lIiwiY2xhc3NFdmVudE5hbWUiLCJwdCIsImFubm90YXRpb25fZXZlbnQiLCJhbm5vdGF0aW9uIiwiaGFzT3duUHJvcGVydHkiLCJnZXRPcHRpb24iLCJhcmVhIiwiZ2V0QXJlYSIsInhUb1VzZWRIZWlnaHQiLCJwIiwiY2FudmFzeCIsIngiLCJ3IiwiY2FudmFzeSIsInkiLCJoIiwidGlja19oZWlnaHQiLCJ0aWNrSGVpZ2h0IiwiZGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJjbGFzc05hbWUiLCJjc3NDbGFzcyIsIndpZHRoIiwiaGVpZ2h0IiwiaW1nIiwic3JjIiwiaWNvbiIsImFwcGVuZENoaWxkIiwiY3JlYXRlVGV4dE5vZGUiLCJzaG9ydFRleHQiLCJsZWZ0IiwiZGl2VG9wIiwiYXR0YWNoQXRCb3R0b20iLCJ0b3AiLCJ0aXRsZSIsInRleHQiLCJjb2xvciIsImNvbG9yc01hcF8iLCJuYW1lIiwiYm9yZGVyQ29sb3IiLCJhZGRBbmRUcmFja0V2ZW50IiwicHVzaCIsImN0eCIsImRyYXdpbmdDb250ZXh0Iiwic2F2ZSIsInN0cm9rZVN0eWxlIiwidGlja0NvbG9yIiwibGluZVdpZHRoIiwidGlja1dpZHRoIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRv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QUFKLENBQVc1QyxFQUFFQyxPQUFiLEVBQXNCRCxFQUFFSSxPQUFGLEdBQVksQ0FBWixHQUFnQkcsV0FBdEM7QUFDRCxLQUhELE1BR087QUFDTCxVQUFJRixJQUFJbUIsU0FBU1IsTUFBakI7QUFDQW1CLFVBQUlRLE1BQUosQ0FBVzNDLEVBQUVDLE9BQWIsRUFBc0JJLENBQXRCO0FBQ0E4QixVQUFJUyxNQUFKLENBQVc1QyxFQUFFQyxPQUFiLEVBQXNCSSxJQUFJRSxXQUExQjtBQUNEO0FBQ0Q0QixRQUFJVSxTQUFKO0FBQ0FWLFFBQUlXLE1BQUo7QUFDQVgsUUFBSVksT0FBSjtBQUNEO0FBQ0YsQ0FuSEQ7O0FBcUhBL0UsWUFBWUUsU0FBWixDQUFzQjhFLE9BQXRCLEdBQWdDLFlBQVc7QUFDekMsT0FBS3hFLFlBQUw7QUFDRCxDQUZEOztBQUlBLHlEQUFlUixXQUFmIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTIgRGFuIFZhbmRlcmthbSAoZGFudmRrQGdtYWlsLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbkN1cnJlbnQgYml0cyBvZiBqYW5raW5lc3M6XG4tIFVzZXMgZHlncmFwaC5sYXlvdXRfIHRvIGdldCB0aGUgcGFyc2VkIGFubm90YXRpb25zLlxuLSBVc2VzIGR5Z3JhcGgucGxvdHRlcl8uYXJlYVxuXG5JdCB3b3VsZCBiZSBuaWNlIGlmIHRoZSBwbHVnaW4gZGlkbid0IHJlcXVpcmUgc28gbXVjaCBzcGVjaWFsIHN1cHBvcnQgaW5zaWRlXG50aGUgY29yZSBkeWdyYXBocyBjbGFzc2VzLCBidXQgYW5ub3RhdGlvbnMgaW52b2x2ZSBxdWl0ZSBhIGJpdCBvZiBwYXJzaW5nIGFuZFxubGF5b3V0LlxuXG5UT0RPKGRhbnZrKTogY2FjaGUgRE9NIGVsZW1lbnRzLlxuKi9cblxudmFyIGFubm90YXRpb25zID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYW5ub3RhdGlvbnNfID0gW107XG59O1xuXG5hbm5vdGF0aW9ucy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFwiQW5ub3RhdGlvbnMgUGx1Z2luXCI7XG59O1xuXG5hbm5vdGF0aW9ucy5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbihnKSB7XG4gIHJldHVybiB7XG4gICAgY2xlYXJDaGFydDogdGhpcy5jbGVhckNoYXJ0LFxuICAgIGRpZERyYXdDaGFydDogdGhpcy5kaWREcmF3Q2hhcnRcbiAgfTtcbn07XG5cbmFubm90YXRpb25zLnByb3RvdHlwZS5kZXRhY2hMYWJlbHMgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFubm90YXRpb25zXy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhID0gdGhpcy5hbm5vdGF0aW9uc19baV07XG4gICAgaWYgKGEucGFyZW50Tm9kZSkgYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpO1xuICAgIHRoaXMuYW5ub3RhdGlvbnNfW2ldID0gbnVsbDtcbiAgfVxuICB0aGlzLmFubm90YXRpb25zXyA9IFtdO1xufTtcblxuYW5ub3RhdGlvbnMucHJvdG90eXBlLmNsZWFyQ2hhcnQgPSBmdW5jdGlvbihlKSB7XG4gIHRoaXMuZGV0YWNoTGFiZWxzKCk7XG59O1xuXG5hbm5vdGF0aW9ucy5wcm90b3R5cGUuZGlkRHJhd0NoYXJ0ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgZyA9IGUuZHlncmFwaDtcblxuICAvLyBFYXJseSBvdXQgaW4gdGhlIChjb21tb24pIGNhc2Ugb2YgemVybyBhbm5vdGF0aW9ucy5cbiAgdmFyIHBvaW50cyA9IGcubGF5b3V0Xy5hbm5vdGF0ZWRfcG9pbnRzO1xuICBpZiAoIXBvaW50cyB8fCBwb2ludHMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgdmFyIGNvbnRhaW5lckRpdiA9IGUuY2FudmFzLnBhcmVudE5vZGU7XG5cbiAgdmFyIGJpbmRFdnQgPSBmdW5jdGlvbihldmVudE5hbWUsIGNsYXNzRXZlbnROYW1lLCBwdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihhbm5vdGF0aW9uX2V2ZW50KSB7XG4gICAgICB2YXIgYSA9IHB0LmFubm90YXRpb247XG4gICAgICBpZiAoYS5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgIGFbZXZlbnROYW1lXShhLCBwdCwgZywgYW5ub3RhdGlvbl9ldmVudCk7XG4gICAgICB9IGVsc2UgaWYgKGcuZ2V0T3B0aW9uKGNsYXNzRXZlbnROYW1lKSkge1xuICAgICAgICBnLmdldE9wdGlvbihjbGFzc0V2ZW50TmFtZSkoYSwgcHQsIGcsIGFubm90YXRpb25fZXZlbnQgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIEFkZCB0aGUgYW5ub3RhdGlvbnMgb25lLWJ5LW9uZS5cbiAgdmFyIGFyZWEgPSBlLmR5Z3JhcGguZ2V0QXJlYSgpO1xuXG4gIC8vIHgtY29vcmQgdG8gc3VtIG9mIHByZXZpb3VzIGFubm90YXRpb24ncyBoZWlnaHRzICh1c2VkIGZvciBzdGFja2luZykuXG4gIHZhciB4VG9Vc2VkSGVpZ2h0ID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICBpZiAocC5jYW52YXN4IDwgYXJlYS54IHx8IHAuY2FudmFzeCA+IGFyZWEueCArIGFyZWEudyB8fFxuICAgICAgICBwLmNhbnZhc3kgPCBhcmVhLnkgfHwgcC5jYW52YXN5ID4gYXJlYS55ICsgYXJlYS5oKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IHAuYW5ub3RhdGlvbjtcbiAgICB2YXIgdGlja19oZWlnaHQgPSA2O1xuICAgIGlmIChhLmhhc093blByb3BlcnR5KFwidGlja0hlaWdodFwiKSkge1xuICAgICAgdGlja19oZWlnaHQgPSBhLnRpY2tIZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogZGVwcmVjYXRlIGF4aXNMYWJlbEZvbnRTaXplIGluIGZhdm9yIG9mIENTU1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5zdHlsZVsnZm9udFNpemUnXSA9IGcuZ2V0T3B0aW9uKCdheGlzTGFiZWxGb250U2l6ZScpICsgXCJweFwiO1xuICAgIHZhciBjbGFzc05hbWUgPSAnZHlncmFwaC1hbm5vdGF0aW9uJztcbiAgICBpZiAoIWEuaGFzT3duUHJvcGVydHkoJ2ljb24nKSkge1xuICAgICAgLy8gY2FtZWxDYXNlIGNsYXNzIG5hbWVzIGFyZSBkZXByZWNhdGVkLlxuICAgICAgY2xhc3NOYW1lICs9ICcgZHlncmFwaERlZmF1bHRBbm5vdGF0aW9uIGR5Z3JhcGgtZGVmYXVsdC1hbm5vdGF0aW9uJztcbiAgICB9XG4gICAgaWYgKGEuaGFzT3duUHJvcGVydHkoJ2Nzc0NsYXNzJykpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBcIiArIGEuY3NzQ2xhc3M7XG4gICAgfVxuICAgIGRpdi5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG5cbiAgICB2YXIgd2lkdGggPSBhLmhhc093blByb3BlcnR5KCd3aWR0aCcpID8gYS53aWR0aCA6IDE2O1xuICAgIHZhciBoZWlnaHQgPSBhLmhhc093blByb3BlcnR5KCdoZWlnaHQnKSA/IGEuaGVpZ2h0IDogMTY7XG4gICAgaWYgKGEuaGFzT3duUHJvcGVydHkoJ2ljb24nKSkge1xuICAgICAgdmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICBpbWcuc3JjID0gYS5pY29uO1xuICAgICAgaW1nLndpZHRoID0gd2lkdGg7XG4gICAgICBpbWcuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgZGl2LmFwcGVuZENoaWxkKGltZyk7XG4gICAgfSBlbHNlIGlmIChwLmFubm90YXRpb24uaGFzT3duUHJvcGVydHkoJ3Nob3J0VGV4dCcpKSB7XG4gICAgICBkaXYuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocC5hbm5vdGF0aW9uLnNob3J0VGV4dCkpO1xuICAgIH1cbiAgICB2YXIgbGVmdCA9IHAuY2FudmFzeCAtIHdpZHRoIC8gMjtcbiAgICBkaXYuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgdmFyIGRpdlRvcCA9IDA7XG4gICAgaWYgKGEuYXR0YWNoQXRCb3R0b20pIHtcbiAgICAgIHZhciB5ID0gKGFyZWEueSArIGFyZWEuaCAtIGhlaWdodCAtIHRpY2tfaGVpZ2h0KTtcbiAgICAgIGlmICh4VG9Vc2VkSGVpZ2h0W2xlZnRdKSB7XG4gICAgICAgIHkgLT0geFRvVXNlZEhlaWdodFtsZWZ0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhUb1VzZWRIZWlnaHRbbGVmdF0gPSAwO1xuICAgICAgfVxuICAgICAgeFRvVXNlZEhlaWdodFtsZWZ0XSArPSAodGlja19oZWlnaHQgKyBoZWlnaHQpO1xuICAgICAgZGl2VG9wID0geTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGl2VG9wID0gcC5jYW52YXN5IC0gaGVpZ2h0IC0gdGlja19oZWlnaHQ7XG4gICAgfVxuICAgIGRpdi5zdHlsZS50b3AgPSBkaXZUb3AgKyBcInB4XCI7XG4gICAgZGl2LnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgZGl2LnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICBkaXYudGl0bGUgPSBwLmFubm90YXRpb24udGV4dDtcbiAgICBkaXYuc3R5bGUuY29sb3IgPSBnLmNvbG9yc01hcF9bcC5uYW1lXTtcbiAgICBkaXYuc3R5bGUuYm9yZGVyQ29sb3IgPSBnLmNvbG9yc01hcF9bcC5uYW1lXTtcbiAgICBhLmRpdiA9IGRpdjtcblxuICAgIGcuYWRkQW5kVHJhY2tFdmVudChkaXYsICdjbGljaycsXG4gICAgICAgIGJpbmRFdnQoJ2NsaWNrSGFuZGxlcicsICdhbm5vdGF0aW9uQ2xpY2tIYW5kbGVyJywgcCwgdGhpcykpO1xuICAgIGcuYWRkQW5kVHJhY2tFdmVudChkaXYsICdtb3VzZW92ZXInLFxuICAgICAgICBiaW5kRXZ0KCdtb3VzZU92ZXJIYW5kbGVyJywgJ2Fubm90YXRpb25Nb3VzZU92ZXJIYW5kbGVyJywgcCwgdGhpcykpO1xuICAgIGcuYWRkQW5kVHJhY2tFdmVudChkaXYsICdtb3VzZW91dCcsXG4gICAgICAgIGJpbmRFdnQoJ21vdXNlT3V0SGFuZGxlcicsICdhbm5vdGF0aW9uTW91c2VPdXRIYW5kbGVyJywgcCwgdGhpcykpO1xuICAgIGcuYWRkQW5kVHJhY2tFdmVudChkaXYsICdkYmxjbGljaycsXG4gICAgICAgIGJpbmRFdnQoJ2RibENsaWNrSGFuZGxlcicsICdhbm5vdGF0aW9uRGJsQ2xpY2tIYW5kbGVyJywgcCwgdGhpcykpO1xuXG4gICAgY29udGFpbmVyRGl2LmFwcGVuZENoaWxkKGRpdik7XG4gICAgdGhpcy5hbm5vdGF0aW9uc18ucHVzaChkaXYpO1xuXG4gICAgdmFyIGN0eCA9IGUuZHJhd2luZ0NvbnRleHQ7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBhLmhhc093blByb3BlcnR5KCd0aWNrQ29sb3InKSA/IGEudGlja0NvbG9yIDogZy5jb2xvcnNNYXBfW3AubmFtZV07XG4gICAgY3R4LmxpbmVXaWR0aCA9IGEuaGFzT3duUHJvcGVydHkoJ3RpY2tXaWR0aCcpID8gYS50aWNrV2lkdGggOiBnLmdldE9wdGlvbignc3Ryb2tlV2lkdGgnKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgaWYgKCFhLmF0dGFjaEF0Qm90dG9tKSB7XG4gICAgICBjdHgubW92ZVRvKHAuY2FudmFzeCwgcC5jYW52YXN5KTtcbiAgICAgIGN0eC5saW5lVG8ocC5jYW52YXN4LCBwLmNhbnZhc3kgLSAyIC0gdGlja19oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeSA9IGRpdlRvcCArIGhlaWdodDtcbiAgICAgIGN0eC5tb3ZlVG8ocC5jYW52YXN4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8ocC5jYW52YXN4LCB5ICsgdGlja19oZWlnaHQpO1xuICAgIH1cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn07XG5cbmFubm90YXRpb25zLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGV0YWNoTGFiZWxzKCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBhbm5vdGF0aW9ucztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZHlncmFwaHMvc3JjL3BsdWdpbnMvYW5ub3RhdGlvbnMuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22\n");

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__ = __webpack_require__(0);\n/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/*global Dygraph:false */\n\n\n\n/*\nBits of jankiness:\n- Direct layout access\n- Direct area access\n- Should include calculation of ticks, not just the drawing.\n\nOptions left to make axis-friendly.\n  ('drawAxesAtZero')\n  ('xAxisHeight')\n*/\n\n\n\n/**\n * Draws the axes. This includes the labels on the x- and y-axes, as well\n * as the tick marks on the axes.\n * It does _not_ draw the grid lines which span the entire chart.\n */\nvar axes = function axes() {\n  this.xlabels_ = [];\n  this.ylabels_ = [];\n};\n\naxes.prototype.toString = function () {\n  return 'Axes Plugin';\n};\n\naxes.prototype.activate = function (g) {\n  return {\n    layout: this.layout,\n    clearChart: this.clearChart,\n    willDrawChart: this.willDrawChart\n  };\n};\n\naxes.prototype.layout = function (e) {\n  var g = e.dygraph;\n\n  if (g.getOptionForAxis('drawAxis', 'y')) {\n    var w = g.getOptionForAxis('axisLabelWidth', 'y') + 2 * g.getOptionForAxis('axisTickSize', 'y');\n    e.reserveSpaceLeft(w);\n  }\n\n  if (g.getOptionForAxis('drawAxis', 'x')) {\n    var h;\n    // NOTE: I think this is probably broken now, since g.getOption() now\n    // hits the dictionary. (That is, g.getOption('xAxisHeight') now always\n    // has a value.)\n    if (g.getOption('xAxisHeight')) {\n      h = g.getOption('xAxisHeight');\n    } else {\n      h = g.getOptionForAxis('axisLabelFontSize', 'x') + 2 * g.getOptionForAxis('axisTickSize', 'x');\n    }\n    e.reserveSpaceBottom(h);\n  }\n\n  if (g.numAxes() == 2) {\n    if (g.getOptionForAxis('drawAxis', 'y2')) {\n      var w = g.getOptionForAxis('axisLabelWidth', 'y2') + 2 * g.getOptionForAxis('axisTickSize', 'y2');\n      e.reserveSpaceRight(w);\n    }\n  } else if (g.numAxes() > 2) {\n    g.error('Only two y-axes are supported at this time. (Trying ' + 'to use ' + g.numAxes() + ')');\n  }\n};\n\naxes.prototype.detachLabels = function () {\n  function removeArray(ary) {\n    for (var i = 0; i < ary.length; i++) {\n      var el = ary[i];\n      if (el.parentNode) el.parentNode.removeChild(el);\n    }\n  }\n\n  removeArray(this.xlabels_);\n  removeArray(this.ylabels_);\n  this.xlabels_ = [];\n  this.ylabels_ = [];\n};\n\naxes.prototype.clearChart = function (e) {\n  this.detachLabels();\n};\n\naxes.prototype.willDrawChart = function (e) {\n  var _this = this;\n\n  var g = e.dygraph;\n\n  if (!g.getOptionForAxis('drawAxis', 'x') && !g.getOptionForAxis('drawAxis', 'y') && !g.getOptionForAxis('drawAxis', 'y2')) {\n    return;\n  }\n\n  // Round pixels to half-integer boundaries for crisper drawing.\n  function halfUp(x) {\n    return Math.round(x) + 0.5;\n  }\n  function halfDown(y) {\n    return Math.round(y) - 0.5;\n  }\n\n  var context = e.drawingContext;\n  var containerDiv = e.canvas.parentNode;\n  var canvasWidth = g.width_; // e.canvas.width is affected by pixel ratio.\n  var canvasHeight = g.height_;\n\n  var label, x, y, tick, i;\n\n  var makeLabelStyle = function makeLabelStyle(axis) {\n    return {\n      position: 'absolute',\n      fontSize: g.getOptionForAxis('axisLabelFontSize', axis) + 'px',\n      width: g.getOptionForAxis('axisLabelWidth', axis) + 'px'\n    };\n  };\n\n  var labelStyles = {\n    x: makeLabelStyle('x'),\n    y: makeLabelStyle('y'),\n    y2: makeLabelStyle('y2')\n  };\n\n  var makeDiv = function makeDiv(txt, axis, prec_axis) {\n    /*\n     * This seems to be called with the following three sets of axis/prec_axis:\n     * x: undefined\n     * y: y1\n     * y: y2\n     */\n    var div = document.createElement('div');\n    var labelStyle = labelStyles[prec_axis == 'y2' ? 'y2' : axis];\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"a\" /* update */](div.style, labelStyle);\n    // TODO: combine outer & inner divs\n    var inner_div = document.createElement('div');\n    inner_div.className = 'dygraph-axis-label' + ' dygraph-axis-label-' + axis + (prec_axis ? ' dygraph-axis-label-' + prec_axis : '');\n    inner_div.innerHTML = txt;\n    div.appendChild(inner_div);\n    return div;\n  };\n\n  // axis lines\n  context.save();\n\n  var layout = g.layout_;\n  var area = e.dygraph.plotter_.area;\n\n  // Helper for repeated axis-option accesses.\n  var makeOptionGetter = function makeOptionGetter(axis) {\n    return function (option) {\n      return g.getOptionForAxis(option, axis);\n    };\n  };\n\n  if (g.getOptionForAxis('drawAxis', 'y')) {\n    if (layout.yticks && layout.yticks.length > 0) {\n      var num_axes = g.numAxes();\n      var getOptions = [makeOptionGetter('y'), makeOptionGetter('y2')];\n      layout.yticks.forEach(function (tick) {\n        if (tick.label === undefined) return; // this tick only has a grid line.\n        x = area.x;\n        var sgn = 1;\n        var prec_axis = 'y1';\n        var getAxisOption = getOptions[0];\n        if (tick.axis == 1) {\n          // right-side y-axis\n          x = area.x + area.w;\n          sgn = -1;\n          prec_axis = 'y2';\n          getAxisOption = getOptions[1];\n        }\n        var fontSize = getAxisOption('axisLabelFontSize');\n        y = area.y + tick.pos * area.h;\n\n        /* Tick marks are currently clipped, so don't bother drawing them.\n        context.beginPath();\n        context.moveTo(halfUp(x), halfDown(y));\n        context.lineTo(halfUp(x - sgn * this.attr_('axisTickSize')), halfDown(y));\n        context.closePath();\n        context.stroke();\n        */\n\n        label = makeDiv(tick.label, 'y', num_axes == 2 ? prec_axis : null);\n        var top = y - fontSize / 2;\n        if (top < 0) top = 0;\n\n        if (top + fontSize + 3 > canvasHeight) {\n          label.style.bottom = '0';\n        } else {\n          label.style.top = top + 'px';\n        }\n        // TODO: replace these with css classes?\n        if (tick.axis === 0) {\n          label.style.left = area.x - getAxisOption('axisLabelWidth') - getAxisOption('axisTickSize') + 'px';\n          label.style.textAlign = 'right';\n        } else if (tick.axis == 1) {\n          label.style.left = area.x + area.w + getAxisOption('axisTickSize') + 'px';\n          label.style.textAlign = 'left';\n        }\n        label.style.width = getAxisOption('axisLabelWidth') + 'px';\n        containerDiv.appendChild(label);\n        _this.ylabels_.push(label);\n      });\n\n      // The lowest tick on the y-axis often overlaps with the leftmost\n      // tick on the x-axis. Shift the bottom tick up a little bit to\n      // compensate if necessary.\n      var bottomTick = this.ylabels_[0];\n      // Interested in the y2 axis also?\n      var fontSize = g.getOptionForAxis('axisLabelFontSize', 'y');\n      var bottom = parseInt(bottomTick.style.top, 10) + fontSize;\n      if (bottom > canvasHeight - fontSize) {\n        bottomTick.style.top = parseInt(bottomTick.style.top, 10) - fontSize / 2 + 'px';\n      }\n    }\n\n    // draw a vertical line on the left to separate the chart from the labels.\n    var axisX;\n    if (g.getOption('drawAxesAtZero')) {\n      var r = g.toPercentXCoord(0);\n      if (r > 1 || r < 0 || isNaN(r)) r = 0;\n      axisX = halfUp(area.x + r * area.w);\n    } else {\n      axisX = halfUp(area.x);\n    }\n\n    context.strokeStyle = g.getOptionForAxis('axisLineColor', 'y');\n    context.lineWidth = g.getOptionForAxis('axisLineWidth', 'y');\n\n    context.beginPath();\n    context.moveTo(axisX, halfDown(area.y));\n    context.lineTo(axisX, halfDown(area.y + area.h));\n    context.closePath();\n    context.stroke();\n\n    // if there's a secondary y-axis, draw a vertical line for that, too.\n    if (g.numAxes() == 2) {\n      context.strokeStyle = g.getOptionForAxis('axisLineColor', 'y2');\n      context.lineWidth = g.getOptionForAxis('axisLineWidth', 'y2');\n      context.beginPath();\n      context.moveTo(halfDown(area.x + area.w), halfDown(area.y));\n      context.lineTo(halfDown(area.x + area.w), halfDown(area.y + area.h));\n      context.closePath();\n      context.stroke();\n    }\n  }\n\n  if (g.getOptionForAxis('drawAxis', 'x')) {\n    if (layout.xticks) {\n      var getAxisOption = makeOptionGetter('x');\n      layout.xticks.forEach(function (tick) {\n        if (tick.label === undefined) return; // this tick only has a grid line.\n        x = area.x + tick.pos * area.w;\n        y = area.y + area.h;\n\n        /* Tick marks are currently clipped, so don't bother drawing them.\n        context.beginPath();\n        context.moveTo(halfUp(x), halfDown(y));\n        context.lineTo(halfUp(x), halfDown(y + this.attr_('axisTickSize')));\n        context.closePath();\n        context.stroke();\n        */\n\n        label = makeDiv(tick.label, 'x');\n        label.style.textAlign = 'center';\n        label.style.top = y + getAxisOption('axisTickSize') + 'px';\n\n        var left = x - getAxisOption('axisLabelWidth') / 2;\n        if (left + getAxisOption('axisLabelWidth') > canvasWidth) {\n          left = canvasWidth - getAxisOption('axisLabelWidth');\n          label.style.textAlign = 'right';\n        }\n        if (left < 0) {\n          left = 0;\n          label.style.textAlign = 'left';\n        }\n\n        label.style.left = left + 'px';\n        label.style.width = getAxisOption('axisLabelWidth') + 'px';\n        containerDiv.appendChild(label);\n        _this.xlabels_.push(label);\n      });\n    }\n\n    context.strokeStyle = g.getOptionForAxis('axisLineColor', 'x');\n    context.lineWidth = g.getOptionForAxis('axisLineWidth', 'x');\n    context.beginPath();\n    var axisY;\n    if (g.getOption('drawAxesAtZero')) {\n      var r = g.toPercentYCoord(0, 0);\n      if (r > 1 || r < 0) r = 1;\n      axisY = halfDown(area.y + r * area.h);\n    } else {\n      axisY = halfDown(area.y + area.h);\n    }\n    context.moveTo(halfUp(area.x), axisY);\n    context.lineTo(halfUp(area.x + area.w), axisY);\n    context.closePath();\n    context.stroke();\n  }\n\n  context.restore();\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (axes);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL2F4ZXMuanM/OWQzMiJdLCJuYW1lcyI6WyJheGVzIiwieGxhYmVsc18iLCJ5bGFiZWxzXyIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiYWN0aXZhdGUiLCJnIiwibGF5b3V0IiwiY2xlYXJDaGFydCIsIndpbGxEcmF3Q2hhcnQiLCJlIiwiZHlncmFwaCIsImdldE9wdGlvbkZvckF4aXMiLCJ3IiwicmVzZXJ2ZVNwYWNlTGVmdCIsImgiLCJnZXRPcHRpb24iLCJyZXNlcnZlU3BhY2VCb3R0b20iLCJudW1BeGVzIiwicmVzZXJ2ZVNwYWNlUmlnaHQiLCJlcnJvciIsImRldGFjaExhYmVscyIsInJlbW92ZUFycmF5IiwiYXJ5IiwiaSIsImxlbmd0aCIsImVsIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiaGFsZlVwIiwieCIsIk1hdGgiLCJyb3VuZCIsImhhbGZEb3duIiwieSIsImNvbnRleHQiLCJkcmF3aW5nQ29udGV4dCIsImNvbnRhaW5lckRpdiIsImNhbnZhcyIsImNhbnZhc1dpZHRoIiwid2lkdGhfIiwiY2FudmFzSGVpZ2h0IiwiaGVpZ2h0XyIsImxhYmVsIiwidGljayIsIm1ha2VMYWJlbFN0eWxlIiwiYXhpcyIsInBvc2l0aW9uIiwiZm9udFNpemUiLCJ3aWR0aCIsImxhYmVsU3R5bGVzIiwieTIiLCJtYWtlRGl2IiwidHh0IiwicHJlY19heGlzIiwiZGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwibGFiZWxTdHlsZSIsInV0aWxzIiwic3R5bGUiLCJpbm5lcl9kaXYiLCJjbGFzc05hbWUiLCJpbm5lckhUTUwiLCJhcHBlbmRDaGlsZCIsInNhdmUiLCJsYXlvdXRfIiwiYXJlYSIsInBsb3R0ZXJfIiwibWFrZU9wdGlvbkdldHRlciIsIm9wdGlvbiIsInl0aWNrcyIsIm51bV9heGVzIiwiZ2V0T3B0aW9ucyIsImZvckVhY2giLCJ1bmRlZmluZWQiLCJzZ24iLCJnZXRBeGlzT3B0aW9uIiwicG9zIiwidG9wIiwiYm90dG9tIiwibGVmdCIsInRleHRBbGlnbiIsInB1c2giLCJib3R0b21UaWNrIiwicGFyc2VJbnQiLCJheGlzWCIsInIiLCJ0b1BlcmNlbnRYQ29vcmQiLCJpc05hTiIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwiY2xvc2VQYXRoIiwic3Ryb2tlIiwieHRpY2tzIiwiYXhpc1kiLCJ0b1BlcmNlbnRZQ29vcmQiLCJyZXN0b3JlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOzs7Ozs7QUFNQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQTs7Ozs7QUFLQSxJQUFJQSxPQUFPLFNBQVBBLElBQU8sR0FBVztBQUNwQixPQUFLQyxRQUFMLEdBQWdCLEVBQWhCO0FBQ0EsT0FBS0MsUUFBTCxHQUFnQixFQUFoQjtBQUNELENBSEQ7O0FBS0FGLEtBQUtHLFNBQUwsQ0FBZUMsUUFBZixHQUEwQixZQUFXO0FBQ25DLFNBQU8sYUFBUDtBQUNELENBRkQ7O0FBSUFKLEtBQUtHLFNBQUwsQ0FBZUUsUUFBZixHQUEwQixVQUFTQyxDQUFULEVBQVk7QUFDcEMsU0FBTztBQUNMQyxZQUFRLEtBQUtBLE1BRFI7QUFFTEMsZ0JBQVksS0FBS0EsVUFGWjtBQUdMQyxtQkFBZSxLQUFLQTtBQUhmLEdBQVA7QUFLRCxDQU5EOztBQVFBVCxLQUFLRyxTQUFMLENBQWVJLE1BQWYsR0FBd0IsVUFBU0csQ0FBVCxFQUFZO0FBQ2xDLE1BQUlKLElBQUlJLEVBQUVDLE9BQVY7O0FBRUEsTUFBSUwsRUFBRU0sZ0JBQUYsQ0FBbUIsVUFBbkIsRUFBK0IsR0FBL0IsQ0FBSixFQUF5QztBQUN2QyxRQUFJQyxJQUFJUCxFQUFFTSxnQkFBRixDQUFtQixnQkFBbkIsRUFBcUMsR0FBckMsSUFBNEMsSUFBSU4sRUFBRU0sZ0JBQUYsQ0FBbUIsY0FBbkIsRUFBbUMsR0FBbkMsQ0FBeEQ7QUFDQUYsTUFBRUksZ0JBQUYsQ0FBbUJELENBQW5C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RixDQUFZLGdCQUFaLENBQUosRUFBbUM7QUFDakMsVUFBSXVFLElBQUlqRixFQUFFNkYsZUFBRixDQUFrQixDQUFsQixFQUFxQixDQUFyQixDQUFSO0FBQ0EsVUFBSVosSUFBSSxDQUFKLElBQVNBLElBQUksQ0FBakIsRUFBb0JBLElBQUksQ0FBSjtBQUNwQlcsY0FBUWpFLFNBQVNrQyxLQUFLakMsQ0FBTCxHQUFTcUQsSUFBSXBCLEtBQUtwRCxDQUEzQixDQUFSO0FBQ0QsS0FKRCxNQUlPO0FBQ0xtRixjQUFRakUsU0FBU2tDLEtBQUtqQyxDQUFMLEdBQVNpQyxLQUFLcEQsQ0FBdkIsQ0FBUjtBQUNEO0FBQ0RvQixZQUFRMEQsTUFBUixDQUFlaEUsT0FBT3NDLEtBQUtyQyxDQUFaLENBQWYsRUFBK0JvRSxLQUEvQjtBQUNBL0QsWUFBUTJELE1BQVIsQ0FBZWpFLE9BQU9zQyxLQUFLckMsQ0FBTCxHQUFTcUMsS0FBS3RELENBQXJCLENBQWYsRUFBd0NxRixLQUF4QztBQUNBL0QsWUFBUTRELFNBQVI7QUFDQTVELFlBQVE2RCxNQUFSO0FBQ0Q7O0FBRUQ3RCxVQUFRaUUsT0FBUjtBQUNELENBeE5EOztBQTBOQSx5REFBZXBHLElBQWYiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMiBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKlxuQml0cyBvZiBqYW5raW5lc3M6XG4tIERpcmVjdCBsYXlvdXQgYWNjZXNzXG4tIERpcmVjdCBhcmVhIGFjY2Vzc1xuLSBTaG91bGQgaW5jbHVkZSBjYWxjdWxhdGlvbiBvZiB0aWNrcywgbm90IGp1c3QgdGhlIGRyYXdpbmcuXG5cbk9wdGlvbnMgbGVmdCB0byBtYWtlIGF4aXMtZnJpZW5kbHkuXG4gICgnZHJhd0F4ZXNBdFplcm8nKVxuICAoJ3hBeGlzSGVpZ2h0JylcbiovXG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL2R5Z3JhcGgtdXRpbHMnO1xuXG4vKipcbiAqIERyYXdzIHRoZSBheGVzLiBUaGlzIGluY2x1ZGVzIHRoZSBsYWJlbHMgb24gdGhlIHgtIGFuZCB5LWF4ZXMsIGFzIHdlbGxcbiAqIGFzIHRoZSB0aWNrIG1hcmtzIG9uIHRoZSBheGVzLlxuICogSXQgZG9lcyBfbm90XyBkcmF3IHRoZSBncmlkIGxpbmVzIHdoaWNoIHNwYW4gdGhlIGVudGlyZSBjaGFydC5cbiAqL1xudmFyIGF4ZXMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy54bGFiZWxzXyA9IFtdO1xuICB0aGlzLnlsYWJlbHNfID0gW107XG59O1xuXG5heGVzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ0F4ZXMgUGx1Z2luJztcbn07XG5cbmF4ZXMucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oZykge1xuICByZXR1cm4ge1xuICAgIGxheW91dDogdGhpcy5sYXlvdXQsXG4gICAgY2xlYXJDaGFydDogdGhpcy5jbGVhckNoYXJ0LFxuICAgIHdpbGxEcmF3Q2hhcnQ6IHRoaXMud2lsbERyYXdDaGFydFxuICB9O1xufTtcblxuYXhlcy5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgZyA9IGUuZHlncmFwaDtcblxuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3QXhpcycsICd5JykpIHtcbiAgICB2YXIgdyA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xhYmVsV2lkdGgnLCAneScpICsgMiAqIGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc1RpY2tTaXplJywgJ3knKTtcbiAgICBlLnJlc2VydmVTcGFjZUxlZnQodyk7XG4gIH1cblxuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3QXhpcycsICd4JykpIHtcbiAgICB2YXIgaDtcbiAgICAvLyBOT1RFOiBJIHRoaW5rIHRoaXMgaXMgcHJvYmFibHkgYnJva2VuIG5vdywgc2luY2UgZy5nZXRPcHRpb24oKSBub3dcbiAgICAvLyBoaXRzIHRoZSBkaWN0aW9uYXJ5LiAoVGhhdCBpcywgZy5nZXRPcHRpb24oJ3hBeGlzSGVpZ2h0Jykgbm93IGFsd2F5c1xuICAgIC8vIGhhcyBhIHZhbHVlLilcbiAgICBpZiAoZy5nZXRPcHRpb24oJ3hBeGlzSGVpZ2h0JykpIHtcbiAgICAgIGggPSBnLmdldE9wdGlvbigneEF4aXNIZWlnaHQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xhYmVsRm9udFNpemUnLCAneCcpICsgMiAqIGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc1RpY2tTaXplJywgJ3gnKTtcbiAgICB9XG4gICAgZS5yZXNlcnZlU3BhY2VCb3R0b20oaCk7XG4gIH1cblxuICBpZiAoZy5udW1BeGVzKCkgPT0gMikge1xuICAgIGlmIChnLmdldE9wdGlvbkZvckF4aXMoJ2RyYXdBeGlzJywgJ3kyJykpIHtcbiAgICAgIHZhciB3ID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGFiZWxXaWR0aCcsICd5MicpICsgMiAqIGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc1RpY2tTaXplJywgJ3kyJyk7XG4gICAgICBlLnJlc2VydmVTcGFjZVJpZ2h0KHcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChnLm51bUF4ZXMoKSA+IDIpIHtcbiAgICBnLmVycm9yKCdPbmx5IHR3byB5LWF4ZXMgYXJlIHN1cHBvcnRlZCBhdCB0aGlzIHRpbWUuIChUcnlpbmcgJyArXG4gICAgICAgICAgICAndG8gdXNlICcgKyBnLm51bUF4ZXMoKSArICcpJyk7XG4gIH1cbn07XG5cbmF4ZXMucHJvdG90eXBlLmRldGFjaExhYmVscyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiByZW1vdmVBcnJheShhcnkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsID0gYXJ5W2ldO1xuICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUFycmF5KHRoaXMueGxhYmVsc18pO1xuICByZW1vdmVBcnJheSh0aGlzLnlsYWJlbHNfKTtcbiAgdGhpcy54bGFiZWxzXyA9IFtdO1xuICB0aGlzLnlsYWJlbHNfID0gW107XG59O1xuXG5heGVzLnByb3RvdHlwZS5jbGVhckNoYXJ0ID0gZnVuY3Rpb24oZSkge1xuICB0aGlzLmRldGFjaExhYmVscygpO1xufTtcblxuYXhlcy5wcm90b3R5cGUud2lsbERyYXdDaGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIGcgPSBlLmR5Z3JhcGg7XG5cbiAgaWYgKCFnLmdldE9wdGlvbkZvckF4aXMoJ2RyYXdBeGlzJywgJ3gnKSAmJlxuICAgICAgIWcuZ2V0T3B0aW9uRm9yQXhpcygnZHJhd0F4aXMnLCAneScpICYmXG4gICAgICAhZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3QXhpcycsICd5MicpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUm91bmQgcGl4ZWxzIHRvIGhhbGYtaW50ZWdlciBib3VuZGFyaWVzIGZvciBjcmlzcGVyIGRyYXdpbmcuXG4gIGZ1bmN0aW9uIGhhbGZVcCh4KSAgeyByZXR1cm4gTWF0aC5yb3VuZCh4KSArIDAuNTsgfVxuICBmdW5jdGlvbiBoYWxmRG93bih5KXsgcmV0dXJuIE1hdGgucm91bmQoeSkgLSAwLjU7IH1cblxuICB2YXIgY29udGV4dCA9IGUuZHJhd2luZ0NvbnRleHQ7XG4gIHZhciBjb250YWluZXJEaXYgPSBlLmNhbnZhcy5wYXJlbnROb2RlO1xuICB2YXIgY2FudmFzV2lkdGggPSBnLndpZHRoXzsgIC8vIGUuY2FudmFzLndpZHRoIGlzIGFmZmVjdGVkIGJ5IHBpeGVsIHJhdGlvLlxuICB2YXIgY2FudmFzSGVpZ2h0ID0gZy5oZWlnaHRfO1xuXG4gIHZhciBsYWJlbCwgeCwgeSwgdGljaywgaTtcblxuICB2YXIgbWFrZUxhYmVsU3R5bGUgPSBmdW5jdGlvbihheGlzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgZm9udFNpemU6IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xhYmVsRm9udFNpemUnLCBheGlzKSArICdweCcsXG4gICAgICB3aWR0aDogZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGFiZWxXaWR0aCcsIGF4aXMpICsgJ3B4JyxcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsYWJlbFN0eWxlcyA9IHtcbiAgICB4OiBtYWtlTGFiZWxTdHlsZSgneCcpLFxuICAgIHk6IG1ha2VMYWJlbFN0eWxlKCd5JyksXG4gICAgeTI6IG1ha2VMYWJlbFN0eWxlKCd5MicpXG4gIH07XG5cbiAgdmFyIG1ha2VEaXYgPSBmdW5jdGlvbih0eHQsIGF4aXMsIHByZWNfYXhpcykge1xuICAgIC8qXG4gICAgICogVGhpcyBzZWVtcyB0byBiZSBjYWxsZWQgd2l0aCB0aGUgZm9sbG93aW5nIHRocmVlIHNldHMgb2YgYXhpcy9wcmVjX2F4aXM6XG4gICAgICogeDogdW5kZWZpbmVkXG4gICAgICogeTogeTFcbiAgICAgKiB5OiB5MlxuICAgICAqL1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgbGFiZWxTdHlsZSA9IGxhYmVsU3R5bGVzW3ByZWNfYXhpcyA9PSAneTInID8gJ3kyJyA6IGF4aXNdO1xuICAgIHV0aWxzLnVwZGF0ZShkaXYuc3R5bGUsIGxhYmVsU3R5bGUpO1xuICAgIC8vIFRPRE86IGNvbWJpbmUgb3V0ZXIgJiBpbm5lciBkaXZzXG4gICAgdmFyIGlubmVyX2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGlubmVyX2Rpdi5jbGFzc05hbWUgPSAnZHlncmFwaC1heGlzLWxhYmVsJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICcgZHlncmFwaC1heGlzLWxhYmVsLScgKyBheGlzICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKHByZWNfYXhpcyA/ICcgZHlncmFwaC1heGlzLWxhYmVsLScgKyBwcmVjX2F4aXMgOiAnJyk7XG4gICAgaW5uZXJfZGl2LmlubmVySFRNTCA9IHR4dDtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoaW5uZXJfZGl2KTtcbiAgICByZXR1cm4gZGl2O1xuICB9O1xuXG4gIC8vIGF4aXMgbGluZXNcbiAgY29udGV4dC5zYXZlKCk7XG5cbiAgdmFyIGxheW91dCA9IGcubGF5b3V0XztcbiAgdmFyIGFyZWEgPSBlLmR5Z3JhcGgucGxvdHRlcl8uYXJlYTtcblxuICAvLyBIZWxwZXIgZm9yIHJlcGVhdGVkIGF4aXMtb3B0aW9uIGFjY2Vzc2VzLlxuICB2YXIgbWFrZU9wdGlvbkdldHRlciA9IGZ1bmN0aW9uKGF4aXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICByZXR1cm4gZy5nZXRPcHRpb25Gb3JBeGlzKG9wdGlvbiwgYXhpcyk7XG4gICAgfTtcbiAgfTtcblxuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3QXhpcycsICd5JykpIHtcbiAgICBpZiAobGF5b3V0Lnl0aWNrcyAmJiBsYXlvdXQueXRpY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBudW1fYXhlcyA9IGcubnVtQXhlcygpO1xuICAgICAgdmFyIGdldE9wdGlvbnMgPSBbbWFrZU9wdGlvbkdldHRlcigneScpLCBtYWtlT3B0aW9uR2V0dGVyKCd5MicpXTtcbiAgICAgIGxheW91dC55dGlja3MuZm9yRWFjaCh0aWNrID0+IHtcbiAgICAgICAgaWYgKHRpY2subGFiZWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAgLy8gdGhpcyB0aWNrIG9ubHkgaGFzIGEgZ3JpZCBsaW5lLlxuICAgICAgICB4ID0gYXJlYS54O1xuICAgICAgICB2YXIgc2duID0gMTtcbiAgICAgICAgdmFyIHByZWNfYXhpcyA9ICd5MSc7XG4gICAgICAgIHZhciBnZXRBeGlzT3B0aW9uID0gZ2V0T3B0aW9uc1swXTtcbiAgICAgICAgaWYgKHRpY2suYXhpcyA9PSAxKSB7ICAvLyByaWdodC1zaWRlIHktYXhpc1xuICAgICAgICAgIHggPSBhcmVhLnggKyBhcmVhLnc7XG4gICAgICAgICAgc2duID0gLTE7XG4gICAgICAgICAgcHJlY19heGlzID0gJ3kyJztcbiAgICAgICAgICBnZXRBeGlzT3B0aW9uID0gZ2V0T3B0aW9uc1sxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9udFNpemUgPSBnZXRBeGlzT3B0aW9uKCdheGlzTGFiZWxGb250U2l6ZScpO1xuICAgICAgICB5ID0gYXJlYS55ICsgdGljay5wb3MgKiBhcmVhLmg7XG5cbiAgICAgICAgLyogVGljayBtYXJrcyBhcmUgY3VycmVudGx5IGNsaXBwZWQsIHNvIGRvbid0IGJvdGhlciBkcmF3aW5nIHRoZW0uXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKGhhbGZVcCh4KSwgaGFsZkRvd24oeSkpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhoYWxmVXAoeCAtIHNnbiAqIHRoaXMuYXR0cl8oJ2F4aXNUaWNrU2l6ZScpKSwgaGFsZkRvd24oeSkpO1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAqL1xuXG4gICAgICAgIGxhYmVsID0gbWFrZURpdih0aWNrLmxhYmVsLCAneScsIG51bV9heGVzID09IDIgPyBwcmVjX2F4aXMgOiBudWxsKTtcbiAgICAgICAgdmFyIHRvcCA9ICh5IC0gZm9udFNpemUgLyAyKTtcbiAgICAgICAgaWYgKHRvcCA8IDApIHRvcCA9IDA7XG5cbiAgICAgICAgaWYgKHRvcCArIGZvbnRTaXplICsgMyA+IGNhbnZhc0hlaWdodCkge1xuICAgICAgICAgIGxhYmVsLnN0eWxlLmJvdHRvbSA9ICcwJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYWJlbC5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJlcGxhY2UgdGhlc2Ugd2l0aCBjc3MgY2xhc3Nlcz9cbiAgICAgICAgaWYgKHRpY2suYXhpcyA9PT0gMCkge1xuICAgICAgICAgIGxhYmVsLnN0eWxlLmxlZnQgPSAoYXJlYS54IC0gZ2V0QXhpc09wdGlvbignYXhpc0xhYmVsV2lkdGgnKSAtIGdldEF4aXNPcHRpb24oJ2F4aXNUaWNrU2l6ZScpKSArICdweCc7XG4gICAgICAgICAgbGFiZWwuc3R5bGUudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmICh0aWNrLmF4aXMgPT0gMSkge1xuICAgICAgICAgIGxhYmVsLnN0eWxlLmxlZnQgPSAoYXJlYS54ICsgYXJlYS53ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEF4aXNPcHRpb24oJ2F4aXNUaWNrU2l6ZScpKSArICdweCc7XG4gICAgICAgICAgbGFiZWwuc3R5bGUudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgICAgIGxhYmVsLnN0eWxlLndpZHRoID0gZ2V0QXhpc09wdGlvbignYXhpc0xhYmVsV2lkdGgnKSArICdweCc7XG4gICAgICAgIGNvbnRhaW5lckRpdi5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICAgIHRoaXMueWxhYmVsc18ucHVzaChsYWJlbCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gVGhlIGxvd2VzdCB0aWNrIG9uIHRoZSB5LWF4aXMgb2Z0ZW4gb3ZlcmxhcHMgd2l0aCB0aGUgbGVmdG1vc3RcbiAgICAgIC8vIHRpY2sgb24gdGhlIHgtYXhpcy4gU2hpZnQgdGhlIGJvdHRvbSB0aWNrIHVwIGEgbGl0dGxlIGJpdCB0b1xuICAgICAgLy8gY29tcGVuc2F0ZSBpZiBuZWNlc3NhcnkuXG4gICAgICB2YXIgYm90dG9tVGljayA9IHRoaXMueWxhYmVsc19bMF07XG4gICAgICAvLyBJbnRlcmVzdGVkIGluIHRoZSB5MiBheGlzIGFsc28/XG4gICAgICB2YXIgZm9udFNpemUgPSBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMYWJlbEZvbnRTaXplJywgJ3knKTtcbiAgICAgIHZhciBib3R0b20gPSBwYXJzZUludChib3R0b21UaWNrLnN0eWxlLnRvcCwgMTApICsgZm9udFNpemU7XG4gICAgICBpZiAoYm90dG9tID4gY2FudmFzSGVpZ2h0IC0gZm9udFNpemUpIHtcbiAgICAgICAgYm90dG9tVGljay5zdHlsZS50b3AgPSAocGFyc2VJbnQoYm90dG9tVGljay5zdHlsZS50b3AsIDEwKSAtXG4gICAgICAgICAgICBmb250U2l6ZSAvIDIpICsgJ3B4JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkcmF3IGEgdmVydGljYWwgbGluZSBvbiB0aGUgbGVmdCB0byBzZXBhcmF0ZSB0aGUgY2hhcnQgZnJvbSB0aGUgbGFiZWxzLlxuICAgIHZhciBheGlzWDtcbiAgICBpZiAoZy5nZXRPcHRpb24oJ2RyYXdBeGVzQXRaZXJvJykpIHtcbiAgICAgIHZhciByID0gZy50b1BlcmNlbnRYQ29vcmQoMCk7XG4gICAgICBpZiAociA+IDEgfHwgciA8IDAgfHwgaXNOYU4ocikpIHIgPSAwO1xuICAgICAgYXhpc1ggPSBoYWxmVXAoYXJlYS54ICsgciAqIGFyZWEudyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF4aXNYID0gaGFsZlVwKGFyZWEueCk7XG4gICAgfVxuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xpbmVDb2xvcicsICd5Jyk7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMaW5lV2lkdGgnLCAneScpO1xuXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhheGlzWCwgaGFsZkRvd24oYXJlYS55KSk7XG4gICAgY29udGV4dC5saW5lVG8oYXhpc1gsIGhhbGZEb3duKGFyZWEueSArIGFyZWEuaCkpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5zdHJva2UoKTtcblxuICAgIC8vIGlmIHRoZXJlJ3MgYSBzZWNvbmRhcnkgeS1heGlzLCBkcmF3IGEgdmVydGljYWwgbGluZSBmb3IgdGhhdCwgdG9vLlxuICAgIGlmIChnLm51bUF4ZXMoKSA9PSAyKSB7XG4gICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGluZUNvbG9yJywgJ3kyJyk7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xpbmVXaWR0aCcsICd5MicpO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKGhhbGZEb3duKGFyZWEueCArIGFyZWEudyksIGhhbGZEb3duKGFyZWEueSkpO1xuICAgICAgY29udGV4dC5saW5lVG8oaGFsZkRvd24oYXJlYS54ICsgYXJlYS53KSwgaGFsZkRvd24oYXJlYS55ICsgYXJlYS5oKSk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3QXhpcycsICd4JykpIHtcbiAgICBpZiAobGF5b3V0Lnh0aWNrcykge1xuICAgICAgdmFyIGdldEF4aXNPcHRpb24gPSBtYWtlT3B0aW9uR2V0dGVyKCd4Jyk7XG4gICAgICBsYXlvdXQueHRpY2tzLmZvckVhY2godGljayA9PiB7XG4gICAgICAgIGlmICh0aWNrLmxhYmVsID09PSB1bmRlZmluZWQpIHJldHVybjsgIC8vIHRoaXMgdGljayBvbmx5IGhhcyBhIGdyaWQgbGluZS5cbiAgICAgICAgeCA9IGFyZWEueCArIHRpY2sucG9zICogYXJlYS53O1xuICAgICAgICB5ID0gYXJlYS55ICsgYXJlYS5oO1xuXG4gICAgICAgIC8qIFRpY2sgbWFya3MgYXJlIGN1cnJlbnRseSBjbGlwcGVkLCBzbyBkb24ndCBib3RoZXIgZHJhd2luZyB0aGVtLlxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhoYWxmVXAoeCksIGhhbGZEb3duKHkpKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oaGFsZlVwKHgpLCBoYWxmRG93bih5ICsgdGhpcy5hdHRyXygnYXhpc1RpY2tTaXplJykpKTtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgKi9cblxuICAgICAgICBsYWJlbCA9IG1ha2VEaXYodGljay5sYWJlbCwgJ3gnKTtcbiAgICAgICAgbGFiZWwuc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIGxhYmVsLnN0eWxlLnRvcCA9ICh5ICsgZ2V0QXhpc09wdGlvbignYXhpc1RpY2tTaXplJykpICsgJ3B4JztcblxuICAgICAgICB2YXIgbGVmdCA9ICh4IC0gZ2V0QXhpc09wdGlvbignYXhpc0xhYmVsV2lkdGgnKS8yKTtcbiAgICAgICAgaWYgKGxlZnQgKyBnZXRBeGlzT3B0aW9uKCdheGlzTGFiZWxXaWR0aCcpID4gY2FudmFzV2lkdGgpIHtcbiAgICAgICAgICBsZWZ0ID0gY2FudmFzV2lkdGggLSBnZXRBeGlzT3B0aW9uKCdheGlzTGFiZWxXaWR0aCcpO1xuICAgICAgICAgIGxhYmVsLnN0eWxlLnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICAgICAgbGVmdCA9IDA7XG4gICAgICAgICAgbGFiZWwuc3R5bGUudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWwuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xuICAgICAgICBsYWJlbC5zdHlsZS53aWR0aCA9IGdldEF4aXNPcHRpb24oJ2F4aXNMYWJlbFdpZHRoJykgKyAncHgnO1xuICAgICAgICBjb250YWluZXJEaXYuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgICAgICB0aGlzLnhsYWJlbHNfLnB1c2gobGFiZWwpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xpbmVDb2xvcicsICd4Jyk7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMaW5lV2lkdGgnLCAneCcpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgdmFyIGF4aXNZO1xuICAgIGlmIChnLmdldE9wdGlvbignZHJhd0F4ZXNBdFplcm8nKSkge1xuICAgICAgdmFyIHIgPSBnLnRvUGVyY2VudFlDb29yZCgwLCAwKTtcbiAgICAgIGlmIChyID4gMSB8fCByIDwgMCkgciA9IDE7XG4gICAgICBheGlzWSA9IGhhbGZEb3duKGFyZWEueSArIHIgKiBhcmVhLmgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBheGlzWSA9IGhhbGZEb3duKGFyZWEueSArIGFyZWEuaCk7XG4gICAgfVxuICAgIGNvbnRleHQubW92ZVRvKGhhbGZVcChhcmVhLngpLCBheGlzWSk7XG4gICAgY29udGV4dC5saW5lVG8oaGFsZlVwKGFyZWEueCArIGFyZWEudyksIGF4aXNZKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH1cblxuICBjb250ZXh0LnJlc3RvcmUoKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGF4ZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL2F4ZXMuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n");

/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n/*global Dygraph:false */\n\n\n\n// TODO(danvk): move chart label options out of dygraphs and into the plugin.\n// TODO(danvk): only tear down & rebuild the DIVs when it's necessary.\n\nvar chart_labels = function chart_labels() {\n  this.title_div_ = null;\n  this.xlabel_div_ = null;\n  this.ylabel_div_ = null;\n  this.y2label_div_ = null;\n};\n\nchart_labels.prototype.toString = function () {\n  return \"ChartLabels Plugin\";\n};\n\nchart_labels.prototype.activate = function (g) {\n  return {\n    layout: this.layout,\n    // clearChart: this.clearChart,\n    didDrawChart: this.didDrawChart\n  };\n};\n\n// QUESTION: should there be a plugin-utils.js?\nvar createDivInRect = function createDivInRect(r) {\n  var div = document.createElement('div');\n  div.style.position = 'absolute';\n  div.style.left = r.x + 'px';\n  div.style.top = r.y + 'px';\n  div.style.width = r.w + 'px';\n  div.style.height = r.h + 'px';\n  return div;\n};\n\n// Detach and null out any existing nodes.\nchart_labels.prototype.detachLabels_ = function () {\n  var els = [this.title_div_, this.xlabel_div_, this.ylabel_div_, this.y2label_div_];\n  for (var i = 0; i < els.length; i++) {\n    var el = els[i];\n    if (!el) continue;\n    if (el.parentNode) el.parentNode.removeChild(el);\n  }\n\n  this.title_div_ = null;\n  this.xlabel_div_ = null;\n  this.ylabel_div_ = null;\n  this.y2label_div_ = null;\n};\n\nvar createRotatedDiv = function createRotatedDiv(g, box, axis, classes, html) {\n  // TODO(danvk): is this outer div actually necessary?\n  var div = document.createElement(\"div\");\n  div.style.position = 'absolute';\n  if (axis == 1) {\n    // NOTE: this is cheating. Should be positioned relative to the box.\n    div.style.left = '0px';\n  } else {\n    div.style.left = box.x + 'px';\n  }\n  div.style.top = box.y + 'px';\n  div.style.width = box.w + 'px';\n  div.style.height = box.h + 'px';\n  div.style.fontSize = g.getOption('yLabelWidth') - 2 + 'px';\n\n  var inner_div = document.createElement(\"div\");\n  inner_div.style.position = 'absolute';\n  inner_div.style.width = box.h + 'px';\n  inner_div.style.height = box.w + 'px';\n  inner_div.style.top = box.h / 2 - box.w / 2 + 'px';\n  inner_div.style.left = box.w / 2 - box.h / 2 + 'px';\n  // TODO: combine inner_div and class_div.\n  inner_div.className = 'dygraph-label-rotate-' + (axis == 1 ? 'right' : 'left');\n\n  var class_div = document.createElement(\"div\");\n  class_div.className = classes;\n  class_div.innerHTML = html;\n\n  inner_div.appendChild(class_div);\n  div.appendChild(inner_div);\n  return div;\n};\n\nchart_labels.prototype.layout = function (e) {\n  this.detachLabels_();\n\n  var g = e.dygraph;\n  var div = e.chart_div;\n  if (g.getOption('title')) {\n    // QUESTION: should this return an absolutely-positioned div instead?\n    var title_rect = e.reserveSpaceTop(g.getOption('titleHeight'));\n    this.title_div_ = createDivInRect(title_rect);\n    this.title_div_.style.fontSize = g.getOption('titleHeight') - 8 + 'px';\n\n    var class_div = document.createElement(\"div\");\n    class_div.className = 'dygraph-label dygraph-title';\n    class_div.innerHTML = g.getOption('title');\n    this.title_div_.appendChild(class_div);\n    div.appendChild(this.title_div_);\n  }\n\n  if (g.getOption('xlabel')) {\n    var x_rect = e.reserveSpaceBottom(g.getOption('xLabelHeight'));\n    this.xlabel_div_ = createDivInRect(x_rect);\n    this.xlabel_div_.style.fontSize = g.getOption('xLabelHeight') - 2 + 'px';\n\n    var class_div = document.createElement(\"div\");\n    class_div.className = 'dygraph-label dygraph-xlabel';\n    class_div.innerHTML = g.getOption('xlabel');\n    this.xlabel_div_.appendChild(class_div);\n    div.appendChild(this.xlabel_div_);\n  }\n\n  if (g.getOption('ylabel')) {\n    // It would make sense to shift the chart here to make room for the y-axis\n    // label, but the default yAxisLabelWidth is large enough that this results\n    // in overly-padded charts. The y-axis label should fit fine. If it\n    // doesn't, the yAxisLabelWidth option can be increased.\n    var y_rect = e.reserveSpaceLeft(0);\n\n    this.ylabel_div_ = createRotatedDiv(g, y_rect, 1, // primary (left) y-axis\n    'dygraph-label dygraph-ylabel', g.getOption('ylabel'));\n    div.appendChild(this.ylabel_div_);\n  }\n\n  if (g.getOption('y2label') && g.numAxes() == 2) {\n    // same logic applies here as for ylabel.\n    var y2_rect = e.reserveSpaceRight(0);\n    this.y2label_div_ = createRotatedDiv(g, y2_rect, 2, // secondary (right) y-axis\n    'dygraph-label dygraph-y2label', g.getOption('y2label'));\n    div.appendChild(this.y2label_div_);\n  }\n};\n\nchart_labels.prototype.didDrawChart = function (e) {\n  var g = e.dygraph;\n  if (this.title_div_) {\n    this.title_div_.children[0].innerHTML = g.getOption('title');\n  }\n  if (this.xlabel_div_) {\n    this.xlabel_div_.children[0].innerHTML = g.getOption('xlabel');\n  }\n  if (this.ylabel_div_) {\n    this.ylabel_div_.children[0].children[0].innerHTML = g.getOption('ylabel');\n  }\n  if (this.y2label_div_) {\n    this.y2label_div_.children[0].children[0].innerHTML = g.getOption('y2label');\n  }\n};\n\nchart_labels.prototype.clearChart = function () {};\n\nchart_labels.prototype.destroy = function () {\n  this.detachLabels_();\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (chart_labels);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL2NoYXJ0LWxhYmVscy5qcz9iZDJlIl0sIm5hbWVzIjpbImNoYXJ0X2xhYmVscyIsInRpdGxlX2Rpdl8iLCJ4bGFiZWxfZGl2XyIsInlsYWJlbF9kaXZfIiwieTJsYWJlbF9kaXZfIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJhY3RpdmF0ZSIsImciLCJsYXlvdXQiLCJkaWREcmF3Q2hhcnQiLCJjcmVhdGVEaXZJblJlY3QiLCJyIiwiZGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJwb3NpdGlvbiIsImxlZnQiLCJ4IiwidG9wIiwieSIsIndpZHRoIiwidyIsImhlaWdodCIsImgiLCJkZXRhY2hMYWJlbHNfIiwiZWxzIiwiaSIsImxlbmd0aCIsImVsIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY3JlYXRlUm90YXRlZERpdiIsImJveCIsImF4aXMiLCJjbGFzc2VzIiwiaHRtbCIsImZvbnRTaXplIiwiZ2V0T3B0aW9uIiwiaW5uZXJfZGl2IiwiY2xhc3NOYW1lIiwiY2xhc3NfZGl2IiwiaW5uZXJIVE1MIiwiYXBwZW5kQ2hpbGQiLCJlIiwiZHlncmFwaCIsImNoYXJ0X2RpdiIsInRpdGxlX3JlY3QiLCJyZXNlcnZlU3BhY2VUb3AiLCJ4X3JlY3QiLCJyZXNlcnZlU3BhY2VCb3R0b20iLCJ5X3JlY3QiLCJyZXNlcnZlU3BhY2VMZWZ0IiwibnVtQXhlcyIsInkyX3JlY3QiLCJyZXNlcnZlU3BhY2VSaWdodCIsImNoaWxkcmVuIiwiY2xlYXJDaGFydCIsImRlc3Ryb3kiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSUEsZUFBZSxTQUFmQSxZQUFlLEdBQVc7QUFDNUIsT0FBS0MsVUFBTCxHQUFrQixJQUFsQjtBQUNBLE9BQUtDLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxPQUFLQyxXQUFMLEdBQW1CLElBQW5CO0FB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K0IsU0FBRixDQUFZLFFBQVosQ0FBckQ7QUFDRDtBQUNELE1BQUksS0FBS25DLFlBQVQsRUFBdUI7QUFDckIsU0FBS0EsWUFBTCxDQUFrQnFELFFBQWxCLENBQTJCLENBQTNCLEVBQThCQSxRQUE5QixDQUF1QyxDQUF2QyxFQUEwQ2QsU0FBMUMsR0FBc0RuQyxFQUFFK0IsU0FBRixDQUFZLFNBQVosQ0FBdEQ7QUFDRDtBQUNGLENBZEQ7O0FBZ0JBdkMsYUFBYUssU0FBYixDQUF1QnFELFVBQXZCLEdBQW9DLFlBQVcsQ0FDOUMsQ0FERDs7QUFHQTFELGFBQWFLLFNBQWIsQ0FBdUJzRCxPQUF2QixHQUFpQyxZQUFXO0FBQzFDLE9BQUtqQyxhQUFMO0FBQ0QsQ0FGRDs7QUFJQSx5REFBZTFCLFlBQWYiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMiBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBUT0RPKGRhbnZrKTogbW92ZSBjaGFydCBsYWJlbCBvcHRpb25zIG91dCBvZiBkeWdyYXBocyBhbmQgaW50byB0aGUgcGx1Z2luLlxuLy8gVE9ETyhkYW52ayk6IG9ubHkgdGVhciBkb3duICYgcmVidWlsZCB0aGUgRElWcyB3aGVuIGl0J3MgbmVjZXNzYXJ5LlxuXG52YXIgY2hhcnRfbGFiZWxzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMudGl0bGVfZGl2XyA9IG51bGw7XG4gIHRoaXMueGxhYmVsX2Rpdl8gPSBudWxsO1xuICB0aGlzLnlsYWJlbF9kaXZfID0gbnVsbDtcbiAgdGhpcy55MmxhYmVsX2Rpdl8gPSBudWxsO1xufTtcblxuY2hhcnRfbGFiZWxzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCJDaGFydExhYmVscyBQbHVnaW5cIjtcbn07XG5cbmNoYXJ0X2xhYmVscy5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbihnKSB7XG4gIHJldHVybiB7XG4gICAgbGF5b3V0OiB0aGlzLmxheW91dCxcbiAgICAvLyBjbGVhckNoYXJ0OiB0aGlzLmNsZWFyQ2hhcnQsXG4gICAgZGlkRHJhd0NoYXJ0OiB0aGlzLmRpZERyYXdDaGFydFxuICB9O1xufTtcblxuLy8gUVVFU1RJT046IHNob3VsZCB0aGVyZSBiZSBhIHBsdWdpbi11dGlscy5qcz9cbnZhciBjcmVhdGVEaXZJblJlY3QgPSBmdW5jdGlvbihyKSB7XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgZGl2LnN0eWxlLmxlZnQgPSByLnggKyAncHgnO1xuICBkaXYuc3R5bGUudG9wID0gci55ICsgJ3B4JztcbiAgZGl2LnN0eWxlLndpZHRoID0gci53ICsgJ3B4JztcbiAgZGl2LnN0eWxlLmhlaWdodCA9IHIuaCArICdweCc7XG4gIHJldHVybiBkaXY7XG59O1xuXG4vLyBEZXRhY2ggYW5kIG51bGwgb3V0IGFueSBleGlzdGluZyBub2Rlcy5cbmNoYXJ0X2xhYmVscy5wcm90b3R5cGUuZGV0YWNoTGFiZWxzXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZWxzID0gWyB0aGlzLnRpdGxlX2Rpdl8sXG4gICAgICAgICAgICAgIHRoaXMueGxhYmVsX2Rpdl8sXG4gICAgICAgICAgICAgIHRoaXMueWxhYmVsX2Rpdl8sXG4gICAgICAgICAgICAgIHRoaXMueTJsYWJlbF9kaXZfIF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gZWxzW2ldO1xuICAgIGlmICghZWwpIGNvbnRpbnVlO1xuICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgfVxuXG4gIHRoaXMudGl0bGVfZGl2XyA9IG51bGw7XG4gIHRoaXMueGxhYmVsX2Rpdl8gPSBudWxsO1xuICB0aGlzLnlsYWJlbF9kaXZfID0gbnVsbDtcbiAgdGhpcy55MmxhYmVsX2Rpdl8gPSBudWxsO1xufTtcblxudmFyIGNyZWF0ZVJvdGF0ZWREaXYgPSBmdW5jdGlvbihnLCBib3gsIGF4aXMsIGNsYXNzZXMsIGh0bWwpIHtcbiAgLy8gVE9ETyhkYW52ayk6IGlzIHRoaXMgb3V0ZXIgZGl2IGFjdHVhbGx5IG5lY2Vzc2FyeT9cbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGlmIChheGlzID09IDEpIHtcbiAgICAvLyBOT1RFOiB0aGlzIGlzIGNoZWF0aW5nLiBTaG91bGQgYmUgcG9zaXRpb25lZCByZWxhdGl2ZSB0byB0aGUgYm94LlxuICAgIGRpdi5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gIH0gZWxzZSB7XG4gICAgZGl2LnN0eWxlLmxlZnQgPSBib3gueCArICdweCc7XG4gIH1cbiAgZGl2LnN0eWxlLnRvcCA9IGJveC55ICsgJ3B4JztcbiAgZGl2LnN0eWxlLndpZHRoID0gYm94LncgKyAncHgnO1xuICBkaXYuc3R5bGUuaGVpZ2h0ID0gYm94LmggKyAncHgnO1xuICBkaXYuc3R5bGUuZm9udFNpemUgPSAoZy5nZXRPcHRpb24oJ3lMYWJlbFdpZHRoJykgLSAyKSArICdweCc7XG5cbiAgdmFyIGlubmVyX2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGlubmVyX2Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGlubmVyX2Rpdi5zdHlsZS53aWR0aCA9IGJveC5oICsgJ3B4JztcbiAgaW5uZXJfZGl2LnN0eWxlLmhlaWdodCA9IGJveC53ICsgJ3B4JztcbiAgaW5uZXJfZGl2LnN0eWxlLnRvcCA9IChib3guaCAvIDIgLSBib3gudyAvIDIpICsgJ3B4JztcbiAgaW5uZXJfZGl2LnN0eWxlLmxlZnQgPSAoYm94LncgLyAyIC0gYm94LmggLyAyKSArICdweCc7XG4gIC8vIFRPRE86IGNvbWJpbmUgaW5uZXJfZGl2IGFuZCBjbGFzc19kaXYuXG4gIGlubmVyX2Rpdi5jbGFzc05hbWUgPSAnZHlncmFwaC1sYWJlbC1yb3RhdGUtJyArIChheGlzID09IDEgPyAncmlnaHQnIDogJ2xlZnQnKTtcblxuICB2YXIgY2xhc3NfZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgY2xhc3NfZGl2LmNsYXNzTmFtZSA9IGNsYXNzZXM7XG4gIGNsYXNzX2Rpdi5pbm5lckhUTUwgPSBodG1sO1xuXG4gIGlubmVyX2Rpdi5hcHBlbmRDaGlsZChjbGFzc19kaXYpO1xuICBkaXYuYXBwZW5kQ2hpbGQoaW5uZXJfZGl2KTtcbiAgcmV0dXJuIGRpdjtcbn07XG5cbmNoYXJ0X2xhYmVscy5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24oZSkge1xuICB0aGlzLmRldGFjaExhYmVsc18oKTtcblxuICB2YXIgZyA9IGUuZHlncmFwaDtcbiAgdmFyIGRpdiA9IGUuY2hhcnRfZGl2O1xuICBpZiAoZy5nZXRPcHRpb24oJ3RpdGxlJykpIHtcbiAgICAvLyBRVUVTVElPTjogc2hvdWxkIHRoaXMgcmV0dXJuIGFuIGFic29sdXRlbHktcG9zaXRpb25lZCBkaXYgaW5zdGVhZD9cbiAgICB2YXIgdGl0bGVfcmVjdCA9IGUucmVzZXJ2ZVNwYWNlVG9wKGcuZ2V0T3B0aW9uKCd0aXRsZUhlaWdodCcpKTtcbiAgICB0aGlzLnRpdGxlX2Rpdl8gPSBjcmVhdGVEaXZJblJlY3QodGl0bGVfcmVjdCk7XG4gICAgdGhpcy50aXRsZV9kaXZfLnN0eWxlLmZvbnRTaXplID0gKGcuZ2V0T3B0aW9uKCd0aXRsZUhlaWdodCcpIC0gOCkgKyAncHgnO1xuXG4gICAgdmFyIGNsYXNzX2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgY2xhc3NfZGl2LmNsYXNzTmFtZSA9ICdkeWdyYXBoLWxhYmVsIGR5Z3JhcGgtdGl0bGUnO1xuICAgIGNsYXNzX2Rpdi5pbm5lckhUTUwgPSBnLmdldE9wdGlvbigndGl0bGUnKTtcbiAgICB0aGlzLnRpdGxlX2Rpdl8uYXBwZW5kQ2hpbGQoY2xhc3NfZGl2KTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQodGhpcy50aXRsZV9kaXZfKTtcbiAgfVxuXG4gIGlmIChnLmdldE9wdGlvbigneGxhYmVsJykpIHtcbiAgICB2YXIgeF9yZWN0ID0gZS5yZXNlcnZlU3BhY2VCb3R0b20oZy5nZXRPcHRpb24oJ3hMYWJlbEhlaWdodCcpKTtcbiAgICB0aGlzLnhsYWJlbF9kaXZfID0gY3JlYXRlRGl2SW5SZWN0KHhfcmVjdCk7XG4gICAgdGhpcy54bGFiZWxfZGl2Xy5zdHlsZS5mb250U2l6ZSA9IChnLmdldE9wdGlvbigneExhYmVsSGVpZ2h0JykgLSAyKSArICdweCc7XG5cbiAgICB2YXIgY2xhc3NfZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjbGFzc19kaXYuY2xhc3NOYW1lID0gJ2R5Z3JhcGgtbGFiZWwgZHlncmFwaC14bGFiZWwnO1xuICAgIGNsYXNzX2Rpdi5pbm5lckhUTUwgPSBnLmdldE9wdGlvbigneGxhYmVsJyk7XG4gICAgdGhpcy54bGFiZWxfZGl2Xy5hcHBlbmRDaGlsZChjbGFzc19kaXYpO1xuICAgIGRpdi5hcHBlbmRDaGlsZCh0aGlzLnhsYWJlbF9kaXZfKTtcbiAgfVxuXG4gIGlmIChnLmdldE9wdGlvbigneWxhYmVsJykpIHtcbiAgICAvLyBJdCB3b3VsZCBtYWtlIHNlbnNlIHRvIHNoaWZ0IHRoZSBjaGFydCBoZXJlIHRvIG1ha2Ugcm9vbSBmb3IgdGhlIHktYXhpc1xuICAgIC8vIGxhYmVsLCBidXQgdGhlIGRlZmF1bHQgeUF4aXNMYWJlbFdpZHRoIGlzIGxhcmdlIGVub3VnaCB0aGF0IHRoaXMgcmVzdWx0c1xuICAgIC8vIGluIG92ZXJseS1wYWRkZWQgY2hhcnRzLiBUaGUgeS1heGlzIGxhYmVsIHNob3VsZCBmaXQgZmluZS4gSWYgaXRcbiAgICAvLyBkb2Vzbid0LCB0aGUgeUF4aXNMYWJlbFdpZHRoIG9wdGlvbiBjYW4gYmUgaW5jcmVhc2VkLlxuICAgIHZhciB5X3JlY3QgPSBlLnJlc2VydmVTcGFjZUxlZnQoMCk7XG5cbiAgICB0aGlzLnlsYWJlbF9kaXZfID0gY3JlYXRlUm90YXRlZERpdihcbiAgICAgICAgZywgeV9yZWN0LFxuICAgICAgICAxLCAgLy8gcHJpbWFyeSAobGVmdCkgeS1heGlzXG4gICAgICAgICdkeWdyYXBoLWxhYmVsIGR5Z3JhcGgteWxhYmVsJyxcbiAgICAgICAgZy5nZXRPcHRpb24oJ3lsYWJlbCcpKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQodGhpcy55bGFiZWxfZGl2Xyk7XG4gIH1cblxuICBpZiAoZy5nZXRPcHRpb24oJ3kybGFiZWwnKSAmJiBnLm51bUF4ZXMoKSA9PSAyKSB7XG4gICAgLy8gc2FtZSBsb2dpYyBhcHBsaWVzIGhlcmUgYXMgZm9yIHlsYWJlbC5cbiAgICB2YXIgeTJfcmVjdCA9IGUucmVzZXJ2ZVNwYWNlUmlnaHQoMCk7XG4gICAgdGhpcy55MmxhYmVsX2Rpdl8gPSBjcmVhdGVSb3RhdGVkRGl2KFxuICAgICAgICBnLCB5Ml9yZWN0LFxuICAgICAgICAyLCAgLy8gc2Vjb25kYXJ5IChyaWdodCkgeS1heGlzXG4gICAgICAgICdkeWdyYXBoLWxhYmVsIGR5Z3JhcGgteTJsYWJlbCcsXG4gICAgICAgIGcuZ2V0T3B0aW9uKCd5MmxhYmVsJykpO1xuICAgIGRpdi5hcHBlbmRDaGlsZCh0aGlzLnkybGFiZWxfZGl2Xyk7XG4gIH1cbn07XG5cbmNoYXJ0X2xhYmVscy5wcm90b3R5cGUuZGlkRHJhd0NoYXJ0ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgZyA9IGUuZHlncmFwaDtcbiAgaWYgKHRoaXMudGl0bGVfZGl2Xykge1xuICAgIHRoaXMudGl0bGVfZGl2Xy5jaGlsZHJlblswXS5pbm5lckhUTUwgPSBnLmdldE9wdGlvbigndGl0bGUnKTtcbiAgfVxuICBpZiAodGhpcy54bGFiZWxfZGl2Xykge1xuICAgIHRoaXMueGxhYmVsX2Rpdl8uY2hpbGRyZW5bMF0uaW5uZXJIVE1MID0gZy5nZXRPcHRpb24oJ3hsYWJlbCcpO1xuICB9XG4gIGlmICh0aGlzLnlsYWJlbF9kaXZfKSB7XG4gICAgdGhpcy55bGFiZWxfZGl2Xy5jaGlsZHJlblswXS5jaGlsZHJlblswXS5pbm5lckhUTUwgPSBnLmdldE9wdGlvbigneWxhYmVsJyk7XG4gIH1cbiAgaWYgKHRoaXMueTJsYWJlbF9kaXZfKSB7XG4gICAgdGhpcy55MmxhYmVsX2Rpdl8uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uaW5uZXJIVE1MID0gZy5nZXRPcHRpb24oJ3kybGFiZWwnKTtcbiAgfVxufTtcblxuY2hhcnRfbGFiZWxzLnByb3RvdHlwZS5jbGVhckNoYXJ0ID0gZnVuY3Rpb24oKSB7XG59O1xuXG5jaGFydF9sYWJlbHMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kZXRhY2hMYWJlbHNfKCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjaGFydF9sYWJlbHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL2NoYXJ0LWxhYmVscy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///24\n");

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n/*global Dygraph:false */\n\n/*\n\nCurrent bits of jankiness:\n- Direct layout access\n- Direct area access\n\n*/\n\n\n\n/**\n * Draws the gridlines, i.e. the gray horizontal & vertical lines running the\n * length of the chart.\n *\n * @constructor\n */\n\nvar grid = function grid() {};\n\ngrid.prototype.toString = function () {\n  return \"Gridline Plugin\";\n};\n\ngrid.prototype.activate = function (g) {\n  return {\n    willDrawChart: this.willDrawChart\n  };\n};\n\ngrid.prototype.willDrawChart = function (e) {\n  // Draw the new X/Y grid. Lines appear crisper when pixels are rounded to\n  // half-integers. This prevents them from drawing in two rows/cols.\n  var g = e.dygraph;\n  var ctx = e.drawingContext;\n  var layout = g.layout_;\n  var area = e.dygraph.plotter_.area;\n\n  function halfUp(x) {\n    return Math.round(x) + 0.5;\n  }\n  function halfDown(y) {\n    return Math.round(y) - 0.5;\n  }\n\n  var x, y, i, ticks;\n  if (g.getOptionForAxis('drawGrid', 'y')) {\n    var axes = [\"y\", \"y2\"];\n    var strokeStyles = [],\n        lineWidths = [],\n        drawGrid = [],\n        stroking = [],\n        strokePattern = [];\n    for (var i = 0; i < axes.length; i++) {\n      drawGrid[i] = g.getOptionForAxis('drawGrid', axes[i]);\n      if (drawGrid[i]) {\n        strokeStyles[i] = g.getOptionForAxis('gridLineColor', axes[i]);\n        lineWidths[i] = g.getOptionForAxis('gridLineWidth', axes[i]);\n        strokePattern[i] = g.getOptionForAxis('gridLinePattern', axes[i]);\n        stroking[i] = strokePattern[i] && strokePattern[i].length >= 2;\n      }\n    }\n    ticks = layout.yticks;\n    ctx.save();\n    // draw grids for the different y axes\n    ticks.forEach(function (tick) {\n      if (!tick.has_tick) return;\n      var axis = tick.axis;\n      if (drawGrid[axis]) {\n        ctx.save();\n        if (stroking[axis]) {\n          if (ctx.setLineDash) ctx.setLineDash(strokePattern[axis]);\n        }\n        ctx.strokeStyle = strokeStyles[axis];\n        ctx.lineWidth = lineWidths[axis];\n\n        x = halfUp(area.x);\n        y = halfDown(area.y + tick.pos * area.h);\n        ctx.beginPath();\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + area.w, y);\n        ctx.stroke();\n\n        ctx.restore();\n      }\n    });\n    ctx.restore();\n  }\n\n  // draw grid for x axis\n  if (g.getOptionForAxis('drawGrid', 'x')) {\n    ticks = layout.xticks;\n    ctx.save();\n    var strokePattern = g.getOptionForAxis('gridLinePattern', 'x');\n    var stroking = strokePattern && strokePattern.length >= 2;\n    if (stroking) {\n      if (ctx.setLineDash) ctx.setLineDash(strokePattern);\n    }\n    ctx.strokeStyle = g.getOptionForAxis('gridLineColor', 'x');\n    ctx.lineWidth = g.getOptionForAxis('gridLineWidth', 'x');\n    ticks.forEach(function (tick) {\n      if (!tick.has_tick) return;\n      x = halfUp(area.x + tick.pos * area.w);\n      y = halfDown(area.y + area.h);\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(x, area.y);\n      ctx.closePath();\n      ctx.stroke();\n    });\n    if (stroking) {\n      if (ctx.setLineDash) ctx.setLineDash([]);\n    }\n    ctx.restore();\n  }\n};\n\ngrid.prototype.destroy = function () {};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (grid);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL2dyaWQuanM/YjE2NCJdLCJuYW1lcyI6WyJncmlkIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJhY3RpdmF0ZSIsImciLCJ3aWxsRHJhd0NoYXJ0IiwiZSIsImR5Z3JhcGgiLCJjdHgiLCJkcmF3aW5nQ29udGV4dCIsImxheW91dCIsImxheW91dF8iLCJhcmVhIiwicGxvdHRlcl8iLCJoYWxmVXAiLCJ4IiwiTWF0aCIsInJvdW5kIiwiaGFsZkRvd24iLCJ5IiwiaSIsInRpY2tzIiwiZ2V0T3B0aW9uRm9yQXhpcyIsImF4ZXMiLCJzdHJva2VTdHlsZXMiLCJsaW5lV2lkdGhzIiwiZHJhd0dyaWQiLCJzdHJva2luZyIsInN0cm9rZVBhdHRlcm4iLCJsZW5ndGgiLCJ5dGlja3MiLCJzYXZlIiwiZm9yRWFjaCIsInRpY2siLCJoYXNfdGljayIsImF4aXMiLCJzZXRMaW5lRGFzaCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwicG9zIiwiaCIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsInciLCJzdHJva2UiLCJyZXN0b3JlIiwieHRpY2tzIiwiY2xvc2VQYXRoIiwiZGVzdHJveSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FBS0E7O0FBRUE7Ozs7Ozs7O0FBUUE7O0FBRUE7Ozs7Ozs7QUFNQSxJQUFJQSxPQUFPLFNBQVBBLElBQU8sR0FBVyxDQUNyQixDQUREOztBQUdBQSxLQUFLQyxTQUFMLENBQWVDLFFBQWYsR0FBMEIsWUFBVztBQUNuQyxTQUFPLGlCQUFQO0FBQ0QsQ0FGRDs7QUFJQUYsS0FBS0MsU0FBTCxDQUFlRSxRQUFmLEdBQTBCLFVBQVNDLENBQVQsRUFBWTtBQUNwQyxTQUFPO0FBQ0xDLG1CQUFlLEtBQUtBO0FBRGYsR0FBUDtBQUdELENBSkQ7O0FBTUFMLEtBQUtDLFNBQUwsQ0FBZUksYUFBZixHQUErQixVQUFTQyxDQUFULEVBQVk7QUFDekM7QUFDQTtBQUNBLE1BQUlGLElBQUlFLEVBQUVDLE9BQVY7QUFDQSxNQUFJQyxNQUFNRixFQUFFRyxjQUFaO0FBQ0EsTUFBSUMsU0FBU04sRUFBRU8sT0FBZjtBQUNBLE1BQUlDLE9BQU9OLEVBQUVDLE9BQUYsQ0FBVU0sUUFBVixDQUFtQkQsSUFBOUI7O0FBRUEsV0FBU0UsTUFBVCxDQUFnQkMsQ0FBaEIsRUFBb0I7QUFBRSxXQUFPQyxLQUFLQyxLQUFMLENBQVdGLENBQVgsSUFBZ0IsR0FBdkI7QUFBNkI7QUFDbkQsV0FBU0csUUFBVCxDQUFrQkMsQ0FBbEIsRUFBb0I7QUFBRSxXQUFPSCxLQUFLQyxLQUFMLENBQVdFLENBQVgsSUFBZ0IsR0FBdkI7QUFBNkI7O0FBRW5ELE1BQUlKLENBQUosRUFBT0ksQ0FBUCxFQUFVQyxDQUFWLEVBQWFDLEtBQWI7QUFDQSxNQUFJakIsRUFBRWtCLGdCQUFGLENBQW1CLFVBQW5CLEVBQStCLEdBQS9CLENBQUosRUFBeUM7QUFDdkMsUUFBSUMsT0FBTyxDQUFDLEdBQUQsRUFBTSxJQUFOLENBQVg7QUFDQSxRQUFJQyxlQUFlLEVBQW5CO0FBQUEsUUFBdUJDLGFBQWEsRUFBcEM7QUFBQSxRQUF3Q0MsV0FBVyxFQUFuRDtBQUFBLFFBQXVEQyxXQUFXLEVBQWxFO0FBQUEsUUFBc0VDLGdCQUFnQixFQUF0RjtBQUNBLFNBQUssSUFBSVIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRyxLQUFLTSxNQUF6QixFQUFpQ1QsR0FBakMsRUFBc0M7QUFDcENNLGVBQVNOLENBQVQsSUFBY2hCLEVBQUVrQixnQkFBRixDQUFtQixVQUFuQixFQUErQkMsS0FBS0gsQ0FBTCxDQUEvQixDQUFkO0FBQ0EsVUFBSU0sU0FBU04sQ0FBVCxDQUFKLEVBQWlCO0FBQ2ZJLHFCQUFhSixDQUFiLElBQWtCaEIsRUFBRWtCLGdCQUFGLENBQW1CLGVBQW5CLEVBQW9DQyxLQUFLSCxDQUFMLENBQXBDLENBQWxCO0FBQ0FLLG1CQUFXTCxDQUFYLElBQWdCaEIsRUFBRWtCLGdCQUFGLENBQW1CLGVBQW5CLEVBQW9DQyxLQUFLSCxDQUFMLENBQXBDLENBQWhCO0FBQ0FRLHNCQUFjUixDQUFkLElBQW1CaEIsRUFBRWtCLGdCQUFGLENBQW1CLGlCQUFuQixFQUFzQ0MsS0FBS0gsQ0FBTCxDQUF0QyxDQUFuQjtBQUNBTyxpQkFBU1AsQ0FBVCxJQUFjUSxjQUFjUixDQUFkLEtBQXFCUSxjQUFjUixDQUFkLEVBQWlCUyxNQUFqQixJQUEyQixDQUE5RDtBQUNEO0FBQ0Y7QUFDRFIsWUFBUVgsT0FBT29CLE1BQWY7QUFDQXRCLFFBQUl1QixJQUFKO0FBQ0E7QUFDQVYsVUFBTVcsT0FBTixDQUFjLGdCQUFRO0FBQ3BCLFVBQUksQ0FBQ0MsS0FBS0MsUUFBVixFQUFvQjtBQUNwQixVQUFJQyxPQUFPRixLQUFLRSxJQUFoQjtBQUNBLFVBQUlULFNBQVNTLElBQVQsQ0FBSixFQUFvQjtBQUNsQjNCLFlBQUl1QixJQUFKO0FBQ0EsWUFBSUosU0FBU1EsSUFBVCxDQUFKLEVBQW9CO0FBQ2xCLGNBQUkzQixJQUFJNEIsV0FBUixFQUFxQjVCLElBQUk0QixXQUFKLENBQWdCUixjQUFjTyxJQUFkLENBQWhCO0FBQ3RCO0FBQ0QzQixZQUFJNkIsV0FBSixHQUFrQmIsYUFBYVcsSUFBYixDQUFsQjtBQUNBM0IsWUFBSThCLFNBQUosR0FBZ0JiLFdBQVdVLElBQVgsQ0FBaEI7O0FBRUFwQixZQUFJRCxPQUFPRixLQUFLRyxDQUFaLENBQUo7QUFDQUksWUFBSUQsU0FBU04sS0FBS08sQ0FBTCxHQUFTYyxLQUFLTSxHQUFMLEdBQVczQixLQUFLNEIsQ0FBbEMsQ0FBSjtBQUNBaEMsWUFBSWlDLFNBQUo7QUFDQWpDLFlBQUlrQyxNQUFKLENBQVczQixDQUFYLEVBQWNJLENBQWQ7QUFDQVgsWUFBSW1DLE1BQUosQ0FBVzVCLElBQUlILEtBQUtnQyxDQUFwQixFQUF1QnpCLENBQXZCO0FBQ0FYLFlBQUlxQyxNQUFKOztBQUVBckMsWUFBSXNDLE9BQUo7QUFDRDtBQUNGLEtBcEJEO0FBcUJBdEMsUUFBSXNDLE9BQUo7QUFDRDs7QUFFRDtBQUNBLE1BQUkxQyxFQUFFa0IsZ0JBQUYsQ0FBbUIsVUFBbkIsRUFBK0IsR0FBL0IsQ0FBSixFQUF5QztBQUN2Q0QsWUFBUVgsT0FBT3FDLE1BQWY7QUFDQXZDLFFBQUl1QixJQUFKO0FBQ0EsUUFBSUgsZ0JBQWdCeEIsRUFBRWtCLGdCQUFGLENBQW1CLGlCQUFuQixFQUFzQyxHQUF0QyxDQUFwQjtBQUNBLFFBQUlLLFdBQVdDLGlCQUFrQkEsY0FBY0MsTUFBZCxJQUF3QixDQUF6RDtBQUNBLFFBQUlGLFFBQUosRUFBYztBQUNaLFVBQUluQixJQUFJNEIsV0FBUixFQUFxQjVCLElBQUk0QixXQUFKLENBQWdCUixhQUFoQjtBQUN0QjtBQUNEcEIsUUFBSTZCLFdBQUosR0FBa0JqQyxFQUFFa0IsZ0JBQUYsQ0FBbUIsZUFBbkIsRUFBb0MsR0FBcEMsQ0FBbEI7QUFDQWQsUUFBSThCLFNBQUosR0FBZ0JsQyxFQUFFa0IsZ0JBQUYsQ0FBbUIsZUFBbkIsRUFBb0MsR0FBcEMsQ0FBaEI7QUFDQUQsVUFBTVcsT0FBTixDQUFjLGdCQUFRO0FBQ3BCLFVBQUksQ0FBQ0MsS0FBS0MsUUFBVixFQUFvQjtBQUNwQm5CLFVBQUlELE9BQU9GLEtBQUtHLENBQUwsR0FBU2tCLEtBQUtNLEdBQUwsR0FBVzNCLEtBQUtnQyxDQUFoQyxDQUFKO0FBQ0F6QixVQUFJRCxTQUFTTixLQUFLTyxDQUFMLEdBQVNQLEtBQUs0QixDQUF2QixDQUFKO0FBQ0FoQyxVQUFJaUMsU0FBSjtBQUNBakMsVUFBSWtDLE1BQUosQ0FBVzNCLENBQVgsRUFBY0ksQ0FBZDtBQUNBWCxVQUFJbUMsTUFBSixDQUFXNUIsQ0FBWCxFQUFjSCxLQUFLTyxDQUFuQjtBQUNBWCxVQUFJd0MsU0FBSjtBQUNBeEMsVUFBSXFDLE1BQUo7QUFDRCxLQVREO0FBVUEsUUFBSWxCLFFBQUosRUFBYztBQUNaLFVBQUluQixJQUFJNEIsV0FBUixFQUFxQjVCLElBQUk0QixXQUFKLENBQWdCLEVBQWhCO0FBQ3RCO0FBQ0Q1QixRQUFJc0MsT0FBSjtBQUNEO0FBQ0YsQ0E3RUQ7O0FBK0VBOUMsS0FBS0MsU0FBTCxDQUFlZ0QsT0FBZixHQUF5QixZQUFXLENBQ25DLENBREQ7O0FBR0EseURBQWVqRCxJQUFmIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTIgRGFuIFZhbmRlcmthbSAoZGFudmRrQGdtYWlsLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXG4vKlxuXG5DdXJyZW50IGJpdHMgb2YgamFua2luZXNzOlxuLSBEaXJlY3QgbGF5b3V0IGFjY2Vzc1xuLSBEaXJlY3QgYXJlYSBhY2Nlc3NcblxuKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogRHJhd3MgdGhlIGdyaWRsaW5lcywgaS5lLiB0aGUgZ3JheSBob3Jpem9udGFsICYgdmVydGljYWwgbGluZXMgcnVubmluZyB0aGVcbiAqIGxlbmd0aCBvZiB0aGUgY2hhcnQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBncmlkID0gZnVuY3Rpb24oKSB7XG59O1xuXG5ncmlkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCJHcmlkbGluZSBQbHVnaW5cIjtcbn07XG5cbmdyaWQucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oZykge1xuICByZXR1cm4ge1xuICAgIHdpbGxEcmF3Q2hhcnQ6IHRoaXMud2lsbERyYXdDaGFydFxuICB9O1xufTtcblxuZ3JpZC5wcm90b3R5cGUud2lsbERyYXdDaGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgLy8gRHJhdyB0aGUgbmV3IFgvWSBncmlkLiBMaW5lcyBhcHBlYXIgY3Jpc3BlciB3aGVuIHBpeGVscyBhcmUgcm91bmRlZCB0b1xuICAvLyBoYWxmLWludGVnZXJzLiBUaGlzIHByZXZlbnRzIHRoZW0gZnJvbSBkcmF3aW5nIGluIHR3byByb3dzL2NvbHMuXG4gIHZhciBnID0gZS5keWdyYXBoO1xuICB2YXIgY3R4ID0gZS5kcmF3aW5nQ29udGV4dDtcbiAgdmFyIGxheW91dCA9IGcubGF5b3V0XztcbiAgdmFyIGFyZWEgPSBlLmR5Z3JhcGgucGxvdHRlcl8uYXJlYTtcblxuICBmdW5jdGlvbiBoYWxmVXAoeCkgIHsgcmV0dXJuIE1hdGgucm91bmQoeCkgKyAwLjU7IH1cbiAgZnVuY3Rpb24gaGFsZkRvd24oeSl7IHJldHVybiBNYXRoLnJvdW5kKHkpIC0gMC41OyB9XG5cbiAgdmFyIHgsIHksIGksIHRpY2tzO1xuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3R3JpZCcsICd5JykpIHtcbiAgICB2YXIgYXhlcyA9IFtcInlcIiwgXCJ5MlwiXTtcbiAgICB2YXIgc3Ryb2tlU3R5bGVzID0gW10sIGxpbmVXaWR0aHMgPSBbXSwgZHJhd0dyaWQgPSBbXSwgc3Ryb2tpbmcgPSBbXSwgc3Ryb2tlUGF0dGVybiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZHJhd0dyaWRbaV0gPSBnLmdldE9wdGlvbkZvckF4aXMoJ2RyYXdHcmlkJywgYXhlc1tpXSk7XG4gICAgICBpZiAoZHJhd0dyaWRbaV0pIHtcbiAgICAgICAgc3Ryb2tlU3R5bGVzW2ldID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdncmlkTGluZUNvbG9yJywgYXhlc1tpXSk7XG4gICAgICAgIGxpbmVXaWR0aHNbaV0gPSBnLmdldE9wdGlvbkZvckF4aXMoJ2dyaWRMaW5lV2lkdGgnLCBheGVzW2ldKTtcbiAgICAgICAgc3Ryb2tlUGF0dGVybltpXSA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnZ3JpZExpbmVQYXR0ZXJuJywgYXhlc1tpXSk7XG4gICAgICAgIHN0cm9raW5nW2ldID0gc3Ryb2tlUGF0dGVybltpXSAmJiAoc3Ryb2tlUGF0dGVybltpXS5sZW5ndGggPj0gMik7XG4gICAgICB9XG4gICAgfVxuICAgIHRpY2tzID0gbGF5b3V0Lnl0aWNrcztcbiAgICBjdHguc2F2ZSgpO1xuICAgIC8vIGRyYXcgZ3JpZHMgZm9yIHRoZSBkaWZmZXJlbnQgeSBheGVzXG4gICAgdGlja3MuZm9yRWFjaCh0aWNrID0+IHtcbiAgICAgIGlmICghdGljay5oYXNfdGljaykgcmV0dXJuO1xuICAgICAgdmFyIGF4aXMgPSB0aWNrLmF4aXM7XG4gICAgICBpZiAoZHJhd0dyaWRbYXhpc10pIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYgKHN0cm9raW5nW2F4aXNdKSB7XG4gICAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCkgY3R4LnNldExpbmVEYXNoKHN0cm9rZVBhdHRlcm5bYXhpc10pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlc1theGlzXTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aHNbYXhpc107XG5cbiAgICAgICAgeCA9IGhhbGZVcChhcmVhLngpO1xuICAgICAgICB5ID0gaGFsZkRvd24oYXJlYS55ICsgdGljay5wb3MgKiBhcmVhLmgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIGFyZWEudywgeSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICAvLyBkcmF3IGdyaWQgZm9yIHggYXhpc1xuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3R3JpZCcsICd4JykpIHtcbiAgICB0aWNrcyA9IGxheW91dC54dGlja3M7XG4gICAgY3R4LnNhdmUoKTtcbiAgICB2YXIgc3Ryb2tlUGF0dGVybiA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnZ3JpZExpbmVQYXR0ZXJuJywgJ3gnKTtcbiAgICB2YXIgc3Ryb2tpbmcgPSBzdHJva2VQYXR0ZXJuICYmIChzdHJva2VQYXR0ZXJuLmxlbmd0aCA+PSAyKTtcbiAgICBpZiAoc3Ryb2tpbmcpIHtcbiAgICAgIGlmIChjdHguc2V0TGluZURhc2gpIGN0eC5zZXRMaW5lRGFzaChzdHJva2VQYXR0ZXJuKTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdncmlkTGluZUNvbG9yJywgJ3gnKTtcbiAgICBjdHgubGluZVdpZHRoID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdncmlkTGluZVdpZHRoJywgJ3gnKTtcbiAgICB0aWNrcy5mb3JFYWNoKHRpY2sgPT4ge1xuICAgICAgaWYgKCF0aWNrLmhhc190aWNrKSByZXR1cm47XG4gICAgICB4ID0gaGFsZlVwKGFyZWEueCArIHRpY2sucG9zICogYXJlYS53KTtcbiAgICAgIHkgPSBoYWxmRG93bihhcmVhLnkgKyBhcmVhLmgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCwgYXJlYS55KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9KTtcbiAgICBpZiAoc3Ryb2tpbmcpIHtcbiAgICAgIGlmIChjdHguc2V0TGluZURhc2gpIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn07XG5cbmdyaWQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdyaWQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL2dyaWQuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///25\n");

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__ = __webpack_require__(0);\n/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n/*global Dygraph:false */\n\n/*\nCurrent bits of jankiness:\n- Uses two private APIs:\n    1. Dygraph.optionsViewForAxis_\n    2. dygraph.plotter_.area\n- Registers for a \"predraw\" event, which should be renamed.\n- I call calculateEmWidthInDiv more often than needed.\n*/\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * Creates the legend, which appears when the user hovers over the chart.\n * The legend can be either a user-specified or generated div.\n *\n * @constructor\n */\nvar Legend = function Legend() {\n  this.legend_div_ = null;\n  this.is_generated_div_ = false; // do we own this div, or was it user-specified?\n};\n\nLegend.prototype.toString = function () {\n  return \"Legend Plugin\";\n};\n\n/**\n * This is called during the dygraph constructor, after options have been set\n * but before the data is available.\n *\n * Proper tasks to do here include:\n * - Reading your own options\n * - DOM manipulation\n * - Registering event listeners\n *\n * @param {Dygraph} g Graph instance.\n * @return {object.<string, function(ev)>} Mapping of event names to callbacks.\n */\nLegend.prototype.activate = function (g) {\n  var div;\n\n  var userLabelsDiv = g.getOption('labelsDiv');\n  if (userLabelsDiv && null !== userLabelsDiv) {\n    if (typeof userLabelsDiv == \"string\" || userLabelsDiv instanceof String) {\n      div = document.getElementById(userLabelsDiv);\n    } else {\n      div = userLabelsDiv;\n    }\n  } else {\n    div = document.createElement(\"div\");\n    div.className = \"dygraph-legend\";\n    // TODO(danvk): come up with a cleaner way to expose this.\n    g.graphDiv.appendChild(div);\n    this.is_generated_div_ = true;\n  }\n\n  this.legend_div_ = div;\n  this.one_em_width_ = 10; // just a guess, will be updated.\n\n  return {\n    select: this.select,\n    deselect: this.deselect,\n    // TODO(danvk): rethink the name \"predraw\" before we commit to it in any API.\n    predraw: this.predraw,\n    didDrawChart: this.didDrawChart\n  };\n};\n\n// Needed for dashed lines.\nvar calculateEmWidthInDiv = function calculateEmWidthInDiv(div) {\n  var sizeSpan = document.createElement('span');\n  sizeSpan.setAttribute('style', 'margin: 0; padding: 0 0 0 1em; border: 0;');\n  div.appendChild(sizeSpan);\n  var oneEmWidth = sizeSpan.offsetWidth;\n  div.removeChild(sizeSpan);\n  return oneEmWidth;\n};\n\nvar escapeHTML = function escapeHTML(str) {\n  return str.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n};\n\nLegend.prototype.select = function (e) {\n  var xValue = e.selectedX;\n  var points = e.selectedPoints;\n  var row = e.selectedRow;\n\n  var legendMode = e.dygraph.getOption('legend');\n  if (legendMode === 'never') {\n    this.legend_div_.style.display = 'none';\n    return;\n  }\n\n  if (legendMode === 'follow') {\n    // create floating legend div\n    var area = e.dygraph.plotter_.area;\n    var labelsDivWidth = this.legend_div_.offsetWidth;\n    var yAxisLabelWidth = e.dygraph.getOptionForAxis('axisLabelWidth', 'y');\n    // determine floating [left, top] coordinates of the legend div\n    // within the plotter_ area\n    // offset 50 px to the right and down from the first selection point\n    // 50 px is guess based on mouse cursor size\n    var leftLegend = points[0].x * area.w + 50;\n    var topLegend = points[0].y * area.h - 50;\n\n    // if legend floats to end of the chart area, it flips to the other\n    // side of the selection point\n    if (leftLegend + labelsDivWidth + 1 > area.w) {\n      leftLegend = leftLegend - 2 * 50 - labelsDivWidth - (yAxisLabelWidth - area.x);\n    }\n\n    e.dygraph.graphDiv.appendChild(this.legend_div_);\n    this.legend_div_.style.left = yAxisLabelWidth + leftLegend + \"px\";\n    this.legend_div_.style.top = topLegend + \"px\";\n  }\n\n  var html = Legend.generateLegendHTML(e.dygraph, xValue, points, this.one_em_width_, row);\n  this.legend_div_.innerHTML = html;\n  this.legend_div_.style.display = '';\n};\n\nLegend.prototype.deselect = function (e) {\n  var legendMode = e.dygraph.getOption('legend');\n  if (legendMode !== 'always') {\n    this.legend_div_.style.display = \"none\";\n  }\n\n  // Have to do this every time, since styles might have changed.\n  var oneEmWidth = calculateEmWidthInDiv(this.legend_div_);\n  this.one_em_width_ = oneEmWidth;\n\n  var html = Legend.generateLegendHTML(e.dygraph, undefined, undefined, oneEmWidth, null);\n  this.legend_div_.innerHTML = html;\n};\n\nLegend.prototype.didDrawChart = function (e) {\n  this.deselect(e);\n};\n\n// Right edge should be flush with the right edge of the charting area (which\n// may not be the same as the right edge of the div, if we have two y-axes.\n// TODO(danvk): is any of this really necessary? Could just set \"right\" in \"activate\".\n/**\n * Position the labels div so that:\n * - its right edge is flush with the right edge of the charting area\n * - its top edge is flush with the top edge of the charting area\n * @private\n */\nLegend.prototype.predraw = function (e) {\n  // Don't touch a user-specified labelsDiv.\n  if (!this.is_generated_div_) return;\n\n  // TODO(danvk): only use real APIs for this.\n  e.dygraph.graphDiv.appendChild(this.legend_div_);\n  var area = e.dygraph.getArea();\n  var labelsDivWidth = this.legend_div_.offsetWidth;\n  this.legend_div_.style.left = area.x + area.w - labelsDivWidth - 1 + \"px\";\n  this.legend_div_.style.top = area.y + \"px\";\n};\n\n/**\n * Called when dygraph.destroy() is called.\n * You should null out any references and detach any DOM elements.\n */\nLegend.prototype.destroy = function () {\n  this.legend_div_ = null;\n};\n\n/**\n * Generates HTML for the legend which is displayed when hovering over the\n * chart. If no selected points are specified, a default legend is returned\n * (this may just be the empty string).\n * @param {number} x The x-value of the selected points.\n * @param {Object} sel_points List of selected points for the given\n *   x-value. Should have properties like 'name', 'yval' and 'canvasy'.\n * @param {number} oneEmWidth The pixel width for 1em in the legend. Only\n *   relevant when displaying a legend with no selection (i.e. {legend:\n *   'always'}) and with dashed lines.\n * @param {number} row The selected row index.\n * @private\n */\nLegend.generateLegendHTML = function (g, x, sel_points, oneEmWidth, row) {\n  // Data about the selection to pass to legendFormatter\n  var data = {\n    dygraph: g,\n    x: x,\n    series: []\n  };\n\n  var labelToSeries = {};\n  var labels = g.getLabels();\n  if (labels) {\n    for (var i = 1; i < labels.length; i++) {\n      var series = g.getPropertiesForSeries(labels[i]);\n      var strokePattern = g.getOption('strokePattern', labels[i]);\n      var seriesData = {\n        dashHTML: generateLegendDashHTML(strokePattern, series.color, oneEmWidth),\n        label: labels[i],\n        labelHTML: escapeHTML(labels[i]),\n        isVisible: series.visible,\n        color: series.color\n      };\n\n      data.series.push(seriesData);\n      labelToSeries[labels[i]] = seriesData;\n    }\n  }\n\n  if (typeof x !== 'undefined') {\n    var xOptView = g.optionsViewForAxis_('x');\n    var xvf = xOptView('valueFormatter');\n    data.xHTML = xvf.call(g, x, xOptView, labels[0], g, row, 0);\n\n    var yOptViews = [];\n    var num_axes = g.numAxes();\n    for (var i = 0; i < num_axes; i++) {\n      // TODO(danvk): remove this use of a private API\n      yOptViews[i] = g.optionsViewForAxis_('y' + (i ? 1 + i : ''));\n    }\n\n    var showZeros = g.getOption('labelsShowZeroValues');\n    var highlightSeries = g.getHighlightSeries();\n    for (i = 0; i < sel_points.length; i++) {\n      var pt = sel_points[i];\n      var seriesData = labelToSeries[pt.name];\n      seriesData.y = pt.yval;\n\n      if (pt.yval === 0 && !showZeros || isNaN(pt.canvasy)) {\n        seriesData.isVisible = false;\n        continue;\n      }\n\n      var series = g.getPropertiesForSeries(pt.name);\n      var yOptView = yOptViews[series.axis - 1];\n      var fmtFunc = yOptView('valueFormatter');\n      var yHTML = fmtFunc.call(g, pt.yval, yOptView, pt.name, g, row, labels.indexOf(pt.name));\n\n      __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"a\" /* update */](seriesData, { yHTML: yHTML });\n\n      if (pt.name == highlightSeries) {\n        seriesData.isHighlighted = true;\n      }\n    }\n  }\n\n  var formatter = g.getOption('legendFormatter') || Legend.defaultFormatter;\n  return formatter.call(g, data);\n};\n\nLegend.defaultFormatter = function (data) {\n  var g = data.dygraph;\n\n  // TODO(danvk): deprecate this option in place of {legend: 'never'}\n  // XXX should this logic be in the formatter?\n  if (g.getOption('showLabelsOnHighlight') !== true) return '';\n\n  var sepLines = g.getOption('labelsSeparateLines');\n  var html;\n\n  if (typeof data.x === 'undefined') {\n    // TODO: this check is duplicated in generateLegendHTML. Put it in one place.\n    if (g.getOption('legend') != 'always') {\n      return '';\n    }\n\n    html = '';\n    for (var i = 0; i < data.series.length; i++) {\n      var series = data.series[i];\n      if (!series.isVisible) continue;\n\n      if (html !== '') html += sepLines ? '<br/>' : ' ';\n      html += \"<span style='font-weight: bold; color: \" + series.color + \";'>\" + series.dashHTML + \" \" + series.labelHTML + \"</span>\";\n    }\n    return html;\n  }\n\n  html = data.xHTML + ':';\n  for (var i = 0; i < data.series.length; i++) {\n    var series = data.series[i];\n    if (!series.isVisible) continue;\n    if (sepLines) html += '<br>';\n    var cls = series.isHighlighted ? ' class=\"highlight\"' : '';\n    html += \"<span\" + cls + \"> <b><span style='color: \" + series.color + \";'>\" + series.labelHTML + \"</span></b>:&#160;\" + series.yHTML + \"</span>\";\n  }\n  return html;\n};\n\n/**\n * Generates html for the \"dash\" displayed on the legend when using \"legend: always\".\n * In particular, this works for dashed lines with any stroke pattern. It will\n * try to scale the pattern to fit in 1em width. Or if small enough repeat the\n * pattern for 1em width.\n *\n * @param strokePattern The pattern\n * @param color The color of the series.\n * @param oneEmWidth The width in pixels of 1em in the legend.\n * @private\n */\n// TODO(danvk): cache the results of this\nfunction generateLegendDashHTML(strokePattern, color, oneEmWidth) {\n  // Easy, common case: a solid line\n  if (!strokePattern || strokePattern.length <= 1) {\n    return \"<div class=\\\"dygraph-legend-line\\\" style=\\\"border-bottom-color: \" + color + \";\\\"></div>\";\n  }\n\n  var i, j, paddingLeft, marginRight;\n  var strokePixelLength = 0,\n      segmentLoop = 0;\n  var normalizedPattern = [];\n  var loop;\n\n  // Compute the length of the pixels including the first segment twice, \n  // since we repeat it.\n  for (i = 0; i <= strokePattern.length; i++) {\n    strokePixelLength += strokePattern[i % strokePattern.length];\n  }\n\n  // See if we can loop the pattern by itself at least twice.\n  loop = Math.floor(oneEmWidth / (strokePixelLength - strokePattern[0]));\n  if (loop > 1) {\n    // This pattern fits at least two times, no scaling just convert to em;\n    for (i = 0; i < strokePattern.length; i++) {\n      normalizedPattern[i] = strokePattern[i] / oneEmWidth;\n    }\n    // Since we are repeating the pattern, we don't worry about repeating the\n    // first segment in one draw.\n    segmentLoop = normalizedPattern.length;\n  } else {\n    // If the pattern doesn't fit in the legend we scale it to fit.\n    loop = 1;\n    for (i = 0; i < strokePattern.length; i++) {\n      normalizedPattern[i] = strokePattern[i] / strokePixelLength;\n    }\n    // For the scaled patterns we do redraw the first segment.\n    segmentLoop = normalizedPattern.length + 1;\n  }\n\n  // Now make the pattern.\n  var dash = \"\";\n  for (j = 0; j < loop; j++) {\n    for (i = 0; i < segmentLoop; i += 2) {\n      // The padding is the drawn segment.\n      paddingLeft = normalizedPattern[i % normalizedPattern.length];\n      if (i < strokePattern.length) {\n        // The margin is the space segment.\n        marginRight = normalizedPattern[(i + 1) % normalizedPattern.length];\n      } else {\n        // The repeated first segment has no right margin.\n        marginRight = 0;\n      }\n      dash += \"<div class=\\\"dygraph-legend-dash\\\" style=\\\"margin-right: \" + marginRight + \"em; padding-left: \" + paddingLeft + \"em;\\\"></div>\";\n    }\n  }\n  return dash;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Legend);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL2xlZ2VuZC5qcz8wNjFkIl0sIm5hbWVzIjpbIkxlZ2VuZCIsImxlZ2VuZF9kaXZfIiwiaXNfZ2VuZXJhdGVkX2Rpdl8iLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImFjdGl2YXRlIiwiZyIsImRpdiIsInVzZXJMYWJlbHNEaXYiLCJnZXRPcHRpb24iLCJTdHJpbmciLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImdyYXBoRGl2IiwiYXBwZW5kQ2hpbGQiLCJvbmVfZW1fd2lkdGhfIiwic2VsZWN0IiwiZGVzZWxlY3QiLCJwcmVkcmF3IiwiZGlkRHJhd0NoYXJ0IiwiY2FsY3VsYXRlRW1XaWR0aEluRGl2Iiwic2l6ZVNwYW4iLCJzZXRBdHRyaWJ1dGUiLCJvbmVFbVdpZHRoIiwib2Zmc2V0V2lkdGgiLCJyZW1vdmVDaGlsZCIsImVzY2FwZUhUTUwiLCJzdHIiLCJyZXBsYWNlIiwiZSIsInhWYWx1ZSIsInNlbGVjdGVkWCIsInBvaW50cyIsInNlbGVjdGVkUG9pbnRzIiwicm93Iiwic2VsZWN0ZWRSb3ciLCJsZWdlbmRNb2RlIiwiZHlncmFwaCIsInN0eWxlIiwiZGlzcGxheSIsImFyZWEiLCJwbG90dGVyXyIsImxhYmVsc0RpdldpZHRoIiwieUF4aXNMYWJlbFdpZHRoIiwiZ2V0T3B0aW9uRm9yQXhpcyIsImxlZnRMZWdlbmQiLCJ4IiwidyIsInRvcExlZ2VuZCIsInkiLCJoIiwibGVmdCIsInRvcCIsImh0bWwiLCJnZW5lcmF0ZUxlZ2VuZEhUTUwiLCJpbm5lckhUTUwiLCJ1bmRlZmluZWQiLCJnZXRBcmVhIiwiZGVzdHJveSIsInNlbF9wb2ludHMiLCJkYXRhIiwic2VyaWVzIiwibGFiZWxUb1NlcmllcyIsImxhYmVscyIsImdldExhYmVscyIsImkiLCJsZW5ndGgiLCJnZXRQcm9wZXJ0aWVzRm9yU2VyaWVzIiwic3Ryb2tlUGF0dGVybiIsInNlcmllc0RhdGEiLCJkYXNoSFRNTCIsImdlbmVyYXRlTGVnZW5kRGFzaEhUTUwiLCJjb2xvciIsImxhYmVsIiwibGFiZWxIVE1MIiwiaXNWaXNpYmxlIiwidmlzaWJsZSIsInB1c2giLCJ4T3B0VmlldyIsIm9wdGlvbnNWaWV3Rm9yQXhpc18iLCJ4dmYiLCJ4SFRNTCIsImNhbGwiLCJ5T3B0Vmlld3MiLCJudW1fYXhlcyIsIm51bUF4ZXMiLCJzaG93WmVyb3MiLCJoaWdobGlnaHRTZXJpZXMiLCJnZXRIaWdobGlnaHRTZXJpZXMiLCJwdCIsIm5hbWUiLCJ5dmFsIiwiaXNOYU4iLCJjYW52YXN5IiwieU9wdFZpZXciLCJheGlzIiwiZm10RnVuYyIsInlIVE1MIiwiaW5kZXhPZiIsInV0aWxzIiwiaXNIaWdobGlnaHRlZCIsImZvcm1hdHRlciIsImRlZmF1bHRGb3JtYXR0ZXIiLCJzZXBMaW5lcyIsImNscyIsImoiLCJwYWRkaW5nTGVmdCIsIm1hcmdpblJpZ2h0Iiwic3Ryb2tlUGl4ZWxMZW5ndGgiLCJzZWdtZW50TG9vcCIsIm5vcm1hbGl6ZWRQYXR0ZXJuIiwibG9vcCIsIk1hdGgiLCJmbG9vciIsImRhc2giXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Ozs7O0FBS0E7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0E7O0FBRUE7O0FBR0E7Ozs7OztBQU1BLElBQUlBLFNBQVMsU0FBVEEsTUFBUyxHQUFXO0FBQ3RCLE9BQUtDLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxPQUFLQyxpQkFBTCxHQUF5QixLQUF6QixDQUZzQixDQUVXO0FBQ2xDLENBSEQ7O0FBS0FGLE9BQU9HLFNBQVAsQ0FBaUJDLFFBQWpCLEdBQTRCLFlBQVc7QUFDckMsU0FBTyxlQUFQO0FBQ0QsQ0FGRDs7QUFJQTs7Ozs7Ozs7Ozs7O0FBWUFKLE9BQU9HLFNBQVAsQ0FBaUJFLFFBQWpCLEdBQTRCLFVBQVNDLENBQVQsRUFBWTtBQUN0QyxNQUFJQyxHQUFKOztBQUVBLE1BQUlDLGdCQUFnQkYsRUFBRUcsU0FBRixDQUFZLFdBQVosQ0FB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c2VcbiAqIENvcHlyaWdodCAyMDEyIERhbiBWYW5kZXJrYW0gKGRhbnZka0BnbWFpbC5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblxuLypcbkN1cnJlbnQgYml0cyBvZiBqYW5raW5lc3M6XG4tIFVzZXMgdHdvIHByaXZhdGUgQVBJczpcbiAgICAxLiBEeWdyYXBoLm9wdGlvbnNWaWV3Rm9yQXhpc19cbiAgICAyLiBkeWdyYXBoLnBsb3R0ZXJfLmFyZWFcbi0gUmVnaXN0ZXJzIGZvciBhIFwicHJlZHJhd1wiIGV2ZW50LCB3aGljaCBzaG91bGQgYmUgcmVuYW1lZC5cbi0gSSBjYWxsIGNhbGN1bGF0ZUVtV2lkdGhJbkRpdiBtb3JlIG9mdGVuIHRoYW4gbmVlZGVkLlxuKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL2R5Z3JhcGgtdXRpbHMnO1xuXG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgbGVnZW5kLCB3aGljaCBhcHBlYXJzIHdoZW4gdGhlIHVzZXIgaG92ZXJzIG92ZXIgdGhlIGNoYXJ0LlxuICogVGhlIGxlZ2VuZCBjYW4gYmUgZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgb3IgZ2VuZXJhdGVkIGRpdi5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIExlZ2VuZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxlZ2VuZF9kaXZfID0gbnVsbDtcbiAgdGhpcy5pc19nZW5lcmF0ZWRfZGl2XyA9IGZhbHNlOyAgLy8gZG8gd2Ugb3duIHRoaXMgZGl2LCBvciB3YXMgaXQgdXNlci1zcGVjaWZpZWQ/XG59O1xuXG5MZWdlbmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBcIkxlZ2VuZCBQbHVnaW5cIjtcbn07XG5cbi8qKlxuICogVGhpcyBpcyBjYWxsZWQgZHVyaW5nIHRoZSBkeWdyYXBoIGNvbnN0cnVjdG9yLCBhZnRlciBvcHRpb25zIGhhdmUgYmVlbiBzZXRcbiAqIGJ1dCBiZWZvcmUgdGhlIGRhdGEgaXMgYXZhaWxhYmxlLlxuICpcbiAqIFByb3BlciB0YXNrcyB0byBkbyBoZXJlIGluY2x1ZGU6XG4gKiAtIFJlYWRpbmcgeW91ciBvd24gb3B0aW9uc1xuICogLSBET00gbWFuaXB1bGF0aW9uXG4gKiAtIFJlZ2lzdGVyaW5nIGV2ZW50IGxpc3RlbmVyc1xuICpcbiAqIEBwYXJhbSB7RHlncmFwaH0gZyBHcmFwaCBpbnN0YW5jZS5cbiAqIEByZXR1cm4ge29iamVjdC48c3RyaW5nLCBmdW5jdGlvbihldik+fSBNYXBwaW5nIG9mIGV2ZW50IG5hbWVzIHRvIGNhbGxiYWNrcy5cbiAqL1xuTGVnZW5kLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKGcpIHtcbiAgdmFyIGRpdjtcblxuICB2YXIgdXNlckxhYmVsc0RpdiA9IGcuZ2V0T3B0aW9uKCdsYWJlbHNEaXYnKTtcbiAgaWYgKHVzZXJMYWJlbHNEaXYgJiYgbnVsbCAhPT0gdXNlckxhYmVsc0Rpdikge1xuICAgIGlmICh0eXBlb2YodXNlckxhYmVsc0RpdikgPT0gXCJzdHJpbmdcIiB8fCB1c2VyTGFiZWxzRGl2IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICBkaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh1c2VyTGFiZWxzRGl2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGl2ID0gdXNlckxhYmVsc0RpdjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuY2xhc3NOYW1lID0gXCJkeWdyYXBoLWxlZ2VuZFwiO1xuICAgIC8vIFRPRE8oZGFudmspOiBjb21lIHVwIHdpdGggYSBjbGVhbmVyIHdheSB0byBleHBvc2UgdGhpcy5cbiAgICBnLmdyYXBoRGl2LmFwcGVuZENoaWxkKGRpdik7XG4gICAgdGhpcy5pc19nZW5lcmF0ZWRfZGl2XyA9IHRydWU7XG4gIH1cblxuICB0aGlzLmxlZ2VuZF9kaXZfID0gZGl2O1xuICB0aGlzLm9uZV9lbV93aWR0aF8gPSAxMDsgIC8vIGp1c3QgYSBndWVzcywgd2lsbCBiZSB1cGRhdGVkLlxuXG4gIHJldHVybiB7XG4gICAgc2VsZWN0OiB0aGlzLnNlbGVjdCxcbiAgICBkZXNlbGVjdDogdGhpcy5kZXNlbGVjdCxcbiAgICAvLyBUT0RPKGRhbnZrKTogcmV0aGluayB0aGUgbmFtZSBcInByZWRyYXdcIiBiZWZvcmUgd2UgY29tbWl0IHRvIGl0IGluIGFueSBBUEkuXG4gICAgcHJlZHJhdzogdGhpcy5wcmVkcmF3LFxuICAgIGRpZERyYXdDaGFydDogdGhpcy5kaWREcmF3Q2hhcnRcbiAgfTtcbn07XG5cbi8vIE5lZWRlZCBmb3IgZGFzaGVkIGxpbmVzLlxudmFyIGNhbGN1bGF0ZUVtV2lkdGhJbkRpdiA9IGZ1bmN0aW9uKGRpdikge1xuICB2YXIgc2l6ZVNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIHNpemVTcGFuLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnbWFyZ2luOiAwOyBwYWRkaW5nOiAwIDAgMCAxZW07IGJvcmRlcjogMDsnKTtcbiAgZGl2LmFwcGVuZENoaWxkKHNpemVTcGFuKTtcbiAgdmFyIG9uZUVtV2lkdGg9c2l6ZVNwYW4ub2Zmc2V0V2lkdGg7XG4gIGRpdi5yZW1vdmVDaGlsZChzaXplU3Bhbik7XG4gIHJldHVybiBvbmVFbVdpZHRoO1xufTtcblxudmFyIGVzY2FwZUhUTUwgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIikucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIikucmVwbGFjZSgvPC9nLCBcIiZsdDtcIikucmVwbGFjZSgvPi9nLCBcIiZndDtcIik7XG59O1xuXG5MZWdlbmQucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHhWYWx1ZSA9IGUuc2VsZWN0ZWRYO1xuICB2YXIgcG9pbnRzID0gZS5zZWxlY3RlZFBvaW50cztcbiAgdmFyIHJvdyA9IGUuc2VsZWN0ZWRSb3c7XG5cbiAgdmFyIGxlZ2VuZE1vZGUgPSBlLmR5Z3JhcGguZ2V0T3B0aW9uKCdsZWdlbmQnKTtcbiAgaWYgKGxlZ2VuZE1vZGUgPT09ICduZXZlcicpIHtcbiAgICB0aGlzLmxlZ2VuZF9kaXZfLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGxlZ2VuZE1vZGUgPT09ICdmb2xsb3cnKSB7XG4gICAgLy8gY3JlYXRlIGZsb2F0aW5nIGxlZ2VuZCBkaXZcbiAgICB2YXIgYXJlYSA9IGUuZHlncmFwaC5wbG90dGVyXy5hcmVhO1xuICAgIHZhciBsYWJlbHNEaXZXaWR0aCA9IHRoaXMubGVnZW5kX2Rpdl8ub2Zmc2V0V2lkdGg7XG4gICAgdmFyIHlBeGlzTGFiZWxXaWR0aCA9IGUuZHlncmFwaC5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGFiZWxXaWR0aCcsICd5Jyk7XG4gICAgLy8gZGV0ZXJtaW5lIGZsb2F0aW5nIFtsZWZ0LCB0b3BdIGNvb3JkaW5hdGVzIG9mIHRoZSBsZWdlbmQgZGl2XG4gICAgLy8gd2l0aGluIHRoZSBwbG90dGVyXyBhcmVhXG4gICAgLy8gb2Zmc2V0IDUwIHB4IHRvIHRoZSByaWdodCBhbmQgZG93biBmcm9tIHRoZSBmaXJzdCBzZWxlY3Rpb24gcG9pbnRcbiAgICAvLyA1MCBweCBpcyBndWVzcyBiYXNlZCBvbiBtb3VzZSBjdXJzb3Igc2l6ZVxuICAgIHZhciBsZWZ0TGVnZW5kID0gcG9pbnRzWzBdLnggKiBhcmVhLncgKyA1MDtcbiAgICB2YXIgdG9wTGVnZW5kICA9IHBvaW50c1swXS55ICogYXJlYS5oIC0gNTA7XG5cbiAgICAvLyBpZiBsZWdlbmQgZmxvYXRzIHRvIGVuZCBvZiB0aGUgY2hhcnQgYXJlYSwgaXQgZmxpcHMgdG8gdGhlIG90aGVyXG4gICAgLy8gc2lkZSBvZiB0aGUgc2VsZWN0aW9uIHBvaW50XG4gICAgaWYgKChsZWZ0TGVnZW5kICsgbGFiZWxzRGl2V2lkdGggKyAxKSA+IGFyZWEudykge1xuICAgICAgbGVmdExlZ2VuZCA9IGxlZnRMZWdlbmQgLSAyICogNTAgLSBsYWJlbHNEaXZXaWR0aCAtICh5QXhpc0xhYmVsV2lkdGggLSBhcmVhLngpO1xuICAgIH1cblxuICAgIGUuZHlncmFwaC5ncmFwaERpdi5hcHBlbmRDaGlsZCh0aGlzLmxlZ2VuZF9kaXZfKTtcbiAgICB0aGlzLmxlZ2VuZF9kaXZfLnN0eWxlLmxlZnQgPSB5QXhpc0xhYmVsV2lkdGggKyBsZWZ0TGVnZW5kICsgXCJweFwiO1xuICAgIHRoaXMubGVnZW5kX2Rpdl8uc3R5bGUudG9wID0gdG9wTGVnZW5kICsgXCJweFwiO1xuICB9XG5cbiAgdmFyIGh0bWwgPSBMZWdlbmQuZ2VuZXJhdGVMZWdlbmRIVE1MKGUuZHlncmFwaCwgeFZhbHVlLCBwb2ludHMsIHRoaXMub25lX2VtX3dpZHRoXywgcm93KTtcbiAgdGhpcy5sZWdlbmRfZGl2Xy5pbm5lckhUTUwgPSBodG1sO1xuICB0aGlzLmxlZ2VuZF9kaXZfLnN0eWxlLmRpc3BsYXkgPSAnJztcbn07XG5cbkxlZ2VuZC5wcm90b3R5cGUuZGVzZWxlY3QgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBsZWdlbmRNb2RlID0gZS5keWdyYXBoLmdldE9wdGlvbignbGVnZW5kJyk7XG4gIGlmIChsZWdlbmRNb2RlICE9PSAnYWx3YXlzJykge1xuICAgIHRoaXMubGVnZW5kX2Rpdl8uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICB9XG5cbiAgLy8gSGF2ZSB0byBkbyB0aGlzIGV2ZXJ5IHRpbWUsIHNpbmNlIHN0eWxlcyBtaWdodCBoYXZlIGNoYW5nZWQuXG4gIHZhciBvbmVFbVdpZHRoID0gY2FsY3VsYXRlRW1XaWR0aEluRGl2KHRoaXMubGVnZW5kX2Rpdl8pO1xuICB0aGlzLm9uZV9lbV93aWR0aF8gPSBvbmVFbVdpZHRoO1xuXG4gIHZhciBodG1sID0gTGVnZW5kLmdlbmVyYXRlTGVnZW5kSFRNTChlLmR5Z3JhcGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbmVFbVdpZHRoLCBudWxsKTtcbiAgdGhpcy5sZWdlbmRfZGl2Xy5pbm5lckhUTUwgPSBodG1sO1xufTtcblxuTGVnZW5kLnByb3RvdHlwZS5kaWREcmF3Q2hhcnQgPSBmdW5jdGlvbihlKSB7XG4gIHRoaXMuZGVzZWxlY3QoZSk7XG59O1xuXG4vLyBSaWdodCBlZGdlIHNob3VsZCBiZSBmbHVzaCB3aXRoIHRoZSByaWdodCBlZGdlIG9mIHRoZSBjaGFydGluZyBhcmVhICh3aGljaFxuLy8gbWF5IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgZGl2LCBpZiB3ZSBoYXZlIHR3byB5LWF4ZXMuXG4vLyBUT0RPKGRhbnZrKTogaXMgYW55IG9mIHRoaXMgcmVhbGx5IG5lY2Vzc2FyeT8gQ291bGQganVzdCBzZXQgXCJyaWdodFwiIGluIFwiYWN0aXZhdGVcIi5cbi8qKlxuICogUG9zaXRpb24gdGhlIGxhYmVscyBkaXYgc28gdGhhdDpcbiAqIC0gaXRzIHJpZ2h0IGVkZ2UgaXMgZmx1c2ggd2l0aCB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgY2hhcnRpbmcgYXJlYVxuICogLSBpdHMgdG9wIGVkZ2UgaXMgZmx1c2ggd2l0aCB0aGUgdG9wIGVkZ2Ugb2YgdGhlIGNoYXJ0aW5nIGFyZWFcbiAqIEBwcml2YXRlXG4gKi9cbkxlZ2VuZC5wcm90b3R5cGUucHJlZHJhdyA9IGZ1bmN0aW9uKGUpIHtcbiAgLy8gRG9uJ3QgdG91Y2ggYSB1c2VyLXNwZWNpZmllZCBsYWJlbHNEaXYuXG4gIGlmICghdGhpcy5pc19nZW5lcmF0ZWRfZGl2XykgcmV0dXJuO1xuXG4gIC8vIFRPRE8oZGFudmspOiBvbmx5IHVzZSByZWFsIEFQSXMgZm9yIHRoaXMuXG4gIGUuZHlncmFwaC5ncmFwaERpdi5hcHBlbmRDaGlsZCh0aGlzLmxlZ2VuZF9kaXZfKTtcbiAgdmFyIGFyZWEgPSBlLmR5Z3JhcGguZ2V0QXJlYSgpO1xuICB2YXIgbGFiZWxzRGl2V2lkdGggPSB0aGlzLmxlZ2VuZF9kaXZfLm9mZnNldFdpZHRoO1xuICB0aGlzLmxlZ2VuZF9kaXZfLnN0eWxlLmxlZnQgPSBhcmVhLnggKyBhcmVhLncgLSBsYWJlbHNEaXZXaWR0aCAtIDEgKyBcInB4XCI7XG4gIHRoaXMubGVnZW5kX2Rpdl8uc3R5bGUudG9wID0gYXJlYS55ICsgXCJweFwiO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBkeWdyYXBoLmRlc3Ryb3koKSBpcyBjYWxsZWQuXG4gKiBZb3Ugc2hvdWxkIG51bGwgb3V0IGFueSByZWZlcmVuY2VzIGFuZCBkZXRhY2ggYW55IERPTSBlbGVtZW50cy5cbiAqL1xuTGVnZW5kLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubGVnZW5kX2Rpdl8gPSBudWxsO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgSFRNTCBmb3IgdGhlIGxlZ2VuZCB3aGljaCBpcyBkaXNwbGF5ZWQgd2hlbiBob3ZlcmluZyBvdmVyIHRoZVxuICogY2hhcnQuIElmIG5vIHNlbGVjdGVkIHBvaW50cyBhcmUgc3BlY2lmaWVkLCBhIGRlZmF1bHQgbGVnZW5kIGlzIHJldHVybmVkXG4gKiAodGhpcyBtYXkganVzdCBiZSB0aGUgZW1wdHkgc3RyaW5nKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSB4LXZhbHVlIG9mIHRoZSBzZWxlY3RlZCBwb2ludHMuXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsX3BvaW50cyBMaXN0IG9mIHNlbGVjdGVkIHBvaW50cyBmb3IgdGhlIGdpdmVuXG4gKiAgIHgtdmFsdWUuIFNob3VsZCBoYXZlIHByb3BlcnRpZXMgbGlrZSAnbmFtZScsICd5dmFsJyBhbmQgJ2NhbnZhc3knLlxuICogQHBhcmFtIHtudW1iZXJ9IG9uZUVtV2lkdGggVGhlIHBpeGVsIHdpZHRoIGZvciAxZW0gaW4gdGhlIGxlZ2VuZC4gT25seVxuICogICByZWxldmFudCB3aGVuIGRpc3BsYXlpbmcgYSBsZWdlbmQgd2l0aCBubyBzZWxlY3Rpb24gKGkuZS4ge2xlZ2VuZDpcbiAqICAgJ2Fsd2F5cyd9KSBhbmQgd2l0aCBkYXNoZWQgbGluZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gcm93IFRoZSBzZWxlY3RlZCByb3cgaW5kZXguXG4gKiBAcHJpdmF0ZVxuICovXG5MZWdlbmQuZ2VuZXJhdGVMZWdlbmRIVE1MID0gZnVuY3Rpb24oZywgeCwgc2VsX3BvaW50cywgb25lRW1XaWR0aCwgcm93KSB7XG4gIC8vIERhdGEgYWJvdXQgdGhlIHNlbGVjdGlvbiB0byBwYXNzIHRvIGxlZ2VuZEZvcm1hdHRlclxuICB2YXIgZGF0YSA9IHtcbiAgICBkeWdyYXBoOiBnLFxuICAgIHg6IHgsXG4gICAgc2VyaWVzOiBbXVxuICB9O1xuXG4gIHZhciBsYWJlbFRvU2VyaWVzID0ge307XG4gIHZhciBsYWJlbHMgPSBnLmdldExhYmVscygpO1xuICBpZiAobGFiZWxzKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZXJpZXMgPSBnLmdldFByb3BlcnRpZXNGb3JTZXJpZXMobGFiZWxzW2ldKTtcbiAgICAgIHZhciBzdHJva2VQYXR0ZXJuID0gZy5nZXRPcHRpb24oJ3N0cm9rZVBhdHRlcm4nLCBsYWJlbHNbaV0pO1xuICAgICAgdmFyIHNlcmllc0RhdGEgPSB7XG4gICAgICAgIGRhc2hIVE1MOiBnZW5lcmF0ZUxlZ2VuZERhc2hIVE1MKHN0cm9rZVBhdHRlcm4sIHNlcmllcy5jb2xvciwgb25lRW1XaWR0aCksXG4gICAgICAgIGxhYmVsOiBsYWJlbHNbaV0sXG4gICAgICAgIGxhYmVsSFRNTDogZXNjYXBlSFRNTChsYWJlbHNbaV0pLFxuICAgICAgICBpc1Zpc2libGU6IHNlcmllcy52aXNpYmxlLFxuICAgICAgICBjb2xvcjogc2VyaWVzLmNvbG9yXG4gICAgICB9O1xuXG4gICAgICBkYXRhLnNlcmllcy5wdXNoKHNlcmllc0RhdGEpO1xuICAgICAgbGFiZWxUb1Nlcmllc1tsYWJlbHNbaV1dID0gc2VyaWVzRGF0YTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mKHgpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciB4T3B0VmlldyA9IGcub3B0aW9uc1ZpZXdGb3JBeGlzXygneCcpO1xuICAgIHZhciB4dmYgPSB4T3B0VmlldygndmFsdWVGb3JtYXR0ZXInKTtcbiAgICBkYXRhLnhIVE1MID0geHZmLmNhbGwoZywgeCwgeE9wdFZpZXcsIGxhYmVsc1swXSwgZywgcm93LCAwKTtcblxuICAgIHZhciB5T3B0Vmlld3MgPSBbXTtcbiAgICB2YXIgbnVtX2F4ZXMgPSBnLm51bUF4ZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9heGVzOyBpKyspIHtcbiAgICAgIC8vIFRPRE8oZGFudmspOiByZW1vdmUgdGhpcyB1c2Ugb2YgYSBwcml2YXRlIEFQSVxuICAgICAgeU9wdFZpZXdzW2ldID0gZy5vcHRpb25zVmlld0ZvckF4aXNfKCd5JyArIChpID8gMSArIGkgOiAnJykpO1xuICAgIH1cblxuICAgIHZhciBzaG93WmVyb3MgPSBnLmdldE9wdGlvbignbGFiZWxzU2hvd1plcm9WYWx1ZXMnKTtcbiAgICB2YXIgaGlnaGxpZ2h0U2VyaWVzID0gZy5nZXRIaWdobGlnaHRTZXJpZXMoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VsX3BvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHB0ID0gc2VsX3BvaW50c1tpXTtcbiAgICAgIHZhciBzZXJpZXNEYXRhID0gbGFiZWxUb1Nlcmllc1twdC5uYW1lXTtcbiAgICAgIHNlcmllc0RhdGEueSA9IHB0Lnl2YWw7XG5cbiAgICAgIGlmICgocHQueXZhbCA9PT0gMCAmJiAhc2hvd1plcm9zKSB8fCBpc05hTihwdC5jYW52YXN5KSkge1xuICAgICAgICBzZXJpZXNEYXRhLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlcmllcyA9IGcuZ2V0UHJvcGVydGllc0ZvclNlcmllcyhwdC5uYW1lKTtcbiAgICAgIHZhciB5T3B0VmlldyA9IHlPcHRWaWV3c1tzZXJpZXMuYXhpcyAtIDFdO1xuICAgICAgdmFyIGZtdEZ1bmMgPSB5T3B0VmlldygndmFsdWVGb3JtYXR0ZXInKTtcbiAgICAgIHZhciB5SFRNTCA9IGZtdEZ1bmMuY2FsbChnLCBwdC55dmFsLCB5T3B0VmlldywgcHQubmFtZSwgZywgcm93LCBsYWJlbHMuaW5kZXhPZihwdC5uYW1lKSk7XG5cbiAgICAgIHV0aWxzLnVwZGF0ZShzZXJpZXNEYXRhLCB7eUhUTUx9KTtcblxuICAgICAgaWYgKHB0Lm5hbWUgPT0gaGlnaGxpZ2h0U2VyaWVzKSB7XG4gICAgICAgIHNlcmllc0RhdGEuaXNIaWdobGlnaHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGZvcm1hdHRlciA9IChnLmdldE9wdGlvbignbGVnZW5kRm9ybWF0dGVyJykgfHwgTGVnZW5kLmRlZmF1bHRGb3JtYXR0ZXIpO1xuICByZXR1cm4gZm9ybWF0dGVyLmNhbGwoZywgZGF0YSk7XG59XG5cbkxlZ2VuZC5kZWZhdWx0Rm9ybWF0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgZyA9IGRhdGEuZHlncmFwaDtcblxuICAvLyBUT0RPKGRhbnZrKTogZGVwcmVjYXRlIHRoaXMgb3B0aW9uIGluIHBsYWNlIG9mIHtsZWdlbmQ6ICduZXZlcid9XG4gIC8vIFhYWCBzaG91bGQgdGhpcyBsb2dpYyBiZSBpbiB0aGUgZm9ybWF0dGVyP1xuICBpZiAoZy5nZXRPcHRpb24oJ3Nob3dMYWJlbHNPbkhpZ2hsaWdodCcpICE9PSB0cnVlKSByZXR1cm4gJyc7XG5cbiAgdmFyIHNlcExpbmVzID0gZy5nZXRPcHRpb24oJ2xhYmVsc1NlcGFyYXRlTGluZXMnKTtcbiAgdmFyIGh0bWw7XG5cbiAgaWYgKHR5cGVvZihkYXRhLngpID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIFRPRE86IHRoaXMgY2hlY2sgaXMgZHVwbGljYXRlZCBpbiBnZW5lcmF0ZUxlZ2VuZEhUTUwuIFB1dCBpdCBpbiBvbmUgcGxhY2UuXG4gICAgaWYgKGcuZ2V0T3B0aW9uKCdsZWdlbmQnKSAhPSAnYWx3YXlzJykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGh0bWwgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VyaWVzID0gZGF0YS5zZXJpZXNbaV07XG4gICAgICBpZiAoIXNlcmllcy5pc1Zpc2libGUpIGNvbnRpbnVlO1xuXG4gICAgICBpZiAoaHRtbCAhPT0gJycpIGh0bWwgKz0gKHNlcExpbmVzID8gJzxici8+JyA6ICcgJyk7XG4gICAgICBodG1sICs9IGA8c3BhbiBzdHlsZT0nZm9udC13ZWlnaHQ6IGJvbGQ7IGNvbG9yOiAke3Nlcmllcy5jb2xvcn07Jz4ke3Nlcmllcy5kYXNoSFRNTH0gJHtzZXJpZXMubGFiZWxIVE1MfTwvc3Bhbj5gO1xuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbiAgfVxuXG4gIGh0bWwgPSBkYXRhLnhIVE1MICsgJzonO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlcmllcyA9IGRhdGEuc2VyaWVzW2ldO1xuICAgIGlmICghc2VyaWVzLmlzVmlzaWJsZSkgY29udGludWU7XG4gICAgaWYgKHNlcExpbmVzKSBodG1sICs9ICc8YnI+JztcbiAgICB2YXIgY2xzID0gc2VyaWVzLmlzSGlnaGxpZ2h0ZWQgPyAnIGNsYXNzPVwiaGlnaGxpZ2h0XCInIDogJyc7XG4gICAgaHRtbCArPSBgPHNwYW4ke2Nsc30+IDxiPjxzcGFuIHN0eWxlPSdjb2xvcjogJHtzZXJpZXMuY29sb3J9Oyc+JHtzZXJpZXMubGFiZWxIVE1MfTwvc3Bhbj48L2I+OiYjMTYwOyR7c2VyaWVzLnlIVE1MfTwvc3Bhbj5gO1xuICB9XG4gIHJldHVybiBodG1sO1xufTtcblxuXG4vKipcbiAqIEdlbmVyYXRlcyBodG1sIGZvciB0aGUgXCJkYXNoXCIgZGlzcGxheWVkIG9uIHRoZSBsZWdlbmQgd2hlbiB1c2luZyBcImxlZ2VuZDogYWx3YXlzXCIuXG4gKiBJbiBwYXJ0aWN1bGFyLCB0aGlzIHdvcmtzIGZvciBkYXNoZWQgbGluZXMgd2l0aCBhbnkgc3Ryb2tlIHBhdHRlcm4uIEl0IHdpbGxcbiAqIHRyeSB0byBzY2FsZSB0aGUgcGF0dGVybiB0byBmaXQgaW4gMWVtIHdpZHRoLiBPciBpZiBzbWFsbCBlbm91Z2ggcmVwZWF0IHRoZVxuICogcGF0dGVybiBmb3IgMWVtIHdpZHRoLlxuICpcbiAqIEBwYXJhbSBzdHJva2VQYXR0ZXJuIFRoZSBwYXR0ZXJuXG4gKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSBzZXJpZXMuXG4gKiBAcGFyYW0gb25lRW1XaWR0aCBUaGUgd2lkdGggaW4gcGl4ZWxzIG9mIDFlbSBpbiB0aGUgbGVnZW5kLlxuICogQHByaXZhdGVcbiAqL1xuLy8gVE9ETyhkYW52ayk6IGNhY2hlIHRoZSByZXN1bHRzIG9mIHRoaXNcbmZ1bmN0aW9uIGdlbmVyYXRlTGVnZW5kRGFzaEhUTUwoc3Ryb2tlUGF0dGVybiwgY29sb3IsIG9uZUVtV2lkdGgpIHtcbiAgLy8gRWFzeSwgY29tbW9uIGNhc2U6IGEgc29saWQgbGluZVxuICBpZiAoIXN0cm9rZVBhdHRlcm4gfHwgc3Ryb2tlUGF0dGVybi5sZW5ndGggPD0gMSkge1xuICAgIHJldHVybiBgPGRpdiBjbGFzcz1cImR5Z3JhcGgtbGVnZW5kLWxpbmVcIiBzdHlsZT1cImJvcmRlci1ib3R0b20tY29sb3I6ICR7Y29sb3J9O1wiPjwvZGl2PmA7XG4gIH1cblxuICB2YXIgaSwgaiwgcGFkZGluZ0xlZnQsIG1hcmdpblJpZ2h0O1xuICB2YXIgc3Ryb2tlUGl4ZWxMZW5ndGggPSAwLCBzZWdtZW50TG9vcCA9IDA7XG4gIHZhciBub3JtYWxpemVkUGF0dGVybiA9IFtdO1xuICB2YXIgbG9vcDtcblxuICAvLyBDb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIHBpeGVscyBpbmNsdWRpbmcgdGhlIGZpcnN0IHNlZ21lbnQgdHdpY2UsIFxuICAvLyBzaW5jZSB3ZSByZXBlYXQgaXQuXG4gIGZvciAoaSA9IDA7IGkgPD0gc3Ryb2tlUGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgIHN0cm9rZVBpeGVsTGVuZ3RoICs9IHN0cm9rZVBhdHRlcm5baSVzdHJva2VQYXR0ZXJuLmxlbmd0aF07XG4gIH1cblxuICAvLyBTZWUgaWYgd2UgY2FuIGxvb3AgdGhlIHBhdHRlcm4gYnkgaXRzZWxmIGF0IGxlYXN0IHR3aWNlLlxuICBsb29wID0gTWF0aC5mbG9vcihvbmVFbVdpZHRoLyhzdHJva2VQaXhlbExlbmd0aC1zdHJva2VQYXR0ZXJuWzBdKSk7XG4gIGlmIChsb29wID4gMSkge1xuICAgIC8vIFRoaXMgcGF0dGVybiBmaXRzIGF0IGxlYXN0IHR3byB0aW1lcywgbm8gc2NhbGluZyBqdXN0IGNvbnZlcnQgdG8gZW07XG4gICAgZm9yIChpID0gMDsgaSA8IHN0cm9rZVBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRQYXR0ZXJuW2ldID0gc3Ryb2tlUGF0dGVybltpXS9vbmVFbVdpZHRoO1xuICAgIH1cbiAgICAvLyBTaW5jZSB3ZSBhcmUgcmVwZWF0aW5nIHRoZSBwYXR0ZXJuLCB3ZSBkb24ndCB3b3JyeSBhYm91dCByZXBlYXRpbmcgdGhlXG4gICAgLy8gZmlyc3Qgc2VnbWVudCBpbiBvbmUgZHJhdy5cbiAgICBzZWdtZW50TG9vcCA9IG5vcm1hbGl6ZWRQYXR0ZXJuLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgcGF0dGVybiBkb2Vzbid0IGZpdCBpbiB0aGUgbGVnZW5kIHdlIHNjYWxlIGl0IHRvIGZpdC5cbiAgICBsb29wID0gMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3Ryb2tlUGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgbm9ybWFsaXplZFBhdHRlcm5baV0gPSBzdHJva2VQYXR0ZXJuW2ldL3N0cm9rZVBpeGVsTGVuZ3RoO1xuICAgIH1cbiAgICAvLyBGb3IgdGhlIHNjYWxlZCBwYXR0ZXJucyB3ZSBkbyByZWRyYXcgdGhlIGZpcnN0IHNlZ21lbnQuXG4gICAgc2VnbWVudExvb3AgPSBub3JtYWxpemVkUGF0dGVybi5sZW5ndGgrMTtcbiAgfVxuXG4gIC8vIE5vdyBtYWtlIHRoZSBwYXR0ZXJuLlxuICB2YXIgZGFzaCA9IFwiXCI7XG4gIGZvciAoaiA9IDA7IGogPCBsb29wOyBqKyspIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VnbWVudExvb3A7IGkrPTIpIHtcbiAgICAgIC8vIFRoZSBwYWRkaW5nIGlzIHRoZSBkcmF3biBzZWdtZW50LlxuICAgICAgcGFkZGluZ0xlZnQgPSBub3JtYWxpemVkUGF0dGVybltpJW5vcm1hbGl6ZWRQYXR0ZXJuLmxlbmd0aF07XG4gICAgICBpZiAoaSA8IHN0cm9rZVBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgICAgIC8vIFRoZSBtYXJnaW4gaXMgdGhlIHNwYWNlIHNlZ21lbnQuXG4gICAgICAgIG1hcmdpblJpZ2h0ID0gbm9ybWFsaXplZFBhdHRlcm5bKGkrMSklbm9ybWFsaXplZFBhdHRlcm4ubGVuZ3RoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSByZXBlYXRlZCBmaXJzdCBzZWdtZW50IGhhcyBubyByaWdodCBtYXJnaW4uXG4gICAgICAgIG1hcmdpblJpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICAgIGRhc2ggKz0gYDxkaXYgY2xhc3M9XCJkeWdyYXBoLWxlZ2VuZC1kYXNoXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6ICR7bWFyZ2luUmlnaHR9ZW07IHBhZGRpbmctbGVmdDogJHtwYWRkaW5nTGVmdH1lbTtcIj48L2Rpdj5gO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGFzaDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IExlZ2VuZDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZHlncmFwaHMvc3JjL3BsdWdpbnMvbGVnZW5kLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26\n");

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dygraph_interaction_model__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iframe_tarp__ = __webpack_require__(13);\n/**\n * @license\n * Copyright 2011 Paul Felix (paul.eric.felix@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n/*global Dygraph:false,TouchEvent:false */\n\n/**\n * @fileoverview This file contains the RangeSelector plugin used to provide\n * a timeline range selector widget for dygraphs.\n */\n\n/*global Dygraph:false */\n\n\n\n\n\n\nvar rangeSelector = function rangeSelector() {\n  this.hasTouchInterface_ = typeof TouchEvent != 'undefined';\n  this.isMobileDevice_ = /mobile|android/gi.test(navigator.appVersion);\n  this.interfaceCreated_ = false;\n};\n\nrangeSelector.prototype.toString = function () {\n  return \"RangeSelector Plugin\";\n};\n\nrangeSelector.prototype.activate = function (dygraph) {\n  this.dygraph_ = dygraph;\n  if (this.getOption_('showRangeSelector')) {\n    this.createInterface_();\n  }\n  return {\n    layout: this.reserveSpace_,\n    predraw: this.renderStaticLayer_,\n    didDrawChart: this.renderInteractiveLayer_\n  };\n};\n\nrangeSelector.prototype.destroy = function () {\n  this.bgcanvas_ = null;\n  this.fgcanvas_ = null;\n  this.leftZoomHandle_ = null;\n  this.rightZoomHandle_ = null;\n};\n\n//------------------------------------------------------------------\n// Private methods\n//------------------------------------------------------------------\n\nrangeSelector.prototype.getOption_ = function (name, opt_series) {\n  return this.dygraph_.getOption(name, opt_series);\n};\n\nrangeSelector.prototype.setDefaultOption_ = function (name, value) {\n  this.dygraph_.attrs_[name] = value;\n};\n\n/**\n * @private\n * Creates the range selector elements and adds them to the graph.\n */\nrangeSelector.prototype.createInterface_ = function () {\n  this.createCanvases_();\n  this.createZoomHandles_();\n  this.initInteraction_();\n\n  // Range selector and animatedZooms have a bad interaction. See issue 359.\n  if (this.getOption_('animatedZooms')) {\n    console.warn('Animated zooms and range selector are not compatible; disabling animatedZooms.');\n    this.dygraph_.updateOptions({ animatedZooms: false }, true);\n  }\n\n  this.interfaceCreated_ = true;\n  this.addToGraph_();\n};\n\n/**\n * @private\n * Adds the range selector to the graph.\n */\nrangeSelector.prototype.addToGraph_ = function () {\n  var graphDiv = this.graphDiv_ = this.dygraph_.graphDiv;\n  graphDiv.appendChild(this.bgcanvas_);\n  graphDiv.appendChild(this.fgcanvas_);\n  graphDiv.appendChild(this.leftZoomHandle_);\n  graphDiv.appendChild(this.rightZoomHandle_);\n};\n\n/**\n * @private\n * Removes the range selector from the graph.\n */\nrangeSelector.prototype.removeFromGraph_ = function () {\n  var graphDiv = this.graphDiv_;\n  graphDiv.removeChild(this.bgcanvas_);\n  graphDiv.removeChild(this.fgcanvas_);\n  graphDiv.removeChild(this.leftZoomHandle_);\n  graphDiv.removeChild(this.rightZoomHandle_);\n  this.graphDiv_ = null;\n};\n\n/**\n * @private\n * Called by Layout to allow range selector to reserve its space.\n */\nrangeSelector.prototype.reserveSpace_ = function (e) {\n  if (this.getOption_('showRangeSelector')) {\n    e.reserveSpaceBottom(this.getOption_('rangeSelectorHeight') + 4);\n  }\n};\n\n/**\n * @private\n * Renders the static portion of the range selector at the predraw stage.\n */\nrangeSelector.prototype.renderStaticLayer_ = function () {\n  if (!this.updateVisibility_()) {\n    return;\n  }\n  this.resize_();\n  this.drawStaticLayer_();\n};\n\n/**\n * @private\n * Renders the interactive portion of the range selector after the chart has been drawn.\n */\nrangeSelector.prototype.renderInteractiveLayer_ = function () {\n  if (!this.updateVisibility_() || this.isChangingRange_) {\n    return;\n  }\n  this.placeZoomHandles_();\n  this.drawInteractiveLayer_();\n};\n\n/**\n * @private\n * Check to see if the range selector is enabled/disabled and update visibility accordingly.\n */\nrangeSelector.prototype.updateVisibility_ = function () {\n  var enabled = this.getOption_('showRangeSelector');\n  if (enabled) {\n    if (!this.interfaceCreated_) {\n      this.createInterface_();\n    } else if (!this.graphDiv_ || !this.graphDiv_.parentNode) {\n      this.addToGraph_();\n    }\n  } else if (this.graphDiv_) {\n    this.removeFromGraph_();\n    var dygraph = this.dygraph_;\n    setTimeout(function () {\n      dygraph.width_ = 0;dygraph.resize();\n    }, 1);\n  }\n  return enabled;\n};\n\n/**\n * @private\n * Resizes the range selector.\n */\nrangeSelector.prototype.resize_ = function () {\n  function setElementRect(canvas, context, rect, pixelRatioOption) {\n    var canvasScale = pixelRatioOption || __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"h\" /* getContextPixelRatio */](context);\n\n    canvas.style.top = rect.y + 'px';\n    canvas.style.left = rect.x + 'px';\n    canvas.width = rect.w * canvasScale;\n    canvas.height = rect.h * canvasScale;\n    canvas.style.width = rect.w + 'px';\n    canvas.style.height = rect.h + 'px';\n\n    if (canvasScale != 1) {\n      context.scale(canvasScale, canvasScale);\n    }\n  }\n\n  var plotArea = this.dygraph_.layout_.getPlotArea();\n\n  var xAxisLabelHeight = 0;\n  if (this.dygraph_.getOptionForAxis('drawAxis', 'x')) {\n    xAxisLabelHeight = this.getOption_('xAxisHeight') || this.getOption_('axisLabelFontSize') + 2 * this.getOption_('axisTickSize');\n  }\n  this.canvasRect_ = {\n    x: plotArea.x,\n    y: plotArea.y + plotArea.h + xAxisLabelHeight + 4,\n    w: plotArea.w,\n    h: this.getOption_('rangeSelectorHeight')\n  };\n\n  var pixelRatioOption = this.dygraph_.getNumericOption('pixelRatio');\n  setElementRect(this.bgcanvas_, this.bgcanvas_ctx_, this.canvasRect_, pixelRatioOption);\n  setElementRect(this.fgcanvas_, this.fgcanvas_ctx_, this.canvasRect_, pixelRatioOption);\n};\n\n/**\n * @private\n * Creates the background and foreground canvases.\n */\nrangeSelector.prototype.createCanvases_ = function () {\n  this.bgcanvas_ = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"e\" /* createCanvas */]();\n  this.bgcanvas_.className = 'dygraph-rangesel-bgcanvas';\n  this.bgcanvas_.style.position = 'absolute';\n  this.bgcanvas_.style.zIndex = 9;\n  this.bgcanvas_ctx_ = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"f\" /* getContext */](this.bgcanvas_);\n\n  this.fgcanvas_ = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"e\" /* createCanvas */]();\n  this.fgcanvas_.className = 'dygraph-rangesel-fgcanvas';\n  this.fgcanvas_.style.position = 'absolute';\n  this.fgcanvas_.style.zIndex = 9;\n  this.fgcanvas_.style.cursor = 'default';\n  this.fgcanvas_ctx_ = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"f\" /* getContext */](this.fgcanvas_);\n};\n\n/**\n * @private\n * Creates the zoom handle elements.\n */\nrangeSelector.prototype.createZoomHandles_ = function () {\n  var img = new Image();\n  img.className = 'dygraph-rangesel-zoomhandle';\n  img.style.position = 'absolute';\n  img.style.zIndex = 10;\n  img.style.visibility = 'hidden'; // Initially hidden so they don't show up in the wrong place.\n  img.style.cursor = 'col-resize';\n  // TODO: change image to more options\n  img.width = 9;\n  img.height = 16;\n  img.src = 'data:image/png;base64,' + 'iVBORw0KGgoAAAANSUhEUgAAAAkAAAAQCAYAAADESFVDAAAAAXNSR0IArs4c6QAAAAZiS0dEANAA' + 'zwDP4Z7KegAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAAd0SU1FB9sHGw0cMqdt1UwAAAAZdEVYdENv' + 'bW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAaElEQVQoz+3SsRFAQBCF4Z9WJM8KCDVwownl' + '6YXsTmCUsyKGkZzcl7zkz3YLkypgAnreFmDEpHkIwVOMfpdi9CEEN2nGpFdwD03yEqDtOgCaun7s' + 'qSTDH32I1pQA2Pb9sZecAxc5r3IAb21d6878xsAAAAAASUVORK5CYII=';\n\n  if (this.isMobileDevice_) {\n    img.width *= 2;\n    img.height *= 2;\n  }\n\n  this.leftZoomHandle_ = img;\n  this.rightZoomHandle_ = img.cloneNode(false);\n};\n\n/**\n * @private\n * Sets up the interaction for the range selector.\n */\nrangeSelector.prototype.initInteraction_ = function () {\n  var self = this;\n  var topElem = document;\n  var clientXLast = 0;\n  var handle = null;\n  var isZooming = false;\n  var isPanning = false;\n  var dynamic = !this.isMobileDevice_;\n\n  // We cover iframes during mouse interactions. See comments in\n  // dygraph-utils.js for more info on why this is a good idea.\n  var tarp = new __WEBPACK_IMPORTED_MODULE_2__iframe_tarp__[\"a\" /* default */]();\n\n  // functions, defined below.  Defining them this way (rather than with\n  // \"function foo() {...}\" makes JSHint happy.\n  var toXDataWindow, onZoomStart, onZoom, _onZoomEnd, doZoom, isMouseInPanZone, onPanStart, onPan, _onPanEnd, doPan, onCanvasHover;\n\n  // Touch event functions\n  var onZoomHandleTouchEvent, onCanvasTouchEvent, addTouchEvents;\n\n  toXDataWindow = function toXDataWindow(zoomHandleStatus) {\n    var xDataLimits = self.dygraph_.xAxisExtremes();\n    var fact = (xDataLimits[1] - xDataLimits[0]) / self.canvasRect_.w;\n    var xDataMin = xDataLimits[0] + (zoomHandleStatus.leftHandlePos - self.canvasRect_.x) * fact;\n    var xDataMax = xDataLimits[0] + (zoomHandleStatus.rightHandlePos - self.canvasRect_.x) * fact;\n    return [xDataMin, xDataMax];\n  };\n\n  onZoomStart = function onZoomStart(e) {\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"O\" /* cancelEvent */](e);\n    isZooming = true;\n    clientXLast = e.clientX;\n    handle = e.target ? e.target : e.srcElement;\n    if (e.type === 'mousedown' || e.type === 'dragstart') {\n      // These events are removed manually.\n      __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"F\" /* addEvent */](topElem, 'mousemove', onZoom);\n      __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"F\" /* addEvent */](topElem, 'mouseup', _onZoomEnd);\n    }\n    self.fgcanvas_.style.cursor = 'col-resize';\n    tarp.cover();\n    return true;\n  };\n\n  onZoom = function onZoom(e) {\n    if (!isZooming) {\n      return false;\n    }\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"O\" /* cancelEvent */](e);\n\n    var delX = e.clientX - clientXLast;\n    if (Math.abs(delX) < 4) {\n      return true;\n    }\n    clientXLast = e.clientX;\n\n    // Move handle.\n    var zoomHandleStatus = self.getZoomHandleStatus_();\n    var newPos;\n    if (handle == self.leftZoomHandle_) {\n      newPos = zoomHandleStatus.leftHandlePos + delX;\n      newPos = Math.min(newPos, zoomHandleStatus.rightHandlePos - handle.width - 3);\n      newPos = Math.max(newPos, self.canvasRect_.x);\n    } else {\n      newPos = zoomHandleStatus.rightHandlePos + delX;\n      newPos = Math.min(newPos, self.canvasRect_.x + self.canvasRect_.w);\n      newPos = Math.max(newPos, zoomHandleStatus.leftHandlePos + handle.width + 3);\n    }\n    var halfHandleWidth = handle.width / 2;\n    handle.style.left = newPos - halfHandleWidth + 'px';\n    self.drawInteractiveLayer_();\n\n    // Zoom on the fly.\n    if (dynamic) {\n      doZoom();\n    }\n    return true;\n  };\n\n  _onZoomEnd = function onZoomEnd(e) {\n    if (!isZooming) {\n      return false;\n    }\n    isZooming = false;\n    tarp.uncover();\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"i\" /* removeEvent */](topElem, 'mousemove', onZoom);\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"i\" /* removeEvent */](topElem, 'mouseup', _onZoomEnd);\n    self.fgcanvas_.style.cursor = 'default';\n\n    // If on a slower device, zoom now.\n    if (!dynamic) {\n      doZoom();\n    }\n    return true;\n  };\n\n  doZoom = function doZoom() {\n    try {\n      var zoomHandleStatus = self.getZoomHandleStatus_();\n      self.isChangingRange_ = true;\n      if (!zoomHandleStatus.isZoomed) {\n        self.dygraph_.resetZoom();\n      } else {\n        var xDataWindow = toXDataWindow(zoomHandleStatus);\n        self.dygraph_.doZoomXDates_(xDataWindow[0], xDataWindow[1]);\n      }\n    } finally {\n      self.isChangingRange_ = false;\n    }\n  };\n\n  isMouseInPanZone = function isMouseInPanZone(e) {\n    var rect = self.leftZoomHandle_.getBoundingClientRect();\n    var leftHandleClientX = rect.left + rect.width / 2;\n    rect = self.rightZoomHandle_.getBoundingClientRect();\n    var rightHandleClientX = rect.left + rect.width / 2;\n    return e.clientX > leftHandleClientX && e.clientX < rightHandleClientX;\n  };\n\n  onPanStart = function onPanStart(e) {\n    if (!isPanning && isMouseInPanZone(e) && self.getZoomHandleStatus_().isZoomed) {\n      __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"O\" /* cancelEvent */](e);\n      isPanning = true;\n      clientXLast = e.clientX;\n      if (e.type === 'mousedown') {\n        // These events are removed manually.\n        __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"F\" /* addEvent */](topElem, 'mousemove', onPan);\n        __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"F\" /* addEvent */](topElem, 'mouseup', _onPanEnd);\n      }\n      return true;\n    }\n    return false;\n  };\n\n  onPan = function onPan(e) {\n    if (!isPanning) {\n      return false;\n    }\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"O\" /* cancelEvent */](e);\n\n    var delX = e.clientX - clientXLast;\n    if (Math.abs(delX) < 4) {\n      return true;\n    }\n    clientXLast = e.clientX;\n\n    // Move range view\n    var zoomHandleStatus = self.getZoomHandleStatus_();\n    var leftHandlePos = zoomHandleStatus.leftHandlePos;\n    var rightHandlePos = zoomHandleStatus.rightHandlePos;\n    var rangeSize = rightHandlePos - leftHandlePos;\n    if (leftHandlePos + delX <= self.canvasRect_.x) {\n      leftHandlePos = self.canvasRect_.x;\n      rightHandlePos = leftHandlePos + rangeSize;\n    } else if (rightHandlePos + delX >= self.canvasRect_.x + self.canvasRect_.w) {\n      rightHandlePos = self.canvasRect_.x + self.canvasRect_.w;\n      leftHandlePos = rightHandlePos - rangeSize;\n    } else {\n      leftHandlePos += delX;\n      rightHandlePos += delX;\n    }\n    var halfHandleWidth = self.leftZoomHandle_.width / 2;\n    self.leftZoomHandle_.style.left = leftHandlePos - halfHandleWidth + 'px';\n    self.rightZoomHandle_.style.left = rightHandlePos - halfHandleWidth + 'px';\n    self.drawInteractiveLayer_();\n\n    // Do pan on the fly.\n    if (dynamic) {\n      doPan();\n    }\n    return true;\n  };\n\n  _onPanEnd = function onPanEnd(e) {\n    if (!isPanning) {\n      return false;\n    }\n    isPanning = false;\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"i\" /* removeEvent */](topElem, 'mousemove', onPan);\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"i\" /* removeEvent */](topElem, 'mouseup', _onPanEnd);\n    // If on a slower device, do pan now.\n    if (!dynamic) {\n      doPan();\n    }\n    return true;\n  };\n\n  doPan = function doPan() {\n    try {\n      self.isChangingRange_ = true;\n      self.dygraph_.dateWindow_ = toXDataWindow(self.getZoomHandleStatus_());\n      self.dygraph_.drawGraph_(false);\n    } finally {\n      self.isChangingRange_ = false;\n    }\n  };\n\n  onCanvasHover = function onCanvasHover(e) {\n    if (isZooming || isPanning) {\n      return;\n    }\n    var cursor = isMouseInPanZone(e) ? 'move' : 'default';\n    if (cursor != self.fgcanvas_.style.cursor) {\n      self.fgcanvas_.style.cursor = cursor;\n    }\n  };\n\n  onZoomHandleTouchEvent = function onZoomHandleTouchEvent(e) {\n    if (e.type == 'touchstart' && e.targetTouches.length == 1) {\n      if (onZoomStart(e.targetTouches[0])) {\n        __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"O\" /* cancelEvent */](e);\n      }\n    } else if (e.type == 'touchmove' && e.targetTouches.length == 1) {\n      if (onZoom(e.targetTouches[0])) {\n        __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"O\" /* cancelEvent */](e);\n      }\n    } else {\n      _onZoomEnd(e);\n    }\n  };\n\n  onCanvasTouchEvent = function onCanvasTouchEvent(e) {\n    if (e.type == 'touchstart' && e.targetTouches.length == 1) {\n      if (onPanStart(e.targetTouches[0])) {\n        __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"O\" /* cancelEvent */](e);\n      }\n    } else if (e.type == 'touchmove' && e.targetTouches.length == 1) {\n      if (onPan(e.targetTouches[0])) {\n        __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"O\" /* cancelEvent */](e);\n      }\n    } else {\n      _onPanEnd(e);\n    }\n  };\n\n  addTouchEvents = function addTouchEvents(elem, fn) {\n    var types = ['touchstart', 'touchend', 'touchmove', 'touchcancel'];\n    for (var i = 0; i < types.length; i++) {\n      self.dygraph_.addAndTrackEvent(elem, types[i], fn);\n    }\n  };\n\n  this.setDefaultOption_('interactionModel', __WEBPACK_IMPORTED_MODULE_1__dygraph_interaction_model__[\"a\" /* default */].dragIsPanInteractionModel);\n  this.setDefaultOption_('panEdgeFraction', 0.0001);\n\n  var dragStartEvent = window.opera ? 'mousedown' : 'dragstart';\n  this.dygraph_.addAndTrackEvent(this.leftZoomHandle_, dragStartEvent, onZoomStart);\n  this.dygraph_.addAndTrackEvent(this.rightZoomHandle_, dragStartEvent, onZoomStart);\n\n  this.dygraph_.addAndTrackEvent(this.fgcanvas_, 'mousedown', onPanStart);\n  this.dygraph_.addAndTrackEvent(this.fgcanvas_, 'mousemove', onCanvasHover);\n\n  // Touch events\n  if (this.hasTouchInterface_) {\n    addTouchEvents(this.leftZoomHandle_, onZoomHandleTouchEvent);\n    addTouchEvents(this.rightZoomHandle_, onZoomHandleTouchEvent);\n    addTouchEvents(this.fgcanvas_, onCanvasTouchEvent);\n  }\n};\n\n/**\n * @private\n * Draws the static layer in the background canvas.\n */\nrangeSelector.prototype.drawStaticLayer_ = function () {\n  var ctx = this.bgcanvas_ctx_;\n  ctx.clearRect(0, 0, this.canvasRect_.w, this.canvasRect_.h);\n  try {\n    this.drawMiniPlot_();\n  } catch (ex) {\n    console.warn(ex);\n  }\n\n  var margin = 0.5;\n  this.bgcanvas_ctx_.lineWidth = this.getOption_('rangeSelectorBackgroundLineWidth');\n  ctx.strokeStyle = this.getOption_('rangeSelectorBackgroundStrokeColor');\n  ctx.beginPath();\n  ctx.moveTo(margin, margin);\n  ctx.lineTo(margin, this.canvasRect_.h - margin);\n  ctx.lineTo(this.canvasRect_.w - margin, this.canvasRect_.h - margin);\n  ctx.lineTo(this.canvasRect_.w - margin, margin);\n  ctx.stroke();\n};\n\n/**\n * @private\n * Draws the mini plot in the background canvas.\n */\nrangeSelector.prototype.drawMiniPlot_ = function () {\n  var fillStyle = this.getOption_('rangeSelectorPlotFillColor');\n  var fillGradientStyle = this.getOption_('rangeSelectorPlotFillGradientColor');\n  var strokeStyle = this.getOption_('rangeSelectorPlotStrokeColor');\n  if (!fillStyle && !strokeStyle) {\n    return;\n  }\n\n  var stepPlot = this.getOption_('stepPlot');\n\n  var combinedSeriesData = this.computeCombinedSeriesAndLimits_();\n  var yRange = combinedSeriesData.yMax - combinedSeriesData.yMin;\n\n  // Draw the mini plot.\n  var ctx = this.bgcanvas_ctx_;\n  var margin = 0.5;\n\n  var xExtremes = this.dygraph_.xAxisExtremes();\n  var xRange = Math.max(xExtremes[1] - xExtremes[0], 1.e-30);\n  var xFact = (this.canvasRect_.w - margin) / xRange;\n  var yFact = (this.canvasRect_.h - margin) / yRange;\n  var canvasWidth = this.canvasRect_.w - margin;\n  var canvasHeight = this.canvasRect_.h - margin;\n\n  var prevX = null,\n      prevY = null;\n\n  ctx.beginPath();\n  ctx.moveTo(margin, canvasHeight);\n  for (var i = 0; i < combinedSeriesData.data.length; i++) {\n    var dataPoint = combinedSeriesData.data[i];\n    var x = dataPoint[0] !== null ? (dataPoint[0] - xExtremes[0]) * xFact : NaN;\n    var y = dataPoint[1] !== null ? canvasHeight - (dataPoint[1] - combinedSeriesData.yMin) * yFact : NaN;\n\n    // Skip points that don't change the x-value. Overly fine-grained points\n    // can cause major slowdowns with the ctx.fill() call below.\n    if (!stepPlot && prevX !== null && Math.round(x) == Math.round(prevX)) {\n      continue;\n    }\n\n    if (isFinite(x) && isFinite(y)) {\n      if (prevX === null) {\n        ctx.lineTo(x, canvasHeight);\n      } else if (stepPlot) {\n        ctx.lineTo(x, prevY);\n      }\n      ctx.lineTo(x, y);\n      prevX = x;\n      prevY = y;\n    } else {\n      if (prevX !== null) {\n        if (stepPlot) {\n          ctx.lineTo(x, prevY);\n          ctx.lineTo(x, canvasHeight);\n        } else {\n          ctx.lineTo(prevX, canvasHeight);\n        }\n      }\n      prevX = prevY = null;\n    }\n  }\n  ctx.lineTo(canvasWidth, canvasHeight);\n  ctx.closePath();\n\n  if (fillStyle) {\n    var lingrad = this.bgcanvas_ctx_.createLinearGradient(0, 0, 0, canvasHeight);\n    if (fillGradientStyle) {\n      lingrad.addColorStop(0, fillGradientStyle);\n    }\n    lingrad.addColorStop(1, fillStyle);\n    this.bgcanvas_ctx_.fillStyle = lingrad;\n    ctx.fill();\n  }\n\n  if (strokeStyle) {\n    this.bgcanvas_ctx_.strokeStyle = strokeStyle;\n    this.bgcanvas_ctx_.lineWidth = this.getOption_('rangeSelectorPlotLineWidth');\n    ctx.stroke();\n  }\n};\n\n/**\n * @private\n * Computes and returns the combined series data along with min/max for the mini plot.\n * The combined series consists of averaged values for all series.\n * When series have error bars, the error bars are ignored.\n * @return {Object} An object containing combined series array, ymin, ymax.\n */\nrangeSelector.prototype.computeCombinedSeriesAndLimits_ = function () {\n  var g = this.dygraph_;\n  var logscale = this.getOption_('logscale');\n  var i;\n\n  // Select series to combine. By default, all series are combined.\n  var numColumns = g.numColumns();\n  var labels = g.getLabels();\n  var includeSeries = new Array(numColumns);\n  var anySet = false;\n  var visibility = g.visibility();\n  var inclusion = [];\n\n  for (i = 1; i < numColumns; i++) {\n    var include = this.getOption_('showInRangeSelector', labels[i]);\n    inclusion.push(include);\n    if (include !== null) anySet = true; // it's set explicitly for this series\n  }\n\n  if (anySet) {\n    for (i = 1; i < numColumns; i++) {\n      includeSeries[i] = inclusion[i - 1];\n    }\n  } else {\n    for (i = 1; i < numColumns; i++) {\n      includeSeries[i] = visibility[i - 1];\n    }\n  }\n\n  // Create a combined series (average of selected series values).\n  // TODO(danvk): short-circuit if there's only one series.\n  var rolledSeries = [];\n  var dataHandler = g.dataHandler_;\n  var options = g.attributes_;\n  for (i = 1; i < g.numColumns(); i++) {\n    if (!includeSeries[i]) continue;\n    var series = dataHandler.extractSeries(g.rawData_, i, options);\n    if (g.rollPeriod() > 1) {\n      series = dataHandler.rollingAverage(series, g.rollPeriod(), options);\n    }\n\n    rolledSeries.push(series);\n  }\n\n  var combinedSeries = [];\n  for (i = 0; i < rolledSeries[0].length; i++) {\n    var sum = 0;\n    var count = 0;\n    for (var j = 0; j < rolledSeries.length; j++) {\n      var y = rolledSeries[j][i][1];\n      if (y === null || isNaN(y)) continue;\n      count++;\n      sum += y;\n    }\n    combinedSeries.push([rolledSeries[0][i][0], sum / count]);\n  }\n\n  // Compute the y range.\n  var yMin = Number.MAX_VALUE;\n  var yMax = -Number.MAX_VALUE;\n  for (i = 0; i < combinedSeries.length; i++) {\n    var yVal = combinedSeries[i][1];\n    if (yVal !== null && isFinite(yVal) && (!logscale || yVal > 0)) {\n      yMin = Math.min(yMin, yVal);\n      yMax = Math.max(yMax, yVal);\n    }\n  }\n\n  // Convert Y data to log scale if needed.\n  // Also, expand the Y range to compress the mini plot a little.\n  var extraPercent = 0.25;\n  if (logscale) {\n    yMax = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](yMax);\n    yMax += yMax * extraPercent;\n    yMin = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](yMin);\n    for (i = 0; i < combinedSeries.length; i++) {\n      combinedSeries[i][1] = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](combinedSeries[i][1]);\n    }\n  } else {\n    var yExtra;\n    var yRange = yMax - yMin;\n    if (yRange <= Number.MIN_VALUE) {\n      yExtra = yMax * extraPercent;\n    } else {\n      yExtra = yRange * extraPercent;\n    }\n    yMax += yExtra;\n    yMin -= yExtra;\n  }\n\n  return { data: combinedSeries, yMin: yMin, yMax: yMax };\n};\n\n/**\n * @private\n * Places the zoom handles in the proper position based on the current X data window.\n */\nrangeSelector.prototype.placeZoomHandles_ = function () {\n  var xExtremes = this.dygraph_.xAxisExtremes();\n  var xWindowLimits = this.dygraph_.xAxisRange();\n  var xRange = xExtremes[1] - xExtremes[0];\n  var leftPercent = Math.max(0, (xWindowLimits[0] - xExtremes[0]) / xRange);\n  var rightPercent = Math.max(0, (xExtremes[1] - xWindowLimits[1]) / xRange);\n  var leftCoord = this.canvasRect_.x + this.canvasRect_.w * leftPercent;\n  var rightCoord = this.canvasRect_.x + this.canvasRect_.w * (1 - rightPercent);\n  var handleTop = Math.max(this.canvasRect_.y, this.canvasRect_.y + (this.canvasRect_.h - this.leftZoomHandle_.height) / 2);\n  var halfHandleWidth = this.leftZoomHandle_.width / 2;\n  this.leftZoomHandle_.style.left = leftCoord - halfHandleWidth + 'px';\n  this.leftZoomHandle_.style.top = handleTop + 'px';\n  this.rightZoomHandle_.style.left = rightCoord - halfHandleWidth + 'px';\n  this.rightZoomHandle_.style.top = this.leftZoomHandle_.style.top;\n\n  this.leftZoomHandle_.style.visibility = 'visible';\n  this.rightZoomHandle_.style.visibility = 'visible';\n};\n\n/**\n * @private\n * Draws the interactive layer in the foreground canvas.\n */\nrangeSelector.prototype.drawInteractiveLayer_ = function () {\n  var ctx = this.fgcanvas_ctx_;\n  ctx.clearRect(0, 0, this.canvasRect_.w, this.canvasRect_.h);\n  var margin = 1;\n  var width = this.canvasRect_.w - margin;\n  var height = this.canvasRect_.h - margin;\n  var zoomHandleStatus = this.getZoomHandleStatus_();\n\n  ctx.strokeStyle = this.getOption_('rangeSelectorForegroundStrokeColor');\n  ctx.lineWidth = this.getOption_('rangeSelectorForegroundLineWidth');\n  if (!zoomHandleStatus.isZoomed) {\n    ctx.beginPath();\n    ctx.moveTo(margin, margin);\n    ctx.lineTo(margin, height);\n    ctx.lineTo(width, height);\n    ctx.lineTo(width, margin);\n    ctx.stroke();\n  } else {\n    var leftHandleCanvasPos = Math.max(margin, zoomHandleStatus.leftHandlePos - this.canvasRect_.x);\n    var rightHandleCanvasPos = Math.min(width, zoomHandleStatus.rightHandlePos - this.canvasRect_.x);\n\n    ctx.fillStyle = 'rgba(240, 240, 240, ' + this.getOption_('rangeSelectorAlpha').toString() + ')';\n    ctx.fillRect(0, 0, leftHandleCanvasPos, this.canvasRect_.h);\n    ctx.fillRect(rightHandleCanvasPos, 0, this.canvasRect_.w - rightHandleCanvasPos, this.canvasRect_.h);\n\n    ctx.beginPath();\n    ctx.moveTo(margin, margin);\n    ctx.lineTo(leftHandleCanvasPos, margin);\n    ctx.lineTo(leftHandleCanvasPos, height);\n    ctx.lineTo(rightHandleCanvasPos, height);\n    ctx.lineTo(rightHandleCanvasPos, margin);\n    ctx.lineTo(width, margin);\n    ctx.stroke();\n  }\n};\n\n/**\n * @private\n * Returns the current zoom handle position information.\n * @return {Object} The zoom handle status.\n */\nrangeSelector.prototype.getZoomHandleStatus_ = function () {\n  var halfHandleWidth = this.leftZoomHandle_.width / 2;\n  var leftHandlePos = parseFloat(this.leftZoomHandle_.style.left) + halfHandleWidth;\n  var rightHandlePos = parseFloat(this.rightZoomHandle_.style.left) + halfHandleWidth;\n  return {\n    leftHandlePos: leftHandlePos,\n    rightHandlePos: rightHandlePos,\n    isZoomed: leftHandlePos - 1 > this.canvasRect_.x || rightHandlePos + 1 < this.canvasRect_.x + this.canvasRect_.w\n  };\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (rangeSelector);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL3JhbmdlLXNlbGVjdG9yLmpzPzJhNGIiXSwibmFtZXMiOlsicmFuZ2VTZWxlY3RvciIsImhhc1RvdWNoSW50ZXJmYWNlXyIsIlRvdWNoRXZlbnQiLCJpc01vYmlsZURldmljZV8iLCJ0ZXN0IiwibmF2aWdhdG9yIiwiYXBwVmVyc2lvbiIsImludGVyZmFjZUNyZWF0ZWRfIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJhY3RpdmF0ZSIsImR5Z3JhcGgiLCJkeWdyYXBoXyIsImdldE9wdGlvbl8iLCJjcmVhdGVJbnRlcmZhY2VfIiwibGF5b3V0IiwicmVzZXJ2ZVNwYWNlXyIsInByZWRyYXciLCJyZW5kZXJTdGF0aWNMYXllcl8iLCJkaWREcmF3Q2hhcnQiLCJyZW5kZXJJbnRlcmFjdGl2ZUxheWVyXyIsImRlc3Ryb3kiLCJiZ2NhbnZhc18iLCJmZ2NhbnZhc18iLCJsZWZ0Wm9vbUhhbmRsZV8iLCJyaWdodFpvb21IYW5kbGVfIiwibmFtZSIsIm9wdF9zZXJpZXMiLCJnZXRPcHRpb24iLCJzZXREZWZhdWx0T3B0aW9uXyIsInZhbHVlIiwiYXR0cnNfIiwiY3JlYXRlQ2FudmFzZXNfIiwiY3JlYXRlWm9vbUhhbmRsZXNfIiwiaW5pdEludGVyYWN0aW9uXyIsImNvbnNvbGUiLCJ3YXJuIiwidXBkYXRlT3B0aW9ucyIsImFuaW1hdGVkWm9vbXMiLCJhZGRUb0dyYXBoXyIsImdyYXBoRGl2IiwiZ3JhcGhEaXZfIiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVGcm9tR3JhcGhfIiwicmVtb3ZlQ2hpbGQiLCJlIiwicmVzZXJ2ZVNwYWNlQm90dG9tIiwidXBkYXRlVmlzaWJpbGl0eV8iLCJyZXNpemVfIiwiZHJhd1N0YXRpY0xheWVyXyIsImlzQ2hhbmdpbmdSYW5nZV8iLCJwbGFjZVpvb21IYW5kbGVzXyIsImRyYXdJbnRlcmFjdGl2ZUxheWVyXyIsImVuYWJsZWQiLCJwYXJlbnROb2RlIiwic2V0VGltZW91dCIsIndpZHRoXyIsInJlc2l6ZSIsInNldEVsZW1lbnRSZWN0IiwiY2FudmFzIiwiY29udGV4dCIsInJlY3QiLCJwaXhlbFJhdGlvT3B0aW9uIiwiY2FudmFzU2NhbGUiLCJzdHlsZSIsInRvcCIsInkiLCJsZWZ0IiwieCIsIndpZHRoIiwidyIsImhlaWdodCIsImgiLCJzY2FsZSIsInBsb3RBcmVhIiwibGF5b3V0XyIsImdldFBsb3RBcmVhIiwieEF4aXNMYWJlbEhlaWdodCIsImdldE9wdGlvbkZvckF4aXMiLCJjYW52YXNSZWN0XyIsImdldE51bWVyaWNPcHRpb24iLCJiZ2NhbnZhc19jdHhfIiwiZmdjYW52YXNfY3R4XyIsImNsYXNzTmFtZSIsInBvc2l0aW9uIiwiekluZGV4IiwiY3Vyc29yIiwiaW1nIiwiSW1hZ2UiLCJ2aXNpYmlsaXR5Iiwic3JjIiwiY2xvbmVOb2RlIiwic2VsZiIsInRvcEVsZW0iLCJkb2N1bWVudCIsImNsaWVudFhMYXN0IiwiaGFuZGxlIiwiaXNab29taW5nIiwiaXNQYW5uaW5nIiwiZHluYW1pYyIsInRhcnAiLCJ0b1hEYXRhV2luZG93Iiwib25ab29tU3RhcnQiLCJvblpvb20iLCJvblpvb21FbmQiLCJkb1pvb20iLCJpc01vdXNlSW5QYW5ab25lIiwib25QYW5TdGFydCIsIm9uUGFuIiwib25QYW5FbmQiLCJkb1BhbiIsIm9uQ2FudmFzSG92ZXIiLCJvblpvb21IYW5kbGVUb3VjaEV2ZW50Iiwib25DYW52YXNUb3VjaEV2ZW50IiwiYWRkVG91Y2hFdmVudHMiLCJ6b29tSGFuZGxlU3RhdHVzIiwieERhdGFMaW1pdHMiLCJ4QXhpc0V4dHJlbWVzIiwiZmFjdCIsInhEYXRhTWluIiwibGVmdEhhbmRsZVBvcyIsInhEYXRhTWF4IiwicmlnaHRIYW5kbGVQb3MiLCJ1dGlscyIsImNsaWVudFgiLCJ0YXJnZXQiLCJzcmNFbGVtZW50IiwidHlwZSIsImNvdmVyIiwiZGVsWCIsIk1hdGgiLCJhYnMiLCJnZXRab29tSGFuZGxlU3RhdHVzXyIsIm5ld1BvcyIsIm1pbiIsIm1heCIsImhhbGZIYW5kbGVXaWR0aCIsInVuY292ZXIiLCJpc1pvb21lZCIsInJlc2V0Wm9vbSIsInhEYXRhV2luZG93IiwiZG9ab29tWERhdGVzXyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxlZnRIYW5kbGVDbGllbnRYIiwicmlnaHRIYW5kbGVDbGllbnRYIiwicmFuZ2VTaXplIiwiZGF0ZVdpbmRvd18iLCJkcmF3R3JhcGhfIiwidGFyZ2V0VG91Y2hlcyIsImxlbmd0aCIsImVsZW0iLCJmbiIsInR5cGVzIiwiaSIsImFkZEFuZFRyYWNrRXZlbnQiLCJEeWdyYXBoSW50ZXJhY3Rpb24iLCJkcmFnSXNQYW5JbnRlcmFjdGlvbk1vZGVsIiwiZHJhZ1N0YXJ0RXZlbnQiLCJ3aW5kb3ciLCJvcGVyYSIsImN0eCIsImNsZWFyUmVjdCIsImRyYXdNaW5pUGxvdF8iLCJleCIsIm1hcmdpbiIsImxpbmVXaWR0aCIsInN0cm9rZVN0eWxlIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwiZmlsbFN0eWxlIiwiZmlsbEdyYWRpZW50U3R5bGUiLCJzdGVwUGxvdCIsImNvbWJpbmVkU2VyaWVzRGF0YSIsImNvbXB1dGVDb21iaW5lZFNlcmllc0FuZExpbWl0c18iLCJ5UmFuZ2UiLCJ5TWF4IiwieU1pbiIsInhFeHRyZW1lcyIsInhSYW5nZSIsInhGYWN0IiwieUZhY3QiLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsInByZXZYIiwicHJldlkiLCJkYXRhIiwiZGF0YVBvaW50IiwiTmFOIiwicm91bmQiLCJpc0Zpbml0ZSIsImNsb3NlUGF0aCIsImxpbmdyYWQiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsImFkZENvbG9yU3RvcCIsImZpbGwiLCJnIiwibG9nc2NhbGUiLCJudW1Db2x1bW5zIiwibGFiZWxzIiwiZ2V0TGFiZWxzIiwiaW5jbHVkZVNlcmllcyIsIkFycmF5IiwiYW55U2V0IiwiaW5jbHVzaW9uIiwiaW5jbHVkZSIsInB1c2giLCJyb2xsZWRTZXJpZXMiLCJkYXRhSGFuZGxlciIsImRhdGFIYW5kbGVyXyIsIm9wdGlvbnMiLCJhdHRyaWJ1dGVzXyIsInNlcmllcyIsImV4dHJhY3RTZXJpZXMiLCJyYXdEYXRhXyIsInJvbGxQZXJpb2QiLCJyb2xsaW5nQXZlcmFnZSIsImNvbWJpbmVkU2VyaWVzIiwic3VtIiwiY291bnQiLCJqIiwiaXNOYU4iLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJ5VmFsIiwiZXh0cmFQZXJjZW50IiwieUV4dHJhIiwiTUlOX1ZBTFVFIiwieFdpbmRvd0xpbWl0cyIsInhBeGlzUmFuZ2UiLCJsZWZ0UGVyY2VudCIsInJpZ2h0UGVyY2VudCIsImxlZnRDb29yZCIsInJpZ2h0Q29vcmQiLCJoYW5kbGVUb3AiLCJsZWZ0SGFuZGxlQ2FudmFzUG9zIiwicmlnaHRIYW5kbGVDYW52YXNQb3MiLCJmaWxsUmVjdCIsInBhcnNlRmxvYXQiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFBQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJQSxnQkFBZ0IsU0FBaEJBLGFBQWdCLEdBQVc7QUFDN0IsT0FBS0Msa0JBQUwsR0FBMEIsT0FBT0MsVUFBUCxJQUFzQixXQUFoRDtBQUNBLE9BQUtDLGVBQUwsR0FBdUIsbUJBQW1CQyxJQUFuQixDQUF3QkMsVUFBVUMsVUFBbEMsQ0FBdkI7QUFDQSxPQUFLQyxpQkFBTCxHQUF5QixLQUF6QjtBQUNELENBSkQ7O0FBTUFQLGNBQWNRLFNBQWQsQ0FBd0JDLFFBQXhCLEdBQW1DLFlBQVc7QUFDNUMsU0FBTyxzQkFBUDtBQUNELENBRkQ7O0FBSUFULGNBQWNRLFNBQWQsQ0FBd0JFLFFBQXhCLEdBQW1DLFVBQVNDLE9BQVQsRUFBa0I7QUFDbkQsT0FBS0MsUUFBTCxHQUFnQkQsT0FBaEI7QUFDQSxNQUFJLEtBQUtFLFVBQUwsQ0FBZ0IsbUJBQWhCLENBQUosRUFBMEM7QUFDeEMsU0FBS0MsZ0JBQUw7QUFDRDtBQUNELFNBQU87QUFDTEMsWUFBUSxLQUFLQyxhQURSO0FBRUxDLGFBQVMs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IjoiMjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMSBQYXVsIEZlbGl4IChwYXVsLmVyaWMuZmVsaXhAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlLFRvdWNoRXZlbnQ6ZmFsc2UgKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgZmlsZSBjb250YWlucyB0aGUgUmFuZ2VTZWxlY3RvciBwbHVnaW4gdXNlZCB0byBwcm92aWRlXG4gKiBhIHRpbWVsaW5lIHJhbmdlIHNlbGVjdG9yIHdpZGdldCBmb3IgZHlncmFwaHMuXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL2R5Z3JhcGgtdXRpbHMnO1xuaW1wb3J0IER5Z3JhcGhJbnRlcmFjdGlvbiBmcm9tICcuLi9keWdyYXBoLWludGVyYWN0aW9uLW1vZGVsJztcbmltcG9ydCBJRnJhbWVUYXJwIGZyb20gJy4uL2lmcmFtZS10YXJwJztcblxudmFyIHJhbmdlU2VsZWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5oYXNUb3VjaEludGVyZmFjZV8gPSB0eXBlb2YoVG91Y2hFdmVudCkgIT0gJ3VuZGVmaW5lZCc7XG4gIHRoaXMuaXNNb2JpbGVEZXZpY2VfID0gL21vYmlsZXxhbmRyb2lkL2dpLnRlc3QobmF2aWdhdG9yLmFwcFZlcnNpb24pO1xuICB0aGlzLmludGVyZmFjZUNyZWF0ZWRfID0gZmFsc2U7XG59O1xuXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCJSYW5nZVNlbGVjdG9yIFBsdWdpblwiO1xufTtcblxucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbihkeWdyYXBoKSB7XG4gIHRoaXMuZHlncmFwaF8gPSBkeWdyYXBoO1xuICBpZiAodGhpcy5nZXRPcHRpb25fKCdzaG93UmFuZ2VTZWxlY3RvcicpKSB7XG4gICAgdGhpcy5jcmVhdGVJbnRlcmZhY2VfKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsYXlvdXQ6IHRoaXMucmVzZXJ2ZVNwYWNlXyxcbiAgICBwcmVkcmF3OiB0aGlzLnJlbmRlclN0YXRpY0xheWVyXyxcbiAgICBkaWREcmF3Q2hhcnQ6IHRoaXMucmVuZGVySW50ZXJhY3RpdmVMYXllcl9cbiAgfTtcbn07XG5cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5iZ2NhbnZhc18gPSBudWxsO1xuICB0aGlzLmZnY2FudmFzXyA9IG51bGw7XG4gIHRoaXMubGVmdFpvb21IYW5kbGVfID0gbnVsbDtcbiAgdGhpcy5yaWdodFpvb21IYW5kbGVfID0gbnVsbDtcbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIG1ldGhvZHNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmdldE9wdGlvbl8gPSBmdW5jdGlvbihuYW1lLCBvcHRfc2VyaWVzKSB7XG4gIHJldHVybiB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbihuYW1lLCBvcHRfc2VyaWVzKTtcbn07XG5cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnNldERlZmF1bHRPcHRpb25fID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5keWdyYXBoXy5hdHRyc19bbmFtZV0gPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENyZWF0ZXMgdGhlIHJhbmdlIHNlbGVjdG9yIGVsZW1lbnRzIGFuZCBhZGRzIHRoZW0gdG8gdGhlIGdyYXBoLlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5jcmVhdGVJbnRlcmZhY2VfID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3JlYXRlQ2FudmFzZXNfKCk7XG4gIHRoaXMuY3JlYXRlWm9vbUhhbmRsZXNfKCk7XG4gIHRoaXMuaW5pdEludGVyYWN0aW9uXygpO1xuXG4gIC8vIFJhbmdlIHNlbGVjdG9yIGFuZCBhbmltYXRlZFpvb21zIGhhdmUgYSBiYWQgaW50ZXJhY3Rpb24uIFNlZSBpc3N1ZSAzNTkuXG4gIGlmICh0aGlzLmdldE9wdGlvbl8oJ2FuaW1hdGVkWm9vbXMnKSkge1xuICAgIGNvbnNvbGUud2FybignQW5pbWF0ZWQgem9vbXMgYW5kIHJhbmdlIHNlbGVjdG9yIGFyZSBub3QgY29tcGF0aWJsZTsgZGlzYWJsaW5nIGFuaW1hdGVkWm9vbXMuJyk7XG4gICAgdGhpcy5keWdyYXBoXy51cGRhdGVPcHRpb25zKHthbmltYXRlZFpvb21zOiBmYWxzZX0sIHRydWUpO1xuICB9XG5cbiAgdGhpcy5pbnRlcmZhY2VDcmVhdGVkXyA9IHRydWU7XG4gIHRoaXMuYWRkVG9HcmFwaF8oKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEFkZHMgdGhlIHJhbmdlIHNlbGVjdG9yIHRvIHRoZSBncmFwaC5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuYWRkVG9HcmFwaF8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGdyYXBoRGl2ID0gdGhpcy5ncmFwaERpdl8gPSB0aGlzLmR5Z3JhcGhfLmdyYXBoRGl2O1xuICBncmFwaERpdi5hcHBlbmRDaGlsZCh0aGlzLmJnY2FudmFzXyk7XG4gIGdyYXBoRGl2LmFwcGVuZENoaWxkKHRoaXMuZmdjYW52YXNfKTtcbiAgZ3JhcGhEaXYuYXBwZW5kQ2hpbGQodGhpcy5sZWZ0Wm9vbUhhbmRsZV8pO1xuICBncmFwaERpdi5hcHBlbmRDaGlsZCh0aGlzLnJpZ2h0Wm9vbUhhbmRsZV8pO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmVtb3ZlcyB0aGUgcmFuZ2Ugc2VsZWN0b3IgZnJvbSB0aGUgZ3JhcGguXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnJlbW92ZUZyb21HcmFwaF8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGdyYXBoRGl2ID0gdGhpcy5ncmFwaERpdl87XG4gIGdyYXBoRGl2LnJlbW92ZUNoaWxkKHRoaXMuYmdjYW52YXNfKTtcbiAgZ3JhcGhEaXYucmVtb3ZlQ2hpbGQodGhpcy5mZ2NhbnZhc18pO1xuICBncmFwaERpdi5yZW1vdmVDaGlsZCh0aGlzLmxlZnRab29tSGFuZGxlXyk7XG4gIGdyYXBoRGl2LnJlbW92ZUNoaWxkKHRoaXMucmlnaHRab29tSGFuZGxlXyk7XG4gIHRoaXMuZ3JhcGhEaXZfID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENhbGxlZCBieSBMYXlvdXQgdG8gYWxsb3cgcmFuZ2Ugc2VsZWN0b3IgdG8gcmVzZXJ2ZSBpdHMgc3BhY2UuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnJlc2VydmVTcGFjZV8gPSBmdW5jdGlvbihlKSB7XG4gIGlmICh0aGlzLmdldE9wdGlvbl8oJ3Nob3dSYW5nZVNlbGVjdG9yJykpIHtcbiAgICBlLnJlc2VydmVTcGFjZUJvdHRvbSh0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JIZWlnaHQnKSArIDQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZW5kZXJzIHRoZSBzdGF0aWMgcG9ydGlvbiBvZiB0aGUgcmFuZ2Ugc2VsZWN0b3IgYXQgdGhlIHByZWRyYXcgc3RhZ2UuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnJlbmRlclN0YXRpY0xheWVyXyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMudXBkYXRlVmlzaWJpbGl0eV8oKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlc2l6ZV8oKTtcbiAgdGhpcy5kcmF3U3RhdGljTGF5ZXJfKCk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZW5kZXJzIHRoZSBpbnRlcmFjdGl2ZSBwb3J0aW9uIG9mIHRoZSByYW5nZSBzZWxlY3RvciBhZnRlciB0aGUgY2hhcnQgaGFzIGJlZW4gZHJhd24uXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnJlbmRlckludGVyYWN0aXZlTGF5ZXJfID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy51cGRhdGVWaXNpYmlsaXR5XygpIHx8IHRoaXMuaXNDaGFuZ2luZ1JhbmdlXykge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnBsYWNlWm9vbUhhbmRsZXNfKCk7XG4gIHRoaXMuZHJhd0ludGVyYWN0aXZlTGF5ZXJfKCk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBDaGVjayB0byBzZWUgaWYgdGhlIHJhbmdlIHNlbGVjdG9yIGlzIGVuYWJsZWQvZGlzYWJsZWQgYW5kIHVwZGF0ZSB2aXNpYmlsaXR5IGFjY29yZGluZ2x5LlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS51cGRhdGVWaXNpYmlsaXR5XyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZW5hYmxlZCA9IHRoaXMuZ2V0T3B0aW9uXygnc2hvd1JhbmdlU2VsZWN0b3InKTtcbiAgaWYgKGVuYWJsZWQpIHtcbiAgICBpZiAoIXRoaXMuaW50ZXJmYWNlQ3JlYXRlZF8pIHtcbiAgICAgIHRoaXMuY3JlYXRlSW50ZXJmYWNlXygpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuZ3JhcGhEaXZfIHx8ICF0aGlzLmdyYXBoRGl2Xy5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmFkZFRvR3JhcGhfKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuZ3JhcGhEaXZfKSB7XG4gICAgdGhpcy5yZW1vdmVGcm9tR3JhcGhfKCk7XG4gICAgdmFyIGR5Z3JhcGggPSB0aGlzLmR5Z3JhcGhfO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGR5Z3JhcGgud2lkdGhfID0gMDsgZHlncmFwaC5yZXNpemUoKTsgfSwgMSk7XG4gIH1cbiAgcmV0dXJuIGVuYWJsZWQ7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZXNpemVzIHRoZSByYW5nZSBzZWxlY3Rvci5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUucmVzaXplXyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzZXRFbGVtZW50UmVjdChjYW52YXMsIGNvbnRleHQsIHJlY3QsIHBpeGVsUmF0aW9PcHRpb24pIHtcbiAgICB2YXIgY2FudmFzU2NhbGUgPSBwaXhlbFJhdGlvT3B0aW9uIHx8IHV0aWxzLmdldENvbnRleHRQaXhlbFJhdGlvKGNvbnRleHQpO1xuXG4gICAgY2FudmFzLnN0eWxlLnRvcCA9IHJlY3QueSArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmxlZnQgPSByZWN0LnggKyAncHgnO1xuICAgIGNhbnZhcy53aWR0aCA9IHJlY3QudyAqIGNhbnZhc1NjYWxlO1xuICAgIGNhbnZhcy5oZWlnaHQgPSByZWN0LmggKiBjYW52YXNTY2FsZTtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSByZWN0LncgKyAncHgnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSByZWN0LmggKyAncHgnO1xuXG4gICAgaWYoY2FudmFzU2NhbGUgIT0gMSkge1xuICAgICAgY29udGV4dC5zY2FsZShjYW52YXNTY2FsZSwgY2FudmFzU2NhbGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwbG90QXJlYSA9IHRoaXMuZHlncmFwaF8ubGF5b3V0Xy5nZXRQbG90QXJlYSgpO1xuXG4gIHZhciB4QXhpc0xhYmVsSGVpZ2h0ID0gMDtcbiAgaWYgKHRoaXMuZHlncmFwaF8uZ2V0T3B0aW9uRm9yQXhpcygnZHJhd0F4aXMnLCAneCcpKSB7XG4gICAgeEF4aXNMYWJlbEhlaWdodCA9IHRoaXMuZ2V0T3B0aW9uXygneEF4aXNIZWlnaHQnKSB8fCAodGhpcy5nZXRPcHRpb25fKCdheGlzTGFiZWxGb250U2l6ZScpICsgMiAqIHRoaXMuZ2V0T3B0aW9uXygnYXhpc1RpY2tTaXplJykpO1xuICB9XG4gIHRoaXMuY2FudmFzUmVjdF8gPSB7XG4gICAgeDogcGxvdEFyZWEueCxcbiAgICB5OiBwbG90QXJlYS55ICsgcGxvdEFyZWEuaCArIHhBeGlzTGFiZWxIZWlnaHQgKyA0LFxuICAgIHc6IHBsb3RBcmVhLncsXG4gICAgaDogdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9ySGVpZ2h0JylcbiAgfTtcblxuICB2YXIgcGl4ZWxSYXRpb09wdGlvbiA9IHRoaXMuZHlncmFwaF8uZ2V0TnVtZXJpY09wdGlvbigncGl4ZWxSYXRpbycpO1xuICBzZXRFbGVtZW50UmVjdCh0aGlzLmJnY2FudmFzXywgdGhpcy5iZ2NhbnZhc19jdHhfLCB0aGlzLmNhbnZhc1JlY3RfLCBwaXhlbFJhdGlvT3B0aW9uKTtcbiAgc2V0RWxlbWVudFJlY3QodGhpcy5mZ2NhbnZhc18sIHRoaXMuZmdjYW52YXNfY3R4XywgdGhpcy5jYW52YXNSZWN0XywgcGl4ZWxSYXRpb09wdGlvbik7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBDcmVhdGVzIHRoZSBiYWNrZ3JvdW5kIGFuZCBmb3JlZ3JvdW5kIGNhbnZhc2VzLlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5jcmVhdGVDYW52YXNlc18gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5iZ2NhbnZhc18gPSB1dGlscy5jcmVhdGVDYW52YXMoKTtcbiAgdGhpcy5iZ2NhbnZhc18uY2xhc3NOYW1lID0gJ2R5Z3JhcGgtcmFuZ2VzZWwtYmdjYW52YXMnO1xuICB0aGlzLmJnY2FudmFzXy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIHRoaXMuYmdjYW52YXNfLnN0eWxlLnpJbmRleCA9IDk7XG4gIHRoaXMuYmdjYW52YXNfY3R4XyA9IHV0aWxzLmdldENvbnRleHQodGhpcy5iZ2NhbnZhc18pO1xuXG4gIHRoaXMuZmdjYW52YXNfID0gdXRpbHMuY3JlYXRlQ2FudmFzKCk7XG4gIHRoaXMuZmdjYW52YXNfLmNsYXNzTmFtZSA9ICdkeWdyYXBoLXJhbmdlc2VsLWZnY2FudmFzJztcbiAgdGhpcy5mZ2NhbnZhc18uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICB0aGlzLmZnY2FudmFzXy5zdHlsZS56SW5kZXggPSA5O1xuICB0aGlzLmZnY2FudmFzXy5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gIHRoaXMuZmdjYW52YXNfY3R4XyA9IHV0aWxzLmdldENvbnRleHQodGhpcy5mZ2NhbnZhc18pO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQ3JlYXRlcyB0aGUgem9vbSBoYW5kbGUgZWxlbWVudHMuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmNyZWF0ZVpvb21IYW5kbGVzXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gIGltZy5jbGFzc05hbWUgPSAnZHlncmFwaC1yYW5nZXNlbC16b29taGFuZGxlJztcbiAgaW1nLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgaW1nLnN0eWxlLnpJbmRleCA9IDEwO1xuICBpbWcuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nOyAvLyBJbml0aWFsbHkgaGlkZGVuIHNvIHRoZXkgZG9uJ3Qgc2hvdyB1cCBpbiB0aGUgd3JvbmcgcGxhY2UuXG4gIGltZy5zdHlsZS5jdXJzb3IgPSAnY29sLXJlc2l6ZSc7XG4gIC8vIFRPRE86IGNoYW5nZSBpbWFnZSB0byBtb3JlIG9wdGlvbnNcbiAgaW1nLndpZHRoID0gOTtcbiAgaW1nLmhlaWdodCA9IDE2O1xuICBpbWcuc3JjID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwnICtcbidpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQWtBQUFBUUNBWUFBQURFU0ZWREFBQUFBWE5TUjBJQXJzNGM2UUFBQUFaaVMwZEVBTkFBJyArXG4nendEUDRaN0tlZ0FBQUFsd1NGbHpBQUFPeEFBQURzUUJsU3NPR3dBQUFBZDBTVTFGQjlzSEd3MGNNcWR0MVV3QUFBQVpkRVZZZEVOdicgK1xuJ2JXMWxiblFBUTNKbFlYUmxaQ0IzYVhSb0lFZEpUVkJYZ1E0WEFBQUFhRWxFUVZRb3orM1NzUkZBUUJDRjRaOVdKTThLQ0RWd293bmwnICtcbic2WVhzVG1DVXN5S0drWnpjbDd6a3ozWUxreXBnQW5yZUZtREVwSGtJd1ZPTWZwZGk5Q0VFTjJuR3BGZHdEMDN5RXFEdE9nQ2F1bjdzJyArXG4ncVNUREgzMkkxcFFBMlBiOXNaZWNBeGM1cjNJQWIyMWQ2ODc4eHNBQUFBQUFTVVZPUks1Q1lJST0nO1xuXG4gIGlmICh0aGlzLmlzTW9iaWxlRGV2aWNlXykge1xuICAgIGltZy53aWR0aCAqPSAyO1xuICAgIGltZy5oZWlnaHQgKj0gMjtcbiAgfVxuXG4gIHRoaXMubGVmdFpvb21IYW5kbGVfID0gaW1nO1xuICB0aGlzLnJpZ2h0Wm9vbUhhbmRsZV8gPSBpbWcuY2xvbmVOb2RlKGZhbHNlKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFNldHMgdXAgdGhlIGludGVyYWN0aW9uIGZvciB0aGUgcmFuZ2Ugc2VsZWN0b3IuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmluaXRJbnRlcmFjdGlvbl8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdG9wRWxlbSA9IGRvY3VtZW50O1xuICB2YXIgY2xpZW50WExhc3QgPSAwO1xuICB2YXIgaGFuZGxlID0gbnVsbDtcbiAgdmFyIGlzWm9vbWluZyA9IGZhbHNlO1xuICB2YXIgaXNQYW5uaW5nID0gZmFsc2U7XG4gIHZhciBkeW5hbWljID0gIXRoaXMuaXNNb2JpbGVEZXZpY2VfO1xuXG4gIC8vIFdlIGNvdmVyIGlmcmFtZXMgZHVyaW5nIG1vdXNlIGludGVyYWN0aW9ucy4gU2VlIGNvbW1lbnRzIGluXG4gIC8vIGR5Z3JhcGgtdXRpbHMuanMgZm9yIG1vcmUgaW5mbyBvbiB3aHkgdGhpcyBpcyBhIGdvb2QgaWRlYS5cbiAgdmFyIHRhcnAgPSBuZXcgSUZyYW1lVGFycCgpO1xuXG4gIC8vIGZ1bmN0aW9ucywgZGVmaW5lZCBiZWxvdy4gIERlZmluaW5nIHRoZW0gdGhpcyB3YXkgKHJhdGhlciB0aGFuIHdpdGhcbiAgLy8gXCJmdW5jdGlvbiBmb28oKSB7Li4ufVwiIG1ha2VzIEpTSGludCBoYXBweS5cbiAgdmFyIHRvWERhdGFXaW5kb3csIG9uWm9vbVN0YXJ0LCBvblpvb20sIG9uWm9vbUVuZCwgZG9ab29tLCBpc01vdXNlSW5QYW5ab25lLFxuICAgICAgb25QYW5TdGFydCwgb25QYW4sIG9uUGFuRW5kLCBkb1Bhbiwgb25DYW52YXNIb3ZlcjtcblxuICAvLyBUb3VjaCBldmVudCBmdW5jdGlvbnNcbiAgdmFyIG9uWm9vbUhhbmRsZVRvdWNoRXZlbnQsIG9uQ2FudmFzVG91Y2hFdmVudCwgYWRkVG91Y2hFdmVudHM7XG5cbiAgdG9YRGF0YVdpbmRvdyA9IGZ1bmN0aW9uKHpvb21IYW5kbGVTdGF0dXMpIHtcbiAgICB2YXIgeERhdGFMaW1pdHMgPSBzZWxmLmR5Z3JhcGhfLnhBeGlzRXh0cmVtZXMoKTtcbiAgICB2YXIgZmFjdCA9ICh4RGF0YUxpbWl0c1sxXSAtIHhEYXRhTGltaXRzWzBdKS9zZWxmLmNhbnZhc1JlY3RfLnc7XG4gICAgdmFyIHhEYXRhTWluID0geERhdGFMaW1pdHNbMF0gKyAoem9vbUhhbmRsZVN0YXR1cy5sZWZ0SGFuZGxlUG9zIC0gc2VsZi5jYW52YXNSZWN0Xy54KSpmYWN0O1xuICAgIHZhciB4RGF0YU1heCA9IHhEYXRhTGltaXRzWzBdICsgKHpvb21IYW5kbGVTdGF0dXMucmlnaHRIYW5kbGVQb3MgLSBzZWxmLmNhbnZhc1JlY3RfLngpKmZhY3Q7XG4gICAgcmV0dXJuIFt4RGF0YU1pbiwgeERhdGFNYXhdO1xuICB9O1xuXG4gIG9uWm9vbVN0YXJ0ID0gZnVuY3Rpb24oZSkge1xuICAgIHV0aWxzLmNhbmNlbEV2ZW50KGUpO1xuICAgIGlzWm9vbWluZyA9IHRydWU7XG4gICAgY2xpZW50WExhc3QgPSBlLmNsaWVudFg7XG4gICAgaGFuZGxlID0gZS50YXJnZXQgPyBlLnRhcmdldCA6IGUuc3JjRWxlbWVudDtcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vkb3duJyB8fCBlLnR5cGUgPT09ICdkcmFnc3RhcnQnKSB7XG4gICAgICAvLyBUaGVzZSBldmVudHMgYXJlIHJlbW92ZWQgbWFudWFsbHkuXG4gICAgICB1dGlscy5hZGRFdmVudCh0b3BFbGVtLCAnbW91c2Vtb3ZlJywgb25ab29tKTtcbiAgICAgIHV0aWxzLmFkZEV2ZW50KHRvcEVsZW0sICdtb3VzZXVwJywgb25ab29tRW5kKTtcbiAgICB9XG4gICAgc2VsZi5mZ2NhbnZhc18uc3R5bGUuY3Vyc29yID0gJ2NvbC1yZXNpemUnO1xuICAgIHRhcnAuY292ZXIoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBvblpvb20gPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFpc1pvb21pbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdXRpbHMuY2FuY2VsRXZlbnQoZSk7XG5cbiAgICB2YXIgZGVsWCA9IGUuY2xpZW50WCAtIGNsaWVudFhMYXN0O1xuICAgIGlmIChNYXRoLmFicyhkZWxYKSA8IDQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjbGllbnRYTGFzdCA9IGUuY2xpZW50WDtcblxuICAgIC8vIE1vdmUgaGFuZGxlLlxuICAgIHZhciB6b29tSGFuZGxlU3RhdHVzID0gc2VsZi5nZXRab29tSGFuZGxlU3RhdHVzXygpO1xuICAgIHZhciBuZXdQb3M7XG4gICAgaWYgKGhhbmRsZSA9PSBzZWxmLmxlZnRab29tSGFuZGxlXykge1xuICAgICAgbmV3UG9zID0gem9vbUhhbmRsZVN0YXR1cy5sZWZ0SGFuZGxlUG9zICsgZGVsWDtcbiAgICAgIG5ld1BvcyA9IE1hdGgubWluKG5ld1Bvcywgem9vbUhhbmRsZVN0YXR1cy5yaWdodEhhbmRsZVBvcyAtIGhhbmRsZS53aWR0aCAtIDMpO1xuICAgICAgbmV3UG9zID0gTWF0aC5tYXgobmV3UG9zLCBzZWxmLmNhbnZhc1JlY3RfLngpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdQb3MgPSB6b29tSGFuZGxlU3RhdHVzLnJpZ2h0SGFuZGxlUG9zICsgZGVsWDtcbiAgICAgIG5ld1BvcyA9IE1hdGgubWluKG5ld1Bvcywgc2VsZi5jYW52YXNSZWN0Xy54ICsgc2VsZi5jYW52YXNSZWN0Xy53KTtcbiAgICAgIG5ld1BvcyA9IE1hdGgubWF4KG5ld1Bvcywgem9vbUhhbmRsZVN0YXR1cy5sZWZ0SGFuZGxlUG9zICsgaGFuZGxlLndpZHRoICsgMyk7XG4gICAgfVxuICAgIHZhciBoYWxmSGFuZGxlV2lkdGggPSBoYW5kbGUud2lkdGgvMjtcbiAgICBoYW5kbGUuc3R5bGUubGVmdCA9IChuZXdQb3MgLSBoYWxmSGFuZGxlV2lkdGgpICsgJ3B4JztcbiAgICBzZWxmLmRyYXdJbnRlcmFjdGl2ZUxheWVyXygpO1xuXG4gICAgLy8gWm9vbSBvbiB0aGUgZmx5LlxuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBkb1pvb20oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgb25ab29tRW5kID0gZnVuY3Rpb24oZSkge1xuICAgIGlmICghaXNab29taW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlzWm9vbWluZyA9IGZhbHNlO1xuICAgIHRhcnAudW5jb3ZlcigpO1xuICAgIHV0aWxzLnJlbW92ZUV2ZW50KHRvcEVsZW0sICdtb3VzZW1vdmUnLCBvblpvb20pO1xuICAgIHV0aWxzLnJlbW92ZUV2ZW50KHRvcEVsZW0sICdtb3VzZXVwJywgb25ab29tRW5kKTtcbiAgICBzZWxmLmZnY2FudmFzXy5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG5cbiAgICAvLyBJZiBvbiBhIHNsb3dlciBkZXZpY2UsIHpvb20gbm93LlxuICAgIGlmICghZHluYW1pYykge1xuICAgICAgZG9ab29tKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIGRvWm9vbSA9IGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgem9vbUhhbmRsZVN0YXR1cyA9IHNlbGYuZ2V0Wm9vbUhhbmRsZVN0YXR1c18oKTtcbiAgICAgIHNlbGYuaXNDaGFuZ2luZ1JhbmdlXyA9IHRydWU7XG4gICAgICBpZiAoIXpvb21IYW5kbGVTdGF0dXMuaXNab29tZWQpIHtcbiAgICAgICAgc2VsZi5keWdyYXBoXy5yZXNldFpvb20oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4RGF0YVdpbmRvdyA9IHRvWERhdGFXaW5kb3coem9vbUhhbmRsZVN0YXR1cyk7XG4gICAgICAgIHNlbGYuZHlncmFwaF8uZG9ab29tWERhdGVzXyh4RGF0YVdpbmRvd1swXSwgeERhdGFXaW5kb3dbMV0pO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZWxmLmlzQ2hhbmdpbmdSYW5nZV8gPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgaXNNb3VzZUluUGFuWm9uZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgcmVjdCA9IHNlbGYubGVmdFpvb21IYW5kbGVfLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBsZWZ0SGFuZGxlQ2xpZW50WCA9IHJlY3QubGVmdCArIHJlY3Qud2lkdGgvMjtcbiAgICByZWN0ID0gc2VsZi5yaWdodFpvb21IYW5kbGVfLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciByaWdodEhhbmRsZUNsaWVudFggPSByZWN0LmxlZnQgKyByZWN0LndpZHRoLzI7XG4gICAgcmV0dXJuIChlLmNsaWVudFggPiBsZWZ0SGFuZGxlQ2xpZW50WCAmJiBlLmNsaWVudFggPCByaWdodEhhbmRsZUNsaWVudFgpO1xuICB9O1xuXG4gIG9uUGFuU3RhcnQgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFpc1Bhbm5pbmcgJiYgaXNNb3VzZUluUGFuWm9uZShlKSAmJiBzZWxmLmdldFpvb21IYW5kbGVTdGF0dXNfKCkuaXNab29tZWQpIHtcbiAgICAgIHV0aWxzLmNhbmNlbEV2ZW50KGUpO1xuICAgICAgaXNQYW5uaW5nID0gdHJ1ZTtcbiAgICAgIGNsaWVudFhMYXN0ID0gZS5jbGllbnRYO1xuICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgLy8gVGhlc2UgZXZlbnRzIGFyZSByZW1vdmVkIG1hbnVhbGx5LlxuICAgICAgICB1dGlscy5hZGRFdmVudCh0b3BFbGVtLCAnbW91c2Vtb3ZlJywgb25QYW4pO1xuICAgICAgICB1dGlscy5hZGRFdmVudCh0b3BFbGVtLCAnbW91c2V1cCcsIG9uUGFuRW5kKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgb25QYW4gPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFpc1Bhbm5pbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdXRpbHMuY2FuY2VsRXZlbnQoZSk7XG5cbiAgICB2YXIgZGVsWCA9IGUuY2xpZW50WCAtIGNsaWVudFhMYXN0O1xuICAgIGlmIChNYXRoLmFicyhkZWxYKSA8IDQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjbGllbnRYTGFzdCA9IGUuY2xpZW50WDtcblxuICAgIC8vIE1vdmUgcmFuZ2Ugdmlld1xuICAgIHZhciB6b29tSGFuZGxlU3RhdHVzID0gc2VsZi5nZXRab29tSGFuZGxlU3RhdHVzXygpO1xuICAgIHZhciBsZWZ0SGFuZGxlUG9zID0gem9vbUhhbmRsZVN0YXR1cy5sZWZ0SGFuZGxlUG9zO1xuICAgIHZhciByaWdodEhhbmRsZVBvcyA9IHpvb21IYW5kbGVTdGF0dXMucmlnaHRIYW5kbGVQb3M7XG4gICAgdmFyIHJhbmdlU2l6ZSA9IHJpZ2h0SGFuZGxlUG9zIC0gbGVmdEhhbmRsZVBvcztcbiAgICBpZiAobGVmdEhhbmRsZVBvcyArIGRlbFggPD0gc2VsZi5jYW52YXNSZWN0Xy54KSB7XG4gICAgICBsZWZ0SGFuZGxlUG9zID0gc2VsZi5jYW52YXNSZWN0Xy54O1xuICAgICAgcmlnaHRIYW5kbGVQb3MgPSBsZWZ0SGFuZGxlUG9zICsgcmFuZ2VTaXplO1xuICAgIH0gZWxzZSBpZiAocmlnaHRIYW5kbGVQb3MgKyBkZWxYID49IHNlbGYuY2FudmFzUmVjdF8ueCArIHNlbGYuY2FudmFzUmVjdF8udykge1xuICAgICAgcmlnaHRIYW5kbGVQb3MgPSBzZWxmLmNhbnZhc1JlY3RfLnggKyBzZWxmLmNhbnZhc1JlY3RfLnc7XG4gICAgICBsZWZ0SGFuZGxlUG9zID0gcmlnaHRIYW5kbGVQb3MgLSByYW5nZVNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnRIYW5kbGVQb3MgKz0gZGVsWDtcbiAgICAgIHJpZ2h0SGFuZGxlUG9zICs9IGRlbFg7XG4gICAgfVxuICAgIHZhciBoYWxmSGFuZGxlV2lkdGggPSBzZWxmLmxlZnRab29tSGFuZGxlXy53aWR0aC8yO1xuICAgIHNlbGYubGVmdFpvb21IYW5kbGVfLnN0eWxlLmxlZnQgPSAobGVmdEhhbmRsZVBvcyAtIGhhbGZIYW5kbGVXaWR0aCkgKyAncHgnO1xuICAgIHNlbGYucmlnaHRab29tSGFuZGxlXy5zdHlsZS5sZWZ0ID0gKHJpZ2h0SGFuZGxlUG9zIC0gaGFsZkhhbmRsZVdpZHRoKSArICdweCc7XG4gICAgc2VsZi5kcmF3SW50ZXJhY3RpdmVMYXllcl8oKTtcblxuICAgIC8vIERvIHBhbiBvbiB0aGUgZmx5LlxuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBkb1BhbigpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBvblBhbkVuZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIWlzUGFubmluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpc1Bhbm5pbmcgPSBmYWxzZTtcbiAgICB1dGlscy5yZW1vdmVFdmVudCh0b3BFbGVtLCAnbW91c2Vtb3ZlJywgb25QYW4pO1xuICAgIHV0aWxzLnJlbW92ZUV2ZW50KHRvcEVsZW0sICdtb3VzZXVwJywgb25QYW5FbmQpO1xuICAgIC8vIElmIG9uIGEgc2xvd2VyIGRldmljZSwgZG8gcGFuIG5vdy5cbiAgICBpZiAoIWR5bmFtaWMpIHtcbiAgICAgIGRvUGFuKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIGRvUGFuID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuaXNDaGFuZ2luZ1JhbmdlXyA9IHRydWU7XG4gICAgICBzZWxmLmR5Z3JhcGhfLmRhdGVXaW5kb3dfID0gdG9YRGF0YVdpbmRvdyhzZWxmLmdldFpvb21IYW5kbGVTdGF0dXNfKCkpO1xuICAgICAgc2VsZi5keWdyYXBoXy5kcmF3R3JhcGhfKGZhbHNlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2VsZi5pc0NoYW5naW5nUmFuZ2VfID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIG9uQ2FudmFzSG92ZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGlzWm9vbWluZyB8fCBpc1Bhbm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGN1cnNvciA9IGlzTW91c2VJblBhblpvbmUoZSkgPyAnbW92ZScgOiAnZGVmYXVsdCc7XG4gICAgaWYgKGN1cnNvciAhPSBzZWxmLmZnY2FudmFzXy5zdHlsZS5jdXJzb3IpIHtcbiAgICAgIHNlbGYuZmdjYW52YXNfLnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcbiAgICB9XG4gIH07XG5cbiAgb25ab29tSGFuZGxlVG91Y2hFdmVudCA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZS50eXBlID09ICd0b3VjaHN0YXJ0JyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAgIGlmIChvblpvb21TdGFydChlLnRhcmdldFRvdWNoZXNbMF0pKSB7XG4gICAgICAgIHV0aWxzLmNhbmNlbEV2ZW50KGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZS50eXBlID09ICd0b3VjaG1vdmUnICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgICAgaWYgKG9uWm9vbShlLnRhcmdldFRvdWNoZXNbMF0pKSB7XG4gICAgICAgIHV0aWxzLmNhbmNlbEV2ZW50KGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvblpvb21FbmQoZSk7XG4gICAgfVxuICB9O1xuXG4gIG9uQ2FudmFzVG91Y2hFdmVudCA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZS50eXBlID09ICd0b3VjaHN0YXJ0JyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAgIGlmIChvblBhblN0YXJ0KGUudGFyZ2V0VG91Y2hlc1swXSkpIHtcbiAgICAgICAgdXRpbHMuY2FuY2VsRXZlbnQoZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlLnR5cGUgPT0gJ3RvdWNobW92ZScgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICBpZiAob25QYW4oZS50YXJnZXRUb3VjaGVzWzBdKSkge1xuICAgICAgICB1dGlscy5jYW5jZWxFdmVudChlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb25QYW5FbmQoZSk7XG4gICAgfVxuICB9O1xuXG4gIGFkZFRvdWNoRXZlbnRzID0gZnVuY3Rpb24oZWxlbSwgZm4pIHtcbiAgICB2YXIgdHlwZXMgPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnLCAndG91Y2htb3ZlJywgJ3RvdWNoY2FuY2VsJ107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgc2VsZi5keWdyYXBoXy5hZGRBbmRUcmFja0V2ZW50KGVsZW0sIHR5cGVzW2ldLCBmbik7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuc2V0RGVmYXVsdE9wdGlvbl8oJ2ludGVyYWN0aW9uTW9kZWwnLCBEeWdyYXBoSW50ZXJhY3Rpb24uZHJhZ0lzUGFuSW50ZXJhY3Rpb25Nb2RlbCk7XG4gIHRoaXMuc2V0RGVmYXVsdE9wdGlvbl8oJ3BhbkVkZ2VGcmFjdGlvbicsIDAuMDAwMSk7XG5cbiAgdmFyIGRyYWdTdGFydEV2ZW50ID0gd2luZG93Lm9wZXJhID8gJ21vdXNlZG93bicgOiAnZHJhZ3N0YXJ0JztcbiAgdGhpcy5keWdyYXBoXy5hZGRBbmRUcmFja0V2ZW50KHRoaXMubGVmdFpvb21IYW5kbGVfLCBkcmFnU3RhcnRFdmVudCwgb25ab29tU3RhcnQpO1xuICB0aGlzLmR5Z3JhcGhfLmFkZEFuZFRyYWNrRXZlbnQodGhpcy5yaWdodFpvb21IYW5kbGVfLCBkcmFnU3RhcnRFdmVudCwgb25ab29tU3RhcnQpO1xuXG4gIHRoaXMuZHlncmFwaF8uYWRkQW5kVHJhY2tFdmVudCh0aGlzLmZnY2FudmFzXywgJ21vdXNlZG93bicsIG9uUGFuU3RhcnQpO1xuICB0aGlzLmR5Z3JhcGhfLmFkZEFuZFRyYWNrRXZlbnQodGhpcy5mZ2NhbnZhc18sICdtb3VzZW1vdmUnLCBvbkNhbnZhc0hvdmVyKTtcblxuICAvLyBUb3VjaCBldmVudHNcbiAgaWYgKHRoaXMuaGFzVG91Y2hJbnRlcmZhY2VfKSB7XG4gICAgYWRkVG91Y2hFdmVudHModGhpcy5sZWZ0Wm9vbUhhbmRsZV8sIG9uWm9vbUhhbmRsZVRvdWNoRXZlbnQpO1xuICAgIGFkZFRvdWNoRXZlbnRzKHRoaXMucmlnaHRab29tSGFuZGxlXywgb25ab29tSGFuZGxlVG91Y2hFdmVudCk7XG4gICAgYWRkVG91Y2hFdmVudHModGhpcy5mZ2NhbnZhc18sIG9uQ2FudmFzVG91Y2hFdmVudCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIERyYXdzIHRoZSBzdGF0aWMgbGF5ZXIgaW4gdGhlIGJhY2tncm91bmQgY2FudmFzLlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5kcmF3U3RhdGljTGF5ZXJfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjdHggPSB0aGlzLmJnY2FudmFzX2N0eF87XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXNSZWN0Xy53LCB0aGlzLmNhbnZhc1JlY3RfLmgpO1xuICB0cnkge1xuICAgIHRoaXMuZHJhd01pbmlQbG90XygpO1xuICB9IGNhdGNoKGV4KSB7XG4gICAgY29uc29sZS53YXJuKGV4KTtcbiAgfVxuXG4gIHZhciBtYXJnaW4gPSAwLjU7XG4gIHRoaXMuYmdjYW52YXNfY3R4Xy5saW5lV2lkdGggPSB0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JCYWNrZ3JvdW5kTGluZVdpZHRoJyk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuZ2V0T3B0aW9uXygncmFuZ2VTZWxlY3RvckJhY2tncm91bmRTdHJva2VDb2xvcicpO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5tb3ZlVG8obWFyZ2luLCBtYXJnaW4pO1xuICBjdHgubGluZVRvKG1hcmdpbiwgdGhpcy5jYW52YXNSZWN0Xy5oLW1hcmdpbik7XG4gIGN0eC5saW5lVG8odGhpcy5jYW52YXNSZWN0Xy53LW1hcmdpbiwgdGhpcy5jYW52YXNSZWN0Xy5oLW1hcmdpbik7XG4gIGN0eC5saW5lVG8odGhpcy5jYW52YXNSZWN0Xy53LW1hcmdpbiwgbWFyZ2luKTtcbiAgY3R4LnN0cm9rZSgpO1xufTtcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBEcmF3cyB0aGUgbWluaSBwbG90IGluIHRoZSBiYWNrZ3JvdW5kIGNhbnZhcy5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuZHJhd01pbmlQbG90XyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlsbFN0eWxlID0gdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yUGxvdEZpbGxDb2xvcicpO1xuICB2YXIgZmlsbEdyYWRpZW50U3R5bGUgPSB0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JQbG90RmlsbEdyYWRpZW50Q29sb3InKTtcbiAgdmFyIHN0cm9rZVN0eWxlID0gdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yUGxvdFN0cm9rZUNvbG9yJyk7XG4gIGlmICghZmlsbFN0eWxlICYmICFzdHJva2VTdHlsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzdGVwUGxvdCA9IHRoaXMuZ2V0T3B0aW9uXygnc3RlcFBsb3QnKTtcblxuICB2YXIgY29tYmluZWRTZXJpZXNEYXRhID0gdGhpcy5jb21wdXRlQ29tYmluZWRTZXJpZXNBbmRMaW1pdHNfKCk7XG4gIHZhciB5UmFuZ2UgPSBjb21iaW5lZFNlcmllc0RhdGEueU1heCAtIGNvbWJpbmVkU2VyaWVzRGF0YS55TWluO1xuXG4gIC8vIERyYXcgdGhlIG1pbmkgcGxvdC5cbiAgdmFyIGN0eCA9IHRoaXMuYmdjYW52YXNfY3R4XztcbiAgdmFyIG1hcmdpbiA9IDAuNTtcblxuICB2YXIgeEV4dHJlbWVzID0gdGhpcy5keWdyYXBoXy54QXhpc0V4dHJlbWVzKCk7XG4gIHZhciB4UmFuZ2UgPSBNYXRoLm1heCh4RXh0cmVtZXNbMV0gLSB4RXh0cmVtZXNbMF0sIDEuZS0zMCk7XG4gIHZhciB4RmFjdCA9ICh0aGlzLmNhbnZhc1JlY3RfLncgLSBtYXJnaW4pL3hSYW5nZTtcbiAgdmFyIHlGYWN0ID0gKHRoaXMuY2FudmFzUmVjdF8uaCAtIG1hcmdpbikveVJhbmdlO1xuICB2YXIgY2FudmFzV2lkdGggPSB0aGlzLmNhbnZhc1JlY3RfLncgLSBtYXJnaW47XG4gIHZhciBjYW52YXNIZWlnaHQgPSB0aGlzLmNhbnZhc1JlY3RfLmggLSBtYXJnaW47XG5cbiAgdmFyIHByZXZYID0gbnVsbCwgcHJldlkgPSBudWxsO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyhtYXJnaW4sIGNhbnZhc0hlaWdodCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29tYmluZWRTZXJpZXNEYXRhLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGF0YVBvaW50ID0gY29tYmluZWRTZXJpZXNEYXRhLmRhdGFbaV07XG4gICAgdmFyIHggPSAoKGRhdGFQb2ludFswXSAhPT0gbnVsbCkgPyAoKGRhdGFQb2ludFswXSAtIHhFeHRyZW1lc1swXSkqeEZhY3QpIDogTmFOKTtcbiAgICB2YXIgeSA9ICgoZGF0YVBvaW50WzFdICE9PSBudWxsKSA/IChjYW52YXNIZWlnaHQgLSAoZGF0YVBvaW50WzFdIC0gY29tYmluZWRTZXJpZXNEYXRhLnlNaW4pKnlGYWN0KSA6IE5hTik7XG5cbiAgICAvLyBTa2lwIHBvaW50cyB0aGF0IGRvbid0IGNoYW5nZSB0aGUgeC12YWx1ZS4gT3Zlcmx5IGZpbmUtZ3JhaW5lZCBwb2ludHNcbiAgICAvLyBjYW4gY2F1c2UgbWFqb3Igc2xvd2Rvd25zIHdpdGggdGhlIGN0eC5maWxsKCkgY2FsbCBiZWxvdy5cbiAgICBpZiAoIXN0ZXBQbG90ICYmIHByZXZYICE9PSBudWxsICYmIE1hdGgucm91bmQoeCkgPT0gTWF0aC5yb3VuZChwcmV2WCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChpc0Zpbml0ZSh4KSAmJiBpc0Zpbml0ZSh5KSkge1xuICAgICAgaWYocHJldlggPT09IG51bGwpIHtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCBjYW52YXNIZWlnaHQpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RlcFBsb3QpIHtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCBwcmV2WSk7XG4gICAgICB9XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgcHJldlggPSB4O1xuICAgICAgcHJldlkgPSB5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmKHByZXZYICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzdGVwUGxvdCkge1xuICAgICAgICAgIGN0eC5saW5lVG8oeCwgcHJldlkpO1xuICAgICAgICAgIGN0eC5saW5lVG8oeCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjdHgubGluZVRvKHByZXZYLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcmV2WCA9IHByZXZZID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgY3R4LmxpbmVUbyhjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gIGlmIChmaWxsU3R5bGUpIHtcbiAgICB2YXIgbGluZ3JhZCA9IHRoaXMuYmdjYW52YXNfY3R4Xy5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCBjYW52YXNIZWlnaHQpO1xuICAgIGlmIChmaWxsR3JhZGllbnRTdHlsZSkge1xuICAgICAgbGluZ3JhZC5hZGRDb2xvclN0b3AoMCwgZmlsbEdyYWRpZW50U3R5bGUpO1xuICAgIH1cbiAgICBsaW5ncmFkLmFkZENvbG9yU3RvcCgxLCBmaWxsU3R5bGUpO1xuICAgIHRoaXMuYmdjYW52YXNfY3R4Xy5maWxsU3R5bGUgPSBsaW5ncmFkO1xuICAgIGN0eC5maWxsKCk7XG4gIH1cblxuICBpZiAoc3Ryb2tlU3R5bGUpIHtcbiAgICB0aGlzLmJnY2FudmFzX2N0eF8uc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICB0aGlzLmJnY2FudmFzX2N0eF8ubGluZVdpZHRoID0gdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yUGxvdExpbmVXaWR0aCcpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQ29tcHV0ZXMgYW5kIHJldHVybnMgdGhlIGNvbWJpbmVkIHNlcmllcyBkYXRhIGFsb25nIHdpdGggbWluL21heCBmb3IgdGhlIG1pbmkgcGxvdC5cbiAqIFRoZSBjb21iaW5lZCBzZXJpZXMgY29uc2lzdHMgb2YgYXZlcmFnZWQgdmFsdWVzIGZvciBhbGwgc2VyaWVzLlxuICogV2hlbiBzZXJpZXMgaGF2ZSBlcnJvciBiYXJzLCB0aGUgZXJyb3IgYmFycyBhcmUgaWdub3JlZC5cbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tYmluZWQgc2VyaWVzIGFycmF5LCB5bWluLCB5bWF4LlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5jb21wdXRlQ29tYmluZWRTZXJpZXNBbmRMaW1pdHNfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBnID0gdGhpcy5keWdyYXBoXztcbiAgdmFyIGxvZ3NjYWxlID0gdGhpcy5nZXRPcHRpb25fKCdsb2dzY2FsZScpO1xuICB2YXIgaTtcblxuICAvLyBTZWxlY3Qgc2VyaWVzIHRvIGNvbWJpbmUuIEJ5IGRlZmF1bHQsIGFsbCBzZXJpZXMgYXJlIGNvbWJpbmVkLlxuICB2YXIgbnVtQ29sdW1ucyA9IGcubnVtQ29sdW1ucygpO1xuICB2YXIgbGFiZWxzID0gZy5nZXRMYWJlbHMoKTtcbiAgdmFyIGluY2x1ZGVTZXJpZXMgPSBuZXcgQXJyYXkobnVtQ29sdW1ucyk7XG4gIHZhciBhbnlTZXQgPSBmYWxzZTtcbiAgdmFyIHZpc2liaWxpdHkgPSBnLnZpc2liaWxpdHkoKTtcbiAgdmFyIGluY2x1c2lvbiA9IFtdO1xuXG4gIGZvciAoaSA9IDE7IGkgPCBudW1Db2x1bW5zOyBpKyspIHtcbiAgICB2YXIgaW5jbHVkZSA9IHRoaXMuZ2V0T3B0aW9uXygnc2hvd0luUmFuZ2VTZWxlY3RvcicsIGxhYmVsc1tpXSk7XG4gICAgaW5jbHVzaW9uLnB1c2goaW5jbHVkZSk7XG4gICAgaWYgKGluY2x1ZGUgIT09IG51bGwpIGFueVNldCA9IHRydWU7ICAvLyBpdCdzIHNldCBleHBsaWNpdGx5IGZvciB0aGlzIHNlcmllc1xuICB9XG5cbiAgaWYgKGFueVNldCkge1xuICAgIGZvciAoaSA9IDE7IGkgPCBudW1Db2x1bW5zOyBpKyspIHtcbiAgICAgIGluY2x1ZGVTZXJpZXNbaV0gPSBpbmNsdXNpb25baSAtIDFdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbnVtQ29sdW1uczsgaSsrKSB7XG4gICAgICBpbmNsdWRlU2VyaWVzW2ldID0gdmlzaWJpbGl0eVtpIC0gMV07XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGEgY29tYmluZWQgc2VyaWVzIChhdmVyYWdlIG9mIHNlbGVjdGVkIHNlcmllcyB2YWx1ZXMpLlxuICAvLyBUT0RPKGRhbnZrKTogc2hvcnQtY2lyY3VpdCBpZiB0aGVyZSdzIG9ubHkgb25lIHNlcmllcy5cbiAgdmFyIHJvbGxlZFNlcmllcyA9IFtdO1xuICB2YXIgZGF0YUhhbmRsZXIgPSBnLmRhdGFIYW5kbGVyXztcbiAgdmFyIG9wdGlvbnMgPSBnLmF0dHJpYnV0ZXNfO1xuICBmb3IgKGkgPSAxOyBpIDwgZy5udW1Db2x1bW5zKCk7IGkrKykge1xuICAgIGlmICghaW5jbHVkZVNlcmllc1tpXSkgY29udGludWU7XG4gICAgdmFyIHNlcmllcyA9IGRhdGFIYW5kbGVyLmV4dHJhY3RTZXJpZXMoZy5yYXdEYXRhXywgaSwgb3B0aW9ucyk7XG4gICAgaWYgKGcucm9sbFBlcmlvZCgpID4gMSkge1xuICAgICAgc2VyaWVzID0gZGF0YUhhbmRsZXIucm9sbGluZ0F2ZXJhZ2Uoc2VyaWVzLCBnLnJvbGxQZXJpb2QoKSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcm9sbGVkU2VyaWVzLnB1c2goc2VyaWVzKTtcbiAgfVxuXG4gIHZhciBjb21iaW5lZFNlcmllcyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgcm9sbGVkU2VyaWVzWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvbGxlZFNlcmllcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHkgPSByb2xsZWRTZXJpZXNbal1baV1bMV07XG4gICAgICBpZiAoeSA9PT0gbnVsbCB8fCBpc05hTih5KSkgY29udGludWU7XG4gICAgICBjb3VudCsrO1xuICAgICAgc3VtICs9IHk7XG4gICAgfVxuICAgIGNvbWJpbmVkU2VyaWVzLnB1c2goW3JvbGxlZFNlcmllc1swXVtpXVswXSwgc3VtIC8gY291bnRdKTtcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIHkgcmFuZ2UuXG4gIHZhciB5TWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgdmFyIHlNYXggPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgZm9yIChpID0gMDsgaSA8IGNvbWJpbmVkU2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHlWYWwgPSBjb21iaW5lZFNlcmllc1tpXVsxXTtcbiAgICBpZiAoeVZhbCAhPT0gbnVsbCAmJiBpc0Zpbml0ZSh5VmFsKSAmJiAoIWxvZ3NjYWxlIHx8IHlWYWwgPiAwKSkge1xuICAgICAgeU1pbiA9IE1hdGgubWluKHlNaW4sIHlWYWwpO1xuICAgICAgeU1heCA9IE1hdGgubWF4KHlNYXgsIHlWYWwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbnZlcnQgWSBkYXRhIHRvIGxvZyBzY2FsZSBpZiBuZWVkZWQuXG4gIC8vIEFsc28sIGV4cGFuZCB0aGUgWSByYW5nZSB0byBjb21wcmVzcyB0aGUgbWluaSBwbG90IGEgbGl0dGxlLlxuICB2YXIgZXh0cmFQZXJjZW50ID0gMC4yNTtcbiAgaWYgKGxvZ3NjYWxlKSB7XG4gICAgeU1heCA9IHV0aWxzLmxvZzEwKHlNYXgpO1xuICAgIHlNYXggKz0geU1heCpleHRyYVBlcmNlbnQ7XG4gICAgeU1pbiA9IHV0aWxzLmxvZzEwKHlNaW4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb21iaW5lZFNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29tYmluZWRTZXJpZXNbaV1bMV0gPSB1dGlscy5sb2cxMChjb21iaW5lZFNlcmllc1tpXVsxXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB5RXh0cmE7XG4gICAgdmFyIHlSYW5nZSA9IHlNYXggLSB5TWluO1xuICAgIGlmICh5UmFuZ2UgPD0gTnVtYmVyLk1JTl9WQUxVRSkge1xuICAgICAgeUV4dHJhID0geU1heCpleHRyYVBlcmNlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHlFeHRyYSA9IHlSYW5nZSpleHRyYVBlcmNlbnQ7XG4gICAgfVxuICAgIHlNYXggKz0geUV4dHJhO1xuICAgIHlNaW4gLT0geUV4dHJhO1xuICB9XG5cbiAgcmV0dXJuIHtkYXRhOiBjb21iaW5lZFNlcmllcywgeU1pbjogeU1pbiwgeU1heDogeU1heH07XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBQbGFjZXMgdGhlIHpvb20gaGFuZGxlcyBpbiB0aGUgcHJvcGVyIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IFggZGF0YSB3aW5kb3cuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnBsYWNlWm9vbUhhbmRsZXNfID0gZnVuY3Rpb24oKSB7XG4gIHZhciB4RXh0cmVtZXMgPSB0aGlzLmR5Z3JhcGhfLnhBeGlzRXh0cmVtZXMoKTtcbiAgdmFyIHhXaW5kb3dMaW1pdHMgPSB0aGlzLmR5Z3JhcGhfLnhBeGlzUmFuZ2UoKTtcbiAgdmFyIHhSYW5nZSA9IHhFeHRyZW1lc1sxXSAtIHhFeHRyZW1lc1swXTtcbiAgdmFyIGxlZnRQZXJjZW50ID0gTWF0aC5tYXgoMCwgKHhXaW5kb3dMaW1pdHNbMF0gLSB4RXh0cmVtZXNbMF0pL3hSYW5nZSk7XG4gIHZhciByaWdodFBlcmNlbnQgPSBNYXRoLm1heCgwLCAoeEV4dHJlbWVzWzFdIC0geFdpbmRvd0xpbWl0c1sxXSkveFJhbmdlKTtcbiAgdmFyIGxlZnRDb29yZCA9IHRoaXMuY2FudmFzUmVjdF8ueCArIHRoaXMuY2FudmFzUmVjdF8udypsZWZ0UGVyY2VudDtcbiAgdmFyIHJpZ2h0Q29vcmQgPSB0aGlzLmNhbnZhc1JlY3RfLnggKyB0aGlzLmNhbnZhc1JlY3RfLncqKDEgLSByaWdodFBlcmNlbnQpO1xuICB2YXIgaGFuZGxlVG9wID0gTWF0aC5tYXgodGhpcy5jYW52YXNSZWN0Xy55LCB0aGlzLmNhbnZhc1JlY3RfLnkgKyAodGhpcy5jYW52YXNSZWN0Xy5oIC0gdGhpcy5sZWZ0Wm9vbUhhbmRsZV8uaGVpZ2h0KS8yKTtcbiAgdmFyIGhhbGZIYW5kbGVXaWR0aCA9IHRoaXMubGVmdFpvb21IYW5kbGVfLndpZHRoLzI7XG4gIHRoaXMubGVmdFpvb21IYW5kbGVfLnN0eWxlLmxlZnQgPSAobGVmdENvb3JkIC0gaGFsZkhhbmRsZVdpZHRoKSArICdweCc7XG4gIHRoaXMubGVmdFpvb21IYW5kbGVfLnN0eWxlLnRvcCA9IGhhbmRsZVRvcCArICdweCc7XG4gIHRoaXMucmlnaHRab29tSGFuZGxlXy5zdHlsZS5sZWZ0ID0gKHJpZ2h0Q29vcmQgLSBoYWxmSGFuZGxlV2lkdGgpICsgJ3B4JztcbiAgdGhpcy5yaWdodFpvb21IYW5kbGVfLnN0eWxlLnRvcCA9IHRoaXMubGVmdFpvb21IYW5kbGVfLnN0eWxlLnRvcDtcblxuICB0aGlzLmxlZnRab29tSGFuZGxlXy5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICB0aGlzLnJpZ2h0Wm9vbUhhbmRsZV8uc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIERyYXdzIHRoZSBpbnRlcmFjdGl2ZSBsYXllciBpbiB0aGUgZm9yZWdyb3VuZCBjYW52YXMuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmRyYXdJbnRlcmFjdGl2ZUxheWVyXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY3R4ID0gdGhpcy5mZ2NhbnZhc19jdHhfO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzUmVjdF8udywgdGhpcy5jYW52YXNSZWN0Xy5oKTtcbiAgdmFyIG1hcmdpbiA9IDE7XG4gIHZhciB3aWR0aCA9IHRoaXMuY2FudmFzUmVjdF8udyAtIG1hcmdpbjtcbiAgdmFyIGhlaWdodCA9IHRoaXMuY2FudmFzUmVjdF8uaCAtIG1hcmdpbjtcbiAgdmFyIHpvb21IYW5kbGVTdGF0dXMgPSB0aGlzLmdldFpvb21IYW5kbGVTdGF0dXNfKCk7XG5cbiAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yRm9yZWdyb3VuZFN0cm9rZUNvbG9yJyk7XG4gIGN0eC5saW5lV2lkdGggPSB0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JGb3JlZ3JvdW5kTGluZVdpZHRoJyk7XG4gIGlmICghem9vbUhhbmRsZVN0YXR1cy5pc1pvb21lZCkge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKG1hcmdpbiwgbWFyZ2luKTtcbiAgICBjdHgubGluZVRvKG1hcmdpbiwgaGVpZ2h0KTtcbiAgICBjdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgIGN0eC5saW5lVG8od2lkdGgsIG1hcmdpbik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZWZ0SGFuZGxlQ2FudmFzUG9zID0gTWF0aC5tYXgobWFyZ2luLCB6b29tSGFuZGxlU3RhdHVzLmxlZnRIYW5kbGVQb3MgLSB0aGlzLmNhbnZhc1JlY3RfLngpO1xuICAgIHZhciByaWdodEhhbmRsZUNhbnZhc1BvcyA9IE1hdGgubWluKHdpZHRoLCB6b29tSGFuZGxlU3RhdHVzLnJpZ2h0SGFuZGxlUG9zIC0gdGhpcy5jYW52YXNSZWN0Xy54KTtcblxuICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgyNDAsIDI0MCwgMjQwLCAnICsgdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yQWxwaGEnKS50b1N0cmluZygpICsgJyknO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBsZWZ0SGFuZGxlQ2FudmFzUG9zLCB0aGlzLmNhbnZhc1JlY3RfLmgpO1xuICAgIGN0eC5maWxsUmVjdChyaWdodEhhbmRsZUNhbnZhc1BvcywgMCwgdGhpcy5jYW52YXNSZWN0Xy53IC0gcmlnaHRIYW5kbGVDYW52YXNQb3MsIHRoaXMuY2FudmFzUmVjdF8uaCk7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyhtYXJnaW4sIG1hcmdpbik7XG4gICAgY3R4LmxpbmVUbyhsZWZ0SGFuZGxlQ2FudmFzUG9zLCBtYXJnaW4pO1xuICAgIGN0eC5saW5lVG8obGVmdEhhbmRsZUNhbnZhc1BvcywgaGVpZ2h0KTtcbiAgICBjdHgubGluZVRvKHJpZ2h0SGFuZGxlQ2FudmFzUG9zLCBoZWlnaHQpO1xuICAgIGN0eC5saW5lVG8ocmlnaHRIYW5kbGVDYW52YXNQb3MsIG1hcmdpbik7XG4gICAgY3R4LmxpbmVUbyh3aWR0aCwgbWFyZ2luKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBoYW5kbGUgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB6b29tIGhhbmRsZSBzdGF0dXMuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmdldFpvb21IYW5kbGVTdGF0dXNfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYWxmSGFuZGxlV2lkdGggPSB0aGlzLmxlZnRab29tSGFuZGxlXy53aWR0aC8yO1xuICB2YXIgbGVmdEhhbmRsZVBvcyA9IHBhcnNlRmxvYXQodGhpcy5sZWZ0Wm9vbUhhbmRsZV8uc3R5bGUubGVmdCkgKyBoYWxmSGFuZGxlV2lkdGg7XG4gIHZhciByaWdodEhhbmRsZVBvcyA9IHBhcnNlRmxvYXQodGhpcy5yaWdodFpvb21IYW5kbGVfLnN0eWxlLmxlZnQpICsgaGFsZkhhbmRsZVdpZHRoO1xuICByZXR1cm4ge1xuICAgICAgbGVmdEhhbmRsZVBvczogbGVmdEhhbmRsZVBvcyxcbiAgICAgIHJpZ2h0SGFuZGxlUG9zOiByaWdodEhhbmRsZVBvcyxcbiAgICAgIGlzWm9vbWVkOiAobGVmdEhhbmRsZVBvcyAtIDEgPiB0aGlzLmNhbnZhc1JlY3RfLnggfHwgcmlnaHRIYW5kbGVQb3MgKyAxIDwgdGhpcy5jYW52YXNSZWN0Xy54K3RoaXMuY2FudmFzUmVjdF8udylcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJhbmdlU2VsZWN0b3I7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL3JhbmdlLXNlbGVjdG9yLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///27\n");

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (immutable) */ __webpack_exports__[\"install\"] = install;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Dygraphs_vue__ = __webpack_require__(15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Dygraphs_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Dygraphs_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_dygraphs__ = __webpack_require__(7);\n/* harmony reexport (default from non-hamory) */ __webpack_require__.d(__webpack_exports__, \"Dygraphs\", function() { return __WEBPACK_IMPORTED_MODULE_0__components_Dygraphs_vue___default.a; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"DygraphsApi\", function() { return __WEBPACK_IMPORTED_MODULE_1_dygraphs__[\"a\"]; });\n\n\n// Install the components\nfunction install(Vue) {\n  Vue.component('dygraphs', __WEBPACK_IMPORTED_MODULE_0__components_Dygraphs_vue___default.a);\n  /* -- Add more components here -- */\n}\n\n// Expose the components\n\n\n/* -- Plugin definition & Auto-install -- */\n/* You shouldn't have to modify the code below */\n\n// Plugin\nvar plugin = {\n  /* eslint-disable no-undef */\n  version: \"0.0.0\",\n  install: install\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (plugin);\n\n// Auto-install\nvar GlobalVue = null;\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue;\n}\nif (GlobalVue) {\n  GlobalVue.use(plugin);\n}\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(14)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/OTU1MiJdLCJuYW1lcyI6WyJpbnN0YWxsIiwiVnVlIiwiY29tcG9uZW50IiwicGx1Z2luIiwidmVyc2lvbiIsIkdsb2JhbFZ1ZSIsIndpbmRvdyIsImdsb2JhbCIsInVzZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNPLFNBQVNBLE9BQVQsQ0FBa0JDLEdBQWxCLEVBQXVCO0FBQzVCQSxNQUFJQyxTQUFKLENBQWMsVUFBZCxFQUEwQixnRUFBMUI7QUFDQTtBQUNEOztBQUVEO0FBQ0E7O0FBTUE7QUFDQTs7QUFFQTtBQUNBLElBQU1DLFNBQVM7QUFDYjtBQUNBQyxXQUFTLE9BRkk7QUFHYko7QUFIYSxDQUFmOztBQU1BLCtEQUFlRyxNQUFmOztBQUVBO0FBQ0EsSUFBSUUsWUFBWSxJQUFoQjtBQUNBLElBQUksT0FBT0MsTUFBUCxLQUFrQixXQUF0QixFQUFtQztBQUNqQ0QsY0FBWUMsT0FBT0wsR0FBbkI7QUFDRCxDQUZELE1BRU8sSUFBSSxPQUFPTSxNQUFQLEtBQWtCLFdBQXRCLEVBQW1DO0FBQ3hDRixjQUFZRSxPQUFPTixHQUFuQjtBQUNEO0FBQ0QsSUFBSUksU0FBSixFQUFlO0FBQ2JBLFlBQVVHLEdBQVYsQ0FBY0wsTUFBZDtBQUNELEMiLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRHlncmFwaHMgZnJvbSAnLi9jb21wb25lbnRzL0R5Z3JhcGhzLnZ1ZSdcclxuaW1wb3J0IER5Z3JhcGhzQXBpIGZyb20gJ2R5Z3JhcGhzJ1xyXG4vLyBJbnN0YWxsIHRoZSBjb21wb25lbnRzXHJcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsIChWdWUpIHtcclxuICBWdWUuY29tcG9uZW50KCdkeWdyYXBocycsIER5Z3JhcGhzKVxyXG4gIC8qIC0tIEFkZCBtb3JlIGNvbXBvbmVudHMgaGVyZSAtLSAqL1xyXG59XHJcblxyXG4vLyBFeHBvc2UgdGhlIGNvbXBvbmVudHNcclxuZXhwb3J0IHtcclxuICBEeWdyYXBocyxcclxuICBEeWdyYXBoc0FwaVxyXG4gIC8qIC0tIEFkZCBtb3JlIGNvbXBvbmVudHMgaGVyZSAtLSAqL1xyXG59XHJcblxyXG4vKiAtLSBQbHVnaW4gZGVmaW5pdGlvbiAmIEF1dG8taW5zdGFsbCAtLSAqL1xyXG4vKiBZb3Ugc2hvdWxkbid0IGhhdmUgdG8gbW9kaWZ5IHRoZSBjb2RlIGJlbG93ICovXHJcblxyXG4vLyBQbHVnaW5cclxuY29uc3QgcGx1Z2luID0ge1xyXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXHJcbiAgdmVyc2lvbjogVkVSU0lPTixcclxuICBpbnN0YWxsLFxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBwbHVnaW5cclxuXHJcbi8vIEF1dG8taW5zdGFsbFxyXG5sZXQgR2xvYmFsVnVlID0gbnVsbFxyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBHbG9iYWxWdWUgPSB3aW5kb3cuVnVlXHJcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBHbG9iYWxWdWUgPSBnbG9iYWwuVnVlXHJcbn1cclxuaWYgKEdsb2JhbFZ1ZSkge1xyXG4gIEdsb2JhbFZ1ZS51c2UocGx1Z2luKVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///28\n");

/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_dygraphs__ = __webpack_require__(7);\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  render: function render(createElement) {\n    return createElement('div', {\n      attrs: {\n        id: 'vue-dygraphs' + this._uid\n      },\n      style: {\n        width: '100%',\n        height: '500px'\n      }\n    });\n  },\n  data: function data() {\n    return {\n      _graph: null\n    };\n  },\n\n  props: {\n    graphData: {\n      required: true\n    },\n    graphOptions: {},\n    interactionModel: {\n      type: Object,\n      default: null\n    },\n    clickCallback: {\n      type: Function,\n      default: null\n    },\n    drawCallback: {\n      type: Function,\n      default: null\n    },\n    highlightCallback: {\n      type: Function,\n      default: null\n    },\n    pointClickCallback: {\n      type: Function,\n      default: null\n    },\n    underlayCallback: {\n      type: Function,\n      default: null\n    },\n    unhighlightCallback: {\n      type: Function,\n      default: null\n    },\n    zoomCallback: {\n      type: Function,\n      default: null\n    },\n    drawHighlightPointCallback: {\n      type: Function,\n      default: null\n    },\n    drawPointCallback: {\n      type: Function,\n      default: null\n    }\n  },\n  created: function created() {\n    //override callback options\n    this.graphOptions.clickCallback = this.clickCallback;\n    this.graphOptions.drawCallback = this.drawCallback;\n    this.graphOptions.highlightCallback = this.highlightCallback;\n    this.graphOptions.pointClickCallback = this.pointClickCallback;\n    this.graphOptions.underlayCallback = this.underlayCallback;\n    this.graphOptions.unhighlightCallback = this.unhighlightCallback;\n    this.graphOptions.zoomCallback = this.zoomCallback;\n    this.graphOptions.drawHighlightPointCallback = this.drawHighlightPointCallback;\n    this.graphOptions.drawPointCallback = this.drawPointCallback;\n    this.graphOptions.interactionModel = this.interactionModel;\n  },\n  mounted: function mounted() {\n    this.renderGraph(this.graphData, this.graphOptions);\n  },\n\n  methods: {\n    renderGraph: function renderGraph(data, options) {\n      this.$data._graph = new __WEBPACK_IMPORTED_MODULE_0_dygraphs__[\"a\" /* default */]('vue-dygraphs' + this._uid, data, options);\n    }\n  },\n  watch: {\n    'graphData': {\n      handler: function handler(val, oldVal) {\n        this.$data._graph.updateOptions({ file: val });\n      }\n    },\n    'graphOptions': {\n      handler: function handler(val, oldVal) {\n        this.$data._graph.updateOptions(val);\n      }\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vRHlncmFwaHMudnVlPzVjMzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0E7O0FBRUE7eUNBRUE7OztrQ0FLQTtBQUZBOztlQUlBO2dCQUlBO0FBTEE7QUFKQSxLQURBO0FBV0E7d0JBQ0E7O2NBR0E7QUFGQTtBQUdBOzs7O2dCQUlBO0FBRkE7a0JBSUE7O1lBRUE7ZUFFQTtBQUhBOztZQUtBO2VBRUE7QUFIQTs7WUFLQTtlQUVBO0FBSEE7O1lBS0E7ZUFFQTtBQUhBOztZQUtBO2VBRUE7QUFIQTs7WUFLQTtlQUVBO0FBSEE7O1lBS0E7ZUFFQTtBQUhBOztZQUtBO2VBRUE7QUFIQTs7WUFLQTtlQUVBO0FBSEE7O1lBS0E7ZUFHQTtBQUpBO0FBMUNBOzhCQStDQTtBQUNBOzJDQUNBOzBDQUNBOytDQUNBO2dEQUNBOzhDQUNBO2lEQUNBOzBDQUNBO3dEQUNBOytDQUNBOzhDQUNBO0FBQ0E7OEJBQ0E7MENBQ0E7QUFDQTs7O3FEQUVBOzBIQUNBO0FBRUE7QUFKQTs7OzZDQU9BO2dEQUNBO0FBRUE7QUFKQTs7NkNBTUE7d0NBQ0E7QUFHQTtBQUxBO0FBTkE7QUF2RkEiLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxyXG5pbXBvcnQgRHlncmFwaHMgZnJvbSAnZHlncmFwaHMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgcmVuZGVyIChjcmVhdGVFbGVtZW50KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChcclxuICAgICAgJ2RpdicsIHtcclxuICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgaWQ6ICd2dWUtZHlncmFwaHMnICsgdGhpcy5fdWlkLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgICBoZWlnaHQ6ICc1MDBweCdcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICApXHJcbiAgfSxcclxuICBkYXRhICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIF9ncmFwaDogbnVsbCxcclxuICAgIH1cclxuICB9LFxyXG4gIHByb3BzOiB7XHJcbiAgICBncmFwaERhdGE6IHtcclxuICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICB9LFxyXG4gICAgZ3JhcGhPcHRpb25zOiB7XHJcbiAgICB9LFxyXG4gICAgaW50ZXJhY3Rpb25Nb2RlbDoge1xyXG4gICAgICB0eXBlOiBPYmplY3QsXHJcbiAgICAgIGRlZmF1bHQ6IG51bGwsXHJcbiAgICB9LFxyXG4gICAgY2xpY2tDYWxsYmFjazoge1xyXG4gICAgICB0eXBlOiBGdW5jdGlvbixcclxuICAgICAgZGVmYXVsdDogbnVsbCxcclxuICAgIH0sXHJcbiAgICBkcmF3Q2FsbGJhY2s6IHtcclxuICAgICAgdHlwZTogRnVuY3Rpb24sXHJcbiAgICAgIGRlZmF1bHQ6IG51bGwsXHJcbiAgICB9LFxyXG4gICAgaGlnaGxpZ2h0Q2FsbGJhY2s6IHtcclxuICAgICAgdHlwZTogRnVuY3Rpb24sXHJcbiAgICAgIGRlZmF1bHQ6IG51bGwsXHJcbiAgICB9LFxyXG4gICAgcG9pbnRDbGlja0NhbGxiYWNrIDoge1xyXG4gICAgICB0eXBlOiBGdW5jdGlvbixcclxuICAgICAgZGVmYXVsdDogbnVsbCxcclxuICAgIH0sXHJcbiAgICB1bmRlcmxheUNhbGxiYWNrOiB7XHJcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxyXG4gICAgICBkZWZhdWx0OiBudWxsLFxyXG4gICAgfSxcclxuICAgIHVuaGlnaGxpZ2h0Q2FsbGJhY2s6IHtcclxuICAgICAgdHlwZTogRnVuY3Rpb24sXHJcbiAgICAgIGRlZmF1bHQ6IG51bGwsXHJcbiAgICB9LFxyXG4gICAgem9vbUNhbGxiYWNrOiB7XHJcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxyXG4gICAgICBkZWZhdWx0OiBudWxsLFxyXG4gICAgfSxcclxuICAgIGRyYXdIaWdobGlnaHRQb2ludENhbGxiYWNrOiB7XHJcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxyXG4gICAgICBkZWZhdWx0OiBudWxsLFxyXG4gICAgfSxcclxuICAgIGRyYXdQb2ludENhbGxiYWNrOiB7XHJcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxyXG4gICAgICBkZWZhdWx0OiBudWxsLFxyXG4gICAgfSxcclxuICB9LFxyXG4gIGNyZWF0ZWQgKCkge1xyXG4gICAgLy9vdmVycmlkZSBjYWxsYmFjayBvcHRpb25zXHJcbiAgICB0aGlzLmdyYXBoT3B0aW9ucy5jbGlja0NhbGxiYWNrID0gdGhpcy5jbGlja0NhbGxiYWNrXHJcbiAgICB0aGlzLmdyYXBoT3B0aW9ucy5kcmF3Q2FsbGJhY2sgPSB0aGlzLmRyYXdDYWxsYmFja1xyXG4gICAgdGhpcy5ncmFwaE9wdGlvbnMuaGlnaGxpZ2h0Q2FsbGJhY2sgPSB0aGlzLmhpZ2hsaWdodENhbGxiYWNrXHJcbiAgICB0aGlzLmdyYXBoT3B0aW9ucy5wb2ludENsaWNrQ2FsbGJhY2sgID0gdGhpcy5wb2ludENsaWNrQ2FsbGJhY2tcclxuICAgIHRoaXMuZ3JhcGhPcHRpb25zLnVuZGVybGF5Q2FsbGJhY2sgID0gdGhpcy51bmRlcmxheUNhbGxiYWNrXHJcbiAgICB0aGlzLmdyYXBoT3B0aW9ucy51bmhpZ2hsaWdodENhbGxiYWNrID0gdGhpcy51bmhpZ2hsaWdodENhbGxiYWNrXHJcbiAgICB0aGlzLmdyYXBoT3B0aW9ucy56b29tQ2FsbGJhY2sgPSB0aGlzLnpvb21DYWxsYmFja1xyXG4gICAgdGhpcy5ncmFwaE9wdGlvbnMuZHJhd0hpZ2hsaWdodFBvaW50Q2FsbGJhY2sgPSB0aGlzLmRyYXdIaWdobGlnaHRQb2ludENhbGxiYWNrXHJcbiAgICB0aGlzLmdyYXBoT3B0aW9ucy5kcmF3UG9pbnRDYWxsYmFjayA9IHRoaXMuZHJhd1BvaW50Q2FsbGJhY2tcclxuICAgIHRoaXMuZ3JhcGhPcHRpb25zLmludGVyYWN0aW9uTW9kZWwgPSB0aGlzLmludGVyYWN0aW9uTW9kZWxcclxuICB9LFxyXG4gIG1vdW50ZWQgKCkge1xyXG4gICAgdGhpcy5yZW5kZXJHcmFwaCh0aGlzLmdyYXBoRGF0YSwgdGhpcy5ncmFwaE9wdGlvbnMpXHJcblx0fSxcclxuICBtZXRob2RzOiB7XHJcbiAgICByZW5kZXJHcmFwaCAoZGF0YSwgb3B0aW9ucykge1xyXG4gICAgICB0aGlzLiRkYXRhLl9ncmFwaCA9IG5ldyBEeWdyYXBocygndnVlLWR5Z3JhcGhzJyArIHRoaXMuX3VpZCwgZGF0YSwgb3B0aW9ucylcclxuICAgIH0sXHJcbiAgfSxcclxuICB3YXRjaDoge1xyXG4gICAgJ2dyYXBoRGF0YSc6IHtcclxuICAgICAgaGFuZGxlciAodmFsLCBvbGRWYWwpIHtcclxuICAgICAgICB0aGlzLiRkYXRhLl9ncmFwaC51cGRhdGVPcHRpb25zKHtmaWxlOiB2YWx9KVxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICAgICdncmFwaE9wdGlvbnMnOiB7XHJcbiAgICAgIGhhbmRsZXIgKHZhbCwgb2xkVmFsKSB7XHJcbiAgICAgICAgdGhpcy4kZGF0YS5fZ3JhcGgudXBkYXRlT3B0aW9ucyh2YWwpXHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gIH0sXHJcbn1cclxuPC9zY3JpcHQ+XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIER5Z3JhcGhzLnZ1ZT81MWQxNmJiMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///29\n");

/***/ }),
/* 30 */
/***/ (function(module, exports) {

eval("module.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzP2Q0ZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgcmF3U2NyaXB0RXhwb3J0cyxcbiAgY29tcGlsZWRUZW1wbGF0ZSxcbiAgc2NvcGVJZCxcbiAgY3NzTW9kdWxlc1xuKSB7XG4gIHZhciBlc01vZHVsZVxuICB2YXIgc2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzIHx8IHt9XG5cbiAgLy8gRVM2IG1vZHVsZXMgaW50ZXJvcFxuICB2YXIgdHlwZSA9IHR5cGVvZiByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgaWYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBlc01vZHVsZSA9IHJhd1NjcmlwdEV4cG9ydHNcbiAgICBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cy5kZWZhdWx0XG4gIH1cblxuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKGNvbXBpbGVkVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGNvbXBpbGVkVGVtcGxhdGUucmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZFRlbXBsYXRlLnN0YXRpY1JlbmRlckZuc1xuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gc2NvcGVJZFxuICB9XG5cbiAgLy8gaW5qZWN0IGNzc01vZHVsZXNcbiAgaWYgKGNzc01vZHVsZXMpIHtcbiAgICB2YXIgY29tcHV0ZWQgPSBvcHRpb25zLmNvbXB1dGVkIHx8IChvcHRpb25zLmNvbXB1dGVkID0ge30pXG4gICAgT2JqZWN0LmtleXMoY3NzTW9kdWxlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbW9kdWxlID0gY3NzTW9kdWxlc1trZXldXG4gICAgICBjb21wdXRlZFtrZXldID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbW9kdWxlIH1cbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlc01vZHVsZTogZXNNb2R1bGUsXG4gICAgZXhwb3J0czogc2NyaXB0RXhwb3J0cyxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///30\n");

/***/ })
/******/ ]);
});