(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["VueDygraphs"] = factory();
	else
		root["VueDygraphs"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOlsiZyIsIkZ1bmN0aW9uIiwiZXZhbCIsImUiLCJ3aW5kb3ciLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBLElBQUlBLENBQUo7O0FBRUE7QUFDQUEsSUFBSyxZQUFXO0FBQ2YsUUFBTyxJQUFQO0FBQ0EsQ0FGRyxFQUFKOztBQUlBLElBQUk7QUFDSDtBQUNBQSxLQUFJQSxLQUFLQyxTQUFTLGFBQVQsR0FBTCxJQUFrQyxDQUFDLEdBQUVDLElBQUgsRUFBUyxNQUFULENBQXRDO0FBQ0EsQ0FIRCxDQUdFLE9BQU1DLENBQU4sRUFBUztBQUNWO0FBQ0EsS0FBRyxRQUFPQyxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQXJCLEVBQ0NKLElBQUlJLE1BQUo7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUFDLE9BQU9DLE9BQVAsR0FBaUJOLENBQWpCIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */,
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (immutable) */ __webpack_exports__[\"install\"] = install;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Dygraphs_vue__ = __webpack_require__(21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Dygraphs_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_Dygraphs_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mixins_mixins_js__ = __webpack_require__(38);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mixins_mixins_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__mixins_mixins_js__);\n/* harmony reexport (default from non-hamory) */ __webpack_require__.d(__webpack_exports__, \"Dygraphs\", function() { return __WEBPACK_IMPORTED_MODULE_0__components_Dygraphs_vue___default.a; });\n/* harmony reexport (default from non-hamory) */ __webpack_require__.d(__webpack_exports__, \"mixins\", function() { return __WEBPACK_IMPORTED_MODULE_1__mixins_mixins_js___default.a; });\n\n\n\n// Install the components\nfunction install(Vue) {\n  Vue.component('dygraphs', __WEBPACK_IMPORTED_MODULE_0__components_Dygraphs_vue___default.a);\n  /* -- Add more components here -- */\n}\n\n// Expose the components\n\n\n/* -- Plugin definition & Auto-install -- */\n/* You shouldn't have to modify the code below */\n\n// Plugin\nvar plugin = {\n  /* eslint-disable no-undef */\n  version: \"0.0.0\",\n  install: install\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (plugin);\n\n// Auto-install\nvar GlobalVue = null;\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue;\n}\nif (GlobalVue) {\n  GlobalVue.use(plugin);\n}\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/OTU1MiJdLCJuYW1lcyI6WyJpbnN0YWxsIiwiVnVlIiwiY29tcG9uZW50IiwicGx1Z2luIiwidmVyc2lvbiIsIkdsb2JhbFZ1ZSIsIndpbmRvdyIsImdsb2JhbCIsInVzZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ08sU0FBU0EsT0FBVCxDQUFrQkMsR0FBbEIsRUFBdUI7QUFDNUJBLE1BQUlDLFNBQUosQ0FBYyxVQUFkLEVBQTBCLGdFQUExQjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQTs7QUFNQTtBQUNBOztBQUVBO0FBQ0EsSUFBTUMsU0FBUztBQUNiO0FBQ0FDLFdBQVMsT0FGSTtBQUdiSjtBQUhhLENBQWY7O0FBTUEsK0RBQWVHLE1BQWY7O0FBRUE7QUFDQSxJQUFJRSxZQUFZLElBQWhCO0FBQ0EsSUFBSSxPQUFPQyxNQUFQLEtBQWtCLFdBQXRCLEVBQW1DO0FBQ2pDRCxjQUFZQyxPQUFPTCxHQUFuQjtBQUNELENBRkQsTUFFTyxJQUFJLE9BQU9NLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7QUFDeENGLGNBQVlFLE9BQU9OLEdBQW5CO0FBQ0Q7QUFDRCxJQUFJSSxTQUFKLEVBQWU7QUFDYkEsWUFBVUcsR0FBVixDQUFjTCxNQUFkO0FBQ0QsQyIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IER5Z3JhcGhzIGZyb20gJy4vY29tcG9uZW50cy9EeWdyYXBocy52dWUnXG5pbXBvcnQgbWl4aW5zIGZyb20gJy4vbWl4aW5zL21peGlucy5qcydcblxuLy8gSW5zdGFsbCB0aGUgY29tcG9uZW50c1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwgKFZ1ZSkge1xuICBWdWUuY29tcG9uZW50KCdkeWdyYXBocycsIER5Z3JhcGhzKVxuICAvKiAtLSBBZGQgbW9yZSBjb21wb25lbnRzIGhlcmUgLS0gKi9cbn1cblxuLy8gRXhwb3NlIHRoZSBjb21wb25lbnRzXG5leHBvcnQge1xuICBEeWdyYXBocyxcbiAgbWl4aW5zXG4gIC8qIC0tIEFkZCBtb3JlIGNvbXBvbmVudHMgaGVyZSAtLSAqL1xufVxuXG4vKiAtLSBQbHVnaW4gZGVmaW5pdGlvbiAmIEF1dG8taW5zdGFsbCAtLSAqL1xuLyogWW91IHNob3VsZG4ndCBoYXZlIHRvIG1vZGlmeSB0aGUgY29kZSBiZWxvdyAqL1xuXG4vLyBQbHVnaW5cbmNvbnN0IHBsdWdpbiA9IHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbiAgdmVyc2lvbjogVkVSU0lPTixcbiAgaW5zdGFsbCxcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGx1Z2luXG5cbi8vIEF1dG8taW5zdGFsbFxubGV0IEdsb2JhbFZ1ZSA9IG51bGxcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBHbG9iYWxWdWUgPSB3aW5kb3cuVnVlXG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIEdsb2JhbFZ1ZSA9IGdsb2JhbC5WdWVcbn1cbmlmIChHbG9iYWxWdWUpIHtcbiAgR2xvYmFsVnVlLnVzZShwbHVnaW4pXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5kZXguanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */,
/* 4 */,
/* 5 */
/***/ (function(module, exports) {

eval("module.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzP2Q0ZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICByYXdTY3JpcHRFeHBvcnRzLFxuICBjb21waWxlZFRlbXBsYXRlLFxuICBzY29wZUlkLFxuICBjc3NNb2R1bGVzXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICAvLyBpbmplY3QgY3NzTW9kdWxlc1xuICBpZiAoY3NzTW9kdWxlcykge1xuICAgIHZhciBjb21wdXRlZCA9IG9wdGlvbnMuY29tcHV0ZWQgfHwgKG9wdGlvbnMuY29tcHV0ZWQgPSB7fSlcbiAgICBPYmplY3Qua2V5cyhjc3NNb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtb2R1bGUgPSBjc3NNb2R1bGVzW2tleV1cbiAgICAgIGNvbXB1dGVkW2tleV0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2R1bGUgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVzTW9kdWxlOiBlc01vZHVsZSxcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */,
/* 7 */,
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"N\", function() { return LOG_SCALE; });\n/* unused harmony export LN_TEN */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return log10; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return logRangeFraction; });\n/* unused harmony export DOTTED_LINE */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"G\", function() { return DASHED_LINE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"H\", function() { return DOT_DASH_LINE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return HORIZONTAL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"o\", function() { return VERTICAL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return getContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"F\", function() { return addEvent; });\n/* harmony export (immutable) */ __webpack_exports__[\"i\"] = removeEvent;\n/* harmony export (immutable) */ __webpack_exports__[\"O\"] = cancelEvent;\n/* harmony export (immutable) */ __webpack_exports__[\"j\"] = hsvToRGB;\n/* harmony export (immutable) */ __webpack_exports__[\"k\"] = findPos;\n/* harmony export (immutable) */ __webpack_exports__[\"q\"] = pageX;\n/* harmony export (immutable) */ __webpack_exports__[\"r\"] = pageY;\n/* harmony export (immutable) */ __webpack_exports__[\"l\"] = dragGetX_;\n/* harmony export (immutable) */ __webpack_exports__[\"m\"] = dragGetY_;\n/* harmony export (immutable) */ __webpack_exports__[\"S\"] = isOK;\n/* harmony export (immutable) */ __webpack_exports__[\"s\"] = isValidPoint;\n/* harmony export (immutable) */ __webpack_exports__[\"J\"] = floatFormat;\n/* unused harmony export zeropad */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"M\", function() { return DateAccessorsLocal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"L\", function() { return DateAccessorsUTC; });\n/* unused harmony export hmsString_ */\n/* harmony export (immutable) */ __webpack_exports__[\"I\"] = dateString_;\n/* unused harmony export round_ */\n/* harmony export (immutable) */ __webpack_exports__[\"K\"] = binarySearch;\n/* harmony export (immutable) */ __webpack_exports__[\"v\"] = dateParser;\n/* unused harmony export dateStrToMillis */\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = update;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = updateDeep;\n/* harmony export (immutable) */ __webpack_exports__[\"B\"] = isArrayLike;\n/* harmony export (immutable) */ __webpack_exports__[\"A\"] = isDateLike;\n/* harmony export (immutable) */ __webpack_exports__[\"C\"] = clone;\n/* harmony export (immutable) */ __webpack_exports__[\"e\"] = createCanvas;\n/* harmony export (immutable) */ __webpack_exports__[\"h\"] = getContextPixelRatio;\n/* unused harmony export Iterator */\n/* harmony export (immutable) */ __webpack_exports__[\"R\"] = createIterator;\n/* unused harmony export requestAnimFrame */\n/* harmony export (immutable) */ __webpack_exports__[\"p\"] = repeatAndCleanup;\n/* harmony export (immutable) */ __webpack_exports__[\"E\"] = isPixelChangingOptionList;\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"u\", function() { return Circles; });\n/* harmony export (immutable) */ __webpack_exports__[\"y\"] = detectLineDelimiter;\n/* harmony export (immutable) */ __webpack_exports__[\"g\"] = isNodeContainedBy;\n/* unused harmony export pow */\n/* harmony export (immutable) */ __webpack_exports__[\"t\"] = toRGB_;\n/* harmony export (immutable) */ __webpack_exports__[\"Q\"] = isCanvasSupported;\n/* harmony export (immutable) */ __webpack_exports__[\"z\"] = parseFloat_;\n/* harmony export (immutable) */ __webpack_exports__[\"P\"] = numberValueFormatter;\n/* harmony export (immutable) */ __webpack_exports__[\"D\"] = numberAxisLabelFormatter;\n/* harmony export (immutable) */ __webpack_exports__[\"x\"] = dateAxisLabelFormatter;\n/* harmony export (immutable) */ __webpack_exports__[\"w\"] = dateValueFormatter;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__ = __webpack_require__(12);\n/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview This file contains utility functions used by dygraphs. These\n * are typically static (i.e. not related to any particular dygraph). Examples\n * include date/time formatting functions, basic algorithms (e.g. binary\n * search) and generic DOM-manipulation functions.\n */\n\n/*global Dygraph:false, Node:false */\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n\n\nvar LOG_SCALE = 10;\nvar LN_TEN = Math.log(LOG_SCALE);\n\n/**\n * @private\n * @param {number} x\n * @return {number}\n */\nvar log10 = function log10(x) {\n  return Math.log(x) / LN_TEN;\n};\n\n/**\n * @private\n * @param {number} r0\n * @param {number} r1\n * @param {number} pct\n * @return {number}\n */\nvar logRangeFraction = function logRangeFraction(r0, r1, pct) {\n  // Computing the inverse of toPercentXCoord. The function was arrived at with\n  // the following steps:\n  //\n  // Original calcuation:\n  // pct = (log(x) - log(xRange[0])) / (log(xRange[1]) - log(xRange[0])));\n  //\n  // Multiply both sides by the right-side denominator.\n  // pct * (log(xRange[1] - log(xRange[0]))) = log(x) - log(xRange[0])\n  //\n  // add log(xRange[0]) to both sides\n  // log(xRange[0]) + (pct * (log(xRange[1]) - log(xRange[0])) = log(x);\n  //\n  // Swap both sides of the equation,\n  // log(x) = log(xRange[0]) + (pct * (log(xRange[1]) - log(xRange[0]))\n  //\n  // Use both sides as the exponent in 10^exp and we're done.\n  // x = 10 ^ (log(xRange[0]) + (pct * (log(xRange[1]) - log(xRange[0])))\n\n  var logr0 = log10(r0);\n  var logr1 = log10(r1);\n  var exponent = logr0 + pct * (logr1 - logr0);\n  var value = Math.pow(LOG_SCALE, exponent);\n  return value;\n};\n\n/** A dotted line stroke pattern. */\nvar DOTTED_LINE = [2, 2];\n/** A dashed line stroke pattern. */\nvar DASHED_LINE = [7, 3];\n/** A dot dash stroke pattern. */\nvar DOT_DASH_LINE = [7, 2, 2, 2];\n\n// Directions for panning and zooming. Use bit operations when combined\n// values are possible.\nvar HORIZONTAL = 1;\nvar VERTICAL = 2;\n\n/**\n * Return the 2d context for a dygraph canvas.\n *\n * This method is only exposed for the sake of replacing the function in\n * automated tests.\n *\n * @param {!HTMLCanvasElement} canvas\n * @return {!CanvasRenderingContext2D}\n * @private\n */\nvar getContext = function getContext(canvas) {\n  return (/** @type{!CanvasRenderingContext2D}*/canvas.getContext(\"2d\")\n  );\n};\n\n/**\n * Add an event handler.\n * @param {!Node} elem The element to add the event to.\n * @param {string} type The type of the event, e.g. 'click' or 'mousemove'.\n * @param {function(Event):(boolean|undefined)} fn The function to call\n *     on the event. The function takes one parameter: the event object.\n * @private\n */\nvar addEvent = function addEvent(elem, type, fn) {\n  elem.addEventListener(type, fn, false);\n};\n\n/**\n * Remove an event handler.\n * @param {!Node} elem The element to remove the event from.\n * @param {string} type The type of the event, e.g. 'click' or 'mousemove'.\n * @param {function(Event):(boolean|undefined)} fn The function to call\n *     on the event. The function takes one parameter: the event object.\n */\nfunction removeEvent(elem, type, fn) {\n  elem.removeEventListener(type, fn, false);\n};\n\n/**\n * Cancels further processing of an event. This is useful to prevent default\n * browser actions, e.g. highlighting text on a double-click.\n * Based on the article at\n * http://www.switchonthecode.com/tutorials/javascript-tutorial-the-scroll-wheel\n * @param {!Event} e The event whose normal behavior should be canceled.\n * @private\n */\nfunction cancelEvent(e) {\n  e = e ? e : window.event;\n  if (e.stopPropagation) {\n    e.stopPropagation();\n  }\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n  e.cancelBubble = true;\n  e.cancel = true;\n  e.returnValue = false;\n  return false;\n};\n\n/**\n * Convert hsv values to an rgb(r,g,b) string. Taken from MochiKit.Color. This\n * is used to generate default series colors which are evenly spaced on the\n * color wheel.\n * @param { number } hue Range is 0.0-1.0.\n * @param { number } saturation Range is 0.0-1.0.\n * @param { number } value Range is 0.0-1.0.\n * @return { string } \"rgb(r,g,b)\" where r, g and b range from 0-255.\n * @private\n */\nfunction hsvToRGB(hue, saturation, value) {\n  var red;\n  var green;\n  var blue;\n  if (saturation === 0) {\n    red = value;\n    green = value;\n    blue = value;\n  } else {\n    var i = Math.floor(hue * 6);\n    var f = hue * 6 - i;\n    var p = value * (1 - saturation);\n    var q = value * (1 - saturation * f);\n    var t = value * (1 - saturation * (1 - f));\n    switch (i) {\n      case 1:\n        red = q;green = value;blue = p;break;\n      case 2:\n        red = p;green = value;blue = t;break;\n      case 3:\n        red = p;green = q;blue = value;break;\n      case 4:\n        red = t;green = p;blue = value;break;\n      case 5:\n        red = value;green = p;blue = q;break;\n      case 6: // fall through\n      case 0:\n        red = value;green = t;blue = p;break;\n    }\n  }\n  red = Math.floor(255 * red + 0.5);\n  green = Math.floor(255 * green + 0.5);\n  blue = Math.floor(255 * blue + 0.5);\n  return 'rgb(' + red + ',' + green + ',' + blue + ')';\n};\n\n/**\n * Find the coordinates of an object relative to the top left of the page.\n *\n * @param {Node} obj\n * @return {{x:number,y:number}}\n * @private\n */\nfunction findPos(obj) {\n  var p = obj.getBoundingClientRect(),\n      w = window,\n      d = document.documentElement;\n\n  return {\n    x: p.left + (w.pageXOffset || d.scrollLeft),\n    y: p.top + (w.pageYOffset || d.scrollTop)\n  };\n};\n\n/**\n * Returns the x-coordinate of the event in a coordinate system where the\n * top-left corner of the page (not the window) is (0,0).\n * Taken from MochiKit.Signal\n * @param {!Event} e\n * @return {number}\n * @private\n */\nfunction pageX(e) {\n  return !e.pageX || e.pageX < 0 ? 0 : e.pageX;\n};\n\n/**\n * Returns the y-coordinate of the event in a coordinate system where the\n * top-left corner of the page (not the window) is (0,0).\n * Taken from MochiKit.Signal\n * @param {!Event} e\n * @return {number}\n * @private\n */\nfunction pageY(e) {\n  return !e.pageY || e.pageY < 0 ? 0 : e.pageY;\n};\n\n/**\n * Converts page the x-coordinate of the event to pixel x-coordinates on the\n * canvas (i.e. DOM Coords).\n * @param {!Event} e Drag event.\n * @param {!DygraphInteractionContext} context Interaction context object.\n * @return {number} The amount by which the drag has moved to the right.\n */\nfunction dragGetX_(e, context) {\n  return pageX(e) - context.px;\n};\n\n/**\n * Converts page the y-coordinate of the event to pixel y-coordinates on the\n * canvas (i.e. DOM Coords).\n * @param {!Event} e Drag event.\n * @param {!DygraphInteractionContext} context Interaction context object.\n * @return {number} The amount by which the drag has moved down.\n */\nfunction dragGetY_(e, context) {\n  return pageY(e) - context.py;\n};\n\n/**\n * This returns true unless the parameter is 0, null, undefined or NaN.\n * TODO(danvk): rename this function to something like 'isNonZeroNan'.\n *\n * @param {number} x The number to consider.\n * @return {boolean} Whether the number is zero or NaN.\n * @private\n */\nfunction isOK(x) {\n  return !!x && !isNaN(x);\n};\n\n/**\n * @param {{x:?number,y:?number,yval:?number}} p The point to consider, valid\n *     points are {x, y} objects\n * @param {boolean=} opt_allowNaNY Treat point with y=NaN as valid\n * @return {boolean} Whether the point has numeric x and y.\n * @private\n */\nfunction isValidPoint(p, opt_allowNaNY) {\n  if (!p) return false; // null or undefined object\n  if (p.yval === null) return false; // missing point\n  if (p.x === null || p.x === undefined) return false;\n  if (p.y === null || p.y === undefined) return false;\n  if (isNaN(p.x) || !opt_allowNaNY && isNaN(p.y)) return false;\n  return true;\n};\n\n/**\n * Number formatting function which mimics the behavior of %g in printf, i.e.\n * either exponential or fixed format (without trailing 0s) is used depending on\n * the length of the generated string.  The advantage of this format is that\n * there is a predictable upper bound on the resulting string length,\n * significant figures are not dropped, and normal numbers are not displayed in\n * exponential notation.\n *\n * NOTE: JavaScript's native toPrecision() is NOT a drop-in replacement for %g.\n * It creates strings which are too long for absolute values between 10^-4 and\n * 10^-6, e.g. '0.00001' instead of '1e-5'. See tests/number-format.html for\n * output examples.\n *\n * @param {number} x The number to format\n * @param {number=} opt_precision The precision to use, default 2.\n * @return {string} A string formatted like %g in printf.  The max generated\n *                  string length should be precision + 6 (e.g 1.123e+300).\n */\nfunction floatFormat(x, opt_precision) {\n  // Avoid invalid precision values; [1, 21] is the valid range.\n  var p = Math.min(Math.max(1, opt_precision || 2), 21);\n\n  // This is deceptively simple.  The actual algorithm comes from:\n  //\n  // Max allowed length = p + 4\n  // where 4 comes from 'e+n' and '.'.\n  //\n  // Length of fixed format = 2 + y + p\n  // where 2 comes from '0.' and y = # of leading zeroes.\n  //\n  // Equating the two and solving for y yields y = 2, or 0.00xxxx which is\n  // 1.0e-3.\n  //\n  // Since the behavior of toPrecision() is identical for larger numbers, we\n  // don't have to worry about the other bound.\n  //\n  // Finally, the argument for toExponential() is the number of trailing digits,\n  // so we take off 1 for the value before the '.'.\n  return Math.abs(x) < 1.0e-3 && x !== 0.0 ? x.toExponential(p - 1) : x.toPrecision(p);\n};\n\n/**\n * Converts '9' to '09' (useful for dates)\n * @param {number} x\n * @return {string}\n * @private\n */\nfunction zeropad(x) {\n  if (x < 10) return \"0\" + x;else return \"\" + x;\n};\n\n/**\n * Date accessors to get the parts of a calendar date (year, month,\n * day, hour, minute, second and millisecond) according to local time,\n * and factory method to call the Date constructor with an array of arguments.\n */\nvar DateAccessorsLocal = {\n  getFullYear: function getFullYear(d) {\n    return d.getFullYear();\n  },\n  getMonth: function getMonth(d) {\n    return d.getMonth();\n  },\n  getDate: function getDate(d) {\n    return d.getDate();\n  },\n  getHours: function getHours(d) {\n    return d.getHours();\n  },\n  getMinutes: function getMinutes(d) {\n    return d.getMinutes();\n  },\n  getSeconds: function getSeconds(d) {\n    return d.getSeconds();\n  },\n  getMilliseconds: function getMilliseconds(d) {\n    return d.getMilliseconds();\n  },\n  getDay: function getDay(d) {\n    return d.getDay();\n  },\n  makeDate: function makeDate(y, m, d, hh, mm, ss, ms) {\n    return new Date(y, m, d, hh, mm, ss, ms);\n  }\n};\n\n/**\n * Date accessors to get the parts of a calendar date (year, month,\n * day of month, hour, minute, second and millisecond) according to UTC time,\n * and factory method to call the Date constructor with an array of arguments.\n */\nvar DateAccessorsUTC = {\n  getFullYear: function getFullYear(d) {\n    return d.getUTCFullYear();\n  },\n  getMonth: function getMonth(d) {\n    return d.getUTCMonth();\n  },\n  getDate: function getDate(d) {\n    return d.getUTCDate();\n  },\n  getHours: function getHours(d) {\n    return d.getUTCHours();\n  },\n  getMinutes: function getMinutes(d) {\n    return d.getUTCMinutes();\n  },\n  getSeconds: function getSeconds(d) {\n    return d.getUTCSeconds();\n  },\n  getMilliseconds: function getMilliseconds(d) {\n    return d.getUTCMilliseconds();\n  },\n  getDay: function getDay(d) {\n    return d.getUTCDay();\n  },\n  makeDate: function makeDate(y, m, d, hh, mm, ss, ms) {\n    return new Date(Date.UTC(y, m, d, hh, mm, ss, ms));\n  }\n};\n\n/**\n * Return a string version of the hours, minutes and seconds portion of a date.\n * @param {number} hh The hours (from 0-23)\n * @param {number} mm The minutes (from 0-59)\n * @param {number} ss The seconds (from 0-59)\n * @return {string} A time of the form \"HH:MM\" or \"HH:MM:SS\"\n * @private\n */\nfunction hmsString_(hh, mm, ss, ms) {\n  var ret = zeropad(hh) + \":\" + zeropad(mm);\n  if (ss) {\n    ret += \":\" + zeropad(ss);\n    if (ms) {\n      var str = \"\" + ms;\n      ret += \".\" + ('000' + str).substring(str.length);\n    }\n  }\n  return ret;\n};\n\n/**\n * Convert a JS date (millis since epoch) to a formatted string.\n * @param {number} time The JavaScript time value (ms since epoch)\n * @param {boolean} utc Whether output UTC or local time\n * @return {string} A date of one of these forms:\n *     \"YYYY/MM/DD\", \"YYYY/MM/DD HH:MM\" or \"YYYY/MM/DD HH:MM:SS\"\n * @private\n */\nfunction dateString_(time, utc) {\n  var accessors = utc ? DateAccessorsUTC : DateAccessorsLocal;\n  var date = new Date(time);\n  var y = accessors.getFullYear(date);\n  var m = accessors.getMonth(date);\n  var d = accessors.getDate(date);\n  var hh = accessors.getHours(date);\n  var mm = accessors.getMinutes(date);\n  var ss = accessors.getSeconds(date);\n  var ms = accessors.getMilliseconds(date);\n  // Get a year string:\n  var year = \"\" + y;\n  // Get a 0 padded month string\n  var month = zeropad(m + 1); //months are 0-offset, sigh\n  // Get a 0 padded day string\n  var day = zeropad(d);\n  var frac = hh * 3600 + mm * 60 + ss + 1e-3 * ms;\n  var ret = year + \"/\" + month + \"/\" + day;\n  if (frac) {\n    ret += \" \" + hmsString_(hh, mm, ss, ms);\n  }\n  return ret;\n};\n\n/**\n * Round a number to the specified number of digits past the decimal point.\n * @param {number} num The number to round\n * @param {number} places The number of decimals to which to round\n * @return {number} The rounded number\n * @private\n */\nfunction round_(num, places) {\n  var shift = Math.pow(10, places);\n  return Math.round(num * shift) / shift;\n};\n\n/**\n * Implementation of binary search over an array.\n * Currently does not work when val is outside the range of arry's values.\n * @param {number} val the value to search for\n * @param {Array.<number>} arry is the value over which to search\n * @param {number} abs If abs > 0, find the lowest entry greater than val\n *     If abs < 0, find the highest entry less than val.\n *     If abs == 0, find the entry that equals val.\n * @param {number=} low The first index in arry to consider (optional)\n * @param {number=} high The last index in arry to consider (optional)\n * @return {number} Index of the element, or -1 if it isn't found.\n * @private\n */\nfunction binarySearch(val, arry, abs, low, high) {\n  if (low === null || low === undefined || high === null || high === undefined) {\n    low = 0;\n    high = arry.length - 1;\n  }\n  if (low > high) {\n    return -1;\n  }\n  if (abs === null || abs === undefined) {\n    abs = 0;\n  }\n  var validIndex = function validIndex(idx) {\n    return idx >= 0 && idx < arry.length;\n  };\n  var mid = parseInt((low + high) / 2, 10);\n  var element = arry[mid];\n  var idx;\n  if (element == val) {\n    return mid;\n  } else if (element > val) {\n    if (abs > 0) {\n      // Accept if element > val, but also if prior element < val.\n      idx = mid - 1;\n      if (validIndex(idx) && arry[idx] < val) {\n        return mid;\n      }\n    }\n    return binarySearch(val, arry, abs, low, mid - 1);\n  } else if (element < val) {\n    if (abs < 0) {\n      // Accept if element < val, but also if prior element > val.\n      idx = mid + 1;\n      if (validIndex(idx) && arry[idx] > val) {\n        return mid;\n      }\n    }\n    return binarySearch(val, arry, abs, mid + 1, high);\n  }\n  return -1; // can't actually happen, but makes closure compiler happy\n};\n\n/**\n * Parses a date, returning the number of milliseconds since epoch. This can be\n * passed in as an xValueParser in the Dygraph constructor.\n * TODO(danvk): enumerate formats that this understands.\n *\n * @param {string} dateStr A date in a variety of possible string formats.\n * @return {number} Milliseconds since epoch.\n * @private\n */\nfunction dateParser(dateStr) {\n  var dateStrSlashed;\n  var d;\n\n  // Let the system try the format first, with one caveat:\n  // YYYY-MM-DD[ HH:MM:SS] is interpreted as UTC by a variety of browsers.\n  // dygraphs displays dates in local time, so this will result in surprising\n  // inconsistencies. But if you specify \"T\" or \"Z\" (i.e. YYYY-MM-DDTHH:MM:SS),\n  // then you probably know what you're doing, so we'll let you go ahead.\n  // Issue: http://code.google.com/p/dygraphs/issues/detail?id=255\n  if (dateStr.search(\"-\") == -1 || dateStr.search(\"T\") != -1 || dateStr.search(\"Z\") != -1) {\n    d = dateStrToMillis(dateStr);\n    if (d && !isNaN(d)) return d;\n  }\n\n  if (dateStr.search(\"-\") != -1) {\n    // e.g. '2009-7-12' or '2009-07-12'\n    dateStrSlashed = dateStr.replace(\"-\", \"/\", \"g\");\n    while (dateStrSlashed.search(\"-\") != -1) {\n      dateStrSlashed = dateStrSlashed.replace(\"-\", \"/\");\n    }\n    d = dateStrToMillis(dateStrSlashed);\n  } else if (dateStr.length == 8) {\n    // e.g. '20090712'\n    // TODO(danvk): remove support for this format. It's confusing.\n    dateStrSlashed = dateStr.substr(0, 4) + \"/\" + dateStr.substr(4, 2) + \"/\" + dateStr.substr(6, 2);\n    d = dateStrToMillis(dateStrSlashed);\n  } else {\n    // Any format that Date.parse will accept, e.g. \"2009/07/12\" or\n    // \"2009/07/12 12:34:56\"\n    d = dateStrToMillis(dateStr);\n  }\n\n  if (!d || isNaN(d)) {\n    console.error(\"Couldn't parse \" + dateStr + \" as a date\");\n  }\n  return d;\n};\n\n/**\n * This is identical to JavaScript's built-in Date.parse() method, except that\n * it doesn't get replaced with an incompatible method by aggressive JS\n * libraries like MooTools or Joomla.\n * @param {string} str The date string, e.g. \"2011/05/06\"\n * @return {number} millis since epoch\n * @private\n */\nfunction dateStrToMillis(str) {\n  return new Date(str).getTime();\n};\n\n// These functions are all based on MochiKit.\n/**\n * Copies all the properties from o to self.\n *\n * @param {!Object} self\n * @param {!Object} o\n * @return {!Object}\n */\nfunction update(self, o) {\n  if (typeof o != 'undefined' && o !== null) {\n    for (var k in o) {\n      if (o.hasOwnProperty(k)) {\n        self[k] = o[k];\n      }\n    }\n  }\n  return self;\n};\n\n/**\n * Copies all the properties from o to self.\n *\n * @param {!Object} self\n * @param {!Object} o\n * @return {!Object}\n * @private\n */\nfunction updateDeep(self, o) {\n  // Taken from http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n  function isNode(o) {\n    return (typeof Node === \"undefined\" ? \"undefined\" : _typeof(Node)) === \"object\" ? o instanceof Node : (typeof o === \"undefined\" ? \"undefined\" : _typeof(o)) === \"object\" && typeof o.nodeType === \"number\" && typeof o.nodeName === \"string\";\n  }\n\n  if (typeof o != 'undefined' && o !== null) {\n    for (var k in o) {\n      if (o.hasOwnProperty(k)) {\n        if (o[k] === null) {\n          self[k] = null;\n        } else if (isArrayLike(o[k])) {\n          self[k] = o[k].slice();\n        } else if (isNode(o[k])) {\n          // DOM objects are shallowly-copied.\n          self[k] = o[k];\n        } else if (_typeof(o[k]) == 'object') {\n          if (_typeof(self[k]) != 'object' || self[k] === null) {\n            self[k] = {};\n          }\n          updateDeep(self[k], o[k]);\n        } else {\n          self[k] = o[k];\n        }\n      }\n    }\n  }\n  return self;\n};\n\n/**\n * @param {*} o\n * @return {boolean}\n * @private\n */\nfunction isArrayLike(o) {\n  var typ = typeof o === \"undefined\" ? \"undefined\" : _typeof(o);\n  if (typ != 'object' && !(typ == 'function' && typeof o.item == 'function') || o === null || typeof o.length != 'number' || o.nodeType === 3) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @param {Object} o\n * @return {boolean}\n * @private\n */\nfunction isDateLike(o) {\n  if ((typeof o === \"undefined\" ? \"undefined\" : _typeof(o)) != \"object\" || o === null || typeof o.getTime != 'function') {\n    return false;\n  }\n  return true;\n};\n\n/**\n * Note: this only seems to work for arrays.\n * @param {!Array} o\n * @return {!Array}\n * @private\n */\nfunction clone(o) {\n  // TODO(danvk): figure out how MochiKit's version works\n  var r = [];\n  for (var i = 0; i < o.length; i++) {\n    if (isArrayLike(o[i])) {\n      r.push(clone(o[i]));\n    } else {\n      r.push(o[i]);\n    }\n  }\n  return r;\n};\n\n/**\n * Create a new canvas element.\n *\n * @return {!HTMLCanvasElement}\n * @private\n */\nfunction createCanvas() {\n  return document.createElement('canvas');\n};\n\n/**\n * Returns the context's pixel ratio, which is the ratio between the device\n * pixel ratio and the backing store ratio. Typically this is 1 for conventional\n * displays, and > 1 for HiDPI displays (such as the Retina MBP).\n * See http://www.html5rocks.com/en/tutorials/canvas/hidpi/ for more details.\n *\n * @param {!CanvasRenderingContext2D} context The canvas's 2d context.\n * @return {number} The ratio of the device pixel ratio and the backing store\n * ratio for the specified context.\n */\nfunction getContextPixelRatio(context) {\n  try {\n    var devicePixelRatio = window.devicePixelRatio;\n    var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n    if (devicePixelRatio !== undefined) {\n      return devicePixelRatio / backingStoreRatio;\n    } else {\n      // At least devicePixelRatio must be defined for this ratio to make sense.\n      // We default backingStoreRatio to 1: this does not exist on some browsers\n      // (i.e. desktop Chrome).\n      return 1;\n    }\n  } catch (e) {\n    return 1;\n  }\n};\n\n/**\n * TODO(danvk): use @template here when it's better supported for classes.\n * @param {!Array} array\n * @param {number} start\n * @param {number} length\n * @param {function(!Array,?):boolean=} predicate\n * @constructor\n */\nfunction Iterator(array, start, length, predicate) {\n  start = start || 0;\n  length = length || array.length;\n  this.hasNext = true; // Use to identify if there's another element.\n  this.peek = null; // Use for look-ahead\n  this.start_ = start;\n  this.array_ = array;\n  this.predicate_ = predicate;\n  this.end_ = Math.min(array.length, start + length);\n  this.nextIdx_ = start - 1; // use -1 so initial advance works.\n  this.next(); // ignoring result.\n};\n\n/**\n * @return {Object}\n */\nIterator.prototype.next = function () {\n  if (!this.hasNext) {\n    return null;\n  }\n  var obj = this.peek;\n\n  var nextIdx = this.nextIdx_ + 1;\n  var found = false;\n  while (nextIdx < this.end_) {\n    if (!this.predicate_ || this.predicate_(this.array_, nextIdx)) {\n      this.peek = this.array_[nextIdx];\n      found = true;\n      break;\n    }\n    nextIdx++;\n  }\n  this.nextIdx_ = nextIdx;\n  if (!found) {\n    this.hasNext = false;\n    this.peek = null;\n  }\n  return obj;\n};\n\n/**\n * Returns a new iterator over array, between indexes start and\n * start + length, and only returns entries that pass the accept function\n *\n * @param {!Array} array the array to iterate over.\n * @param {number} start the first index to iterate over, 0 if absent.\n * @param {number} length the number of elements in the array to iterate over.\n *     This, along with start, defines a slice of the array, and so length\n *     doesn't imply the number of elements in the iterator when accept doesn't\n *     always accept all values. array.length when absent.\n * @param {function(?):boolean=} opt_predicate a function that takes\n *     parameters array and idx, which returns true when the element should be\n *     returned.  If omitted, all elements are accepted.\n * @private\n */\nfunction createIterator(array, start, length, opt_predicate) {\n  return new Iterator(array, start, length, opt_predicate);\n};\n\n// Shim layer with setTimeout fallback.\n// From: http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// Should be called with the window context:\n//   Dygraph.requestAnimFrame.call(window, function() {})\nvar requestAnimFrame = function () {\n  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n    window.setTimeout(callback, 1000 / 60);\n  };\n}();\n\n/**\n * Call a function at most maxFrames times at an attempted interval of\n * framePeriodInMillis, then call a cleanup function once. repeatFn is called\n * once immediately, then at most (maxFrames - 1) times asynchronously. If\n * maxFrames==1, then cleanup_fn() is also called synchronously.  This function\n * is used to sequence animation.\n * @param {function(number)} repeatFn Called repeatedly -- takes the frame\n *     number (from 0 to maxFrames-1) as an argument.\n * @param {number} maxFrames The max number of times to call repeatFn\n * @param {number} framePeriodInMillis Max requested time between frames.\n * @param {function()} cleanupFn A function to call after all repeatFn calls.\n * @private\n */\nfunction repeatAndCleanup(repeatFn, maxFrames, framePeriodInMillis, cleanupFn) {\n  var frameNumber = 0;\n  var previousFrameNumber;\n  var startTime = new Date().getTime();\n  repeatFn(frameNumber);\n  if (maxFrames == 1) {\n    cleanupFn();\n    return;\n  }\n  var maxFrameArg = maxFrames - 1;\n\n  (function loop() {\n    if (frameNumber >= maxFrames) return;\n    requestAnimFrame.call(window, function () {\n      // Determine which frame to draw based on the delay so far.  Will skip\n      // frames if necessary.\n      var currentTime = new Date().getTime();\n      var delayInMillis = currentTime - startTime;\n      previousFrameNumber = frameNumber;\n      frameNumber = Math.floor(delayInMillis / framePeriodInMillis);\n      var frameDelta = frameNumber - previousFrameNumber;\n      // If we predict that the subsequent repeatFn call will overshoot our\n      // total frame target, so our last call will cause a stutter, then jump to\n      // the last call immediately.  If we're going to cause a stutter, better\n      // to do it faster than slower.\n      var predictOvershootStutter = frameNumber + frameDelta > maxFrameArg;\n      if (predictOvershootStutter || frameNumber >= maxFrameArg) {\n        repeatFn(maxFrameArg); // Ensure final call with maxFrameArg.\n        cleanupFn();\n      } else {\n        if (frameDelta !== 0) {\n          // Don't call repeatFn with duplicate frames.\n          repeatFn(frameNumber);\n        }\n        loop();\n      }\n    });\n  })();\n};\n\n// A whitelist of options that do not change pixel positions.\nvar pixelSafeOptions = {\n  'annotationClickHandler': true,\n  'annotationDblClickHandler': true,\n  'annotationMouseOutHandler': true,\n  'annotationMouseOverHandler': true,\n  'axisLineColor': true,\n  'axisLineWidth': true,\n  'clickCallback': true,\n  'drawCallback': true,\n  'drawHighlightPointCallback': true,\n  'drawPoints': true,\n  'drawPointCallback': true,\n  'drawGrid': true,\n  'fillAlpha': true,\n  'gridLineColor': true,\n  'gridLineWidth': true,\n  'hideOverlayOnMouseOut': true,\n  'highlightCallback': true,\n  'highlightCircleSize': true,\n  'interactionModel': true,\n  'labelsDiv': true,\n  'labelsKMB': true,\n  'labelsKMG2': true,\n  'labelsSeparateLines': true,\n  'labelsShowZeroValues': true,\n  'legend': true,\n  'panEdgeFraction': true,\n  'pixelsPerYLabel': true,\n  'pointClickCallback': true,\n  'pointSize': true,\n  'rangeSelectorPlotFillColor': true,\n  'rangeSelectorPlotFillGradientColor': true,\n  'rangeSelectorPlotStrokeColor': true,\n  'rangeSelectorBackgroundStrokeColor': true,\n  'rangeSelectorBackgroundLineWidth': true,\n  'rangeSelectorPlotLineWidth': true,\n  'rangeSelectorForegroundStrokeColor': true,\n  'rangeSelectorForegroundLineWidth': true,\n  'rangeSelectorAlpha': true,\n  'showLabelsOnHighlight': true,\n  'showRoller': true,\n  'strokeWidth': true,\n  'underlayCallback': true,\n  'unhighlightCallback': true,\n  'zoomCallback': true\n};\n\n/**\n * This function will scan the option list and determine if they\n * require us to recalculate the pixel positions of each point.\n * TODO: move this into dygraph-options.js\n * @param {!Array.<string>} labels a list of options to check.\n * @param {!Object} attrs\n * @return {boolean} true if the graph needs new points else false.\n * @private\n */\nfunction isPixelChangingOptionList(labels, attrs) {\n  // Assume that we do not require new points.\n  // This will change to true if we actually do need new points.\n\n  // Create a dictionary of series names for faster lookup.\n  // If there are no labels, then the dictionary stays empty.\n  var seriesNamesDictionary = {};\n  if (labels) {\n    for (var i = 1; i < labels.length; i++) {\n      seriesNamesDictionary[labels[i]] = true;\n    }\n  }\n\n  // Scan through a flat (i.e. non-nested) object of options.\n  // Returns true/false depending on whether new points are needed.\n  var scanFlatOptions = function scanFlatOptions(options) {\n    for (var property in options) {\n      if (options.hasOwnProperty(property) && !pixelSafeOptions[property]) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // Iterate through the list of updated options.\n  for (var property in attrs) {\n    if (!attrs.hasOwnProperty(property)) continue;\n\n    // Find out of this field is actually a series specific options list.\n    if (property == 'highlightSeriesOpts' || seriesNamesDictionary[property] && !attrs.series) {\n      // This property value is a list of options for this series.\n      if (scanFlatOptions(attrs[property])) return true;\n    } else if (property == 'series' || property == 'axes') {\n      // This is twice-nested options list.\n      var perSeries = attrs[property];\n      for (var series in perSeries) {\n        if (perSeries.hasOwnProperty(series) && scanFlatOptions(perSeries[series])) {\n          return true;\n        }\n      }\n    } else {\n      // If this was not a series specific option list, check if it's a pixel\n      // changing property.\n      if (!pixelSafeOptions[property]) return true;\n    }\n  }\n\n  return false;\n};\n\nvar Circles = {\n  DEFAULT: function DEFAULT(g, name, ctx, canvasx, canvasy, color, radius) {\n    ctx.beginPath();\n    ctx.fillStyle = color;\n    ctx.arc(canvasx, canvasy, radius, 0, 2 * Math.PI, false);\n    ctx.fill();\n  }\n  // For more shapes, include extras/shapes.js\n};\n\n/**\n * Determine whether |data| is delimited by CR, CRLF, LF, LFCR.\n * @param {string} data\n * @return {?string} the delimiter that was detected (or null on failure).\n */\nfunction detectLineDelimiter(data) {\n  for (var i = 0; i < data.length; i++) {\n    var code = data.charAt(i);\n    if (code === '\\r') {\n      // Might actually be \"\\r\\n\".\n      if (i + 1 < data.length && data.charAt(i + 1) === '\\n') {\n        return '\\r\\n';\n      }\n      return code;\n    }\n    if (code === '\\n') {\n      // Might actually be \"\\n\\r\".\n      if (i + 1 < data.length && data.charAt(i + 1) === '\\r') {\n        return '\\n\\r';\n      }\n      return code;\n    }\n  }\n\n  return null;\n};\n\n/**\n * Is one node contained by another?\n * @param {Node} containee The contained node.\n * @param {Node} container The container node.\n * @return {boolean} Whether containee is inside (or equal to) container.\n * @private\n */\nfunction isNodeContainedBy(containee, container) {\n  if (container === null || containee === null) {\n    return false;\n  }\n  var containeeNode = /** @type {Node} */containee;\n  while (containeeNode && containeeNode !== container) {\n    containeeNode = containeeNode.parentNode;\n  }\n  return containeeNode === container;\n};\n\n// This masks some numeric issues in older versions of Firefox,\n// where 1.0/Math.pow(10,2) != Math.pow(10,-2).\n/** @type {function(number,number):number} */\nfunction pow(base, exp) {\n  if (exp < 0) {\n    return 1.0 / Math.pow(base, -exp);\n  }\n  return Math.pow(base, exp);\n};\n\nvar RGBA_RE = /^rgba?\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})(?:,\\s*([01](?:\\.\\d+)?))?\\)$/;\n\n/**\n * Helper for toRGB_ which parses strings of the form:\n * rgb(123, 45, 67)\n * rgba(123, 45, 67, 0.5)\n * @return parsed {r,g,b,a?} tuple or null.\n */\nfunction parseRGBA(rgbStr) {\n  var bits = RGBA_RE.exec(rgbStr);\n  if (!bits) return null;\n  var r = parseInt(bits[1], 10),\n      g = parseInt(bits[2], 10),\n      b = parseInt(bits[3], 10);\n  if (bits[4]) {\n    return { r: r, g: g, b: b, a: parseFloat(bits[4]) };\n  } else {\n    return { r: r, g: g, b: b };\n  }\n}\n\n/**\n * Converts any valid CSS color (hex, rgb(), named color) to an RGB tuple.\n *\n * @param {!string} colorStr Any valid CSS color string.\n * @return {{r:number,g:number,b:number,a:number?}} Parsed RGB tuple.\n * @private\n */\nfunction toRGB_(colorStr) {\n  // Strategy: First try to parse colorStr directly. This is fast & avoids DOM\n  // manipulation.  If that fails (e.g. for named colors like 'red'), then\n  // create a hidden DOM element and parse its computed color.\n  var rgb = parseRGBA(colorStr);\n  if (rgb) return rgb;\n\n  var div = document.createElement('div');\n  div.style.backgroundColor = colorStr;\n  div.style.visibility = 'hidden';\n  document.body.appendChild(div);\n  var rgbStr = window.getComputedStyle(div, null).backgroundColor;\n  document.body.removeChild(div);\n  return parseRGBA(rgbStr);\n};\n\n/**\n * Checks whether the browser supports the &lt;canvas&gt; tag.\n * @param {HTMLCanvasElement=} opt_canvasElement Pass a canvas element as an\n *     optimization if you have one.\n * @return {boolean} Whether the browser supports canvas.\n */\nfunction isCanvasSupported(opt_canvasElement) {\n  try {\n    var canvas = opt_canvasElement || document.createElement(\"canvas\");\n    canvas.getContext(\"2d\");\n  } catch (e) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * Parses the value as a floating point number. This is like the parseFloat()\n * built-in, but with a few differences:\n * - the empty string is parsed as null, rather than NaN.\n * - if the string cannot be parsed at all, an error is logged.\n * If the string can't be parsed, this method returns null.\n * @param {string} x The string to be parsed\n * @param {number=} opt_line_no The line number from which the string comes.\n * @param {string=} opt_line The text of the line from which the string comes.\n */\nfunction parseFloat_(x, opt_line_no, opt_line) {\n  var val = parseFloat(x);\n  if (!isNaN(val)) return val;\n\n  // Try to figure out what happeend.\n  // If the value is the empty string, parse it as null.\n  if (/^ *$/.test(x)) return null;\n\n  // If it was actually \"NaN\", return it as NaN.\n  if (/^ *nan *$/i.test(x)) return NaN;\n\n  // Looks like a parsing error.\n  var msg = \"Unable to parse '\" + x + \"' as a number\";\n  if (opt_line !== undefined && opt_line_no !== undefined) {\n    msg += \" on line \" + (1 + (opt_line_no || 0)) + \" ('\" + opt_line + \"') of CSV.\";\n  }\n  console.error(msg);\n\n  return null;\n};\n\n// Label constants for the labelsKMB and labelsKMG2 options.\n// (i.e. '100000' -> '100K')\nvar KMB_LABELS = ['K', 'M', 'B', 'T', 'Q'];\nvar KMG2_BIG_LABELS = ['k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];\nvar KMG2_SMALL_LABELS = ['m', 'u', 'n', 'p', 'f', 'a', 'z', 'y'];\n\n/**\n * @private\n * Return a string version of a number. This respects the digitsAfterDecimal\n * and maxNumberWidth options.\n * @param {number} x The number to be formatted\n * @param {Dygraph} opts An options view\n */\nfunction numberValueFormatter(x, opts) {\n  var sigFigs = opts('sigFigs');\n\n  if (sigFigs !== null) {\n    // User has opted for a fixed number of significant figures.\n    return floatFormat(x, sigFigs);\n  }\n\n  var digits = opts('digitsAfterDecimal');\n  var maxNumberWidth = opts('maxNumberWidth');\n\n  var kmb = opts('labelsKMB');\n  var kmg2 = opts('labelsKMG2');\n\n  var label;\n\n  // switch to scientific notation if we underflow or overflow fixed display.\n  if (x !== 0.0 && (Math.abs(x) >= Math.pow(10, maxNumberWidth) || Math.abs(x) < Math.pow(10, -digits))) {\n    label = x.toExponential(digits);\n  } else {\n    label = '' + round_(x, digits);\n  }\n\n  if (kmb || kmg2) {\n    var k;\n    var k_labels = [];\n    var m_labels = [];\n    if (kmb) {\n      k = 1000;\n      k_labels = KMB_LABELS;\n    }\n    if (kmg2) {\n      if (kmb) console.warn(\"Setting both labelsKMB and labelsKMG2. Pick one!\");\n      k = 1024;\n      k_labels = KMG2_BIG_LABELS;\n      m_labels = KMG2_SMALL_LABELS;\n    }\n\n    var absx = Math.abs(x);\n    var n = pow(k, k_labels.length);\n    for (var j = k_labels.length - 1; j >= 0; j--, n /= k) {\n      if (absx >= n) {\n        label = round_(x / n, digits) + k_labels[j];\n        break;\n      }\n    }\n    if (kmg2) {\n      // TODO(danvk): clean up this logic. Why so different than kmb?\n      var x_parts = String(x.toExponential()).split('e-');\n      if (x_parts.length === 2 && x_parts[1] >= 3 && x_parts[1] <= 24) {\n        if (x_parts[1] % 3 > 0) {\n          label = round_(x_parts[0] / pow(10, x_parts[1] % 3), digits);\n        } else {\n          label = Number(x_parts[0]).toFixed(2);\n        }\n        label += m_labels[Math.floor(x_parts[1] / 3) - 1];\n      }\n    }\n  }\n\n  return label;\n};\n\n/**\n * variant for use as an axisLabelFormatter.\n * @private\n */\nfunction numberAxisLabelFormatter(x, granularity, opts) {\n  return numberValueFormatter.call(this, x, opts);\n};\n\n/**\n * @type {!Array.<string>}\n * @private\n * @constant\n */\nvar SHORT_MONTH_NAMES_ = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\n/**\n * Convert a JS date to a string appropriate to display on an axis that\n * is displaying values at the stated granularity. This respects the\n * labelsUTC option.\n * @param {Date} date The date to format\n * @param {number} granularity One of the Dygraph granularity constants\n * @param {Dygraph} opts An options view\n * @return {string} The date formatted as local time\n * @private\n */\nfunction dateAxisLabelFormatter(date, granularity, opts) {\n  var utc = opts('labelsUTC');\n  var accessors = utc ? DateAccessorsUTC : DateAccessorsLocal;\n\n  var year = accessors.getFullYear(date),\n      month = accessors.getMonth(date),\n      day = accessors.getDate(date),\n      hours = accessors.getHours(date),\n      mins = accessors.getMinutes(date),\n      secs = accessors.getSeconds(date),\n      millis = accessors.getMilliseconds(date);\n\n  if (granularity >= __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__[\"d\" /* Granularity */].DECADAL) {\n    return '' + year;\n  } else if (granularity >= __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__[\"d\" /* Granularity */].MONTHLY) {\n    return SHORT_MONTH_NAMES_[month] + '&#160;' + year;\n  } else {\n    var frac = hours * 3600 + mins * 60 + secs + 1e-3 * millis;\n    if (frac === 0 || granularity >= __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__[\"d\" /* Granularity */].DAILY) {\n      // e.g. '21 Jan' (%d%b)\n      return zeropad(day) + '&#160;' + SHORT_MONTH_NAMES_[month];\n    } else if (granularity < __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__[\"d\" /* Granularity */].SECONDLY) {\n      // e.g. 40.310 (meaning 40 seconds and 310 milliseconds)\n      var str = \"\" + millis;\n      return zeropad(secs) + \".\" + ('000' + str).substring(str.length);\n    } else if (granularity > __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__[\"d\" /* Granularity */].MINUTELY) {\n      return hmsString_(hours, mins, secs, 0);\n    } else {\n      return hmsString_(hours, mins, secs, millis);\n    }\n  }\n};\n// alias in case anyone is referencing the old method.\n// Dygraph.dateAxisFormatter = Dygraph.dateAxisLabelFormatter;\n\n/**\n * Return a string version of a JS date for a value label. This respects the\n * labelsUTC option.\n * @param {Date} date The date to be formatted\n * @param {Dygraph} opts An options view\n * @private\n */\nfunction dateValueFormatter(d, opts) {\n  return dateString_(d, opts('labelsUTC'));\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLXV0aWxzLmpzPzllM2MiXSwibmFtZXMiOlsiTE9HX1NDQUxFIiwiTE5fVEVOIiwiTWF0aCIsImxvZyIsImxvZzEwIiwieCIsImxvZ1JhbmdlRnJhY3Rpb24iLCJyMCIsInIxIiwicGN0IiwibG9ncjAiLCJsb2dyMSIsImV4cG9uZW50IiwidmFsdWUiLCJwb3ciLCJET1RURURfTElORSIsIkRBU0hFRF9MSU5FIiwiRE9UX0RBU0hfTElORSIsIkhPUklaT05UQUwiLCJWRVJUSUNBTCIsImdldENvbnRleHQiLCJjYW52YXMiLCJhZGRFdmVudCIsImVsZW0iLCJ0eXBlIiwiZm4iLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FuY2VsRXZlbnQiLCJlIiwid2luZG93IiwiZXZlbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsImNhbmNlbEJ1YmJsZSIsImNhbmNlbCIsInJldHVyblZhbHVlIiwiaHN2VG9SR0IiLCJodWUiLCJzYXR1cmF0aW9uIiwicmVkIiwiZ3JlZW4iLCJibHVlIiwiaSIsImZsb29yIiwiZiIsInAiLCJxIiwidCIsImZpbmRQb3MiLCJvYmoiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3IiwiZCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwibGVmdCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsTGVmdCIsInkiLCJ0b3AiLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsInBhZ2VYIiwicGFnZVkiLCJkcmFnR2V0WF8iLCJjb250ZXh0IiwicHgiLCJkcmFnR2V0WV8iLCJweSIsImlzT0siLCJpc05hTiIsImlzVmFsaWRQb2ludCIsIm9wdF9hbGxvd05hTlkiLCJ5dmFsIiwidW5kZWZpbmVkIiwiZmxvYXRGb3JtYXQiLCJvcHRfcHJlY2lzaW9uIiwibWluIiwibWF4IiwiYWJzIiwidG9FeHBvbmVudGlhbCIsInRvUHJlY2lzaW9uIiwiemVyb3BhZCIsIkRhdGVBY2Nlc3NvcnNMb2NhbCIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsImdldERheSIsIm1ha2VEYXRlIiwibSIsImhoIiwibW0iLCJzcyIsIm1zIiwiRGF0ZSIsIkRhdGVBY2Nlc3NvcnNVVEMiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJnZXRVVENNaWxsaXNlY29uZHMiLCJnZXRVVENEYXkiLCJVVEMiLCJobXNTdHJpbmdfIiwicmV0Iiwic3RyIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiZGF0ZVN0cmluZ18iLCJ0aW1lIiwidXRjIiwiYWNjZXNzb3JzIiwiZGF0ZSIsInllYXIiLCJtb250aCIsImRheSIsImZyYWMiLCJyb3VuZF8iLCJudW0iLCJwbGFjZXMiLCJzaGlmdCIsInJvdW5kIiwiYmluYXJ5U2VhcmNoIiwidmFsIiwiYXJyeSIsImxvdyIsImhpZ2giLCJ2YWxpZEluZGV4IiwiaWR4IiwibWlkIiwicGFyc2VJbnQiLCJlbGVtZW50IiwiZGF0ZVBhcnNlciIsImRhdGVTdHIiLCJkYXRlU3RyU2xhc2hlZCIsInNlYXJjaCIsImRhdGVTdHJUb01pbGxpcyIsInJlcGxhY2UiLCJzdWJzdHIiLCJjb25zb2xlIiwiZXJyb3IiLCJnZXRUaW1lIiwidXBkYXRlIiwic2VsZiIsIm8iLCJrIiwiaGFzT3duUHJvcGVydHkiLCJ1cGRhdGVEZWVwIiwiaXNOb2RlIiwiTm9kZSIsIm5vZGVUeXBlIiwibm9kZU5hbWUiLCJpc0FycmF5TGlrZSIsInNsaWNlIiwidHlwIiwiaXRlbSIsImlzRGF0ZUxpa2UiLCJjbG9uZSIsInIiLCJwdXNoIiwiY3JlYXRlQ2FudmFzIiwiY3JlYXRlRWxlbWVudCIsImdldENvbnRleHRQaXhlbFJhdGlvIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImJhY2tpbmdTdG9yZVJhdGlvIiwid2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsIm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJtc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJvQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsImJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJJdGVyYXRvciIsImFycmF5Iiwic3RhcnQiLCJwcmVkaWNhdGUiLCJoYXNOZXh0IiwicGVlayIsInN0YXJ0XyIsImFycmF5XyIsInByZWRpY2F0ZV8iLCJlbmRfIiwibmV4dElkeF8iLCJuZXh0IiwicHJvdG90eXBlIiwibmV4dElkeCIsImZvdW5kIiwiY3JlYXRlSXRlcmF0b3IiLCJvcHRfcHJlZGljYXRlIiwicmVxdWVzdEFuaW1GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbGxiYWNrIiwic2V0VGltZW91dCIsInJlcGVhdEFuZENsZWFudXAiLCJyZXBlYXRGbiIsIm1heEZyYW1lcyIsImZyYW1lUGVyaW9kSW5NaWxsaXMiLCJjbGVhbnVwRm4iLCJmcmFtZU51bWJlciIsInByZXZpb3VzRnJhbWVOdW1iZXIiLCJzdGFydFRpbWUiLCJtYXhGcmFtZUFyZyIsImxvb3AiLCJjYWxsIiwiY3VycmVudFRpbWUiLCJkZWxheUluTWlsbGlzIiwiZnJhbWVEZWx0YSIsInByZWRpY3RPdmVyc2hvb3RTdHV0dGVyIiwicGl4ZWxTYWZlT3B0aW9ucyIsImlzUGl4ZWxDaGFuZ2luZ09wdGlvbkxpc3QiLCJsYWJlbHMiLCJhdHRycyIsInNlcmllc05hbWVzRGljdGlvbmFyeSIsInNjYW5GbGF0T3B0aW9ucyIsIm9wdGlvbnMiLCJwcm9wZXJ0eSIsInNlcmllcyIsInBlclNlcmllcyIsIkNpcmNsZXMiLCJERUZBVUxUIiwiZyIsIm5hbWUiLCJjdHgiLCJjYW52YXN4IiwiY2FudmFzeSIsImNvbG9yIiwicmFkaXVzIiwiYmVnaW5QYXRoIiwiZmlsbFN0eWxlIiwiYXJjIiwiUEkiLCJmaWxsIiwiZGV0ZWN0TGluZURlbGltaXRlciIsImRhdGEiLCJjb2RlIiwiY2hhckF0IiwiaXNOb2RlQ29udGFpbmVkQnkiLCJjb250YWluZWUiLCJjb250YWluZXIiLCJjb250YWluZWVOb2RlIiwicGFyZW50Tm9kZSIsImJhc2UiLCJleHAiLCJSR0JBX1JFIiwicGFyc2VSR0JBIiwicmdiU3RyIiwiYml0cyIsImV4ZWMiLCJiIiwiYSIsInBhcnNlRmxvYXQiLCJ0b1JHQl8iLCJjb2xvclN0ciIsInJnYiIsImRpdiIsInN0eWxlIiwiYmFja2dyb3VuZENvbG9yIiwidmlzaWJpbGl0eSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImdldENvbXB1dGVkU3R5bGUiLCJyZW1vdmVDaGlsZCIsImlzQ2FudmFzU3VwcG9ydGVkIiwib3B0X2NhbnZhc0VsZW1lbnQiLCJwYXJzZUZsb2F0XyIsIm9wdF9saW5lX25vIiwib3B0X2xpbmUiLCJ0ZXN0IiwiTmFOIiwibXNnIiwiS01CX0xBQkVMUyIsIktNRzJfQklHX0xBQkVMUyIsIktNRzJfU01BTExfTEFCRUxTIiwibnVtYmVyVmFsdWVGb3JtYXR0ZXIiLCJvcHRzIiwic2lnRmlncyIsImRpZ2l0cyIsIm1heE51bWJlcldpZHRoIiwia21iIiwia21nMiIsImxhYmVsIiwia19sYWJlbHMiLCJtX2xhYmVscyIsIndhcm4iLCJhYnN4IiwibiIsImoiLCJ4X3BhcnRzIiwiU3RyaW5nIiwic3BsaXQiLCJOdW1iZXIiLCJ0b0ZpeGVkIiwibnVtYmVyQXhpc0xhYmVsRm9ybWF0dGVyIiwiZ3JhbnVsYXJpdHkiLCJTSE9SVF9NT05USF9OQU1FU18iLCJkYXRlQXhpc0xhYmVsRm9ybWF0dGVyIiwiaG91cnMiLCJtaW5zIiwic2VjcyIsIm1pbGxpcyIsIkRFQ0FEQUwiLCJNT05USExZIiwiREFJTFkiLCJTRUNPTkRMWSIsIk1JTlVURUxZIiwiZGF0ZVZhbHVlRm9ybWF0dGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBOzs7Ozs7QUFNQTs7Ozs7OztBQU9BO0FBQ0E7Ozs7QUFFQTs7QUFFTyxJQUFJQSxZQUFZLEVBQWhCO0FBQ0EsSUFBSUMsU0FBU0MsS0FBS0MsR0FBTCxDQUFTSCxTQUFULENBQWI7O0FBRVA7Ozs7O0FBS08sSUFBSUksUUFBUSxTQUFSQSxLQUFRLENBQVNDLENBQVQsRUFBWTtBQUM3QixTQUFPSCxLQUFLQyxHQUFMLENBQVNFLENBQVQsSUFBY0osTUFBckI7QUFDRCxDQUZNOztBQUlQOzs7Ozs7O0FBT08sSUFBSUssbUJBQW1CLFNBQW5CQSxnQkFBbUIsQ0FBU0MsRUFBVCxFQUFhQyxFQUFiLEVBQWlCQyxHQUFqQixFQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUlDLFFBQVFOLE1BQU1HLEVBQU4sQ0FBWjtBQUNBLE1BQUlJLFFBQVFQLE1BQU1JLEVBQU4sQ0FBWjtBQUNBLE1BQUlJLFdBQVdGLFFBQVNELE9BQU9FLFFBQVFELEtBQWYsQ0FBeEI7QUFDQSxNQUFJRyxRQUFRWCxLQUFLWSxHQUFMLENBQVNkLFNBQVQsRUFBb0JZLFFBQXBCLENBQVo7QUFDQSxTQUFPQyxLQUFQO0FBQ0QsQ0F4Qk07O0FBMEJQO0FBQ08sSUFBSUUsY0FBYyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQWxCO0FBQ1A7QUFDTyxJQUFJQyxjQUFjLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBbEI7QUFDUDtBQUNPLElBQUlDLGdCQUFnQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBcEI7O0FBRVA7QUFDQTtBQUNPLElB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QixFQUE4QixDQUE5QixDQUFQO0FBQ0QsS0FGTSxNQUVBO0FBQ0wsYUFBT3JNLFdBQVdtTSxLQUFYLEVBQWtCQyxJQUFsQixFQUF3QkMsSUFBeEIsRUFBOEJDLE1BQTlCLENBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRDtBQUNBOztBQUVBOzs7Ozs7O0FBT08sU0FBU00sa0JBQVQsQ0FBNEJyUSxDQUE1QixFQUErQnNPLElBQS9CLEVBQXFDO0FBQzFDLFNBQU94SyxZQUFZOUQsQ0FBWixFQUFlc08sS0FBSyxXQUFMLENBQWYsQ0FBUDtBQUNEIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMSBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIGZpbGUgY29udGFpbnMgdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCBieSBkeWdyYXBocy4gVGhlc2VcbiAqIGFyZSB0eXBpY2FsbHkgc3RhdGljIChpLmUuIG5vdCByZWxhdGVkIHRvIGFueSBwYXJ0aWN1bGFyIGR5Z3JhcGgpLiBFeGFtcGxlc1xuICogaW5jbHVkZSBkYXRlL3RpbWUgZm9ybWF0dGluZyBmdW5jdGlvbnMsIGJhc2ljIGFsZ29yaXRobXMgKGUuZy4gYmluYXJ5XG4gKiBzZWFyY2gpIGFuZCBnZW5lcmljIERPTS1tYW5pcHVsYXRpb24gZnVuY3Rpb25zLlxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UsIE5vZGU6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgKiBhcyBEeWdyYXBoVGlja2VycyBmcm9tICcuL2R5Z3JhcGgtdGlja2Vycyc7XG5cbmV4cG9ydCB2YXIgTE9HX1NDQUxFID0gMTA7XG5leHBvcnQgdmFyIExOX1RFTiA9IE1hdGgubG9nKExPR19TQ0FMRSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgbG9nMTAgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBNYXRoLmxvZyh4KSAvIExOX1RFTjtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByMFxuICogQHBhcmFtIHtudW1iZXJ9IHIxXG4gKiBAcGFyYW0ge251bWJlcn0gcGN0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgbG9nUmFuZ2VGcmFjdGlvbiA9IGZ1bmN0aW9uKHIwLCByMSwgcGN0KSB7XG4gIC8vIENvbXB1dGluZyB0aGUgaW52ZXJzZSBvZiB0b1BlcmNlbnRYQ29vcmQuIFRoZSBmdW5jdGlvbiB3YXMgYXJyaXZlZCBhdCB3aXRoXG4gIC8vIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gIC8vXG4gIC8vIE9yaWdpbmFsIGNhbGN1YXRpb246XG4gIC8vIHBjdCA9IChsb2coeCkgLSBsb2coeFJhbmdlWzBdKSkgLyAobG9nKHhSYW5nZVsxXSkgLSBsb2coeFJhbmdlWzBdKSkpO1xuICAvL1xuICAvLyBNdWx0aXBseSBib3RoIHNpZGVzIGJ5IHRoZSByaWdodC1zaWRlIGRlbm9taW5hdG9yLlxuICAvLyBwY3QgKiAobG9nKHhSYW5nZVsxXSAtIGxvZyh4UmFuZ2VbMF0pKSkgPSBsb2coeCkgLSBsb2coeFJhbmdlWzBdKVxuICAvL1xuICAvLyBhZGQgbG9nKHhSYW5nZVswXSkgdG8gYm90aCBzaWRlc1xuICAvLyBsb2coeFJhbmdlWzBdKSArIChwY3QgKiAobG9nKHhSYW5nZVsxXSkgLSBsb2coeFJhbmdlWzBdKSkgPSBsb2coeCk7XG4gIC8vXG4gIC8vIFN3YXAgYm90aCBzaWRlcyBvZiB0aGUgZXF1YXRpb24sXG4gIC8vIGxvZyh4KSA9IGxvZyh4UmFuZ2VbMF0pICsgKHBjdCAqIChsb2coeFJhbmdlWzFdKSAtIGxvZyh4UmFuZ2VbMF0pKVxuICAvL1xuICAvLyBVc2UgYm90aCBzaWRlcyBhcyB0aGUgZXhwb25lbnQgaW4gMTBeZXhwIGFuZCB3ZSdyZSBkb25lLlxuICAvLyB4ID0gMTAgXiAobG9nKHhSYW5nZVswXSkgKyAocGN0ICogKGxvZyh4UmFuZ2VbMV0pIC0gbG9nKHhSYW5nZVswXSkpKVxuXG4gIHZhciBsb2dyMCA9IGxvZzEwKHIwKTtcbiAgdmFyIGxvZ3IxID0gbG9nMTAocjEpO1xuICB2YXIgZXhwb25lbnQgPSBsb2dyMCArIChwY3QgKiAobG9ncjEgLSBsb2dyMCkpO1xuICB2YXIgdmFsdWUgPSBNYXRoLnBvdyhMT0dfU0NBTEUsIGV4cG9uZW50KTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqIEEgZG90dGVkIGxpbmUgc3Ryb2tlIHBhdHRlcm4uICovXG5leHBvcnQgdmFyIERPVFRFRF9MSU5FID0gWzIsIDJdO1xuLyoqIEEgZGFzaGVkIGxpbmUgc3Ryb2tlIHBhdHRlcm4uICovXG5leHBvcnQgdmFyIERBU0hFRF9MSU5FID0gWzcsIDNdO1xuLyoqIEEgZG90IGRhc2ggc3Ryb2tlIHBhdHRlcm4uICovXG5leHBvcnQgdmFyIERPVF9EQVNIX0xJTkUgPSBbNywgMiwgMiwgMl07XG5cbi8vIERpcmVjdGlvbnMgZm9yIHBhbm5pbmcgYW5kIHpvb21pbmcuIFVzZSBiaXQgb3BlcmF0aW9ucyB3aGVuIGNvbWJpbmVkXG4vLyB2YWx1ZXMgYXJlIHBvc3NpYmxlLlxuZXhwb3J0IHZhciBIT1JJWk9OVEFMID0gMTtcbmV4cG9ydCB2YXIgVkVSVElDQUwgPSAyO1xuXG4vKipcbiAqIFJldHVybiB0aGUgMmQgY29udGV4dCBmb3IgYSBkeWdyYXBoIGNhbnZhcy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBvbmx5IGV4cG9zZWQgZm9yIHRoZSBzYWtlIG9mIHJlcGxhY2luZyB0aGUgZnVuY3Rpb24gaW5cbiAqIGF1dG9tYXRlZCB0ZXN0cy5cbiAqXG4gKiBAcGFyYW0geyFIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gKiBAcmV0dXJuIHshQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IHZhciBnZXRDb250ZXh0ID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gIHJldHVybiAvKiogQHR5cGV7IUNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0qLyhjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpKTtcbn07XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGhhbmRsZXIuXG4gKiBAcGFyYW0geyFOb2RlfSBlbGVtIFRoZSBlbGVtZW50IHRvIGFkZCB0aGUgZXZlbnQgdG8uXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2Vtb3ZlJy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnQpOihib29sZWFufHVuZGVmaW5lZCl9IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsXG4gKiAgICAgb24gdGhlIGV2ZW50LiBUaGUgZnVuY3Rpb24gdGFrZXMgb25lIHBhcmFtZXRlcjogdGhlIGV2ZW50IG9iamVjdC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCB2YXIgYWRkRXZlbnQgPSBmdW5jdGlvbiBhZGRFdmVudChlbGVtLCB0eXBlLCBmbikge1xuICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGZhbHNlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXIuXG4gKiBAcGFyYW0geyFOb2RlfSBlbGVtIFRoZSBlbGVtZW50IHRvIHJlbW92ZSB0aGUgZXZlbnQgZnJvbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBldmVudCwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW1vdmUnLlxuICogQHBhcmFtIHtmdW5jdGlvbihFdmVudCk6KGJvb2xlYW58dW5kZWZpbmVkKX0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGxcbiAqICAgICBvbiB0aGUgZXZlbnQuIFRoZSBmdW5jdGlvbiB0YWtlcyBvbmUgcGFyYW1ldGVyOiB0aGUgZXZlbnQgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZWxlbSwgdHlwZSwgZm4pIHtcbiAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIENhbmNlbHMgZnVydGhlciBwcm9jZXNzaW5nIG9mIGFuIGV2ZW50LiBUaGlzIGlzIHVzZWZ1bCB0byBwcmV2ZW50IGRlZmF1bHRcbiAqIGJyb3dzZXIgYWN0aW9ucywgZS5nLiBoaWdobGlnaHRpbmcgdGV4dCBvbiBhIGRvdWJsZS1jbGljay5cbiAqIEJhc2VkIG9uIHRoZSBhcnRpY2xlIGF0XG4gKiBodHRwOi8vd3d3LnN3aXRjaG9udGhlY29kZS5jb20vdHV0b3JpYWxzL2phdmFzY3JpcHQtdHV0b3JpYWwtdGhlLXNjcm9sbC13aGVlbFxuICogQHBhcmFtIHshRXZlbnR9IGUgVGhlIGV2ZW50IHdob3NlIG5vcm1hbCBiZWhhdmlvciBzaG91bGQgYmUgY2FuY2VsZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FuY2VsRXZlbnQoZSkge1xuICBlID0gZSA/IGUgOiB3aW5kb3cuZXZlbnQ7XG4gIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICBlLmNhbmNlbCA9IHRydWU7XG4gIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGhzdiB2YWx1ZXMgdG8gYW4gcmdiKHIsZyxiKSBzdHJpbmcuIFRha2VuIGZyb20gTW9jaGlLaXQuQ29sb3IuIFRoaXNcbiAqIGlzIHVzZWQgdG8gZ2VuZXJhdGUgZGVmYXVsdCBzZXJpZXMgY29sb3JzIHdoaWNoIGFyZSBldmVubHkgc3BhY2VkIG9uIHRoZVxuICogY29sb3Igd2hlZWwuXG4gKiBAcGFyYW0geyBudW1iZXIgfSBodWUgUmFuZ2UgaXMgMC4wLTEuMC5cbiAqIEBwYXJhbSB7IG51bWJlciB9IHNhdHVyYXRpb24gUmFuZ2UgaXMgMC4wLTEuMC5cbiAqIEBwYXJhbSB7IG51bWJlciB9IHZhbHVlIFJhbmdlIGlzIDAuMC0xLjAuXG4gKiBAcmV0dXJuIHsgc3RyaW5nIH0gXCJyZ2IocixnLGIpXCIgd2hlcmUgciwgZyBhbmQgYiByYW5nZSBmcm9tIDAtMjU1LlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhzdlRvUkdCKGh1ZSwgc2F0dXJhdGlvbiwgdmFsdWUpIHtcbiAgdmFyIHJlZDtcbiAgdmFyIGdyZWVuO1xuICB2YXIgYmx1ZTtcbiAgaWYgKHNhdHVyYXRpb24gPT09IDApIHtcbiAgICByZWQgPSB2YWx1ZTtcbiAgICBncmVlbiA9IHZhbHVlO1xuICAgIGJsdWUgPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoaHVlICogNik7XG4gICAgdmFyIGYgPSAoaHVlICogNikgLSBpO1xuICAgIHZhciBwID0gdmFsdWUgKiAoMSAtIHNhdHVyYXRpb24pO1xuICAgIHZhciBxID0gdmFsdWUgKiAoMSAtIChzYXR1cmF0aW9uICogZikpO1xuICAgIHZhciB0ID0gdmFsdWUgKiAoMSAtIChzYXR1cmF0aW9uICogKDEgLSBmKSkpO1xuICAgIHN3aXRjaCAoaSkge1xuICAgICAgY2FzZSAxOiByZWQgPSBxOyBncmVlbiA9IHZhbHVlOyBibHVlID0gcDsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHJlZCA9IHA7IGdyZWVuID0gdmFsdWU7IGJsdWUgPSB0OyBicmVhaztcbiAgICAgIGNhc2UgMzogcmVkID0gcDsgZ3JlZW4gPSBxOyBibHVlID0gdmFsdWU7IGJyZWFrO1xuICAgICAgY2FzZSA0OiByZWQgPSB0OyBncmVlbiA9IHA7IGJsdWUgPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlIDU6IHJlZCA9IHZhbHVlOyBncmVlbiA9IHA7IGJsdWUgPSBxOyBicmVhaztcbiAgICAgIGNhc2UgNjogLy8gZmFsbCB0aHJvdWdoXG4gICAgICBjYXNlIDA6IHJlZCA9IHZhbHVlOyBncmVlbiA9IHQ7IGJsdWUgPSBwOyBicmVhaztcbiAgICB9XG4gIH1cbiAgcmVkID0gTWF0aC5mbG9vcigyNTUgKiByZWQgKyAwLjUpO1xuICBncmVlbiA9IE1hdGguZmxvb3IoMjU1ICogZ3JlZW4gKyAwLjUpO1xuICBibHVlID0gTWF0aC5mbG9vcigyNTUgKiBibHVlICsgMC41KTtcbiAgcmV0dXJuICdyZ2IoJyArIHJlZCArICcsJyArIGdyZWVuICsgJywnICsgYmx1ZSArICcpJztcbn07XG5cbi8qKlxuICogRmluZCB0aGUgY29vcmRpbmF0ZXMgb2YgYW4gb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSB0b3AgbGVmdCBvZiB0aGUgcGFnZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG9ialxuICogQHJldHVybiB7e3g6bnVtYmVyLHk6bnVtYmVyfX1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUG9zKG9iaikge1xuICB2YXIgcCA9IG9iai5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHcgPSB3aW5kb3csXG4gICAgICBkID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gIHJldHVybiB7XG4gICAgeDogcC5sZWZ0ICsgKHcucGFnZVhPZmZzZXQgfHwgZC5zY3JvbGxMZWZ0KSxcbiAgICB5OiBwLnRvcCAgKyAody5wYWdlWU9mZnNldCB8fCBkLnNjcm9sbFRvcClcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IGluIGEgY29vcmRpbmF0ZSBzeXN0ZW0gd2hlcmUgdGhlXG4gKiB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIHBhZ2UgKG5vdCB0aGUgd2luZG93KSBpcyAoMCwwKS5cbiAqIFRha2VuIGZyb20gTW9jaGlLaXQuU2lnbmFsXG4gKiBAcGFyYW0geyFFdmVudH0gZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZ2VYKGUpIHtcbiAgcmV0dXJuICghZS5wYWdlWCB8fCBlLnBhZ2VYIDwgMCkgPyAwIDogZS5wYWdlWDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgeS1jb29yZGluYXRlIG9mIHRoZSBldmVudCBpbiBhIGNvb3JkaW5hdGUgc3lzdGVtIHdoZXJlIHRoZVxuICogdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBwYWdlIChub3QgdGhlIHdpbmRvdykgaXMgKDAsMCkuXG4gKiBUYWtlbiBmcm9tIE1vY2hpS2l0LlNpZ25hbFxuICogQHBhcmFtIHshRXZlbnR9IGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWdlWShlKSB7XG4gIHJldHVybiAoIWUucGFnZVkgfHwgZS5wYWdlWSA8IDApID8gMCA6IGUucGFnZVk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHBhZ2UgdGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgdG8gcGl4ZWwgeC1jb29yZGluYXRlcyBvbiB0aGVcbiAqIGNhbnZhcyAoaS5lLiBET00gQ29vcmRzKS5cbiAqIEBwYXJhbSB7IUV2ZW50fSBlIERyYWcgZXZlbnQuXG4gKiBAcGFyYW0geyFEeWdyYXBoSW50ZXJhY3Rpb25Db250ZXh0fSBjb250ZXh0IEludGVyYWN0aW9uIGNvbnRleHQgb2JqZWN0LlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW1vdW50IGJ5IHdoaWNoIHRoZSBkcmFnIGhhcyBtb3ZlZCB0byB0aGUgcmlnaHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkcmFnR2V0WF8oZSwgY29udGV4dCkge1xuICByZXR1cm4gcGFnZVgoZSkgLSBjb250ZXh0LnB4O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBwYWdlIHRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IHRvIHBpeGVsIHktY29vcmRpbmF0ZXMgb24gdGhlXG4gKiBjYW52YXMgKGkuZS4gRE9NIENvb3JkcykuXG4gKiBAcGFyYW0geyFFdmVudH0gZSBEcmFnIGV2ZW50LlxuICogQHBhcmFtIHshRHlncmFwaEludGVyYWN0aW9uQ29udGV4dH0gY29udGV4dCBJbnRlcmFjdGlvbiBjb250ZXh0IG9iamVjdC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFtb3VudCBieSB3aGljaCB0aGUgZHJhZyBoYXMgbW92ZWQgZG93bi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRyYWdHZXRZXyhlLCBjb250ZXh0KSB7XG4gIHJldHVybiBwYWdlWShlKSAtIGNvbnRleHQucHk7XG59O1xuXG4vKipcbiAqIFRoaXMgcmV0dXJucyB0cnVlIHVubGVzcyB0aGUgcGFyYW1ldGVyIGlzIDAsIG51bGwsIHVuZGVmaW5lZCBvciBOYU4uXG4gKiBUT0RPKGRhbnZrKTogcmVuYW1lIHRoaXMgZnVuY3Rpb24gdG8gc29tZXRoaW5nIGxpa2UgJ2lzTm9uWmVyb05hbicuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIG51bWJlciB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIG51bWJlciBpcyB6ZXJvIG9yIE5hTi5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09LKHgpIHtcbiAgcmV0dXJuICEheCAmJiAhaXNOYU4oeCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7e3g6P251bWJlcix5Oj9udW1iZXIseXZhbDo/bnVtYmVyfX0gcCBUaGUgcG9pbnQgdG8gY29uc2lkZXIsIHZhbGlkXG4gKiAgICAgcG9pbnRzIGFyZSB7eCwgeX0gb2JqZWN0c1xuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2FsbG93TmFOWSBUcmVhdCBwb2ludCB3aXRoIHk9TmFOIGFzIHZhbGlkXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwb2ludCBoYXMgbnVtZXJpYyB4IGFuZCB5LlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRQb2ludChwLCBvcHRfYWxsb3dOYU5ZKSB7XG4gIGlmICghcCkgcmV0dXJuIGZhbHNlOyAgLy8gbnVsbCBvciB1bmRlZmluZWQgb2JqZWN0XG4gIGlmIChwLnl2YWwgPT09IG51bGwpIHJldHVybiBmYWxzZTsgIC8vIG1pc3NpbmcgcG9pbnRcbiAgaWYgKHAueCA9PT0gbnVsbCB8fCBwLnggPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICBpZiAocC55ID09PSBudWxsIHx8IHAueSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG4gIGlmIChpc05hTihwLngpIHx8ICghb3B0X2FsbG93TmFOWSAmJiBpc05hTihwLnkpKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogTnVtYmVyIGZvcm1hdHRpbmcgZnVuY3Rpb24gd2hpY2ggbWltaWNzIHRoZSBiZWhhdmlvciBvZiAlZyBpbiBwcmludGYsIGkuZS5cbiAqIGVpdGhlciBleHBvbmVudGlhbCBvciBmaXhlZCBmb3JtYXQgKHdpdGhvdXQgdHJhaWxpbmcgMHMpIGlzIHVzZWQgZGVwZW5kaW5nIG9uXG4gKiB0aGUgbGVuZ3RoIG9mIHRoZSBnZW5lcmF0ZWQgc3RyaW5nLiAgVGhlIGFkdmFudGFnZSBvZiB0aGlzIGZvcm1hdCBpcyB0aGF0XG4gKiB0aGVyZSBpcyBhIHByZWRpY3RhYmxlIHVwcGVyIGJvdW5kIG9uIHRoZSByZXN1bHRpbmcgc3RyaW5nIGxlbmd0aCxcbiAqIHNpZ25pZmljYW50IGZpZ3VyZXMgYXJlIG5vdCBkcm9wcGVkLCBhbmQgbm9ybWFsIG51bWJlcnMgYXJlIG5vdCBkaXNwbGF5ZWQgaW5cbiAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxuICpcbiAqIE5PVEU6IEphdmFTY3JpcHQncyBuYXRpdmUgdG9QcmVjaXNpb24oKSBpcyBOT1QgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciAlZy5cbiAqIEl0IGNyZWF0ZXMgc3RyaW5ncyB3aGljaCBhcmUgdG9vIGxvbmcgZm9yIGFic29sdXRlIHZhbHVlcyBiZXR3ZWVuIDEwXi00IGFuZFxuICogMTBeLTYsIGUuZy4gJzAuMDAwMDEnIGluc3RlYWQgb2YgJzFlLTUnLiBTZWUgdGVzdHMvbnVtYmVyLWZvcm1hdC5odG1sIGZvclxuICogb3V0cHV0IGV4YW1wbGVzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBudW1iZXIgdG8gZm9ybWF0XG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9wcmVjaXNpb24gVGhlIHByZWNpc2lvbiB0byB1c2UsIGRlZmF1bHQgMi5cbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgZm9ybWF0dGVkIGxpa2UgJWcgaW4gcHJpbnRmLiAgVGhlIG1heCBnZW5lcmF0ZWRcbiAqICAgICAgICAgICAgICAgICAgc3RyaW5nIGxlbmd0aCBzaG91bGQgYmUgcHJlY2lzaW9uICsgNiAoZS5nIDEuMTIzZSszMDApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxvYXRGb3JtYXQoeCwgb3B0X3ByZWNpc2lvbikge1xuICAvLyBBdm9pZCBpbnZhbGlkIHByZWNpc2lvbiB2YWx1ZXM7IFsxLCAyMV0gaXMgdGhlIHZhbGlkIHJhbmdlLlxuICB2YXIgcCA9IE1hdGgubWluKE1hdGgubWF4KDEsIG9wdF9wcmVjaXNpb24gfHwgMiksIDIxKTtcblxuICAvLyBUaGlzIGlzIGRlY2VwdGl2ZWx5IHNpbXBsZS4gIFRoZSBhY3R1YWwgYWxnb3JpdGhtIGNvbWVzIGZyb206XG4gIC8vXG4gIC8vIE1heCBhbGxvd2VkIGxlbmd0aCA9IHAgKyA0XG4gIC8vIHdoZXJlIDQgY29tZXMgZnJvbSAnZStuJyBhbmQgJy4nLlxuICAvL1xuICAvLyBMZW5ndGggb2YgZml4ZWQgZm9ybWF0ID0gMiArIHkgKyBwXG4gIC8vIHdoZXJlIDIgY29tZXMgZnJvbSAnMC4nIGFuZCB5ID0gIyBvZiBsZWFkaW5nIHplcm9lcy5cbiAgLy9cbiAgLy8gRXF1YXRpbmcgdGhlIHR3byBhbmQgc29sdmluZyBmb3IgeSB5aWVsZHMgeSA9IDIsIG9yIDAuMDB4eHh4IHdoaWNoIGlzXG4gIC8vIDEuMGUtMy5cbiAgLy9cbiAgLy8gU2luY2UgdGhlIGJlaGF2aW9yIG9mIHRvUHJlY2lzaW9uKCkgaXMgaWRlbnRpY2FsIGZvciBsYXJnZXIgbnVtYmVycywgd2VcbiAgLy8gZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCB0aGUgb3RoZXIgYm91bmQuXG4gIC8vXG4gIC8vIEZpbmFsbHksIHRoZSBhcmd1bWVudCBmb3IgdG9FeHBvbmVudGlhbCgpIGlzIHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgZGlnaXRzLFxuICAvLyBzbyB3ZSB0YWtlIG9mZiAxIGZvciB0aGUgdmFsdWUgYmVmb3JlIHRoZSAnLicuXG4gIHJldHVybiAoTWF0aC5hYnMoeCkgPCAxLjBlLTMgJiYgeCAhPT0gMC4wKSA/XG4gICAgICB4LnRvRXhwb25lbnRpYWwocCAtIDEpIDogeC50b1ByZWNpc2lvbihwKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgJzknIHRvICcwOScgKHVzZWZ1bCBmb3IgZGF0ZXMpXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHplcm9wYWQoeCkge1xuICBpZiAoeCA8IDEwKSByZXR1cm4gXCIwXCIgKyB4OyBlbHNlIHJldHVybiBcIlwiICsgeDtcbn07XG5cbi8qKlxuICogRGF0ZSBhY2Nlc3NvcnMgdG8gZ2V0IHRoZSBwYXJ0cyBvZiBhIGNhbGVuZGFyIGRhdGUgKHllYXIsIG1vbnRoLFxuICogZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCBhbmQgbWlsbGlzZWNvbmQpIGFjY29yZGluZyB0byBsb2NhbCB0aW1lLFxuICogYW5kIGZhY3RvcnkgbWV0aG9kIHRvIGNhbGwgdGhlIERhdGUgY29uc3RydWN0b3Igd2l0aCBhbiBhcnJheSBvZiBhcmd1bWVudHMuXG4gKi9cbmV4cG9ydCB2YXIgRGF0ZUFjY2Vzc29yc0xvY2FsID0ge1xuICBnZXRGdWxsWWVhcjogICAgIGQgPT4gZC5nZXRGdWxsWWVhcigpLFxuICBnZXRNb250aDogICAgICAgIGQgPT4gZC5nZXRNb250aCgpLFxuICBnZXREYXRlOiAgICAgICAgIGQgPT4gZC5nZXREYXRlKCksXG4gIGdldEhvdXJzOiAgICAgICAgZCA9PiBkLmdldEhvdXJzKCksXG4gIGdldE1pbnV0ZXM6ICAgICAgZCA9PiBkLmdldE1pbnV0ZXMoKSxcbiAgZ2V0U2Vjb25kczogICAgICBkID0+IGQuZ2V0U2Vjb25kcygpLFxuICBnZXRNaWxsaXNlY29uZHM6IGQgPT4gZC5nZXRNaWxsaXNlY29uZHMoKSxcbiAgZ2V0RGF5OiAgICAgICAgICBkID0+IGQuZ2V0RGF5KCksXG4gIG1ha2VEYXRlOiAgICAgICAgZnVuY3Rpb24oeSwgbSwgZCwgaGgsIG1tLCBzcywgbXMpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoeSwgbSwgZCwgaGgsIG1tLCBzcywgbXMpO1xuICB9XG59O1xuXG4vKipcbiAqIERhdGUgYWNjZXNzb3JzIHRvIGdldCB0aGUgcGFydHMgb2YgYSBjYWxlbmRhciBkYXRlICh5ZWFyLCBtb250aCxcbiAqIGRheSBvZiBtb250aCwgaG91ciwgbWludXRlLCBzZWNvbmQgYW5kIG1pbGxpc2Vjb25kKSBhY2NvcmRpbmcgdG8gVVRDIHRpbWUsXG4gKiBhbmQgZmFjdG9yeSBtZXRob2QgdG8gY2FsbCB0aGUgRGF0ZSBjb25zdHJ1Y3RvciB3aXRoIGFuIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAqL1xuZXhwb3J0IHZhciBEYXRlQWNjZXNzb3JzVVRDID0ge1xuICBnZXRGdWxsWWVhcjogICAgIGQgPT4gZC5nZXRVVENGdWxsWWVhcigpLFxuICBnZXRNb250aDogICAgICAgIGQgPT4gZC5nZXRVVENNb250aCgpLFxuICBnZXREYXRlOiAgICAgICAgIGQgPT4gZC5nZXRVVENEYXRlKCksXG4gIGdldEhvdXJzOiAgICAgICAgZCA9PiBkLmdldFVUQ0hvdXJzKCksXG4gIGdldE1pbnV0ZXM6ICAgICAgZCA9PiBkLmdldFVUQ01pbnV0ZXMoKSxcbiAgZ2V0U2Vjb25kczogICAgICBkID0+IGQuZ2V0VVRDU2Vjb25kcygpLFxuICBnZXRNaWxsaXNlY29uZHM6IGQgPT4gZC5nZXRVVENNaWxsaXNlY29uZHMoKSxcbiAgZ2V0RGF5OiAgICAgICAgICBkID0+IGQuZ2V0VVRDRGF5KCksXG4gIG1ha2VEYXRlOiAgICAgICAgZnVuY3Rpb24oeSwgbSwgZCwgaGgsIG1tLCBzcywgbXMpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeSwgbSwgZCwgaGgsIG1tLCBzcywgbXMpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgdmVyc2lvbiBvZiB0aGUgaG91cnMsIG1pbnV0ZXMgYW5kIHNlY29uZHMgcG9ydGlvbiBvZiBhIGRhdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gaGggVGhlIGhvdXJzIChmcm9tIDAtMjMpXG4gKiBAcGFyYW0ge251bWJlcn0gbW0gVGhlIG1pbnV0ZXMgKGZyb20gMC01OSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzcyBUaGUgc2Vjb25kcyAoZnJvbSAwLTU5KVxuICogQHJldHVybiB7c3RyaW5nfSBBIHRpbWUgb2YgdGhlIGZvcm0gXCJISDpNTVwiIG9yIFwiSEg6TU06U1NcIlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhtc1N0cmluZ18oaGgsIG1tLCBzcywgbXMpIHtcbiAgdmFyIHJldCA9IHplcm9wYWQoaGgpICsgXCI6XCIgKyB6ZXJvcGFkKG1tKTtcbiAgaWYgKHNzKSB7XG4gICAgcmV0ICs9IFwiOlwiICsgemVyb3BhZChzcyk7XG4gICAgaWYgKG1zKSB7XG4gICAgICB2YXIgc3RyID0gXCJcIiArIG1zO1xuICAgICAgcmV0ICs9IFwiLlwiICsgKCcwMDAnK3N0cikuc3Vic3RyaW5nKHN0ci5sZW5ndGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgSlMgZGF0ZSAobWlsbGlzIHNpbmNlIGVwb2NoKSB0byBhIGZvcm1hdHRlZCBzdHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaGUgSmF2YVNjcmlwdCB0aW1lIHZhbHVlIChtcyBzaW5jZSBlcG9jaClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXRjIFdoZXRoZXIgb3V0cHV0IFVUQyBvciBsb2NhbCB0aW1lXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgZGF0ZSBvZiBvbmUgb2YgdGhlc2UgZm9ybXM6XG4gKiAgICAgXCJZWVlZL01NL0REXCIsIFwiWVlZWS9NTS9ERCBISDpNTVwiIG9yIFwiWVlZWS9NTS9ERCBISDpNTTpTU1wiXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0ZVN0cmluZ18odGltZSwgdXRjKSB7XG4gIHZhciBhY2Nlc3NvcnMgPSB1dGMgPyBEYXRlQWNjZXNzb3JzVVRDIDogRGF0ZUFjY2Vzc29yc0xvY2FsO1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHRpbWUpO1xuICB2YXIgeSA9IGFjY2Vzc29ycy5nZXRGdWxsWWVhcihkYXRlKTtcbiAgdmFyIG0gPSBhY2Nlc3NvcnMuZ2V0TW9udGgoZGF0ZSk7XG4gIHZhciBkID0gYWNjZXNzb3JzLmdldERhdGUoZGF0ZSk7XG4gIHZhciBoaCA9IGFjY2Vzc29ycy5nZXRIb3VycyhkYXRlKTtcbiAgdmFyIG1tID0gYWNjZXNzb3JzLmdldE1pbnV0ZXMoZGF0ZSk7XG4gIHZhciBzcyA9IGFjY2Vzc29ycy5nZXRTZWNvbmRzKGRhdGUpO1xuICB2YXIgbXMgPSBhY2Nlc3NvcnMuZ2V0TWlsbGlzZWNvbmRzKGRhdGUpO1xuICAvLyBHZXQgYSB5ZWFyIHN0cmluZzpcbiAgdmFyIHllYXIgPSBcIlwiICsgeTtcbiAgLy8gR2V0IGEgMCBwYWRkZWQgbW9udGggc3RyaW5nXG4gIHZhciBtb250aCA9IHplcm9wYWQobSArIDEpOyAgLy9tb250aHMgYXJlIDAtb2Zmc2V0LCBzaWdoXG4gIC8vIEdldCBhIDAgcGFkZGVkIGRheSBzdHJpbmdcbiAgdmFyIGRheSA9IHplcm9wYWQoZCk7XG4gIHZhciBmcmFjID0gaGggKiAzNjAwICsgbW0gKiA2MCArIHNzICsgMWUtMyAqIG1zO1xuICB2YXIgcmV0ID0geWVhciArIFwiL1wiICsgbW9udGggKyBcIi9cIiArIGRheTtcbiAgaWYgKGZyYWMpIHtcbiAgICByZXQgKz0gXCIgXCIgKyBobXNTdHJpbmdfKGhoLCBtbSwgc3MsIG1zKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBSb3VuZCBhIG51bWJlciB0byB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBkaWdpdHMgcGFzdCB0aGUgZGVjaW1hbCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0byByb3VuZFxuICogQHBhcmFtIHtudW1iZXJ9IHBsYWNlcyBUaGUgbnVtYmVyIG9mIGRlY2ltYWxzIHRvIHdoaWNoIHRvIHJvdW5kXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByb3VuZGVkIG51bWJlclxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kXyhudW0sIHBsYWNlcykge1xuICB2YXIgc2hpZnQgPSBNYXRoLnBvdygxMCwgcGxhY2VzKTtcbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICogc2hpZnQpL3NoaWZ0O1xufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIG92ZXIgYW4gYXJyYXkuXG4gKiBDdXJyZW50bHkgZG9lcyBub3Qgd29yayB3aGVuIHZhbCBpcyBvdXRzaWRlIHRoZSByYW5nZSBvZiBhcnJ5J3MgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCB0aGUgdmFsdWUgdG8gc2VhcmNoIGZvclxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyeSBpcyB0aGUgdmFsdWUgb3ZlciB3aGljaCB0byBzZWFyY2hcbiAqIEBwYXJhbSB7bnVtYmVyfSBhYnMgSWYgYWJzID4gMCwgZmluZCB0aGUgbG93ZXN0IGVudHJ5IGdyZWF0ZXIgdGhhbiB2YWxcbiAqICAgICBJZiBhYnMgPCAwLCBmaW5kIHRoZSBoaWdoZXN0IGVudHJ5IGxlc3MgdGhhbiB2YWwuXG4gKiAgICAgSWYgYWJzID09IDAsIGZpbmQgdGhlIGVudHJ5IHRoYXQgZXF1YWxzIHZhbC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gbG93IFRoZSBmaXJzdCBpbmRleCBpbiBhcnJ5IHRvIGNvbnNpZGVyIChvcHRpb25hbClcbiAqIEBwYXJhbSB7bnVtYmVyPX0gaGlnaCBUaGUgbGFzdCBpbmRleCBpbiBhcnJ5IHRvIGNvbnNpZGVyIChvcHRpb25hbClcbiAqIEByZXR1cm4ge251bWJlcn0gSW5kZXggb2YgdGhlIGVsZW1lbnQsIG9yIC0xIGlmIGl0IGlzbid0IGZvdW5kLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaCh2YWwsIGFycnksIGFicywgbG93LCBoaWdoKSB7XG4gIGlmIChsb3cgPT09IG51bGwgfHwgbG93ID09PSB1bmRlZmluZWQgfHxcbiAgICAgIGhpZ2ggPT09IG51bGwgfHwgaGlnaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbG93ID0gMDtcbiAgICBoaWdoID0gYXJyeS5sZW5ndGggLSAxO1xuICB9XG4gIGlmIChsb3cgPiBoaWdoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmIChhYnMgPT09IG51bGwgfHwgYWJzID09PSB1bmRlZmluZWQpIHtcbiAgICBhYnMgPSAwO1xuICB9XG4gIHZhciB2YWxpZEluZGV4ID0gZnVuY3Rpb24oaWR4KSB7XG4gICAgcmV0dXJuIGlkeCA+PSAwICYmIGlkeCA8IGFycnkubGVuZ3RoO1xuICB9O1xuICB2YXIgbWlkID0gcGFyc2VJbnQoKGxvdyArIGhpZ2gpIC8gMiwgMTApO1xuICB2YXIgZWxlbWVudCA9IGFycnlbbWlkXTtcbiAgdmFyIGlkeDtcbiAgaWYgKGVsZW1lbnQgPT0gdmFsKSB7XG4gICAgcmV0dXJuIG1pZDtcbiAgfSBlbHNlIGlmIChlbGVtZW50ID4gdmFsKSB7XG4gICAgaWYgKGFicyA+IDApIHtcbiAgICAgIC8vIEFjY2VwdCBpZiBlbGVtZW50ID4gdmFsLCBidXQgYWxzbyBpZiBwcmlvciBlbGVtZW50IDwgdmFsLlxuICAgICAgaWR4ID0gbWlkIC0gMTtcbiAgICAgIGlmICh2YWxpZEluZGV4KGlkeCkgJiYgYXJyeVtpZHhdIDwgdmFsKSB7XG4gICAgICAgIHJldHVybiBtaWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiaW5hcnlTZWFyY2godmFsLCBhcnJ5LCBhYnMsIGxvdywgbWlkIC0gMSk7XG4gIH0gZWxzZSBpZiAoZWxlbWVudCA8IHZhbCkge1xuICAgIGlmIChhYnMgPCAwKSB7XG4gICAgICAvLyBBY2NlcHQgaWYgZWxlbWVudCA8IHZhbCwgYnV0IGFsc28gaWYgcHJpb3IgZWxlbWVudCA+IHZhbC5cbiAgICAgIGlkeCA9IG1pZCArIDE7XG4gICAgICBpZiAodmFsaWRJbmRleChpZHgpICYmIGFycnlbaWR4XSA+IHZhbCkge1xuICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmluYXJ5U2VhcmNoKHZhbCwgYXJyeSwgYWJzLCBtaWQgKyAxLCBoaWdoKTtcbiAgfVxuICByZXR1cm4gLTE7ICAvLyBjYW4ndCBhY3R1YWxseSBoYXBwZW4sIGJ1dCBtYWtlcyBjbG9zdXJlIGNvbXBpbGVyIGhhcHB5XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIGRhdGUsIHJldHVybmluZyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaC4gVGhpcyBjYW4gYmVcbiAqIHBhc3NlZCBpbiBhcyBhbiB4VmFsdWVQYXJzZXIgaW4gdGhlIER5Z3JhcGggY29uc3RydWN0b3IuXG4gKiBUT0RPKGRhbnZrKTogZW51bWVyYXRlIGZvcm1hdHMgdGhhdCB0aGlzIHVuZGVyc3RhbmRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlU3RyIEEgZGF0ZSBpbiBhIHZhcmlldHkgb2YgcG9zc2libGUgc3RyaW5nIGZvcm1hdHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRlUGFyc2VyKGRhdGVTdHIpIHtcbiAgdmFyIGRhdGVTdHJTbGFzaGVkO1xuICB2YXIgZDtcblxuICAvLyBMZXQgdGhlIHN5c3RlbSB0cnkgdGhlIGZvcm1hdCBmaXJzdCwgd2l0aCBvbmUgY2F2ZWF0OlxuICAvLyBZWVlZLU1NLUREWyBISDpNTTpTU10gaXMgaW50ZXJwcmV0ZWQgYXMgVVRDIGJ5IGEgdmFyaWV0eSBvZiBicm93c2Vycy5cbiAgLy8gZHlncmFwaHMgZGlzcGxheXMgZGF0ZXMgaW4gbG9jYWwgdGltZSwgc28gdGhpcyB3aWxsIHJlc3VsdCBpbiBzdXJwcmlzaW5nXG4gIC8vIGluY29uc2lzdGVuY2llcy4gQnV0IGlmIHlvdSBzcGVjaWZ5IFwiVFwiIG9yIFwiWlwiIChpLmUuIFlZWVktTU0tRERUSEg6TU06U1MpLFxuICAvLyB0aGVuIHlvdSBwcm9iYWJseSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLCBzbyB3ZSdsbCBsZXQgeW91IGdvIGFoZWFkLlxuICAvLyBJc3N1ZTogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2R5Z3JhcGhzL2lzc3Vlcy9kZXRhaWw/aWQ9MjU1XG4gIGlmIChkYXRlU3RyLnNlYXJjaChcIi1cIikgPT0gLTEgfHxcbiAgICAgIGRhdGVTdHIuc2VhcmNoKFwiVFwiKSAhPSAtMSB8fCBkYXRlU3RyLnNlYXJjaChcIlpcIikgIT0gLTEpIHtcbiAgICBkID0gZGF0ZVN0clRvTWlsbGlzKGRhdGVTdHIpO1xuICAgIGlmIChkICYmICFpc05hTihkKSkgcmV0dXJuIGQ7XG4gIH1cblxuICBpZiAoZGF0ZVN0ci5zZWFyY2goXCItXCIpICE9IC0xKSB7ICAvLyBlLmcuICcyMDA5LTctMTInIG9yICcyMDA5LTA3LTEyJ1xuICAgIGRhdGVTdHJTbGFzaGVkID0gZGF0ZVN0ci5yZXBsYWNlKFwiLVwiLCBcIi9cIiwgXCJnXCIpO1xuICAgIHdoaWxlIChkYXRlU3RyU2xhc2hlZC5zZWFyY2goXCItXCIpICE9IC0xKSB7XG4gICAgICBkYXRlU3RyU2xhc2hlZCA9IGRhdGVTdHJTbGFzaGVkLnJlcGxhY2UoXCItXCIsIFwiL1wiKTtcbiAgICB9XG4gICAgZCA9IGRhdGVTdHJUb01pbGxpcyhkYXRlU3RyU2xhc2hlZCk7XG4gIH0gZWxzZSBpZiAoZGF0ZVN0ci5sZW5ndGggPT0gOCkgeyAgLy8gZS5nLiAnMjAwOTA3MTInXG4gICAgLy8gVE9ETyhkYW52ayk6IHJlbW92ZSBzdXBwb3J0IGZvciB0aGlzIGZvcm1hdC4gSXQncyBjb25mdXNpbmcuXG4gICAgZGF0ZVN0clNsYXNoZWQgPSBkYXRlU3RyLnN1YnN0cigwLDQpICsgXCIvXCIgKyBkYXRlU3RyLnN1YnN0cig0LDIpICsgXCIvXCIgK1xuICAgICAgICBkYXRlU3RyLnN1YnN0cig2LDIpO1xuICAgIGQgPSBkYXRlU3RyVG9NaWxsaXMoZGF0ZVN0clNsYXNoZWQpO1xuICB9IGVsc2Uge1xuICAgIC8vIEFueSBmb3JtYXQgdGhhdCBEYXRlLnBhcnNlIHdpbGwgYWNjZXB0LCBlLmcuIFwiMjAwOS8wNy8xMlwiIG9yXG4gICAgLy8gXCIyMDA5LzA3LzEyIDEyOjM0OjU2XCJcbiAgICBkID0gZGF0ZVN0clRvTWlsbGlzKGRhdGVTdHIpO1xuICB9XG5cbiAgaWYgKCFkIHx8IGlzTmFOKGQpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkNvdWxkbid0IHBhcnNlIFwiICsgZGF0ZVN0ciArIFwiIGFzIGEgZGF0ZVwiKTtcbiAgfVxuICByZXR1cm4gZDtcbn07XG5cbi8qKlxuICogVGhpcyBpcyBpZGVudGljYWwgdG8gSmF2YVNjcmlwdCdzIGJ1aWx0LWluIERhdGUucGFyc2UoKSBtZXRob2QsIGV4Y2VwdCB0aGF0XG4gKiBpdCBkb2Vzbid0IGdldCByZXBsYWNlZCB3aXRoIGFuIGluY29tcGF0aWJsZSBtZXRob2QgYnkgYWdncmVzc2l2ZSBKU1xuICogbGlicmFyaWVzIGxpa2UgTW9vVG9vbHMgb3IgSm9vbWxhLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgZGF0ZSBzdHJpbmcsIGUuZy4gXCIyMDExLzA1LzA2XCJcbiAqIEByZXR1cm4ge251bWJlcn0gbWlsbGlzIHNpbmNlIGVwb2NoXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0ZVN0clRvTWlsbGlzKHN0cikge1xuICByZXR1cm4gbmV3IERhdGUoc3RyKS5nZXRUaW1lKCk7XG59O1xuXG4vLyBUaGVzZSBmdW5jdGlvbnMgYXJlIGFsbCBiYXNlZCBvbiBNb2NoaUtpdC5cbi8qKlxuICogQ29waWVzIGFsbCB0aGUgcHJvcGVydGllcyBmcm9tIG8gdG8gc2VsZi5cbiAqXG4gKiBAcGFyYW0geyFPYmplY3R9IHNlbGZcbiAqIEBwYXJhbSB7IU9iamVjdH0gb1xuICogQHJldHVybiB7IU9iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZShzZWxmLCBvKSB7XG4gIGlmICh0eXBlb2YobykgIT0gJ3VuZGVmaW5lZCcgJiYgbyAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIGsgaW4gbykge1xuICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgc2VsZltrXSA9IG9ba107XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWxmO1xufTtcblxuLyoqXG4gKiBDb3BpZXMgYWxsIHRoZSBwcm9wZXJ0aWVzIGZyb20gbyB0byBzZWxmLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gc2VsZlxuICogQHBhcmFtIHshT2JqZWN0fSBvXG4gKiBAcmV0dXJuIHshT2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZURlZXAoc2VsZiwgbykge1xuICAvLyBUYWtlbiBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzg0Mjg2L2phdmFzY3JpcHQtaXNkb20taG93LWRvLXlvdS1jaGVjay1pZi1hLWphdmFzY3JpcHQtb2JqZWN0LWlzLWEtZG9tLW9iamVjdFxuICBmdW5jdGlvbiBpc05vZGUobykge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgTm9kZSA9PT0gXCJvYmplY3RcIiA/IG8gaW5zdGFuY2VvZiBOb2RlIDpcbiAgICAgIHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvLm5vZGVUeXBlID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBvLm5vZGVOYW1lPT09XCJzdHJpbmdcIlxuICAgICk7XG4gIH1cblxuICBpZiAodHlwZW9mKG8pICE9ICd1bmRlZmluZWQnICYmIG8gIT09IG51bGwpIHtcbiAgICBmb3IgKHZhciBrIGluIG8pIHtcbiAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgIGlmIChvW2tdID09PSBudWxsKSB7XG4gICAgICAgICAgc2VsZltrXSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUxpa2Uob1trXSkpIHtcbiAgICAgICAgICBzZWxmW2tdID0gb1trXS5zbGljZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShvW2tdKSkge1xuICAgICAgICAgIC8vIERPTSBvYmplY3RzIGFyZSBzaGFsbG93bHktY29waWVkLlxuICAgICAgICAgIHNlbGZba10gPSBvW2tdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihvW2tdKSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmICh0eXBlb2Yoc2VsZltrXSkgIT0gJ29iamVjdCcgfHwgc2VsZltrXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc2VsZltrXSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVEZWVwKHNlbGZba10sIG9ba10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGZba10gPSBvW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWxmO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG9cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheUxpa2Uobykge1xuICB2YXIgdHlwID0gdHlwZW9mKG8pO1xuICBpZiAoXG4gICAgICAodHlwICE9ICdvYmplY3QnICYmICEodHlwID09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mKG8uaXRlbSkgPT0gJ2Z1bmN0aW9uJykpIHx8XG4gICAgICBvID09PSBudWxsIHx8XG4gICAgICB0eXBlb2Yoby5sZW5ndGgpICE9ICdudW1iZXInIHx8XG4gICAgICBvLm5vZGVUeXBlID09PSAzXG4gICAgICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlTGlrZShvKSB7XG4gIGlmICh0eXBlb2YobykgIT0gXCJvYmplY3RcIiB8fCBvID09PSBudWxsIHx8XG4gICAgICB0eXBlb2Yoby5nZXRUaW1lKSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBOb3RlOiB0aGlzIG9ubHkgc2VlbXMgdG8gd29yayBmb3IgYXJyYXlzLlxuICogQHBhcmFtIHshQXJyYXl9IG9cbiAqIEByZXR1cm4geyFBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShvKSB7XG4gIC8vIFRPRE8oZGFudmspOiBmaWd1cmUgb3V0IGhvdyBNb2NoaUtpdCdzIHZlcnNpb24gd29ya3NcbiAgdmFyIHIgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9baV0pKSB7XG4gICAgICByLnB1c2goY2xvbmUob1tpXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByLnB1c2gob1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgY2FudmFzIGVsZW1lbnQuXG4gKlxuICogQHJldHVybiB7IUhUTUxDYW52YXNFbGVtZW50fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcygpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250ZXh0J3MgcGl4ZWwgcmF0aW8sIHdoaWNoIGlzIHRoZSByYXRpbyBiZXR3ZWVuIHRoZSBkZXZpY2VcbiAqIHBpeGVsIHJhdGlvIGFuZCB0aGUgYmFja2luZyBzdG9yZSByYXRpby4gVHlwaWNhbGx5IHRoaXMgaXMgMSBmb3IgY29udmVudGlvbmFsXG4gKiBkaXNwbGF5cywgYW5kID4gMSBmb3IgSGlEUEkgZGlzcGxheXMgKHN1Y2ggYXMgdGhlIFJldGluYSBNQlApLlxuICogU2VlIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2NhbnZhcy9oaWRwaS8gZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAcGFyYW0geyFDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgVGhlIGNhbnZhcydzIDJkIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByYXRpbyBvZiB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvIGFuZCB0aGUgYmFja2luZyBzdG9yZVxuICogcmF0aW8gZm9yIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRleHRQaXhlbFJhdGlvKGNvbnRleHQpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIHZhciBiYWNraW5nU3RvcmVSYXRpbyA9IGNvbnRleHQud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuICAgIGlmIChkZXZpY2VQaXhlbFJhdGlvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0IGxlYXN0IGRldmljZVBpeGVsUmF0aW8gbXVzdCBiZSBkZWZpbmVkIGZvciB0aGlzIHJhdGlvIHRvIG1ha2Ugc2Vuc2UuXG4gICAgICAvLyBXZSBkZWZhdWx0IGJhY2tpbmdTdG9yZVJhdGlvIHRvIDE6IHRoaXMgZG9lcyBub3QgZXhpc3Qgb24gc29tZSBicm93c2Vyc1xuICAgICAgLy8gKGkuZS4gZGVza3RvcCBDaHJvbWUpLlxuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn07XG5cbi8qKlxuICogVE9ETyhkYW52ayk6IHVzZSBAdGVtcGxhdGUgaGVyZSB3aGVuIGl0J3MgYmV0dGVyIHN1cHBvcnRlZCBmb3IgY2xhc3Nlcy5cbiAqIEBwYXJhbSB7IUFycmF5fSBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCFBcnJheSw/KTpib29sZWFuPX0gcHJlZGljYXRlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEl0ZXJhdG9yKGFycmF5LCBzdGFydCwgbGVuZ3RoLCBwcmVkaWNhdGUpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBsZW5ndGggPSBsZW5ndGggfHwgYXJyYXkubGVuZ3RoO1xuICB0aGlzLmhhc05leHQgPSB0cnVlOyAvLyBVc2UgdG8gaWRlbnRpZnkgaWYgdGhlcmUncyBhbm90aGVyIGVsZW1lbnQuXG4gIHRoaXMucGVlayA9IG51bGw7IC8vIFVzZSBmb3IgbG9vay1haGVhZFxuICB0aGlzLnN0YXJ0XyA9IHN0YXJ0O1xuICB0aGlzLmFycmF5XyA9IGFycmF5O1xuICB0aGlzLnByZWRpY2F0ZV8gPSBwcmVkaWNhdGU7XG4gIHRoaXMuZW5kXyA9IE1hdGgubWluKGFycmF5Lmxlbmd0aCwgc3RhcnQgKyBsZW5ndGgpO1xuICB0aGlzLm5leHRJZHhfID0gc3RhcnQgLSAxOyAvLyB1c2UgLTEgc28gaW5pdGlhbCBhZHZhbmNlIHdvcmtzLlxuICB0aGlzLm5leHQoKTsgLy8gaWdub3JpbmcgcmVzdWx0LlxufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5oYXNOZXh0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG9iaiA9IHRoaXMucGVlaztcblxuICB2YXIgbmV4dElkeCA9IHRoaXMubmV4dElkeF8gKyAxO1xuICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgd2hpbGUgKG5leHRJZHggPCB0aGlzLmVuZF8pIHtcbiAgICBpZiAoIXRoaXMucHJlZGljYXRlXyB8fCB0aGlzLnByZWRpY2F0ZV8odGhpcy5hcnJheV8sIG5leHRJZHgpKSB7XG4gICAgICB0aGlzLnBlZWsgPSB0aGlzLmFycmF5X1tuZXh0SWR4XTtcbiAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBuZXh0SWR4Kys7XG4gIH1cbiAgdGhpcy5uZXh0SWR4XyA9IG5leHRJZHg7XG4gIGlmICghZm91bmQpIHtcbiAgICB0aGlzLmhhc05leHQgPSBmYWxzZTtcbiAgICB0aGlzLnBlZWsgPSBudWxsO1xuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgaXRlcmF0b3Igb3ZlciBhcnJheSwgYmV0d2VlbiBpbmRleGVzIHN0YXJ0IGFuZFxuICogc3RhcnQgKyBsZW5ndGgsIGFuZCBvbmx5IHJldHVybnMgZW50cmllcyB0aGF0IHBhc3MgdGhlIGFjY2VwdCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7IUFycmF5fSBhcnJheSB0aGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IHRoZSBmaXJzdCBpbmRleCB0byBpdGVyYXRlIG92ZXIsIDAgaWYgYWJzZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiAgICAgVGhpcywgYWxvbmcgd2l0aCBzdGFydCwgZGVmaW5lcyBhIHNsaWNlIG9mIHRoZSBhcnJheSwgYW5kIHNvIGxlbmd0aFxuICogICAgIGRvZXNuJ3QgaW1wbHkgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaXRlcmF0b3Igd2hlbiBhY2NlcHQgZG9lc24ndFxuICogICAgIGFsd2F5cyBhY2NlcHQgYWxsIHZhbHVlcy4gYXJyYXkubGVuZ3RoIHdoZW4gYWJzZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbig/KTpib29sZWFuPX0gb3B0X3ByZWRpY2F0ZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXNcbiAqICAgICBwYXJhbWV0ZXJzIGFycmF5IGFuZCBpZHgsIHdoaWNoIHJldHVybnMgdHJ1ZSB3aGVuIHRoZSBlbGVtZW50IHNob3VsZCBiZVxuICogICAgIHJldHVybmVkLiAgSWYgb21pdHRlZCwgYWxsIGVsZW1lbnRzIGFyZSBhY2NlcHRlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJdGVyYXRvcihhcnJheSwgc3RhcnQsIGxlbmd0aCwgb3B0X3ByZWRpY2F0ZSkge1xuICByZXR1cm4gbmV3IEl0ZXJhdG9yKGFycmF5LCBzdGFydCwgbGVuZ3RoLCBvcHRfcHJlZGljYXRlKTtcbn07XG5cbi8vIFNoaW0gbGF5ZXIgd2l0aCBzZXRUaW1lb3V0IGZhbGxiYWNrLlxuLy8gRnJvbTogaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbi8vIFNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgd2luZG93IGNvbnRleHQ6XG4vLyAgIER5Z3JhcGgucmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24oKSB7fSlcbmV4cG9ydCB2YXIgcmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICAgfHxcbiAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICB8fFxuICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgfHxcbiAgICAgICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgIHx8XG4gICAgICAgICAgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgICAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gYXQgbW9zdCBtYXhGcmFtZXMgdGltZXMgYXQgYW4gYXR0ZW1wdGVkIGludGVydmFsIG9mXG4gKiBmcmFtZVBlcmlvZEluTWlsbGlzLCB0aGVuIGNhbGwgYSBjbGVhbnVwIGZ1bmN0aW9uIG9uY2UuIHJlcGVhdEZuIGlzIGNhbGxlZFxuICogb25jZSBpbW1lZGlhdGVseSwgdGhlbiBhdCBtb3N0IChtYXhGcmFtZXMgLSAxKSB0aW1lcyBhc3luY2hyb25vdXNseS4gSWZcbiAqIG1heEZyYW1lcz09MSwgdGhlbiBjbGVhbnVwX2ZuKCkgaXMgYWxzbyBjYWxsZWQgc3luY2hyb25vdXNseS4gIFRoaXMgZnVuY3Rpb25cbiAqIGlzIHVzZWQgdG8gc2VxdWVuY2UgYW5pbWF0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpfSByZXBlYXRGbiBDYWxsZWQgcmVwZWF0ZWRseSAtLSB0YWtlcyB0aGUgZnJhbWVcbiAqICAgICBudW1iZXIgKGZyb20gMCB0byBtYXhGcmFtZXMtMSkgYXMgYW4gYXJndW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RnJhbWVzIFRoZSBtYXggbnVtYmVyIG9mIHRpbWVzIHRvIGNhbGwgcmVwZWF0Rm5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcmFtZVBlcmlvZEluTWlsbGlzIE1heCByZXF1ZXN0ZWQgdGltZSBiZXR3ZWVuIGZyYW1lcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2xlYW51cEZuIEEgZnVuY3Rpb24gdG8gY2FsbCBhZnRlciBhbGwgcmVwZWF0Rm4gY2FsbHMuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwZWF0QW5kQ2xlYW51cChyZXBlYXRGbiwgbWF4RnJhbWVzLCBmcmFtZVBlcmlvZEluTWlsbGlzLFxuICAgIGNsZWFudXBGbikge1xuICB2YXIgZnJhbWVOdW1iZXIgPSAwO1xuICB2YXIgcHJldmlvdXNGcmFtZU51bWJlcjtcbiAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICByZXBlYXRGbihmcmFtZU51bWJlcik7XG4gIGlmIChtYXhGcmFtZXMgPT0gMSkge1xuICAgIGNsZWFudXBGbigpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF4RnJhbWVBcmcgPSBtYXhGcmFtZXMgLSAxO1xuXG4gIChmdW5jdGlvbiBsb29wKCkge1xuICAgIGlmIChmcmFtZU51bWJlciA+PSBtYXhGcmFtZXMpIHJldHVybjtcbiAgICByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbigpIHtcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBmcmFtZSB0byBkcmF3IGJhc2VkIG9uIHRoZSBkZWxheSBzbyBmYXIuICBXaWxsIHNraXBcbiAgICAgIC8vIGZyYW1lcyBpZiBuZWNlc3NhcnkuXG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHZhciBkZWxheUluTWlsbGlzID0gY3VycmVudFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBwcmV2aW91c0ZyYW1lTnVtYmVyID0gZnJhbWVOdW1iZXI7XG4gICAgICBmcmFtZU51bWJlciA9IE1hdGguZmxvb3IoZGVsYXlJbk1pbGxpcyAvIGZyYW1lUGVyaW9kSW5NaWxsaXMpO1xuICAgICAgdmFyIGZyYW1lRGVsdGEgPSBmcmFtZU51bWJlciAtIHByZXZpb3VzRnJhbWVOdW1iZXI7XG4gICAgICAvLyBJZiB3ZSBwcmVkaWN0IHRoYXQgdGhlIHN1YnNlcXVlbnQgcmVwZWF0Rm4gY2FsbCB3aWxsIG92ZXJzaG9vdCBvdXJcbiAgICAgIC8vIHRvdGFsIGZyYW1lIHRhcmdldCwgc28gb3VyIGxhc3QgY2FsbCB3aWxsIGNhdXNlIGEgc3R1dHRlciwgdGhlbiBqdW1wIHRvXG4gICAgICAvLyB0aGUgbGFzdCBjYWxsIGltbWVkaWF0ZWx5LiAgSWYgd2UncmUgZ29pbmcgdG8gY2F1c2UgYSBzdHV0dGVyLCBiZXR0ZXJcbiAgICAgIC8vIHRvIGRvIGl0IGZhc3RlciB0aGFuIHNsb3dlci5cbiAgICAgIHZhciBwcmVkaWN0T3ZlcnNob290U3R1dHRlciA9IChmcmFtZU51bWJlciArIGZyYW1lRGVsdGEpID4gbWF4RnJhbWVBcmc7XG4gICAgICBpZiAocHJlZGljdE92ZXJzaG9vdFN0dXR0ZXIgfHwgKGZyYW1lTnVtYmVyID49IG1heEZyYW1lQXJnKSkge1xuICAgICAgICByZXBlYXRGbihtYXhGcmFtZUFyZyk7ICAvLyBFbnN1cmUgZmluYWwgY2FsbCB3aXRoIG1heEZyYW1lQXJnLlxuICAgICAgICBjbGVhbnVwRm4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmcmFtZURlbHRhICE9PSAwKSB7ICAvLyBEb24ndCBjYWxsIHJlcGVhdEZuIHdpdGggZHVwbGljYXRlIGZyYW1lcy5cbiAgICAgICAgICByZXBlYXRGbihmcmFtZU51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgbG9vcCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSgpO1xufTtcblxuLy8gQSB3aGl0ZWxpc3Qgb2Ygb3B0aW9ucyB0aGF0IGRvIG5vdCBjaGFuZ2UgcGl4ZWwgcG9zaXRpb25zLlxudmFyIHBpeGVsU2FmZU9wdGlvbnMgPSB7XG4gICdhbm5vdGF0aW9uQ2xpY2tIYW5kbGVyJzogdHJ1ZSxcbiAgJ2Fubm90YXRpb25EYmxDbGlja0hhbmRsZXInOiB0cnVlLFxuICAnYW5ub3RhdGlvbk1vdXNlT3V0SGFuZGxlcic6IHRydWUsXG4gICdhbm5vdGF0aW9uTW91c2VPdmVySGFuZGxlcic6IHRydWUsXG4gICdheGlzTGluZUNvbG9yJzogdHJ1ZSxcbiAgJ2F4aXNMaW5lV2lkdGgnOiB0cnVlLFxuICAnY2xpY2tDYWxsYmFjayc6IHRydWUsXG4gICdkcmF3Q2FsbGJhY2snOiB0cnVlLFxuICAnZHJhd0hpZ2hsaWdodFBvaW50Q2FsbGJhY2snOiB0cnVlLFxuICAnZHJhd1BvaW50cyc6IHRydWUsXG4gICdkcmF3UG9pbnRDYWxsYmFjayc6IHRydWUsXG4gICdkcmF3R3JpZCc6IHRydWUsXG4gICdmaWxsQWxwaGEnOiB0cnVlLFxuICAnZ3JpZExpbmVDb2xvcic6IHRydWUsXG4gICdncmlkTGluZVdpZHRoJzogdHJ1ZSxcbiAgJ2hpZGVPdmVybGF5T25Nb3VzZU91dCc6IHRydWUsXG4gICdoaWdobGlnaHRDYWxsYmFjayc6IHRydWUsXG4gICdoaWdobGlnaHRDaXJjbGVTaXplJzogdHJ1ZSxcbiAgJ2ludGVyYWN0aW9uTW9kZWwnOiB0cnVlLFxuICAnbGFiZWxzRGl2JzogdHJ1ZSxcbiAgJ2xhYmVsc0tNQic6IHRydWUsXG4gICdsYWJlbHNLTUcyJzogdHJ1ZSxcbiAgJ2xhYmVsc1NlcGFyYXRlTGluZXMnOiB0cnVlLFxuICAnbGFiZWxzU2hvd1plcm9WYWx1ZXMnOiB0cnVlLFxuICAnbGVnZW5kJzogdHJ1ZSxcbiAgJ3BhbkVkZ2VGcmFjdGlvbic6IHRydWUsXG4gICdwaXhlbHNQZXJZTGFiZWwnOiB0cnVlLFxuICAncG9pbnRDbGlja0NhbGxiYWNrJzogdHJ1ZSxcbiAgJ3BvaW50U2l6ZSc6IHRydWUsXG4gICdyYW5nZVNlbGVjdG9yUGxvdEZpbGxDb2xvcic6IHRydWUsXG4gICdyYW5nZVNlbGVjdG9yUGxvdEZpbGxHcmFkaWVudENvbG9yJzogdHJ1ZSxcbiAgJ3JhbmdlU2VsZWN0b3JQbG90U3Ryb2tlQ29sb3InOiB0cnVlLFxuICAncmFuZ2VTZWxlY3RvckJhY2tncm91bmRTdHJva2VDb2xvcic6IHRydWUsXG4gICdyYW5nZVNlbGVjdG9yQmFja2dyb3VuZExpbmVXaWR0aCc6IHRydWUsXG4gICdyYW5nZVNlbGVjdG9yUGxvdExpbmVXaWR0aCc6IHRydWUsXG4gICdyYW5nZVNlbGVjdG9yRm9yZWdyb3VuZFN0cm9rZUNvbG9yJzogdHJ1ZSxcbiAgJ3JhbmdlU2VsZWN0b3JGb3JlZ3JvdW5kTGluZVdpZHRoJzogdHJ1ZSxcbiAgJ3JhbmdlU2VsZWN0b3JBbHBoYSc6IHRydWUsXG4gICdzaG93TGFiZWxzT25IaWdobGlnaHQnOiB0cnVlLFxuICAnc2hvd1JvbGxlcic6IHRydWUsXG4gICdzdHJva2VXaWR0aCc6IHRydWUsXG4gICd1bmRlcmxheUNhbGxiYWNrJzogdHJ1ZSxcbiAgJ3VuaGlnaGxpZ2h0Q2FsbGJhY2snOiB0cnVlLFxuICAnem9vbUNhbGxiYWNrJzogdHJ1ZVxufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgc2NhbiB0aGUgb3B0aW9uIGxpc3QgYW5kIGRldGVybWluZSBpZiB0aGV5XG4gKiByZXF1aXJlIHVzIHRvIHJlY2FsY3VsYXRlIHRoZSBwaXhlbCBwb3NpdGlvbnMgb2YgZWFjaCBwb2ludC5cbiAqIFRPRE86IG1vdmUgdGhpcyBpbnRvIGR5Z3JhcGgtb3B0aW9ucy5qc1xuICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz59IGxhYmVscyBhIGxpc3Qgb2Ygb3B0aW9ucyB0byBjaGVjay5cbiAqIEBwYXJhbSB7IU9iamVjdH0gYXR0cnNcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGdyYXBoIG5lZWRzIG5ldyBwb2ludHMgZWxzZSBmYWxzZS5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1BpeGVsQ2hhbmdpbmdPcHRpb25MaXN0KGxhYmVscywgYXR0cnMpIHtcbiAgLy8gQXNzdW1lIHRoYXQgd2UgZG8gbm90IHJlcXVpcmUgbmV3IHBvaW50cy5cbiAgLy8gVGhpcyB3aWxsIGNoYW5nZSB0byB0cnVlIGlmIHdlIGFjdHVhbGx5IGRvIG5lZWQgbmV3IHBvaW50cy5cblxuICAvLyBDcmVhdGUgYSBkaWN0aW9uYXJ5IG9mIHNlcmllcyBuYW1lcyBmb3IgZmFzdGVyIGxvb2t1cC5cbiAgLy8gSWYgdGhlcmUgYXJlIG5vIGxhYmVscywgdGhlbiB0aGUgZGljdGlvbmFyeSBzdGF5cyBlbXB0eS5cbiAgdmFyIHNlcmllc05hbWVzRGljdGlvbmFyeSA9IHsgfTtcbiAgaWYgKGxhYmVscykge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZXJpZXNOYW1lc0RpY3Rpb25hcnlbbGFiZWxzW2ldXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gU2NhbiB0aHJvdWdoIGEgZmxhdCAoaS5lLiBub24tbmVzdGVkKSBvYmplY3Qgb2Ygb3B0aW9ucy5cbiAgLy8gUmV0dXJucyB0cnVlL2ZhbHNlIGRlcGVuZGluZyBvbiB3aGV0aGVyIG5ldyBwb2ludHMgYXJlIG5lZWRlZC5cbiAgdmFyIHNjYW5GbGF0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkgJiZcbiAgICAgICAgICAhcGl4ZWxTYWZlT3B0aW9uc1twcm9wZXJ0eV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2YgdXBkYXRlZCBvcHRpb25zLlxuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBhdHRycykge1xuICAgIGlmICghYXR0cnMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSBjb250aW51ZTtcblxuICAgIC8vIEZpbmQgb3V0IG9mIHRoaXMgZmllbGQgaXMgYWN0dWFsbHkgYSBzZXJpZXMgc3BlY2lmaWMgb3B0aW9ucyBsaXN0LlxuICAgIGlmIChwcm9wZXJ0eSA9PSAnaGlnaGxpZ2h0U2VyaWVzT3B0cycgfHxcbiAgICAgICAgKHNlcmllc05hbWVzRGljdGlvbmFyeVtwcm9wZXJ0eV0gJiYgIWF0dHJzLnNlcmllcykpIHtcbiAgICAgIC8vIFRoaXMgcHJvcGVydHkgdmFsdWUgaXMgYSBsaXN0IG9mIG9wdGlvbnMgZm9yIHRoaXMgc2VyaWVzLlxuICAgICAgaWYgKHNjYW5GbGF0T3B0aW9ucyhhdHRyc1twcm9wZXJ0eV0pKSByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5ID09ICdzZXJpZXMnIHx8IHByb3BlcnR5ID09ICdheGVzJykge1xuICAgICAgLy8gVGhpcyBpcyB0d2ljZS1uZXN0ZWQgb3B0aW9ucyBsaXN0LlxuICAgICAgdmFyIHBlclNlcmllcyA9IGF0dHJzW3Byb3BlcnR5XTtcbiAgICAgIGZvciAodmFyIHNlcmllcyBpbiBwZXJTZXJpZXMpIHtcbiAgICAgICAgaWYgKHBlclNlcmllcy5oYXNPd25Qcm9wZXJ0eShzZXJpZXMpICYmXG4gICAgICAgICAgICBzY2FuRmxhdE9wdGlvbnMocGVyU2VyaWVzW3Nlcmllc10pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhpcyB3YXMgbm90IGEgc2VyaWVzIHNwZWNpZmljIG9wdGlvbiBsaXN0LCBjaGVjayBpZiBpdCdzIGEgcGl4ZWxcbiAgICAgIC8vIGNoYW5naW5nIHByb3BlcnR5LlxuICAgICAgaWYgKCFwaXhlbFNhZmVPcHRpb25zW3Byb3BlcnR5XSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IHZhciBDaXJjbGVzID0ge1xuICBERUZBVUxUIDogZnVuY3Rpb24oZywgbmFtZSwgY3R4LCBjYW52YXN4LCBjYW52YXN5LCBjb2xvciwgcmFkaXVzKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICBjdHguYXJjKGNhbnZhc3gsIGNhbnZhc3ksIHJhZGl1cywgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICBjdHguZmlsbCgpO1xuICB9XG4gIC8vIEZvciBtb3JlIHNoYXBlcywgaW5jbHVkZSBleHRyYXMvc2hhcGVzLmpzXG59O1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIHxkYXRhfCBpcyBkZWxpbWl0ZWQgYnkgQ1IsIENSTEYsIExGLCBMRkNSLlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiAqIEByZXR1cm4gez9zdHJpbmd9IHRoZSBkZWxpbWl0ZXIgdGhhdCB3YXMgZGV0ZWN0ZWQgKG9yIG51bGwgb24gZmFpbHVyZSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RMaW5lRGVsaW1pdGVyKGRhdGEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvZGUgPSBkYXRhLmNoYXJBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gJ1xccicpIHtcbiAgICAgIC8vIE1pZ2h0IGFjdHVhbGx5IGJlIFwiXFxyXFxuXCIuXG4gICAgICBpZiAoKChpICsgMSkgPCBkYXRhLmxlbmd0aCkgJiYgKGRhdGEuY2hhckF0KGkgKyAxKSA9PT0gJ1xcbicpKSB7XG4gICAgICAgIHJldHVybiAnXFxyXFxuJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gJ1xcbicpIHtcbiAgICAgIC8vIE1pZ2h0IGFjdHVhbGx5IGJlIFwiXFxuXFxyXCIuXG4gICAgICBpZiAoKChpICsgMSkgPCBkYXRhLmxlbmd0aCkgJiYgKGRhdGEuY2hhckF0KGkgKyAxKSA9PT0gJ1xccicpKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxyJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBJcyBvbmUgbm9kZSBjb250YWluZWQgYnkgYW5vdGhlcj9cbiAqIEBwYXJhbSB7Tm9kZX0gY29udGFpbmVlIFRoZSBjb250YWluZWQgbm9kZS5cbiAqIEBwYXJhbSB7Tm9kZX0gY29udGFpbmVyIFRoZSBjb250YWluZXIgbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgY29udGFpbmVlIGlzIGluc2lkZSAob3IgZXF1YWwgdG8pIGNvbnRhaW5lci5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVDb250YWluZWRCeShjb250YWluZWUsIGNvbnRhaW5lcikge1xuICBpZiAoY29udGFpbmVyID09PSBudWxsIHx8IGNvbnRhaW5lZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgY29udGFpbmVlTm9kZSA9IC8qKiBAdHlwZSB7Tm9kZX0gKi8gKGNvbnRhaW5lZSk7XG4gIHdoaWxlIChjb250YWluZWVOb2RlICYmIGNvbnRhaW5lZU5vZGUgIT09IGNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lZU5vZGUgPSBjb250YWluZWVOb2RlLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIChjb250YWluZWVOb2RlID09PSBjb250YWluZXIpO1xufTtcblxuLy8gVGhpcyBtYXNrcyBzb21lIG51bWVyaWMgaXNzdWVzIGluIG9sZGVyIHZlcnNpb25zIG9mIEZpcmVmb3gsXG4vLyB3aGVyZSAxLjAvTWF0aC5wb3coMTAsMikgIT0gTWF0aC5wb3coMTAsLTIpLlxuLyoqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyKTpudW1iZXJ9ICovXG5leHBvcnQgZnVuY3Rpb24gcG93KGJhc2UsIGV4cCkge1xuICBpZiAoZXhwIDwgMCkge1xuICAgIHJldHVybiAxLjAgLyBNYXRoLnBvdyhiYXNlLCAtZXhwKTtcbiAgfVxuICByZXR1cm4gTWF0aC5wb3coYmFzZSwgZXhwKTtcbn07XG5cbnZhciBSR0JBX1JFID0gL15yZ2JhP1xcKChcXGR7MSwzfSksXFxzKihcXGR7MSwzfSksXFxzKihcXGR7MSwzfSkoPzosXFxzKihbMDFdKD86XFwuXFxkKyk/KSk/XFwpJC87XG5cbi8qKlxuICogSGVscGVyIGZvciB0b1JHQl8gd2hpY2ggcGFyc2VzIHN0cmluZ3Mgb2YgdGhlIGZvcm06XG4gKiByZ2IoMTIzLCA0NSwgNjcpXG4gKiByZ2JhKDEyMywgNDUsIDY3LCAwLjUpXG4gKiBAcmV0dXJuIHBhcnNlZCB7cixnLGIsYT99IHR1cGxlIG9yIG51bGwuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUkdCQShyZ2JTdHIpIHtcbiAgdmFyIGJpdHMgPSBSR0JBX1JFLmV4ZWMocmdiU3RyKTtcbiAgaWYgKCFiaXRzKSByZXR1cm4gbnVsbDtcbiAgdmFyIHIgPSBwYXJzZUludChiaXRzWzFdLCAxMCksXG4gICAgICBnID0gcGFyc2VJbnQoYml0c1syXSwgMTApLFxuICAgICAgYiA9IHBhcnNlSW50KGJpdHNbM10sIDEwKTtcbiAgaWYgKGJpdHNbNF0pIHtcbiAgICByZXR1cm4ge3I6IHIsIGc6IGcsIGI6IGIsIGE6IHBhcnNlRmxvYXQoYml0c1s0XSl9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7cjogciwgZzogZywgYjogYn07XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbnkgdmFsaWQgQ1NTIGNvbG9yIChoZXgsIHJnYigpLCBuYW1lZCBjb2xvcikgdG8gYW4gUkdCIHR1cGxlLlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gY29sb3JTdHIgQW55IHZhbGlkIENTUyBjb2xvciBzdHJpbmcuXG4gKiBAcmV0dXJuIHt7cjpudW1iZXIsZzpudW1iZXIsYjpudW1iZXIsYTpudW1iZXI/fX0gUGFyc2VkIFJHQiB0dXBsZS5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JHQl8oY29sb3JTdHIpIHtcbiAgLy8gU3RyYXRlZ3k6IEZpcnN0IHRyeSB0byBwYXJzZSBjb2xvclN0ciBkaXJlY3RseS4gVGhpcyBpcyBmYXN0ICYgYXZvaWRzIERPTVxuICAvLyBtYW5pcHVsYXRpb24uICBJZiB0aGF0IGZhaWxzIChlLmcuIGZvciBuYW1lZCBjb2xvcnMgbGlrZSAncmVkJyksIHRoZW5cbiAgLy8gY3JlYXRlIGEgaGlkZGVuIERPTSBlbGVtZW50IGFuZCBwYXJzZSBpdHMgY29tcHV0ZWQgY29sb3IuXG4gIHZhciByZ2IgPSBwYXJzZVJHQkEoY29sb3JTdHIpO1xuICBpZiAocmdiKSByZXR1cm4gcmdiO1xuXG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yU3RyO1xuICBkaXYuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gIHZhciByZ2JTdHIgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkaXYsIG51bGwpLmJhY2tncm91bmRDb2xvcjtcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICByZXR1cm4gcGFyc2VSR0JBKHJnYlN0cik7XG59O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSAmbHQ7Y2FudmFzJmd0OyB0YWcuXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50PX0gb3B0X2NhbnZhc0VsZW1lbnQgUGFzcyBhIGNhbnZhcyBlbGVtZW50IGFzIGFuXG4gKiAgICAgb3B0aW1pemF0aW9uIGlmIHlvdSBoYXZlIG9uZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgY2FudmFzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDYW52YXNTdXBwb3J0ZWQob3B0X2NhbnZhc0VsZW1lbnQpIHtcbiAgdHJ5IHtcbiAgICB2YXIgY2FudmFzID0gb3B0X2NhbnZhc0VsZW1lbnQgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIHZhbHVlIGFzIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLiBUaGlzIGlzIGxpa2UgdGhlIHBhcnNlRmxvYXQoKVxuICogYnVpbHQtaW4sIGJ1dCB3aXRoIGEgZmV3IGRpZmZlcmVuY2VzOlxuICogLSB0aGUgZW1wdHkgc3RyaW5nIGlzIHBhcnNlZCBhcyBudWxsLCByYXRoZXIgdGhhbiBOYU4uXG4gKiAtIGlmIHRoZSBzdHJpbmcgY2Fubm90IGJlIHBhcnNlZCBhdCBhbGwsIGFuIGVycm9yIGlzIGxvZ2dlZC5cbiAqIElmIHRoZSBzdHJpbmcgY2FuJ3QgYmUgcGFyc2VkLCB0aGlzIG1ldGhvZCByZXR1cm5zIG51bGwuXG4gKiBAcGFyYW0ge3N0cmluZ30geCBUaGUgc3RyaW5nIHRvIGJlIHBhcnNlZFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfbGluZV9ubyBUaGUgbGluZSBudW1iZXIgZnJvbSB3aGljaCB0aGUgc3RyaW5nIGNvbWVzLlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbGluZSBUaGUgdGV4dCBvZiB0aGUgbGluZSBmcm9tIHdoaWNoIHRoZSBzdHJpbmcgY29tZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZsb2F0Xyh4LCBvcHRfbGluZV9ubywgb3B0X2xpbmUpIHtcbiAgdmFyIHZhbCA9IHBhcnNlRmxvYXQoeCk7XG4gIGlmICghaXNOYU4odmFsKSkgcmV0dXJuIHZhbDtcblxuICAvLyBUcnkgdG8gZmlndXJlIG91dCB3aGF0IGhhcHBlZW5kLlxuICAvLyBJZiB0aGUgdmFsdWUgaXMgdGhlIGVtcHR5IHN0cmluZywgcGFyc2UgaXQgYXMgbnVsbC5cbiAgaWYgKC9eICokLy50ZXN0KHgpKSByZXR1cm4gbnVsbDtcblxuICAvLyBJZiBpdCB3YXMgYWN0dWFsbHkgXCJOYU5cIiwgcmV0dXJuIGl0IGFzIE5hTi5cbiAgaWYgKC9eICpuYW4gKiQvaS50ZXN0KHgpKSByZXR1cm4gTmFOO1xuXG4gIC8vIExvb2tzIGxpa2UgYSBwYXJzaW5nIGVycm9yLlxuICB2YXIgbXNnID0gXCJVbmFibGUgdG8gcGFyc2UgJ1wiICsgeCArIFwiJyBhcyBhIG51bWJlclwiO1xuICBpZiAob3B0X2xpbmUgIT09IHVuZGVmaW5lZCAmJiBvcHRfbGluZV9ubyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbXNnICs9IFwiIG9uIGxpbmUgXCIgKyAoMSsob3B0X2xpbmVfbm98fDApKSArIFwiICgnXCIgKyBvcHRfbGluZSArIFwiJykgb2YgQ1NWLlwiO1xuICB9XG4gIGNvbnNvbGUuZXJyb3IobXNnKTtcblxuICByZXR1cm4gbnVsbDtcbn07XG5cblxuLy8gTGFiZWwgY29uc3RhbnRzIGZvciB0aGUgbGFiZWxzS01CIGFuZCBsYWJlbHNLTUcyIG9wdGlvbnMuXG4vLyAoaS5lLiAnMTAwMDAwJyAtPiAnMTAwSycpXG52YXIgS01CX0xBQkVMUyA9IFsgJ0snLCAnTScsICdCJywgJ1QnLCAnUScgXTtcbnZhciBLTUcyX0JJR19MQUJFTFMgPSBbICdrJywgJ00nLCAnRycsICdUJywgJ1AnLCAnRScsICdaJywgJ1knIF07XG52YXIgS01HMl9TTUFMTF9MQUJFTFMgPSBbICdtJywgJ3UnLCAnbicsICdwJywgJ2YnLCAnYScsICd6JywgJ3knIF07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJldHVybiBhIHN0cmluZyB2ZXJzaW9uIG9mIGEgbnVtYmVyLiBUaGlzIHJlc3BlY3RzIHRoZSBkaWdpdHNBZnRlckRlY2ltYWxcbiAqIGFuZCBtYXhOdW1iZXJXaWR0aCBvcHRpb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIG51bWJlciB0byBiZSBmb3JtYXR0ZWRcbiAqIEBwYXJhbSB7RHlncmFwaH0gb3B0cyBBbiBvcHRpb25zIHZpZXdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclZhbHVlRm9ybWF0dGVyKHgsIG9wdHMpIHtcbiAgdmFyIHNpZ0ZpZ3MgPSBvcHRzKCdzaWdGaWdzJyk7XG5cbiAgaWYgKHNpZ0ZpZ3MgIT09IG51bGwpIHtcbiAgICAvLyBVc2VyIGhhcyBvcHRlZCBmb3IgYSBmaXhlZCBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZmlndXJlcy5cbiAgICByZXR1cm4gZmxvYXRGb3JtYXQoeCwgc2lnRmlncyk7XG4gIH1cblxuICB2YXIgZGlnaXRzID0gb3B0cygnZGlnaXRzQWZ0ZXJEZWNpbWFsJyk7XG4gIHZhciBtYXhOdW1iZXJXaWR0aCA9IG9wdHMoJ21heE51bWJlcldpZHRoJyk7XG5cbiAgdmFyIGttYiA9IG9wdHMoJ2xhYmVsc0tNQicpO1xuICB2YXIga21nMiA9IG9wdHMoJ2xhYmVsc0tNRzInKTtcblxuICB2YXIgbGFiZWw7XG5cbiAgLy8gc3dpdGNoIHRvIHNjaWVudGlmaWMgbm90YXRpb24gaWYgd2UgdW5kZXJmbG93IG9yIG92ZXJmbG93IGZpeGVkIGRpc3BsYXkuXG4gIGlmICh4ICE9PSAwLjAgJiZcbiAgICAgIChNYXRoLmFicyh4KSA+PSBNYXRoLnBvdygxMCwgbWF4TnVtYmVyV2lkdGgpIHx8XG4gICAgICAgTWF0aC5hYnMoeCkgPCBNYXRoLnBvdygxMCwgLWRpZ2l0cykpKSB7XG4gICAgbGFiZWwgPSB4LnRvRXhwb25lbnRpYWwoZGlnaXRzKTtcbiAgfSBlbHNlIHtcbiAgICBsYWJlbCA9ICcnICsgcm91bmRfKHgsIGRpZ2l0cyk7XG4gIH1cblxuICBpZiAoa21iIHx8IGttZzIpIHtcbiAgICB2YXIgaztcbiAgICB2YXIga19sYWJlbHMgPSBbXTtcbiAgICB2YXIgbV9sYWJlbHMgPSBbXTtcbiAgICBpZiAoa21iKSB7XG4gICAgICBrID0gMTAwMDtcbiAgICAgIGtfbGFiZWxzID0gS01CX0xBQkVMUztcbiAgICB9XG4gICAgaWYgKGttZzIpIHtcbiAgICAgIGlmIChrbWIpIGNvbnNvbGUud2FybihcIlNldHRpbmcgYm90aCBsYWJlbHNLTUIgYW5kIGxhYmVsc0tNRzIuIFBpY2sgb25lIVwiKTtcbiAgICAgIGsgPSAxMDI0O1xuICAgICAga19sYWJlbHMgPSBLTUcyX0JJR19MQUJFTFM7XG4gICAgICBtX2xhYmVscyA9IEtNRzJfU01BTExfTEFCRUxTO1xuICAgIH1cblxuICAgIHZhciBhYnN4ID0gTWF0aC5hYnMoeCk7XG4gICAgdmFyIG4gPSBwb3coaywga19sYWJlbHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBqID0ga19sYWJlbHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0sIG4gLz0gaykge1xuICAgICAgaWYgKGFic3ggPj0gbikge1xuICAgICAgICBsYWJlbCA9IHJvdW5kXyh4IC8gbiwgZGlnaXRzKSArIGtfbGFiZWxzW2pdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGttZzIpIHtcbiAgICAgIC8vIFRPRE8oZGFudmspOiBjbGVhbiB1cCB0aGlzIGxvZ2ljLiBXaHkgc28gZGlmZmVyZW50IHRoYW4ga21iP1xuICAgICAgdmFyIHhfcGFydHMgPSBTdHJpbmcoeC50b0V4cG9uZW50aWFsKCkpLnNwbGl0KCdlLScpO1xuICAgICAgaWYgKHhfcGFydHMubGVuZ3RoID09PSAyICYmIHhfcGFydHNbMV0gPj0gMyAmJiB4X3BhcnRzWzFdIDw9IDI0KSB7XG4gICAgICAgIGlmICh4X3BhcnRzWzFdICUgMyA+IDApIHtcbiAgICAgICAgICBsYWJlbCA9IHJvdW5kXyh4X3BhcnRzWzBdIC9cbiAgICAgICAgICAgICAgcG93KDEwLCAoeF9wYXJ0c1sxXSAlIDMpKSxcbiAgICAgICAgICAgICAgZGlnaXRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYWJlbCA9IE51bWJlcih4X3BhcnRzWzBdKS50b0ZpeGVkKDIpO1xuICAgICAgICB9XG4gICAgICAgIGxhYmVsICs9IG1fbGFiZWxzW01hdGguZmxvb3IoeF9wYXJ0c1sxXSAvIDMpIC0gMV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxhYmVsO1xufTtcblxuLyoqXG4gKiB2YXJpYW50IGZvciB1c2UgYXMgYW4gYXhpc0xhYmVsRm9ybWF0dGVyLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bWJlckF4aXNMYWJlbEZvcm1hdHRlcih4LCBncmFudWxhcml0eSwgb3B0cykge1xuICByZXR1cm4gbnVtYmVyVmFsdWVGb3JtYXR0ZXIuY2FsbCh0aGlzLCB4LCBvcHRzKTtcbn07XG5cbi8qKlxuICogQHR5cGUgeyFBcnJheS48c3RyaW5nPn1cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnRcbiAqL1xudmFyIFNIT1JUX01PTlRIX05BTUVTXyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuXG4vKipcbiAqIENvbnZlcnQgYSBKUyBkYXRlIHRvIGEgc3RyaW5nIGFwcHJvcHJpYXRlIHRvIGRpc3BsYXkgb24gYW4gYXhpcyB0aGF0XG4gKiBpcyBkaXNwbGF5aW5nIHZhbHVlcyBhdCB0aGUgc3RhdGVkIGdyYW51bGFyaXR5LiBUaGlzIHJlc3BlY3RzIHRoZVxuICogbGFiZWxzVVRDIG9wdGlvbi5cbiAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBUaGUgZGF0ZSB0byBmb3JtYXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBncmFudWxhcml0eSBPbmUgb2YgdGhlIER5Z3JhcGggZ3JhbnVsYXJpdHkgY29uc3RhbnRzXG4gKiBAcGFyYW0ge0R5Z3JhcGh9IG9wdHMgQW4gb3B0aW9ucyB2aWV3XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBkYXRlIGZvcm1hdHRlZCBhcyBsb2NhbCB0aW1lXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0ZUF4aXNMYWJlbEZvcm1hdHRlcihkYXRlLCBncmFudWxhcml0eSwgb3B0cykge1xuICB2YXIgdXRjID0gb3B0cygnbGFiZWxzVVRDJyk7XG4gIHZhciBhY2Nlc3NvcnMgPSB1dGMgPyBEYXRlQWNjZXNzb3JzVVRDIDogRGF0ZUFjY2Vzc29yc0xvY2FsO1xuXG4gIHZhciB5ZWFyID0gYWNjZXNzb3JzLmdldEZ1bGxZZWFyKGRhdGUpLFxuICAgICAgbW9udGggPSBhY2Nlc3NvcnMuZ2V0TW9udGgoZGF0ZSksXG4gICAgICBkYXkgPSBhY2Nlc3NvcnMuZ2V0RGF0ZShkYXRlKSxcbiAgICAgIGhvdXJzID0gYWNjZXNzb3JzLmdldEhvdXJzKGRhdGUpLFxuICAgICAgbWlucyA9IGFjY2Vzc29ycy5nZXRNaW51dGVzKGRhdGUpLFxuICAgICAgc2VjcyA9IGFjY2Vzc29ycy5nZXRTZWNvbmRzKGRhdGUpLFxuICAgICAgbWlsbGlzID0gYWNjZXNzb3JzLmdldE1pbGxpc2Vjb25kcyhkYXRlKTtcblxuICBpZiAoZ3JhbnVsYXJpdHkgPj0gRHlncmFwaFRpY2tlcnMuR3JhbnVsYXJpdHkuREVDQURBTCkge1xuICAgIHJldHVybiAnJyArIHllYXI7XG4gIH0gZWxzZSBpZiAoZ3JhbnVsYXJpdHkgPj0gRHlncmFwaFRpY2tlcnMuR3JhbnVsYXJpdHkuTU9OVEhMWSkge1xuICAgIHJldHVybiBTSE9SVF9NT05USF9OQU1FU19bbW9udGhdICsgJyYjMTYwOycgKyB5ZWFyO1xuICB9IGVsc2Uge1xuICAgIHZhciBmcmFjID0gaG91cnMgKiAzNjAwICsgbWlucyAqIDYwICsgc2VjcyArIDFlLTMgKiBtaWxsaXM7XG4gICAgaWYgKGZyYWMgPT09IDAgfHwgZ3JhbnVsYXJpdHkgPj0gRHlncmFwaFRpY2tlcnMuR3JhbnVsYXJpdHkuREFJTFkpIHtcbiAgICAgIC8vIGUuZy4gJzIxIEphbicgKCVkJWIpXG4gICAgICByZXR1cm4gemVyb3BhZChkYXkpICsgJyYjMTYwOycgKyBTSE9SVF9NT05USF9OQU1FU19bbW9udGhdO1xuICAgIH0gZWxzZSBpZiAoZ3JhbnVsYXJpdHkgPCBEeWdyYXBoVGlja2Vycy5HcmFudWxhcml0eS5TRUNPTkRMWSkge1xuICAgICAgLy8gZS5nLiA0MC4zMTAgKG1lYW5pbmcgNDAgc2Vjb25kcyBhbmQgMzEwIG1pbGxpc2Vjb25kcylcbiAgICAgIHZhciBzdHIgPSBcIlwiICsgbWlsbGlzO1xuICAgICAgcmV0dXJuIHplcm9wYWQoc2VjcykgKyBcIi5cIiArICgnMDAwJytzdHIpLnN1YnN0cmluZyhzdHIubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGdyYW51bGFyaXR5ID4gRHlncmFwaFRpY2tlcnMuR3JhbnVsYXJpdHkuTUlOVVRFTFkpIHtcbiAgICAgIHJldHVybiBobXNTdHJpbmdfKGhvdXJzLCBtaW5zLCBzZWNzLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGhtc1N0cmluZ18oaG91cnMsIG1pbnMsIHNlY3MsIG1pbGxpcyk7XG4gICAgfVxuICB9XG59O1xuLy8gYWxpYXMgaW4gY2FzZSBhbnlvbmUgaXMgcmVmZXJlbmNpbmcgdGhlIG9sZCBtZXRob2QuXG4vLyBEeWdyYXBoLmRhdGVBeGlzRm9ybWF0dGVyID0gRHlncmFwaC5kYXRlQXhpc0xhYmVsRm9ybWF0dGVyO1xuXG4vKipcbiAqIFJldHVybiBhIHN0cmluZyB2ZXJzaW9uIG9mIGEgSlMgZGF0ZSBmb3IgYSB2YWx1ZSBsYWJlbC4gVGhpcyByZXNwZWN0cyB0aGVcbiAqIGxhYmVsc1VUQyBvcHRpb24uXG4gKiBAcGFyYW0ge0RhdGV9IGRhdGUgVGhlIGRhdGUgdG8gYmUgZm9ybWF0dGVkXG4gKiBAcGFyYW0ge0R5Z3JhcGh9IG9wdHMgQW4gb3B0aW9ucyB2aWV3XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0ZVZhbHVlRm9ybWF0dGVyKGQsIG9wdHMpIHtcbiAgcmV0dXJuIGRhdGVTdHJpbmdfKGQsIG9wdHMoJ2xhYmVsc1VUQycpKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLXV0aWxzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__datahandler__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dygraph_layout__ = __webpack_require__(18);\n/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler base implementation for the \"bar\" \n * data formats. This implementation must be extended and the\n * extractSeries and rollingAverage must be implemented.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n/*global DygraphLayout:false */\n\n\n\n\n\n/**\n * @constructor\n * @extends {Dygraph.DataHandler}\n */\nvar BarsHandler = function BarsHandler() {\n  __WEBPACK_IMPORTED_MODULE_0__datahandler__[\"a\" /* default */].call(this);\n};\nBarsHandler.prototype = new __WEBPACK_IMPORTED_MODULE_0__datahandler__[\"a\" /* default */]();\n\n// TODO(danvk): figure out why the jsdoc has to be copy/pasted from superclass.\n//   (I get closure compiler errors if this isn't here.)\n/**\n * @override\n * @param {!Array.<Array>} rawData The raw data passed into dygraphs where \n *     rawData[i] = [x,ySeries1,...,ySeriesN].\n * @param {!number} seriesIndex Index of the series to extract. All other\n *     series should be ignored.\n * @param {!DygraphOptions} options Dygraph options.\n * @return {Array.<[!number,?number,?]>} The series in the unified data format\n *     where series[i] = [x,y,{extras}]. \n */\nBarsHandler.prototype.extractSeries = function (rawData, seriesIndex, options) {\n  // Not implemented here must be extended\n};\n\n/**\n * @override\n * @param {!Array.<[!number,?number,?]>} series The series in the unified \n *          data format where series[i] = [x,y,{extras}].\n * @param {!number} rollPeriod The number of points over which to average the data\n * @param {!DygraphOptions} options The dygraph options.\n * TODO(danvk): be more specific than \"Array\" here.\n * @return {!Array.<[!number,?number,?]>} the rolled series.\n */\nBarsHandler.prototype.rollingAverage = function (series, rollPeriod, options) {\n  // Not implemented here, must be extended.\n};\n\n/** @inheritDoc */\nBarsHandler.prototype.onPointsCreated_ = function (series, points) {\n  for (var i = 0; i < series.length; ++i) {\n    var item = series[i];\n    var point = points[i];\n    point.y_top = NaN;\n    point.y_bottom = NaN;\n    point.yval_minus = __WEBPACK_IMPORTED_MODULE_0__datahandler__[\"a\" /* default */].parseFloat(item[2][0]);\n    point.yval_plus = __WEBPACK_IMPORTED_MODULE_0__datahandler__[\"a\" /* default */].parseFloat(item[2][1]);\n  }\n};\n\n/** @inheritDoc */\nBarsHandler.prototype.getExtremeYValues = function (series, dateWindow, options) {\n  var minY = null,\n      maxY = null,\n      y;\n\n  var firstIdx = 0;\n  var lastIdx = series.length - 1;\n\n  for (var j = firstIdx; j <= lastIdx; j++) {\n    y = series[j][1];\n    if (y === null || isNaN(y)) continue;\n\n    var low = series[j][2][0];\n    var high = series[j][2][1];\n\n    if (low > y) low = y; // this can happen with custom bars,\n    if (high < y) high = y; // e.g. in tests/custom-bars.html\n\n    if (maxY === null || high > maxY) maxY = high;\n    if (minY === null || low < minY) minY = low;\n  }\n\n  return [minY, maxY];\n};\n\n/** @inheritDoc */\nBarsHandler.prototype.onLineEvaluated = function (points, axis, logscale) {\n  var point;\n  for (var j = 0; j < points.length; j++) {\n    // Copy over the error terms\n    point = points[j];\n    point.y_top = __WEBPACK_IMPORTED_MODULE_1__dygraph_layout__[\"a\" /* default */].calcYNormal_(axis, point.yval_minus, logscale);\n    point.y_bottom = __WEBPACK_IMPORTED_MODULE_1__dygraph_layout__[\"a\" /* default */].calcYNormal_(axis, point.yval_plus, logscale);\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (BarsHandler);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9iYXJzLmpzPzhmNGYiXSwibmFtZXMiOlsiQmFyc0hhbmRsZXIiLCJEeWdyYXBoRGF0YUhhbmRsZXIiLCJjYWxsIiwicHJvdG90eXBlIiwiZXh0cmFjdFNlcmllcyIsInJhd0RhdGEiLCJzZXJpZXNJbmRleCIsIm9wdGlvbnMiLCJyb2xsaW5nQXZlcmFnZSIsInNlcmllcyIsInJvbGxQZXJpb2QiLCJvblBvaW50c0NyZWF0ZWRfIiwicG9pbnRzIiwiaSIsImxlbmd0aCIsIml0ZW0iLCJwb2ludCIsInlfdG9wIiwiTmFOIiwieV9ib3R0b20iLCJ5dmFsX21pbnVzIiwicGFyc2VGbG9hdCIsInl2YWxfcGx1cyIsImdldEV4dHJlbWVZVmFsdWVzIiwiZGF0ZVdpbmRvdyIsIm1pblkiLCJtYXhZIiwieSIsImZpcnN0SWR4IiwibGFzdElkeCIsImoiLCJpc05hTiIsImxvdyIsImhpZ2giLCJvbkxpbmVFdmFsdWF0ZWQiLCJheGlzIiwibG9nc2NhbGUiLCJEeWdyYXBoTGF5b3V0IiwiY2FsY1lOb3JtYWxfIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFBQTs7Ozs7O0FBTUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7OztBQUlBLElBQUlBLGNBQWMsU0FBZEEsV0FBYyxHQUFXO0FBQzNCQyxFQUFBLDZEQUFBQSxDQUFtQkMsSUFBbkIsQ0FBd0IsSUFBeEI7QUFDRCxDQUZEO0FBR0FGLFlBQVlHLFNBQVosR0FBd0IsSUFBSSw2REFBSixFQUF4Qjs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQUgsWUFBWUcsU0FBWixDQUFzQkMsYUFBdEIsR0FBc0MsVUFBU0MsT0FBVCxFQUFrQkMsV0FBbEIsRUFBK0JDLE9BQS9CLEVBQXdDO0FBQzVFO0FBQ0QsQ0FGRDs7QUFJQTs7Ozs7Ozs7O0FBU0FQLFlBQVlHLFNBQVosQ0FBc0JLLGNBQXRCLEdBQ0ksVUFBU0MsTUFBVCxFQUFpQkMsVUFBakIsRUFBNkJILE9BQTdCLEVBQXNDO0FBQ3hDO0FBQ0QsQ0FIRDs7QUFLQTtBQUNBUCxZQUFZRyxTQUFaLENBQXNCUSxnQkFBdEIsR0FBeUMsVUFBU0YsTUFBVCxFQUFpQkcsTUFBakIsRUFBeUI7QUFDaEUsT0FBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlKLE9BQU9LLE1BQTNCLEVBQW1DLEVBQUVELENBQXJDLEVBQXdDO0FBQ3RDLFFBQUlFLE9BQU9OLE9BQU9JLENBQVAsQ0FBWDtBQUNBLFFBQUlHLFFBQVFKLE9BQU9DLENBQVAsQ0FBWjtBQUNBRyxVQUFNQyxLQUFOLEdBQWNDLEdBQWQ7QUFDQUYsVUFBTUcsUUFBTixHQUFpQkQsR0FBakI7QUFDQUYsVUFBTUksVUFBTixHQUFtQiw2REFBQW5CLENBQW1Cb0IsVUFBbkIsQ0FBOEJOLEtBQUssQ0FBTCxFQUFRLENBQVIsQ0FBOUIsQ0FBbkI7QUFDQUMsVUFBTU0sU0FBTixHQUFrQiw2REFBQXJCLENBQW1Cb0IsVUFBbkIsQ0FBOEJOLEtBQUssQ0FBTCxFQUFRLENBQVIsQ0FBOUIsQ0FBbEI7QUFDRDtBQUNGLENBVEQ7O0FBV0E7QUFDQWYsWUFBWUcsU0FBWixDQUFzQm9CLGlCQUF0QixHQUEwQyxVQUFTZCxNQUFULEVBQWlCZSxVQUFqQixFQUE2QmpCLE9BQTdCLEVBQXNDO0FBQzlFLE1BQUlrQixPQUFPLElBQVg7QUFBQSxNQUFpQkMsT0FBTyxJQUF4QjtBQUFBLE1BQThCQyxDQUE5Qjs7QUFFQSxNQUFJQyxXQUFXLENBQWY7QUFDQSxNQUFJQyxVQUFVcEIsT0FBT0ssTUFBUCxHQUFnQixDQUE5Qjs7QUFFQSxPQUFNLElBQUlnQixJQUFJRixRQUFkLEVBQXdCRSxLQUFLRCxPQUE3QixFQUFzQ0MsR0FBdEMsRUFBMkM7QUFDekNILFFBQUlsQixPQUFPcUIsQ0FBUCxFQUFVLENBQVYsQ0FBSjtBQUNBLFFBQUlILE1BQU0sSUFBTixJQUFjSSxNQUFNSixDQUFOLENBQWxCLEVBQTRCOztBQUU1QixRQUFJSyxNQUFNdkIsT0FBT3FCLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixDQUFWO0FBQ0EsUUFBSUcsT0FBT3hCLE9BQU9xQixDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsQ0FBWDs7QUFFQSxRQUFJRSxNQUFNTCxDQUFWLEVBQWFLLE1BQU1MLENBQU4sQ0FQNEIsQ0FPbkI7QUFDdEIsUUFBSU0sT0FBT04sQ0FBWCxFQUFjTSxPQUFPTixDQUFQLENBUjJCLENBUWpCOztBQUV4QixRQUFJRCxTQUFTLElBQVQsSUFBaUJPLE9BQU9QLElBQTVCLEVBQWtDQSxPQUFPTyxJQUFQO0FBQ2xDLFFBQUlSLFNBQVMsSUFBVCxJQUFpQk8sTUFBTVAsSUFBM0IsRUFBaUNBLE9BQU9PLEdBQVA7QUFDbEM7O0FBRUQsU0FBTyxDQUFFUCxJQUFGLEVBQVFDLElBQVIsQ0FBUDtBQUNELENBckJEOztBQXVCQTtBQUNBMUIsWUFBWUcsU0FBWixDQUFzQitCLGVBQXRCLEdBQXdDLFVBQVN0QixNQUFULEVBQWlCdUIsSUFBakIsRUFBdUJDLFFBQXZCLEVBQWlDO0FBQ3ZFLE1BQUlwQixLQUFKO0FBQ0EsT0FBSyxJQUFJYyxJQUFJLENBQWIsRUFBZ0JBLElBQUlsQixPQUFPRSxNQUEzQixFQUFtQ2dCLEdBQW5DLEVBQXdDO0FBQ3RDO0FBQ0FkLFlBQVFKLE9BQU9rQixDQUFQLENBQVI7QUFDQWQsVUFBTUMsS0FBTixHQUFjLGdFQUFBb0IsQ0FBY0MsWUFBZCxDQUEyQkgsSUFBM0IsRUFBaUNuQixNQUFNSSxVQUF2QyxFQUFtRGdCLFFBQW5ELENBQWQ7QUFDQXBCLFVBQU1HLFFBQU4sR0FBaUIsZ0VBQUFrQixDQUFjQyxZQUFkLENBQTJCSCxJQUEzQixFQUFpQ25CLE1BQU1NLFNBQXZDLEVBQWtEYyxRQUFsRCxDQUFqQjtBQUNEO0FBQ0YsQ0FSRDs7QUFVQSx5REFBZXBDLFdBQWYiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEzIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEYXRhSGFuZGxlciBiYXNlIGltcGxlbWVudGF0aW9uIGZvciB0aGUgXCJiYXJcIiBcbiAqIGRhdGEgZm9ybWF0cy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBtdXN0IGJlIGV4dGVuZGVkIGFuZCB0aGVcbiAqIGV4dHJhY3RTZXJpZXMgYW5kIHJvbGxpbmdBdmVyYWdlIG11c3QgYmUgaW1wbGVtZW50ZWQuXG4gKiBAYXV0aG9yIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cbi8qZ2xvYmFsIER5Z3JhcGhMYXlvdXQ6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRHlncmFwaERhdGFIYW5kbGVyIGZyb20gJy4vZGF0YWhhbmRsZXInO1xuaW1wb3J0IER5Z3JhcGhMYXlvdXQgZnJvbSAnLi4vZHlncmFwaC1sYXlvdXQnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0R5Z3JhcGguRGF0YUhhbmRsZXJ9XG4gKi9cbnZhciBCYXJzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICBEeWdyYXBoRGF0YUhhbmRsZXIuY2FsbCh0aGlzKTtcbn07XG5CYXJzSGFuZGxlci5wcm90b3R5cGUgPSBuZXcgRHlncmFwaERhdGFIYW5kbGVyKCk7XG5cbi8vIFRPRE8oZGFudmspOiBmaWd1cmUgb3V0IHdoeSB0aGUganNkb2MgaGFzIHRvIGJlIGNvcHkvcGFzdGVkIGZyb20gc3VwZXJjbGFzcy5cbi8vICAgKEkgZ2V0IGNsb3N1cmUgY29tcGlsZXIgZXJyb3JzIGlmIHRoaXMgaXNuJ3QgaGVyZS4pXG4vKipcbiAqIEBvdmVycmlkZVxuICogQHBhcmFtIHshQXJyYXkuPEFycmF5Pn0gcmF3RGF0YSBUaGUgcmF3IGRhdGEgcGFzc2VkIGludG8gZHlncmFwaHMgd2hlcmUgXG4gKiAgICAgcmF3RGF0YVtpXSA9IFt4LHlTZXJpZXMxLC4uLix5U2VyaWVzTl0uXG4gKiBAcGFyYW0geyFudW1iZXJ9IHNlcmllc0luZGV4IEluZGV4IG9mIHRoZSBzZXJpZXMgdG8gZXh0cmFjdC4gQWxsIG90aGVyXG4gKiAgICAgc2VyaWVzIHNob3VsZCBiZSBpZ25vcmVkLlxuICogQHBhcmFtIHshRHlncmFwaE9wdGlvbnN9IG9wdGlvbnMgRHlncmFwaCBvcHRpb25zLlxuICogQHJldHVybiB7QXJyYXkuPFshbnVtYmVyLD9udW1iZXIsP10+fSBUaGUgc2VyaWVzIGluIHRoZSB1bmlmaWVkIGRhdGEgZm9ybWF0XG4gKiAgICAgd2hlcmUgc2VyaWVzW2ldID0gW3gseSx7ZXh0cmFzfV0uIFxuICovXG5CYXJzSGFuZGxlci5wcm90b3R5cGUuZXh0cmFjdFNlcmllcyA9IGZ1bmN0aW9uKHJhd0RhdGEsIHNlcmllc0luZGV4LCBvcHRpb25zKSB7XG4gIC8vIE5vdCBpbXBsZW1lbnRlZCBoZXJlIG11c3QgYmUgZXh0ZW5kZWRcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKiBAcGFyYW0geyFBcnJheS48WyFudW1iZXIsP251bWJlciw/XT59IHNlcmllcyBUaGUgc2VyaWVzIGluIHRoZSB1bmlmaWVkIFxuICogICAgICAgICAgZGF0YSBmb3JtYXQgd2hlcmUgc2VyaWVzW2ldID0gW3gseSx7ZXh0cmFzfV0uXG4gKiBAcGFyYW0geyFudW1iZXJ9IHJvbGxQZXJpb2QgVGhlIG51bWJlciBvZiBwb2ludHMgb3ZlciB3aGljaCB0byBhdmVyYWdlIHRoZSBkYXRhXG4gKiBAcGFyYW0geyFEeWdyYXBoT3B0aW9uc30gb3B0aW9ucyBUaGUgZHlncmFwaCBvcHRpb25zLlxuICogVE9ETyhkYW52ayk6IGJlIG1vcmUgc3BlY2lmaWMgdGhhbiBcIkFycmF5XCIgaGVyZS5cbiAqIEByZXR1cm4geyFBcnJheS48WyFudW1iZXIsP251bWJlciw/XT59IHRoZSByb2xsZWQgc2VyaWVzLlxuICovXG5CYXJzSGFuZGxlci5wcm90b3R5cGUucm9sbGluZ0F2ZXJhZ2UgPVxuICAgIGZ1bmN0aW9uKHNlcmllcywgcm9sbFBlcmlvZCwgb3B0aW9ucykge1xuICAvLyBOb3QgaW1wbGVtZW50ZWQgaGVyZSwgbXVzdCBiZSBleHRlbmRlZC5cbn07XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuQmFyc0hhbmRsZXIucHJvdG90eXBlLm9uUG9pbnRzQ3JlYXRlZF8gPSBmdW5jdGlvbihzZXJpZXMsIHBvaW50cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBpdGVtID0gc2VyaWVzW2ldO1xuICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcbiAgICBwb2ludC55X3RvcCA9IE5hTjtcbiAgICBwb2ludC55X2JvdHRvbSA9IE5hTjtcbiAgICBwb2ludC55dmFsX21pbnVzID0gRHlncmFwaERhdGFIYW5kbGVyLnBhcnNlRmxvYXQoaXRlbVsyXVswXSk7XG4gICAgcG9pbnQueXZhbF9wbHVzID0gRHlncmFwaERhdGFIYW5kbGVyLnBhcnNlRmxvYXQoaXRlbVsyXVsxXSk7XG4gIH1cbn07XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuQmFyc0hhbmRsZXIucHJvdG90eXBlLmdldEV4dHJlbWVZVmFsdWVzID0gZnVuY3Rpb24oc2VyaWVzLCBkYXRlV2luZG93LCBvcHRpb25zKSB7XG4gIHZhciBtaW5ZID0gbnVsbCwgbWF4WSA9IG51bGwsIHk7XG5cbiAgdmFyIGZpcnN0SWR4ID0gMDtcbiAgdmFyIGxhc3RJZHggPSBzZXJpZXMubGVuZ3RoIC0gMTtcblxuICBmb3IgKCB2YXIgaiA9IGZpcnN0SWR4OyBqIDw9IGxhc3RJZHg7IGorKykge1xuICAgIHkgPSBzZXJpZXNbal1bMV07XG4gICAgaWYgKHkgPT09IG51bGwgfHwgaXNOYU4oeSkpIGNvbnRpbnVlO1xuXG4gICAgdmFyIGxvdyA9IHNlcmllc1tqXVsyXVswXTtcbiAgICB2YXIgaGlnaCA9IHNlcmllc1tqXVsyXVsxXTtcblxuICAgIGlmIChsb3cgPiB5KSBsb3cgPSB5OyAvLyB0aGlzIGNhbiBoYXBwZW4gd2l0aCBjdXN0b20gYmFycyxcbiAgICBpZiAoaGlnaCA8IHkpIGhpZ2ggPSB5OyAvLyBlLmcuIGluIHRlc3RzL2N1c3RvbS1iYXJzLmh0bWxcblxuICAgIGlmIChtYXhZID09PSBudWxsIHx8IGhpZ2ggPiBtYXhZKSBtYXhZID0gaGlnaDtcbiAgICBpZiAobWluWSA9PT0gbnVsbCB8fCBsb3cgPCBtaW5ZKSBtaW5ZID0gbG93O1xuICB9XG5cbiAgcmV0dXJuIFsgbWluWSwgbWF4WSBdO1xufTtcblxuLyoqIEBpbmhlcml0RG9jICovXG5CYXJzSGFuZGxlci5wcm90b3R5cGUub25MaW5lRXZhbHVhdGVkID0gZnVuY3Rpb24ocG9pbnRzLCBheGlzLCBsb2dzY2FsZSkge1xuICB2YXIgcG9pbnQ7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgLy8gQ29weSBvdmVyIHRoZSBlcnJvciB0ZXJtc1xuICAgIHBvaW50ID0gcG9pbnRzW2pdO1xuICAgIHBvaW50LnlfdG9wID0gRHlncmFwaExheW91dC5jYWxjWU5vcm1hbF8oYXhpcywgcG9pbnQueXZhbF9taW51cywgbG9nc2NhbGUpO1xuICAgIHBvaW50LnlfYm90dG9tID0gRHlncmFwaExheW91dC5jYWxjWU5vcm1hbF8oYXhpcywgcG9pbnQueXZhbF9wbHVzLCBsb2dzY2FsZSk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJhcnNIYW5kbGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9keWdyYXBocy9zcmMvZGF0YWhhbmRsZXIvYmFycy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview This file contains the managment of data handlers\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n *\n * The idea is to define a common, generic data format that works for all data\n * structures supported by dygraphs. To make this possible, the DataHandler\n * interface is introduced. This makes it possible, that dygraph itself can work\n * with the same logic for every data type independent of the actual format and\n * the DataHandler takes care of the data format specific jobs.\n * DataHandlers are implemented for all data types supported by Dygraphs and\n * return Dygraphs compliant formats.\n * By default the correct DataHandler is chosen based on the options set.\n * Optionally the user may use his own DataHandler (similar to the plugin\n * system).\n *\n *\n * The unified data format returend by each handler is defined as so:\n * series[n][point] = [x,y,(extras)]\n *\n * This format contains the common basis that is needed to draw a simple line\n * series extended by optional extras for more complex graphing types. It\n * contains a primitive x value as first array entry, a primitive y value as\n * second array entry and an optional extras object for additional data needed.\n *\n * x must always be a number.\n * y must always be a number, NaN of type number or null.\n * extras is optional and must be interpreted by the DataHandler. It may be of\n * any type.\n *\n * In practice this might look something like this:\n * default: [x, yVal]\n * errorBar / customBar: [x, yVal, [yTopVariance, yBottomVariance] ]\n *\n */\n/*global Dygraph:false */\n/*global DygraphLayout:false */\n\n\n\n/**\n *\n * The data handler is responsible for all data specific operations. All of the\n * series data it receives and returns is always in the unified data format.\n * Initially the unified data is created by the extractSeries method\n * @constructor\n */\n\nvar DygraphDataHandler = function DygraphDataHandler() {};\n\nvar handler = DygraphDataHandler;\n\n/**\n * X-value array index constant for unified data samples.\n * @const\n * @type {number}\n */\nhandler.X = 0;\n\n/**\n * Y-value array index constant for unified data samples.\n * @const\n * @type {number}\n */\nhandler.Y = 1;\n\n/**\n * Extras-value array index constant for unified data samples.\n * @const\n * @type {number}\n */\nhandler.EXTRAS = 2;\n\n/**\n * Extracts one series from the raw data (a 2D array) into an array of the\n * unified data format.\n * This is where undesirable points (i.e. negative values on log scales and\n * missing values through which we wish to connect lines) are dropped.\n * TODO(danvk): the \"missing values\" bit above doesn't seem right.\n *\n * @param {!Array.<Array>} rawData The raw data passed into dygraphs where\n *     rawData[i] = [x,ySeries1,...,ySeriesN].\n * @param {!number} seriesIndex Index of the series to extract. All other\n *     series should be ignored.\n * @param {!DygraphOptions} options Dygraph options.\n * @return {Array.<[!number,?number,?]>} The series in the unified data format\n *     where series[i] = [x,y,{extras}].\n */\nhandler.prototype.extractSeries = function (rawData, seriesIndex, options) {};\n\n/**\n * Converts a series to a Point array.  The resulting point array must be\n * returned in increasing order of idx property.\n *\n * @param {!Array.<[!number,?number,?]>} series The series in the unified\n *          data format where series[i] = [x,y,{extras}].\n * @param {!string} setName Name of the series.\n * @param {!number} boundaryIdStart Index offset of the first point, equal to the\n *          number of skipped points left of the date window minimum (if any).\n * @return {!Array.<Dygraph.PointType>} List of points for this series.\n */\nhandler.prototype.seriesToPoints = function (series, setName, boundaryIdStart) {\n  // TODO(bhs): these loops are a hot-spot for high-point-count charts. In\n  // fact,\n  // on chrome+linux, they are 6 times more expensive than iterating through\n  // the\n  // points and drawing the lines. The brunt of the cost comes from allocating\n  // the |point| structures.\n  var points = [];\n  for (var i = 0; i < series.length; ++i) {\n    var item = series[i];\n    var yraw = item[1];\n    var yval = yraw === null ? null : handler.parseFloat(yraw);\n    var point = {\n      x: NaN,\n      y: NaN,\n      xval: handler.parseFloat(item[0]),\n      yval: yval,\n      name: setName, // TODO(danvk): is this really necessary?\n      idx: i + boundaryIdStart\n    };\n    points.push(point);\n  }\n  this.onPointsCreated_(series, points);\n  return points;\n};\n\n/**\n * Callback called for each series after the series points have been generated\n * which will later be used by the plotters to draw the graph.\n * Here data may be added to the seriesPoints which is needed by the plotters.\n * The indexes of series and points are in sync meaning the original data\n * sample for series[i] is points[i].\n *\n * @param {!Array.<[!number,?number,?]>} series The series in the unified\n *     data format where series[i] = [x,y,{extras}].\n * @param {!Array.<Dygraph.PointType>} points The corresponding points passed\n *     to the plotter.\n * @protected\n */\nhandler.prototype.onPointsCreated_ = function (series, points) {};\n\n/**\n * Calculates the rolling average of a data set.\n *\n * @param {!Array.<[!number,?number,?]>} series The series in the unified\n *          data format where series[i] = [x,y,{extras}].\n * @param {!number} rollPeriod The number of points over which to average the data\n * @param {!DygraphOptions} options The dygraph options.\n * @return {!Array.<[!number,?number,?]>} the rolled series.\n */\nhandler.prototype.rollingAverage = function (series, rollPeriod, options) {};\n\n/**\n * Computes the range of the data series (including confidence intervals).\n *\n * @param {!Array.<[!number,?number,?]>} series The series in the unified\n *     data format where series[i] = [x, y, {extras}].\n * @param {!Array.<number>} dateWindow The x-value range to display with\n *     the format: [min, max].\n * @param {!DygraphOptions} options The dygraph options.\n * @return {Array.<number>} The low and high extremes of the series in the\n *     given window with the format: [low, high].\n */\nhandler.prototype.getExtremeYValues = function (series, dateWindow, options) {};\n\n/**\n * Callback called for each series after the layouting data has been\n * calculated before the series is drawn. Here normalized positioning data\n * should be calculated for the extras of each point.\n *\n * @param {!Array.<Dygraph.PointType>} points The points passed to\n *          the plotter.\n * @param {!Object} axis The axis on which the series will be plotted.\n * @param {!boolean} logscale Weather or not to use a logscale.\n */\nhandler.prototype.onLineEvaluated = function (points, axis, logscale) {};\n\n/**\n * Optimized replacement for parseFloat, which was way too slow when almost\n * all values were type number, with few edge cases, none of which were strings.\n * @param {?number} val\n * @return {number}\n * @protected\n */\nhandler.parseFloat = function (val) {\n  // parseFloat(null) is NaN\n  if (val === null) {\n    return NaN;\n  }\n\n  // Assume it's a number or NaN. If it's something else, I'll be shocked.\n  return val;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DygraphDataHandler);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9kYXRhaGFuZGxlci5qcz82ZmRjIl0sIm5hbWVzIjpbIkR5Z3JhcGhEYXRhSGFuZGxlciIsImhhbmRsZXIiLCJYIiwiWSIsIkVYVFJBUyIsInByb3RvdHlwZSIsImV4dHJhY3RTZXJpZXMiLCJyYXdEYXRhIiwic2VyaWVzSW5kZXgiLCJvcHRpb25zIiwic2VyaWVzVG9Qb2ludHMiLCJzZXJpZXMiLCJzZXROYW1lIiwiYm91bmRhcnlJZFN0YXJ0IiwicG9pbnRzIiwiaSIsImxlbmd0aCIsIml0ZW0iLCJ5cmF3IiwieXZhbCIsInBhcnNlRmxvYXQiLCJwb2ludCIsIngiLCJOYU4iLCJ5IiwieHZhbCIsIm5hbWUiLCJpZHgiLCJwdXNoIiwib25Qb2ludHNDcmVhdGVkXyIsInJvbGxpbmdBdmVyYWdlIiwicm9sbFBlcmlvZCIsImdldEV4dHJlbWVZVmFsdWVzIiwiZGF0ZVdpbmRvdyIsIm9uTGluZUV2YWx1YXRlZCIsImF4aXMiLCJsb2dzY2FsZSIsInZhbCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQU1BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FBT0EsSUFBSUEscUJBQXFCLFNBQXJCQSxrQkFBcUIsR0FBWSxDQUNwQyxDQUREOztBQUdBLElBQUlDLFVBQVVELGtCQUFkOztBQUVBOzs7OztBQUtBQyxRQUFRQyxDQUFSLEdBQVksQ0FBWjs7QUFFQTs7Ozs7QUFLQUQsUUFBUUUsQ0FBUixHQUFZLENBQVo7O0FBRUE7Ozs7O0FBS0FGLFFBQVFHLE1BQVIsR0FBaUIsQ0FBakI7O0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQWVBSCxRQUFRSSxTQUFSLENBQWtCQyxhQUFsQixHQUFrQyxVQUFTQyxPQUFULEVBQWtCQyxXQUFsQixFQUErQkMsT0FBL0IsRUFBd0MsQ0FDekUsQ0FERDs7QUFHQTs7Ozs7Ozs7Ozs7QUFXQVIsUUFBUUksU0FBUixDQUFrQkssY0FBbEIsR0FBbUMsVUFBU0MsTUFBVCxFQUFpQkMsT0FBakIsRUFBMEJDLGVBQTFCLEVBQTJDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUlDLFNBQVMsRUFBYjtBQUNBLE9BQU0sSUFBSUMsSUFBSSxDQUFkLEVBQWlCQSxJQUFJSixPQUFPSyxNQUE1QixFQUFvQyxFQUFFRCxDQUF0QyxFQUF5QztBQUN2QyxRQUFJRSxPQUFPTixPQUFPSSxDQUFQLENBQVg7QUFDQSxRQUFJRyxPQUFPRCxLQUFLLENBQUwsQ0FBWDtBQUNBLFFBQUlFLE9BQU9ELFNBQVMsSUFBVCxHQUFnQixJQUFoQixHQUF1QmpCLFFBQVFtQixVQUFSLENBQW1CRixJQUFuQixDQUFsQztBQUNBLFFBQUlHLFFBQVE7QUFDVkMsU0FBSUMsR0FETTtBQUVWQyxTQUFJRCxHQUZNO0FBR1ZFLFlBQU94QixRQUFRbUIsVUFBUixDQUFtQkgsS0FBSyxDQUFMLENBQW5CLENBSEc7QUFJVkUsWUFBT0EsSUFKRztBQUtWTyxZQUFPZCxPQUxHLEVBS007QUFDaEJlLFdBQU1aLElBQUlGO0FBTkEsS0FBWjtBQVFBQyxXQUFPYyxJQUFQLENBQVlQLEtBQVo7QUFDRDtBQUNELE9BQUtRLGdCQUFMLENBQXNCbEIsTUFBdEIsRUFBOEJHLE1BQTlCO0FBQ0EsU0FBT0EsTUFBUDtBQUNELENBeEJEOztBQTBCQTs7Ozs7Ozs7Ozs7OztBQWFBYixRQUFRSSxTQUFSLENBQWtCd0IsZ0JBQWxCLEdBQXFDLFVBQVNsQixNQUFULEVBQWlCRyxNQUFqQixFQUF5QixDQUM3RCxDQUREOztBQUdBOzs7Ozs7Ozs7QUFTQWIsUUFBUUksU0FBUixDQUFrQnlCLGNBQWxCLEdBQW1DLFVBQVNuQixNQUFULEVBQWlCb0IsVUFBakIsRUFBNkJ0QixPQUE3QixFQUFzQyxDQUN4RSxDQUREOztBQUdBOzs7Ozs7Ozs7OztBQVdBUixRQUFRSSxTQUFSLENBQWtCMkIsaUJBQWxCLEdBQXNDLFVBQVNyQixNQUFULEVBQWlCc0IsVUFBakIsRUFBNkJ4QixPQUE3QixFQUFzQyxDQUMzRSxDQUREOztBQUdBOzs7Ozs7Ozs7O0FBVUFSLFFBQVFJLFNBQVIsQ0FBa0I2QixlQUFsQixHQUFvQyxVQUFTcEIsTUFBVCxFQUFpQnFCLElBQWpCLEVBQXVCQyxRQUF2QixFQUFpQyxDQUNwRSxDQUREOztBQUdBOzs7Ozs7O0FBT0FuQyxRQUFRbUIsVUFBUixHQUFxQixVQUFTaUIsR0FBVCxFQUFjO0FBQ2pDO0FBQ0EsTUFBSUEsUUFBUSxJQUFaLEVBQWtCO0FBQ2hCLFdBQU9kLEdBQVA7QUFDRDs7QUFFRDtBQUNBLFNBQU9jLEdBQVA7QUFDRCxDQVJEOztBQVVBLHlEQUFlckMsa0JBQWYiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMyBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBtYW5hZ21lbnQgb2YgZGF0YSBoYW5kbGVyc1xuICogQGF1dGhvciBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqXG4gKiBUaGUgaWRlYSBpcyB0byBkZWZpbmUgYSBjb21tb24sIGdlbmVyaWMgZGF0YSBmb3JtYXQgdGhhdCB3b3JrcyBmb3IgYWxsIGRhdGFcbiAqIHN0cnVjdHVyZXMgc3VwcG9ydGVkIGJ5IGR5Z3JhcGhzLiBUbyBtYWtlIHRoaXMgcG9zc2libGUsIHRoZSBEYXRhSGFuZGxlclxuICogaW50ZXJmYWNlIGlzIGludHJvZHVjZWQuIFRoaXMgbWFrZXMgaXQgcG9zc2libGUsIHRoYXQgZHlncmFwaCBpdHNlbGYgY2FuIHdvcmtcbiAqIHdpdGggdGhlIHNhbWUgbG9naWMgZm9yIGV2ZXJ5IGRhdGEgdHlwZSBpbmRlcGVuZGVudCBvZiB0aGUgYWN0dWFsIGZvcm1hdCBhbmRcbiAqIHRoZSBEYXRhSGFuZGxlciB0YWtlcyBjYXJlIG9mIHRoZSBkYXRhIGZvcm1hdCBzcGVjaWZpYyBqb2JzLlxuICogRGF0YUhhbmRsZXJzIGFyZSBpbXBsZW1lbnRlZCBmb3IgYWxsIGRhdGEgdHlwZXMgc3VwcG9ydGVkIGJ5IER5Z3JhcGhzIGFuZFxuICogcmV0dXJuIER5Z3JhcGhzIGNvbXBsaWFudCBmb3JtYXRzLlxuICogQnkgZGVmYXVsdCB0aGUgY29ycmVjdCBEYXRhSGFuZGxlciBpcyBjaG9zZW4gYmFzZWQgb24gdGhlIG9wdGlvbnMgc2V0LlxuICogT3B0aW9uYWxseSB0aGUgdXNlciBtYXkgdXNlIGhpcyBvd24gRGF0YUhhbmRsZXIgKHNpbWlsYXIgdG8gdGhlIHBsdWdpblxuICogc3lzdGVtKS5cbiAqXG4gKlxuICogVGhlIHVuaWZpZWQgZGF0YSBmb3JtYXQgcmV0dXJlbmQgYnkgZWFjaCBoYW5kbGVyIGlzIGRlZmluZWQgYXMgc286XG4gKiBzZXJpZXNbbl1bcG9pbnRdID0gW3gseSwoZXh0cmFzKV1cbiAqXG4gKiBUaGlzIGZvcm1hdCBjb250YWlucyB0aGUgY29tbW9uIGJhc2lzIHRoYXQgaXMgbmVlZGVkIHRvIGRyYXcgYSBzaW1wbGUgbGluZVxuICogc2VyaWVzIGV4dGVuZGVkIGJ5IG9wdGlvbmFsIGV4dHJhcyBmb3IgbW9yZSBjb21wbGV4IGdyYXBoaW5nIHR5cGVzLiBJdFxuICogY29udGFpbnMgYSBwcmltaXRpdmUgeCB2YWx1ZSBhcyBmaXJzdCBhcnJheSBlbnRyeSwgYSBwcmltaXRpdmUgeSB2YWx1ZSBhc1xuICogc2Vjb25kIGFycmF5IGVudHJ5IGFuZCBhbiBvcHRpb25hbCBleHRyYXMgb2JqZWN0IGZvciBhZGRpdGlvbmFsIGRhdGEgbmVlZGVkLlxuICpcbiAqIHggbXVzdCBhbHdheXMgYmUgYSBudW1iZXIuXG4gKiB5IG11c3QgYWx3YXlzIGJlIGEgbnVtYmVyLCBOYU4gb2YgdHlwZSBudW1iZXIgb3IgbnVsbC5cbiAqIGV4dHJhcyBpcyBvcHRpb25hbCBhbmQgbXVzdCBiZSBpbnRlcnByZXRlZCBieSB0aGUgRGF0YUhhbmRsZXIuIEl0IG1heSBiZSBvZlxuICogYW55IHR5cGUuXG4gKlxuICogSW4gcHJhY3RpY2UgdGhpcyBtaWdodCBsb29rIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4gKiBkZWZhdWx0OiBbeCwgeVZhbF1cbiAqIGVycm9yQmFyIC8gY3VzdG9tQmFyOiBbeCwgeVZhbCwgW3lUb3BWYXJpYW5jZSwgeUJvdHRvbVZhcmlhbmNlXSBdXG4gKlxuICovXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG4vKmdsb2JhbCBEeWdyYXBoTGF5b3V0OmZhbHNlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqXG4gKiBUaGUgZGF0YSBoYW5kbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBhbGwgZGF0YSBzcGVjaWZpYyBvcGVyYXRpb25zLiBBbGwgb2YgdGhlXG4gKiBzZXJpZXMgZGF0YSBpdCByZWNlaXZlcyBhbmQgcmV0dXJucyBpcyBhbHdheXMgaW4gdGhlIHVuaWZpZWQgZGF0YSBmb3JtYXQuXG4gKiBJbml0aWFsbHkgdGhlIHVuaWZpZWQgZGF0YSBpcyBjcmVhdGVkIGJ5IHRoZSBleHRyYWN0U2VyaWVzIG1ldGhvZFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEeWdyYXBoRGF0YUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG59O1xuXG52YXIgaGFuZGxlciA9IER5Z3JhcGhEYXRhSGFuZGxlcjtcblxuLyoqXG4gKiBYLXZhbHVlIGFycmF5IGluZGV4IGNvbnN0YW50IGZvciB1bmlmaWVkIGRhdGEgc2FtcGxlcy5cbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuaGFuZGxlci5YID0gMDtcblxuLyoqXG4gKiBZLXZhbHVlIGFycmF5IGluZGV4IGNvbnN0YW50IGZvciB1bmlmaWVkIGRhdGEgc2FtcGxlcy5cbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuaGFuZGxlci5ZID0gMTtcblxuLyoqXG4gKiBFeHRyYXMtdmFsdWUgYXJyYXkgaW5kZXggY29uc3RhbnQgZm9yIHVuaWZpZWQgZGF0YSBzYW1wbGVzLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5oYW5kbGVyLkVYVFJBUyA9IDI7XG5cbi8qKlxuICogRXh0cmFjdHMgb25lIHNlcmllcyBmcm9tIHRoZSByYXcgZGF0YSAoYSAyRCBhcnJheSkgaW50byBhbiBhcnJheSBvZiB0aGVcbiAqIHVuaWZpZWQgZGF0YSBmb3JtYXQuXG4gKiBUaGlzIGlzIHdoZXJlIHVuZGVzaXJhYmxlIHBvaW50cyAoaS5lLiBuZWdhdGl2ZSB2YWx1ZXMgb24gbG9nIHNjYWxlcyBhbmRcbiAqIG1pc3NpbmcgdmFsdWVzIHRocm91Z2ggd2hpY2ggd2Ugd2lzaCB0byBjb25uZWN0IGxpbmVzKSBhcmUgZHJvcHBlZC5cbiAqIFRPRE8oZGFudmspOiB0aGUgXCJtaXNzaW5nIHZhbHVlc1wiIGJpdCBhYm92ZSBkb2Vzbid0IHNlZW0gcmlnaHQuXG4gKlxuICogQHBhcmFtIHshQXJyYXkuPEFycmF5Pn0gcmF3RGF0YSBUaGUgcmF3IGRhdGEgcGFzc2VkIGludG8gZHlncmFwaHMgd2hlcmVcbiAqICAgICByYXdEYXRhW2ldID0gW3gseVNlcmllczEsLi4uLHlTZXJpZXNOXS5cbiAqIEBwYXJhbSB7IW51bWJlcn0gc2VyaWVzSW5kZXggSW5kZXggb2YgdGhlIHNlcmllcyB0byBleHRyYWN0LiBBbGwgb3RoZXJcbiAqICAgICBzZXJpZXMgc2hvdWxkIGJlIGlnbm9yZWQuXG4gKiBAcGFyYW0geyFEeWdyYXBoT3B0aW9uc30gb3B0aW9ucyBEeWdyYXBoIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtBcnJheS48WyFudW1iZXIsP251bWJlciw/XT59IFRoZSBzZXJpZXMgaW4gdGhlIHVuaWZpZWQgZGF0YSBmb3JtYXRcbiAqICAgICB3aGVyZSBzZXJpZXNbaV0gPSBbeCx5LHtleHRyYXN9XS5cbiAqL1xuaGFuZGxlci5wcm90b3R5cGUuZXh0cmFjdFNlcmllcyA9IGZ1bmN0aW9uKHJhd0RhdGEsIHNlcmllc0luZGV4LCBvcHRpb25zKSB7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc2VyaWVzIHRvIGEgUG9pbnQgYXJyYXkuICBUaGUgcmVzdWx0aW5nIHBvaW50IGFycmF5IG11c3QgYmVcbiAqIHJldHVybmVkIGluIGluY3JlYXNpbmcgb3JkZXIgb2YgaWR4IHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7IUFycmF5LjxbIW51bWJlciw/bnVtYmVyLD9dPn0gc2VyaWVzIFRoZSBzZXJpZXMgaW4gdGhlIHVuaWZpZWRcbiAqICAgICAgICAgIGRhdGEgZm9ybWF0IHdoZXJlIHNlcmllc1tpXSA9IFt4LHkse2V4dHJhc31dLlxuICogQHBhcmFtIHshc3RyaW5nfSBzZXROYW1lIE5hbWUgb2YgdGhlIHNlcmllcy5cbiAqIEBwYXJhbSB7IW51bWJlcn0gYm91bmRhcnlJZFN0YXJ0IEluZGV4IG9mZnNldCBvZiB0aGUgZmlyc3QgcG9pbnQsIGVxdWFsIHRvIHRoZVxuICogICAgICAgICAgbnVtYmVyIG9mIHNraXBwZWQgcG9pbnRzIGxlZnQgb2YgdGhlIGRhdGUgd2luZG93IG1pbmltdW0gKGlmIGFueSkuXG4gKiBAcmV0dXJuIHshQXJyYXkuPER5Z3JhcGguUG9pbnRUeXBlPn0gTGlzdCBvZiBwb2ludHMgZm9yIHRoaXMgc2VyaWVzLlxuICovXG5oYW5kbGVyLnByb3RvdHlwZS5zZXJpZXNUb1BvaW50cyA9IGZ1bmN0aW9uKHNlcmllcywgc2V0TmFtZSwgYm91bmRhcnlJZFN0YXJ0KSB7XG4gIC8vIFRPRE8oYmhzKTogdGhlc2UgbG9vcHMgYXJlIGEgaG90LXNwb3QgZm9yIGhpZ2gtcG9pbnQtY291bnQgY2hhcnRzLiBJblxuICAvLyBmYWN0LFxuICAvLyBvbiBjaHJvbWUrbGludXgsIHRoZXkgYXJlIDYgdGltZXMgbW9yZSBleHBlbnNpdmUgdGhhbiBpdGVyYXRpbmcgdGhyb3VnaFxuICAvLyB0aGVcbiAgLy8gcG9pbnRzIGFuZCBkcmF3aW5nIHRoZSBsaW5lcy4gVGhlIGJydW50IG9mIHRoZSBjb3N0IGNvbWVzIGZyb20gYWxsb2NhdGluZ1xuICAvLyB0aGUgfHBvaW50fCBzdHJ1Y3R1cmVzLlxuICB2YXIgcG9pbnRzID0gW107XG4gIGZvciAoIHZhciBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBpdGVtID0gc2VyaWVzW2ldO1xuICAgIHZhciB5cmF3ID0gaXRlbVsxXTtcbiAgICB2YXIgeXZhbCA9IHlyYXcgPT09IG51bGwgPyBudWxsIDogaGFuZGxlci5wYXJzZUZsb2F0KHlyYXcpO1xuICAgIHZhciBwb2ludCA9IHtcbiAgICAgIHggOiBOYU4sXG4gICAgICB5IDogTmFOLFxuICAgICAgeHZhbCA6IGhhbmRsZXIucGFyc2VGbG9hdChpdGVtWzBdKSxcbiAgICAgIHl2YWwgOiB5dmFsLFxuICAgICAgbmFtZSA6IHNldE5hbWUsIC8vIFRPRE8oZGFudmspOiBpcyB0aGlzIHJlYWxseSBuZWNlc3Nhcnk/XG4gICAgICBpZHggOiBpICsgYm91bmRhcnlJZFN0YXJ0XG4gICAgfTtcbiAgICBwb2ludHMucHVzaChwb2ludCk7XG4gIH1cbiAgdGhpcy5vblBvaW50c0NyZWF0ZWRfKHNlcmllcywgcG9pbnRzKTtcbiAgcmV0dXJuIHBvaW50cztcbn07XG5cbi8qKlxuICogQ2FsbGJhY2sgY2FsbGVkIGZvciBlYWNoIHNlcmllcyBhZnRlciB0aGUgc2VyaWVzIHBvaW50cyBoYXZlIGJlZW4gZ2VuZXJhdGVkXG4gKiB3aGljaCB3aWxsIGxhdGVyIGJlIHVzZWQgYnkgdGhlIHBsb3R0ZXJzIHRvIGRyYXcgdGhlIGdyYXBoLlxuICogSGVyZSBkYXRhIG1heSBiZSBhZGRlZCB0byB0aGUgc2VyaWVzUG9pbnRzIHdoaWNoIGlzIG5lZWRlZCBieSB0aGUgcGxvdHRlcnMuXG4gKiBUaGUgaW5kZXhlcyBvZiBzZXJpZXMgYW5kIHBvaW50cyBhcmUgaW4gc3luYyBtZWFuaW5nIHRoZSBvcmlnaW5hbCBkYXRhXG4gKiBzYW1wbGUgZm9yIHNlcmllc1tpXSBpcyBwb2ludHNbaV0uXG4gKlxuICogQHBhcmFtIHshQXJyYXkuPFshbnVtYmVyLD9udW1iZXIsP10+fSBzZXJpZXMgVGhlIHNlcmllcyBpbiB0aGUgdW5pZmllZFxuICogICAgIGRhdGEgZm9ybWF0IHdoZXJlIHNlcmllc1tpXSA9IFt4LHkse2V4dHJhc31dLlxuICogQHBhcmFtIHshQXJyYXkuPER5Z3JhcGguUG9pbnRUeXBlPn0gcG9pbnRzIFRoZSBjb3JyZXNwb25kaW5nIHBvaW50cyBwYXNzZWRcbiAqICAgICB0byB0aGUgcGxvdHRlci5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuaGFuZGxlci5wcm90b3R5cGUub25Qb2ludHNDcmVhdGVkXyA9IGZ1bmN0aW9uKHNlcmllcywgcG9pbnRzKSB7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHJvbGxpbmcgYXZlcmFnZSBvZiBhIGRhdGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7IUFycmF5LjxbIW51bWJlciw/bnVtYmVyLD9dPn0gc2VyaWVzIFRoZSBzZXJpZXMgaW4gdGhlIHVuaWZpZWRcbiAqICAgICAgICAgIGRhdGEgZm9ybWF0IHdoZXJlIHNlcmllc1tpXSA9IFt4LHkse2V4dHJhc31dLlxuICogQHBhcmFtIHshbnVtYmVyfSByb2xsUGVyaW9kIFRoZSBudW1iZXIgb2YgcG9pbnRzIG92ZXIgd2hpY2ggdG8gYXZlcmFnZSB0aGUgZGF0YVxuICogQHBhcmFtIHshRHlncmFwaE9wdGlvbnN9IG9wdGlvbnMgVGhlIGR5Z3JhcGggb3B0aW9ucy5cbiAqIEByZXR1cm4geyFBcnJheS48WyFudW1iZXIsP251bWJlciw/XT59IHRoZSByb2xsZWQgc2VyaWVzLlxuICovXG5oYW5kbGVyLnByb3RvdHlwZS5yb2xsaW5nQXZlcmFnZSA9IGZ1bmN0aW9uKHNlcmllcywgcm9sbFBlcmlvZCwgb3B0aW9ucykge1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGEgc2VyaWVzIChpbmNsdWRpbmcgY29uZmlkZW5jZSBpbnRlcnZhbHMpLlxuICpcbiAqIEBwYXJhbSB7IUFycmF5LjxbIW51bWJlciw/bnVtYmVyLD9dPn0gc2VyaWVzIFRoZSBzZXJpZXMgaW4gdGhlIHVuaWZpZWRcbiAqICAgICBkYXRhIGZvcm1hdCB3aGVyZSBzZXJpZXNbaV0gPSBbeCwgeSwge2V4dHJhc31dLlxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGRhdGVXaW5kb3cgVGhlIHgtdmFsdWUgcmFuZ2UgdG8gZGlzcGxheSB3aXRoXG4gKiAgICAgdGhlIGZvcm1hdDogW21pbiwgbWF4XS5cbiAqIEBwYXJhbSB7IUR5Z3JhcGhPcHRpb25zfSBvcHRpb25zIFRoZSBkeWdyYXBoIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gVGhlIGxvdyBhbmQgaGlnaCBleHRyZW1lcyBvZiB0aGUgc2VyaWVzIGluIHRoZVxuICogICAgIGdpdmVuIHdpbmRvdyB3aXRoIHRoZSBmb3JtYXQ6IFtsb3csIGhpZ2hdLlxuICovXG5oYW5kbGVyLnByb3RvdHlwZS5nZXRFeHRyZW1lWVZhbHVlcyA9IGZ1bmN0aW9uKHNlcmllcywgZGF0ZVdpbmRvdywgb3B0aW9ucykge1xufTtcblxuLyoqXG4gKiBDYWxsYmFjayBjYWxsZWQgZm9yIGVhY2ggc2VyaWVzIGFmdGVyIHRoZSBsYXlvdXRpbmcgZGF0YSBoYXMgYmVlblxuICogY2FsY3VsYXRlZCBiZWZvcmUgdGhlIHNlcmllcyBpcyBkcmF3bi4gSGVyZSBub3JtYWxpemVkIHBvc2l0aW9uaW5nIGRhdGFcbiAqIHNob3VsZCBiZSBjYWxjdWxhdGVkIGZvciB0aGUgZXh0cmFzIG9mIGVhY2ggcG9pbnQuXG4gKlxuICogQHBhcmFtIHshQXJyYXkuPER5Z3JhcGguUG9pbnRUeXBlPn0gcG9pbnRzIFRoZSBwb2ludHMgcGFzc2VkIHRvXG4gKiAgICAgICAgICB0aGUgcGxvdHRlci5cbiAqIEBwYXJhbSB7IU9iamVjdH0gYXhpcyBUaGUgYXhpcyBvbiB3aGljaCB0aGUgc2VyaWVzIHdpbGwgYmUgcGxvdHRlZC5cbiAqIEBwYXJhbSB7IWJvb2xlYW59IGxvZ3NjYWxlIFdlYXRoZXIgb3Igbm90IHRvIHVzZSBhIGxvZ3NjYWxlLlxuICovXG5oYW5kbGVyLnByb3RvdHlwZS5vbkxpbmVFdmFsdWF0ZWQgPSBmdW5jdGlvbihwb2ludHMsIGF4aXMsIGxvZ3NjYWxlKSB7XG59O1xuXG4vKipcbiAqIE9wdGltaXplZCByZXBsYWNlbWVudCBmb3IgcGFyc2VGbG9hdCwgd2hpY2ggd2FzIHdheSB0b28gc2xvdyB3aGVuIGFsbW9zdFxuICogYWxsIHZhbHVlcyB3ZXJlIHR5cGUgbnVtYmVyLCB3aXRoIGZldyBlZGdlIGNhc2VzLCBub25lIG9mIHdoaWNoIHdlcmUgc3RyaW5ncy5cbiAqIEBwYXJhbSB7P251bWJlcn0gdmFsXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbmhhbmRsZXIucGFyc2VGbG9hdCA9IGZ1bmN0aW9uKHZhbCkge1xuICAvLyBwYXJzZUZsb2F0KG51bGwpIGlzIE5hTlxuICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIC8vIEFzc3VtZSBpdCdzIGEgbnVtYmVyIG9yIE5hTi4gSWYgaXQncyBzb21ldGhpbmcgZWxzZSwgSSdsbCBiZSBzaG9ja2VkLlxuICByZXR1cm4gdmFsO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRHlncmFwaERhdGFIYW5kbGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9keWdyYXBocy9zcmMvZGF0YWhhbmRsZXIvZGF0YWhhbmRsZXIuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__ = __webpack_require__(8);\n/**\n * @license\n * Copyright 2011 Robert Konigsberg (konigsberg@google.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview The default interaction model for Dygraphs. This is kept out\n * of dygraph.js for better navigability.\n * @author Robert Konigsberg (konigsberg@google.com)\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * You can drag this many pixels past the edge of the chart and still have it\n * be considered a zoom. This makes it easier to zoom to the exact edge of the\n * chart, a fairly common operation.\n */\nvar DRAG_EDGE_MARGIN = 100;\n\n/**\n * A collection of functions to facilitate build custom interaction models.\n * @class\n */\nvar DygraphInteraction = {};\n\n/**\n * Checks whether the beginning & ending of an event were close enough that it\n * should be considered a click. If it should, dispatch appropriate events.\n * Returns true if the event was treated as a click.\n *\n * @param {Event} event\n * @param {Dygraph} g\n * @param {Object} context\n */\nDygraphInteraction.maybeTreatMouseOpAsClick = function (event, g, context) {\n  context.dragEndX = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"l\" /* dragGetX_ */](event, context);\n  context.dragEndY = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"m\" /* dragGetY_ */](event, context);\n  var regionWidth = Math.abs(context.dragEndX - context.dragStartX);\n  var regionHeight = Math.abs(context.dragEndY - context.dragStartY);\n\n  if (regionWidth < 2 && regionHeight < 2 && g.lastx_ !== undefined && g.lastx_ != -1) {\n    DygraphInteraction.treatMouseOpAsClick(g, event, context);\n  }\n\n  context.regionWidth = regionWidth;\n  context.regionHeight = regionHeight;\n};\n\n/**\n * Called in response to an interaction model operation that\n * should start the default panning behavior.\n *\n * It's used in the default callback for \"mousedown\" operations.\n * Custom interaction model builders can use it to provide the default\n * panning behavior.\n *\n * @param {Event} event the event object which led to the startPan call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\nDygraphInteraction.startPan = function (event, g, context) {\n  var i, axis;\n  context.isPanning = true;\n  var xRange = g.xAxisRange();\n\n  if (g.getOptionForAxis(\"logscale\", \"x\")) {\n    context.initialLeftmostDate = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](xRange[0]);\n    context.dateRange = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](xRange[1]) - __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](xRange[0]);\n  } else {\n    context.initialLeftmostDate = xRange[0];\n    context.dateRange = xRange[1] - xRange[0];\n  }\n  context.xUnitsPerPixel = context.dateRange / (g.plotter_.area.w - 1);\n\n  if (g.getNumericOption(\"panEdgeFraction\")) {\n    var maxXPixelsToDraw = g.width_ * g.getNumericOption(\"panEdgeFraction\");\n    var xExtremes = g.xAxisExtremes(); // I REALLY WANT TO CALL THIS xTremes!\n\n    var boundedLeftX = g.toDomXCoord(xExtremes[0]) - maxXPixelsToDraw;\n    var boundedRightX = g.toDomXCoord(xExtremes[1]) + maxXPixelsToDraw;\n\n    var boundedLeftDate = g.toDataXCoord(boundedLeftX);\n    var boundedRightDate = g.toDataXCoord(boundedRightX);\n    context.boundedDates = [boundedLeftDate, boundedRightDate];\n\n    var boundedValues = [];\n    var maxYPixelsToDraw = g.height_ * g.getNumericOption(\"panEdgeFraction\");\n\n    for (i = 0; i < g.axes_.length; i++) {\n      axis = g.axes_[i];\n      var yExtremes = axis.extremeRange;\n\n      var boundedTopY = g.toDomYCoord(yExtremes[0], i) + maxYPixelsToDraw;\n      var boundedBottomY = g.toDomYCoord(yExtremes[1], i) - maxYPixelsToDraw;\n\n      var boundedTopValue = g.toDataYCoord(boundedTopY, i);\n      var boundedBottomValue = g.toDataYCoord(boundedBottomY, i);\n\n      boundedValues[i] = [boundedTopValue, boundedBottomValue];\n    }\n    context.boundedValues = boundedValues;\n  }\n\n  // Record the range of each y-axis at the start of the drag.\n  // If any axis has a valueRange, then we want a 2D pan.\n  // We can't store data directly in g.axes_, because it does not belong to us\n  // and could change out from under us during a pan (say if there's a data\n  // update).\n  context.is2DPan = false;\n  context.axes = [];\n  for (i = 0; i < g.axes_.length; i++) {\n    axis = g.axes_[i];\n    var axis_data = {};\n    var yRange = g.yAxisRange(i);\n    // TODO(konigsberg): These values should be in |context|.\n    // In log scale, initialTopValue, dragValueRange and unitsPerPixel are log scale.\n    var logscale = g.attributes_.getForAxis(\"logscale\", i);\n    if (logscale) {\n      axis_data.initialTopValue = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](yRange[1]);\n      axis_data.dragValueRange = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](yRange[1]) - __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](yRange[0]);\n    } else {\n      axis_data.initialTopValue = yRange[1];\n      axis_data.dragValueRange = yRange[1] - yRange[0];\n    }\n    axis_data.unitsPerPixel = axis_data.dragValueRange / (g.plotter_.area.h - 1);\n    context.axes.push(axis_data);\n\n    // While calculating axes, set 2dpan.\n    if (axis.valueRange) context.is2DPan = true;\n  }\n};\n\n/**\n * Called in response to an interaction model operation that\n * responds to an event that pans the view.\n *\n * It's used in the default callback for \"mousemove\" operations.\n * Custom interaction model builders can use it to provide the default\n * panning behavior.\n *\n * @param {Event} event the event object which led to the movePan call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\nDygraphInteraction.movePan = function (event, g, context) {\n  context.dragEndX = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"l\" /* dragGetX_ */](event, context);\n  context.dragEndY = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"m\" /* dragGetY_ */](event, context);\n\n  var minDate = context.initialLeftmostDate - (context.dragEndX - context.dragStartX) * context.xUnitsPerPixel;\n  if (context.boundedDates) {\n    minDate = Math.max(minDate, context.boundedDates[0]);\n  }\n  var maxDate = minDate + context.dateRange;\n  if (context.boundedDates) {\n    if (maxDate > context.boundedDates[1]) {\n      // Adjust minDate, and recompute maxDate.\n      minDate = minDate - (maxDate - context.boundedDates[1]);\n      maxDate = minDate + context.dateRange;\n    }\n  }\n\n  if (g.getOptionForAxis(\"logscale\", \"x\")) {\n    g.dateWindow_ = [Math.pow(__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"N\" /* LOG_SCALE */], minDate), Math.pow(__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"N\" /* LOG_SCALE */], maxDate)];\n  } else {\n    g.dateWindow_ = [minDate, maxDate];\n  }\n\n  // y-axis scaling is automatic unless this is a full 2D pan.\n  if (context.is2DPan) {\n\n    var pixelsDragged = context.dragEndY - context.dragStartY;\n\n    // Adjust each axis appropriately.\n    for (var i = 0; i < g.axes_.length; i++) {\n      var axis = g.axes_[i];\n      var axis_data = context.axes[i];\n      var unitsDragged = pixelsDragged * axis_data.unitsPerPixel;\n\n      var boundedValue = context.boundedValues ? context.boundedValues[i] : null;\n\n      // In log scale, maxValue and minValue are the logs of those values.\n      var maxValue = axis_data.initialTopValue + unitsDragged;\n      if (boundedValue) {\n        maxValue = Math.min(maxValue, boundedValue[1]);\n      }\n      var minValue = maxValue - axis_data.dragValueRange;\n      if (boundedValue) {\n        if (minValue < boundedValue[0]) {\n          // Adjust maxValue, and recompute minValue.\n          maxValue = maxValue - (minValue - boundedValue[0]);\n          minValue = maxValue - axis_data.dragValueRange;\n        }\n      }\n      if (g.attributes_.getForAxis(\"logscale\", i)) {\n        axis.valueRange = [Math.pow(__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"N\" /* LOG_SCALE */], minValue), Math.pow(__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"N\" /* LOG_SCALE */], maxValue)];\n      } else {\n        axis.valueRange = [minValue, maxValue];\n      }\n    }\n  }\n\n  g.drawGraph_(false);\n};\n\n/**\n * Called in response to an interaction model operation that\n * responds to an event that ends panning.\n *\n * It's used in the default callback for \"mouseup\" operations.\n * Custom interaction model builders can use it to provide the default\n * panning behavior.\n *\n * @param {Event} event the event object which led to the endPan call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\nDygraphInteraction.endPan = DygraphInteraction.maybeTreatMouseOpAsClick;\n\n/**\n * Called in response to an interaction model operation that\n * responds to an event that starts zooming.\n *\n * It's used in the default callback for \"mousedown\" operations.\n * Custom interaction model builders can use it to provide the default\n * zooming behavior.\n *\n * @param {Event} event the event object which led to the startZoom call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\nDygraphInteraction.startZoom = function (event, g, context) {\n  context.isZooming = true;\n  context.zoomMoved = false;\n};\n\n/**\n * Called in response to an interaction model operation that\n * responds to an event that defines zoom boundaries.\n *\n * It's used in the default callback for \"mousemove\" operations.\n * Custom interaction model builders can use it to provide the default\n * zooming behavior.\n *\n * @param {Event} event the event object which led to the moveZoom call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\nDygraphInteraction.moveZoom = function (event, g, context) {\n  context.zoomMoved = true;\n  context.dragEndX = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"l\" /* dragGetX_ */](event, context);\n  context.dragEndY = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"m\" /* dragGetY_ */](event, context);\n\n  var xDelta = Math.abs(context.dragStartX - context.dragEndX);\n  var yDelta = Math.abs(context.dragStartY - context.dragEndY);\n\n  // drag direction threshold for y axis is twice as large as x axis\n  context.dragDirection = xDelta < yDelta / 2 ? __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"o\" /* VERTICAL */] : __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"n\" /* HORIZONTAL */];\n\n  g.drawZoomRect_(context.dragDirection, context.dragStartX, context.dragEndX, context.dragStartY, context.dragEndY, context.prevDragDirection, context.prevEndX, context.prevEndY);\n\n  context.prevEndX = context.dragEndX;\n  context.prevEndY = context.dragEndY;\n  context.prevDragDirection = context.dragDirection;\n};\n\n/**\n * TODO(danvk): move this logic into dygraph.js\n * @param {Dygraph} g\n * @param {Event} event\n * @param {Object} context\n */\nDygraphInteraction.treatMouseOpAsClick = function (g, event, context) {\n  var clickCallback = g.getFunctionOption('clickCallback');\n  var pointClickCallback = g.getFunctionOption('pointClickCallback');\n\n  var selectedPoint = null;\n\n  // Find out if the click occurs on a point.\n  var closestIdx = -1;\n  var closestDistance = Number.MAX_VALUE;\n\n  // check if the click was on a particular point.\n  for (var i = 0; i < g.selPoints_.length; i++) {\n    var p = g.selPoints_[i];\n    var distance = Math.pow(p.canvasx - context.dragEndX, 2) + Math.pow(p.canvasy - context.dragEndY, 2);\n    if (!isNaN(distance) && (closestIdx == -1 || distance < closestDistance)) {\n      closestDistance = distance;\n      closestIdx = i;\n    }\n  }\n\n  // Allow any click within two pixels of the dot.\n  var radius = g.getNumericOption('highlightCircleSize') + 2;\n  if (closestDistance <= radius * radius) {\n    selectedPoint = g.selPoints_[closestIdx];\n  }\n\n  if (selectedPoint) {\n    var e = {\n      cancelable: true,\n      point: selectedPoint,\n      canvasx: context.dragEndX,\n      canvasy: context.dragEndY\n    };\n    var defaultPrevented = g.cascadeEvents_('pointClick', e);\n    if (defaultPrevented) {\n      // Note: this also prevents click / clickCallback from firing.\n      return;\n    }\n    if (pointClickCallback) {\n      pointClickCallback.call(g, event, selectedPoint);\n    }\n  }\n\n  var e = {\n    cancelable: true,\n    xval: g.lastx_, // closest point by x value\n    pts: g.selPoints_,\n    canvasx: context.dragEndX,\n    canvasy: context.dragEndY\n  };\n  if (!g.cascadeEvents_('click', e)) {\n    if (clickCallback) {\n      // TODO(danvk): pass along more info about the points, e.g. 'x'\n      clickCallback.call(g, event, g.lastx_, g.selPoints_);\n    }\n  }\n};\n\n/**\n * Called in response to an interaction model operation that\n * responds to an event that performs a zoom based on previously defined\n * bounds..\n *\n * It's used in the default callback for \"mouseup\" operations.\n * Custom interaction model builders can use it to provide the default\n * zooming behavior.\n *\n * @param {Event} event the event object which led to the endZoom call.\n * @param {Dygraph} g The dygraph on which to end the zoom.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\nDygraphInteraction.endZoom = function (event, g, context) {\n  g.clearZoomRect_();\n  context.isZooming = false;\n  DygraphInteraction.maybeTreatMouseOpAsClick(event, g, context);\n\n  // The zoom rectangle is visibly clipped to the plot area, so its behavior\n  // should be as well.\n  // See http://code.google.com/p/dygraphs/issues/detail?id=280\n  var plotArea = g.getArea();\n  if (context.regionWidth >= 10 && context.dragDirection == __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"n\" /* HORIZONTAL */]) {\n    var left = Math.min(context.dragStartX, context.dragEndX),\n        right = Math.max(context.dragStartX, context.dragEndX);\n    left = Math.max(left, plotArea.x);\n    right = Math.min(right, plotArea.x + plotArea.w);\n    if (left < right) {\n      g.doZoomX_(left, right);\n    }\n    context.cancelNextDblclick = true;\n  } else if (context.regionHeight >= 10 && context.dragDirection == __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"o\" /* VERTICAL */]) {\n    var top = Math.min(context.dragStartY, context.dragEndY),\n        bottom = Math.max(context.dragStartY, context.dragEndY);\n    top = Math.max(top, plotArea.y);\n    bottom = Math.min(bottom, plotArea.y + plotArea.h);\n    if (top < bottom) {\n      g.doZoomY_(top, bottom);\n    }\n    context.cancelNextDblclick = true;\n  }\n  context.dragStartX = null;\n  context.dragStartY = null;\n};\n\n/**\n * @private\n */\nDygraphInteraction.startTouch = function (event, g, context) {\n  event.preventDefault(); // touch browsers are all nice.\n  if (event.touches.length > 1) {\n    // If the user ever puts two fingers down, it's not a double tap.\n    context.startTimeForDoubleTapMs = null;\n  }\n\n  var touches = [];\n  for (var i = 0; i < event.touches.length; i++) {\n    var t = event.touches[i];\n    // we dispense with 'dragGetX_' because all touchBrowsers support pageX\n    touches.push({\n      pageX: t.pageX,\n      pageY: t.pageY,\n      dataX: g.toDataXCoord(t.pageX),\n      dataY: g.toDataYCoord(t.pageY)\n      // identifier: t.identifier\n    });\n  }\n  context.initialTouches = touches;\n\n  if (touches.length == 1) {\n    // This is just a swipe.\n    context.initialPinchCenter = touches[0];\n    context.touchDirections = { x: true, y: true };\n  } else if (touches.length >= 2) {\n    // It's become a pinch!\n    // In case there are 3+ touches, we ignore all but the \"first\" two.\n\n    // only screen coordinates can be averaged (data coords could be log scale).\n    context.initialPinchCenter = {\n      pageX: 0.5 * (touches[0].pageX + touches[1].pageX),\n      pageY: 0.5 * (touches[0].pageY + touches[1].pageY),\n\n      // TODO(danvk): remove\n      dataX: 0.5 * (touches[0].dataX + touches[1].dataX),\n      dataY: 0.5 * (touches[0].dataY + touches[1].dataY)\n    };\n\n    // Make pinches in a 45-degree swath around either axis 1-dimensional zooms.\n    var initialAngle = 180 / Math.PI * Math.atan2(context.initialPinchCenter.pageY - touches[0].pageY, touches[0].pageX - context.initialPinchCenter.pageX);\n\n    // use symmetry to get it into the first quadrant.\n    initialAngle = Math.abs(initialAngle);\n    if (initialAngle > 90) initialAngle = 90 - initialAngle;\n\n    context.touchDirections = {\n      x: initialAngle < 90 - 45 / 2,\n      y: initialAngle > 45 / 2\n    };\n  }\n\n  // save the full x & y ranges.\n  context.initialRange = {\n    x: g.xAxisRange(),\n    y: g.yAxisRange()\n  };\n};\n\n/**\n * @private\n */\nDygraphInteraction.moveTouch = function (event, g, context) {\n  // If the tap moves, then it's definitely not part of a double-tap.\n  context.startTimeForDoubleTapMs = null;\n\n  var i,\n      touches = [];\n  for (i = 0; i < event.touches.length; i++) {\n    var t = event.touches[i];\n    touches.push({\n      pageX: t.pageX,\n      pageY: t.pageY\n    });\n  }\n  var initialTouches = context.initialTouches;\n\n  var c_now;\n\n  // old and new centers.\n  var c_init = context.initialPinchCenter;\n  if (touches.length == 1) {\n    c_now = touches[0];\n  } else {\n    c_now = {\n      pageX: 0.5 * (touches[0].pageX + touches[1].pageX),\n      pageY: 0.5 * (touches[0].pageY + touches[1].pageY)\n    };\n  }\n\n  // this is the \"swipe\" component\n  // we toss it out for now, but could use it in the future.\n  var swipe = {\n    pageX: c_now.pageX - c_init.pageX,\n    pageY: c_now.pageY - c_init.pageY\n  };\n  var dataWidth = context.initialRange.x[1] - context.initialRange.x[0];\n  var dataHeight = context.initialRange.y[0] - context.initialRange.y[1];\n  swipe.dataX = swipe.pageX / g.plotter_.area.w * dataWidth;\n  swipe.dataY = swipe.pageY / g.plotter_.area.h * dataHeight;\n  var xScale, yScale;\n\n  // The residual bits are usually split into scale & rotate bits, but we split\n  // them into x-scale and y-scale bits.\n  if (touches.length == 1) {\n    xScale = 1.0;\n    yScale = 1.0;\n  } else if (touches.length >= 2) {\n    var initHalfWidth = initialTouches[1].pageX - c_init.pageX;\n    xScale = (touches[1].pageX - c_now.pageX) / initHalfWidth;\n\n    var initHalfHeight = initialTouches[1].pageY - c_init.pageY;\n    yScale = (touches[1].pageY - c_now.pageY) / initHalfHeight;\n  }\n\n  // Clip scaling to [1/8, 8] to prevent too much blowup.\n  xScale = Math.min(8, Math.max(0.125, xScale));\n  yScale = Math.min(8, Math.max(0.125, yScale));\n\n  var didZoom = false;\n  if (context.touchDirections.x) {\n    g.dateWindow_ = [c_init.dataX - swipe.dataX + (context.initialRange.x[0] - c_init.dataX) / xScale, c_init.dataX - swipe.dataX + (context.initialRange.x[1] - c_init.dataX) / xScale];\n    didZoom = true;\n  }\n\n  if (context.touchDirections.y) {\n    for (i = 0; i < 1 /*g.axes_.length*/; i++) {\n      var axis = g.axes_[i];\n      var logscale = g.attributes_.getForAxis(\"logscale\", i);\n      if (logscale) {\n        // TODO(danvk): implement\n      } else {\n        axis.valueRange = [c_init.dataY - swipe.dataY + (context.initialRange.y[0] - c_init.dataY) / yScale, c_init.dataY - swipe.dataY + (context.initialRange.y[1] - c_init.dataY) / yScale];\n        didZoom = true;\n      }\n    }\n  }\n\n  g.drawGraph_(false);\n\n  // We only call zoomCallback on zooms, not pans, to mirror desktop behavior.\n  if (didZoom && touches.length > 1 && g.getFunctionOption('zoomCallback')) {\n    var viewWindow = g.xAxisRange();\n    g.getFunctionOption(\"zoomCallback\").call(g, viewWindow[0], viewWindow[1], g.yAxisRanges());\n  }\n};\n\n/**\n * @private\n */\nDygraphInteraction.endTouch = function (event, g, context) {\n  if (event.touches.length !== 0) {\n    // this is effectively a \"reset\"\n    DygraphInteraction.startTouch(event, g, context);\n  } else if (event.changedTouches.length == 1) {\n    // Could be part of a \"double tap\"\n    // The heuristic here is that it's a double-tap if the two touchend events\n    // occur within 500ms and within a 50x50 pixel box.\n    var now = new Date().getTime();\n    var t = event.changedTouches[0];\n    if (context.startTimeForDoubleTapMs && now - context.startTimeForDoubleTapMs < 500 && context.doubleTapX && Math.abs(context.doubleTapX - t.screenX) < 50 && context.doubleTapY && Math.abs(context.doubleTapY - t.screenY) < 50) {\n      g.resetZoom();\n    } else {\n      context.startTimeForDoubleTapMs = now;\n      context.doubleTapX = t.screenX;\n      context.doubleTapY = t.screenY;\n    }\n  }\n};\n\n// Determine the distance from x to [left, right].\nvar distanceFromInterval = function distanceFromInterval(x, left, right) {\n  if (x < left) {\n    return left - x;\n  } else if (x > right) {\n    return x - right;\n  } else {\n    return 0;\n  }\n};\n\n/**\n * Returns the number of pixels by which the event happens from the nearest\n * edge of the chart. For events in the interior of the chart, this returns zero.\n */\nvar distanceFromChart = function distanceFromChart(event, g) {\n  var chartPos = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"k\" /* findPos */](g.canvas_);\n  var box = {\n    left: chartPos.x,\n    right: chartPos.x + g.canvas_.offsetWidth,\n    top: chartPos.y,\n    bottom: chartPos.y + g.canvas_.offsetHeight\n  };\n\n  var pt = {\n    x: __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"q\" /* pageX */](event),\n    y: __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"r\" /* pageY */](event)\n  };\n\n  var dx = distanceFromInterval(pt.x, box.left, box.right),\n      dy = distanceFromInterval(pt.y, box.top, box.bottom);\n  return Math.max(dx, dy);\n};\n\n/**\n * Default interation model for dygraphs. You can refer to specific elements of\n * this when constructing your own interaction model, e.g.:\n * g.updateOptions( {\n *   interactionModel: {\n *     mousedown: DygraphInteraction.defaultInteractionModel.mousedown\n *   }\n * } );\n */\nDygraphInteraction.defaultModel = {\n  // Track the beginning of drag events\n  mousedown: function mousedown(event, g, context) {\n    // Right-click should not initiate a zoom.\n    if (event.button && event.button == 2) return;\n\n    context.initializeMouseDown(event, g, context);\n\n    if (event.altKey || event.shiftKey) {\n      DygraphInteraction.startPan(event, g, context);\n    } else {\n      DygraphInteraction.startZoom(event, g, context);\n    }\n\n    // Note: we register mousemove/mouseup on document to allow some leeway for\n    // events to move outside of the chart. Interaction model events get\n    // registered on the canvas, which is too small to allow this.\n    var mousemove = function mousemove(event) {\n      if (context.isZooming) {\n        // When the mouse moves >200px from the chart edge, cancel the zoom.\n        var d = distanceFromChart(event, g);\n        if (d < DRAG_EDGE_MARGIN) {\n          DygraphInteraction.moveZoom(event, g, context);\n        } else {\n          if (context.dragEndX !== null) {\n            context.dragEndX = null;\n            context.dragEndY = null;\n            g.clearZoomRect_();\n          }\n        }\n      } else if (context.isPanning) {\n        DygraphInteraction.movePan(event, g, context);\n      }\n    };\n    var mouseup = function mouseup(event) {\n      if (context.isZooming) {\n        if (context.dragEndX !== null) {\n          DygraphInteraction.endZoom(event, g, context);\n        } else {\n          DygraphInteraction.maybeTreatMouseOpAsClick(event, g, context);\n        }\n      } else if (context.isPanning) {\n        DygraphInteraction.endPan(event, g, context);\n      }\n\n      __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"i\" /* removeEvent */](document, 'mousemove', mousemove);\n      __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"i\" /* removeEvent */](document, 'mouseup', mouseup);\n      context.destroy();\n    };\n\n    g.addAndTrackEvent(document, 'mousemove', mousemove);\n    g.addAndTrackEvent(document, 'mouseup', mouseup);\n  },\n  willDestroyContextMyself: true,\n\n  touchstart: function touchstart(event, g, context) {\n    DygraphInteraction.startTouch(event, g, context);\n  },\n  touchmove: function touchmove(event, g, context) {\n    DygraphInteraction.moveTouch(event, g, context);\n  },\n  touchend: function touchend(event, g, context) {\n    DygraphInteraction.endTouch(event, g, context);\n  },\n\n  // Disable zooming out if panning.\n  dblclick: function dblclick(event, g, context) {\n    if (context.cancelNextDblclick) {\n      context.cancelNextDblclick = false;\n      return;\n    }\n\n    // Give plugins a chance to grab this event.\n    var e = {\n      canvasx: context.dragEndX,\n      canvasy: context.dragEndY,\n      cancelable: true\n    };\n    if (g.cascadeEvents_('dblclick', e)) {\n      return;\n    }\n\n    if (event.altKey || event.shiftKey) {\n      return;\n    }\n    g.resetZoom();\n  }\n};\n\n/*\nDygraph.DEFAULT_ATTRS.interactionModel = DygraphInteraction.defaultModel;\n\n// old ways of accessing these methods/properties\nDygraph.defaultInteractionModel = DygraphInteraction.defaultModel;\nDygraph.endZoom = DygraphInteraction.endZoom;\nDygraph.moveZoom = DygraphInteraction.moveZoom;\nDygraph.startZoom = DygraphInteraction.startZoom;\nDygraph.endPan = DygraphInteraction.endPan;\nDygraph.movePan = DygraphInteraction.movePan;\nDygraph.startPan = DygraphInteraction.startPan;\n*/\n\nDygraphInteraction.nonInteractiveModel_ = {\n  mousedown: function mousedown(event, g, context) {\n    context.initializeMouseDown(event, g, context);\n  },\n  mouseup: DygraphInteraction.maybeTreatMouseOpAsClick\n};\n\n// Default interaction model when using the range selector.\nDygraphInteraction.dragIsPanInteractionModel = {\n  mousedown: function mousedown(event, g, context) {\n    context.initializeMouseDown(event, g, context);\n    DygraphInteraction.startPan(event, g, context);\n  },\n  mousemove: function mousemove(event, g, context) {\n    if (context.isPanning) {\n      DygraphInteraction.movePan(event, g, context);\n    }\n  },\n  mouseup: function mouseup(event, g, context) {\n    if (context.isPanning) {\n      DygraphInteraction.endPan(event, g, context);\n    }\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DygraphInteraction);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLWludGVyYWN0aW9uLW1vZGVsLmpzP2IzZWQiXSwibmFtZXMiOlsiRFJBR19FREdFX01BUkdJTiIsIkR5Z3JhcGhJbnRlcmFjdGlvbiIsIm1heWJlVHJlYXRNb3VzZU9wQXNDbGljayIsImV2ZW50IiwiZyIsImNvbnRleHQiLCJkcmFnRW5kWCIsImRyYWdFbmRZIiwicmVnaW9uV2lkdGgiLCJNYXRoIiwiYWJzIiwiZHJhZ1N0YXJ0WCIsInJlZ2lvbkhlaWdodCIsImRyYWdTdGFydFkiLCJsYXN0eF8iLCJ1bmRlZmluZWQiLCJ0cmVhdE1vdXNlT3BBc0NsaWNrIiwic3RhcnRQYW4iLCJpIiwiYXhpcyIsImlzUGFubmluZyIsInhSYW5nZSIsInhBeGlzUmFuZ2UiLCJnZXRPcHRpb25Gb3JBeGlzIiwiaW5pdGlhbExlZnRtb3N0RGF0ZSIsImRhdGVSYW5nZSIsInhVbml0c1BlclBpeGVsIiwicGxvdHRlcl8iLCJhcmVhIiwidyIsImdldE51bWVyaWNPcHRpb24iLCJtYXhYUGl4ZWxzVG9EcmF3Iiwid2lkdGhfIiwieEV4dHJlbWVzIiwieEF4aXNFeHRyZW1lcyIsImJvdW5kZWRMZWZ0WCIsInRvRG9tWENvb3JkIiwiYm91bmRlZFJpZ2h0WCIsImJvdW5kZWRMZWZ0RGF0ZSIsInRvRGF0YVhDb29yZCIsImJvdW5kZWRSaWdodERhdGUiLCJib3VuZGVkRGF0ZXMiLCJib3VuZGVkVmFsdWVzIiwibWF4WVBpeGVsc1RvRHJhdyIsImhlaWdodF8iLCJheGVzXyIsImxlbmd0aCIsInlFeHRyZW1lcyIsImV4dHJlbWVSYW5nZSIsImJvdW5kZWRUb3BZIiwidG9Eb21ZQ29vcmQiLCJib3VuZGVkQm90dG9tWSIsImJvdW5kZWRUb3BWYWx1ZSIsInRvRGF0YVlDb29yZCIsImJvdW5kZWRCb3R0b21WYWx1ZSIsImlzMkRQYW4iLCJheGVzIiwiYXhpc19kYXRhIiwieVJhbmdlIiwieUF4aXNSYW5nZSIsImxvZ3NjYWxlIiwiYXR0cmlidXRlc18iLCJnZXRGb3JBeGlzIiwiaW5pdGlhbFRvcFZhbHVlIiwiZHJhZ1ZhbHVlUmFuZ2UiLCJ1bml0c1BlclBpeGVsIiwiaCIsInB1c2giLCJ2YWx1ZVJhbmdlIiwibW92ZVBhbiIsIm1pbkRhdGUiLCJtYXgiLCJtYXhEYXRlIiwiZGF0ZVdpbmRvd18iLCJwb3ciLCJwaXhlbHNEcmFnZ2VkIiwidW5pdHNEcmFnZ2VkIiwiYm91bmRlZFZhbHVlIiwibWF4VmFsdWUiLCJtaW4iLCJtaW5WYWx1ZSIsImRyYXdHcmFwaF8iLCJlbmRQYW4iLCJzdGFydFpvb20iLCJpc1pvb21pbmciLCJ6b29tTW92ZWQiLCJtb3ZlWm9vbSIsInhEZWx0YSIsInlEZWx0YSIsImRyYWdEaXJlY3Rpb24iLCJkcmF3Wm9vbVJlY3RfIiwicHJldkRyYWdEaXJlY3Rpb24iLCJwcmV2RW5kWCIsInByZXZFbmRZIiwiY2xpY2tDYWxsYmFjayIsImdldEZ1bmN0aW9uT3B0aW9uIiwicG9pbnRDbGlja0NhbGxiYWNrIiwic2VsZWN0ZWRQb2ludCIsImNsb3Nlc3RJZHgiLCJjbG9zZXN0RGlzdGFuY2UiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJzZWxQb2ludHNfIiwicCIsImRpc3RhbmNlIiwiY2FudmFzeCIsImNhbnZhc3kiLCJpc05hTiIsInJhZGl1cyIsImUiLCJjYW5jZWxhYmxlIiwicG9pbnQiLCJkZWZhdWx0UHJldmVudGVkIiwiY2FzY2FkZUV2ZW50c18iLCJjYWxsIiwieHZhbCIsInB0cyIsImVuZFpvb20iLCJjbGVhclpvb21SZWN0XyIsInBsb3RBcmVhIiwiZ2V0QXJlYSIsImxlZnQiLCJyaWdodCIsIngiLCJkb1pvb21YXyIsImNhbmNlbE5leHREYmxjbGljayIsInRvcCIsImJvdHRvbSIsInkiLCJkb1pvb21ZXyIsInN0YXJ0VG91Y2giLCJwcmV2ZW50RGVmYXVsdCIsInRvdWNoZXMiLCJzdGFydFRpbWVGb3JEb3VibGVUYXBNcyIsInQiLCJwYWdlWCIsInBhZ2VZIiwiZGF0YVgiLCJkYXRhWSIsImluaXRpYWxUb3VjaGVzIiwiaW5pdGlhbFBpbmNoQ2VudGVyIiwidG91Y2hEaXJlY3Rpb25zIiwiaW5pdGlhbEFuZ2xlIiwiUEkiLCJhdGFuMiIsImluaXRpYWxSYW5nZSIsIm1vdmVUb3VjaCIsImNfbm93IiwiY19pbml0Iiwic3dpcGUiLCJkYXRhV2lkdGgiLCJkYXRhSGVpZ2h0IiwieFNjYWxlIiwieVNjYWxlIiwiaW5pdEhhbGZXaWR0aCIsImluaXRIYWxmSGVpZ2h0IiwiZGlkWm9vbSIsInZpZXdXaW5kb3ciLCJ5QXhpc1JhbmdlcyIsImVuZFRvdWNoIiwiY2hhbmdlZFRvdWNoZXMiLCJub3ciLCJEYXRlIiwiZ2V0VGltZSIsImRvdWJsZVRhcFgiLCJzY3JlZW5YIiwiZG91YmxlVGFwWSIsInNjcmVlblkiLCJyZXNldFpvb20iLCJkaXN0YW5jZUZyb21JbnRlcnZhbCIsImRpc3RhbmNlRnJvbUNoYXJ0IiwiY2hhcnRQb3MiLCJjYW52YXNfIiwiYm94Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJwdCIsImR4IiwiZHkiLCJkZWZhdWx0TW9kZWwiLCJtb3VzZWRvd24iLCJidXR0b24iLCJpbml0aWFsaXplTW91c2VEb3duIiwiYWx0S2V5Iiwic2hpZnRLZXkiLCJtb3VzZW1vdmUiLCJkIiwibW91c2V1cCIsInV0aWxzIiwiZG9jdW1lbnQiLCJkZXN0cm95IiwiYWRkQW5kVHJhY2tFdmVudCIsIndpbGxEZXN0cm95Q29udGV4dE15c2VsZiIsInRvdWNoc3RhcnQiLCJ0b3VjaG1vdmUiLCJ0b3VjaGVuZCIsImRibGNsaWNrIiwibm9uSW50ZXJhY3RpdmVNb2RlbF8iLCJkcmFnSXNQYW5JbnRlcmFjdGlvbk1vZGVsIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7QUFLQSxJQUFJQSxtQkFBbUIsR0FBdkI7O0FBRUE7Ozs7QUFJQSxJQUFJQyxxQkFBcUIsRUFBekI7O0FBRUE7Ozs7Ozs7OztBQVNBQSxtQkFBbUJDLHdC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QUFuQixDQUE0QmQsS0FBNUIsRUFBbUNDLENBQW5DLEVBQXNDQyxPQUF0QztBQUNELEdBSjRDO0FBSzdDb0wsYUFBVyxtQkFBU3RMLEtBQVQsRUFBZ0JDLENBQWhCLEVBQW1CQyxPQUFuQixFQUE0QjtBQUNyQyxRQUFJQSxRQUFRZSxTQUFaLEVBQXVCO0FBQ3JCbkIseUJBQW1Cb0UsT0FBbkIsQ0FBMkJsRSxLQUEzQixFQUFrQ0MsQ0FBbEMsRUFBcUNDLE9BQXJDO0FBQ0Q7QUFDRixHQVQ0QztBQVU3Q3NMLFdBQVMsaUJBQVN4TCxLQUFULEVBQWdCQyxDQUFoQixFQUFtQkMsT0FBbkIsRUFBNEI7QUFDbkMsUUFBSUEsUUFBUWUsU0FBWixFQUF1QjtBQUNyQm5CLHlCQUFtQmlGLE1BQW5CLENBQTBCL0UsS0FBMUIsRUFBaUNDLENBQWpDLEVBQW9DQyxPQUFwQztBQUNEO0FBQ0Y7QUFkNEMsQ0FBL0M7O0FBaUJBLHlEQUFlSixrQkFBZiIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDExIFJvYmVydCBLb25pZ3NiZXJnIChrb25pZ3NiZXJnQGdvb2dsZS5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoZSBkZWZhdWx0IGludGVyYWN0aW9uIG1vZGVsIGZvciBEeWdyYXBocy4gVGhpcyBpcyBrZXB0IG91dFxuICogb2YgZHlncmFwaC5qcyBmb3IgYmV0dGVyIG5hdmlnYWJpbGl0eS5cbiAqIEBhdXRob3IgUm9iZXJ0IEtvbmlnc2JlcmcgKGtvbmlnc2JlcmdAZ29vZ2xlLmNvbSlcbiAqL1xuXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi9keWdyYXBoLXV0aWxzJztcblxuLyoqXG4gKiBZb3UgY2FuIGRyYWcgdGhpcyBtYW55IHBpeGVscyBwYXN0IHRoZSBlZGdlIG9mIHRoZSBjaGFydCBhbmQgc3RpbGwgaGF2ZSBpdFxuICogYmUgY29uc2lkZXJlZCBhIHpvb20uIFRoaXMgbWFrZXMgaXQgZWFzaWVyIHRvIHpvb20gdG8gdGhlIGV4YWN0IGVkZ2Ugb2YgdGhlXG4gKiBjaGFydCwgYSBmYWlybHkgY29tbW9uIG9wZXJhdGlvbi5cbiAqL1xudmFyIERSQUdfRURHRV9NQVJHSU4gPSAxMDA7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyB0byBmYWNpbGl0YXRlIGJ1aWxkIGN1c3RvbSBpbnRlcmFjdGlvbiBtb2RlbHMuXG4gKiBAY2xhc3NcbiAqL1xudmFyIER5Z3JhcGhJbnRlcmFjdGlvbiA9IHt9O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBiZWdpbm5pbmcgJiBlbmRpbmcgb2YgYW4gZXZlbnQgd2VyZSBjbG9zZSBlbm91Z2ggdGhhdCBpdFxuICogc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjbGljay4gSWYgaXQgc2hvdWxkLCBkaXNwYXRjaCBhcHByb3ByaWF0ZSBldmVudHMuXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGV2ZW50IHdhcyB0cmVhdGVkIGFzIGEgY2xpY2suXG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7RHlncmFwaH0gZ1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuRHlncmFwaEludGVyYWN0aW9uLm1heWJlVHJlYXRNb3VzZU9wQXNDbGljayA9IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gIGNvbnRleHQuZHJhZ0VuZFggPSB1dGlscy5kcmFnR2V0WF8oZXZlbnQsIGNvbnRleHQpO1xuICBjb250ZXh0LmRyYWdFbmRZID0gdXRpbHMuZHJhZ0dldFlfKGV2ZW50LCBjb250ZXh0KTtcbiAgdmFyIHJlZ2lvbldpZHRoID0gTWF0aC5hYnMoY29udGV4dC5kcmFnRW5kWCAtIGNvbnRleHQuZHJhZ1N0YXJ0WCk7XG4gIHZhciByZWdpb25IZWlnaHQgPSBNYXRoLmFicyhjb250ZXh0LmRyYWdFbmRZIC0gY29udGV4dC5kcmFnU3RhcnRZKTtcblxuICBpZiAocmVnaW9uV2lkdGggPCAyICYmIHJlZ2lvbkhlaWdodCA8IDIgJiZcbiAgICAgIGcubGFzdHhfICE9PSB1bmRlZmluZWQgJiYgZy5sYXN0eF8gIT0gLTEpIHtcbiAgICBEeWdyYXBoSW50ZXJhY3Rpb24udHJlYXRNb3VzZU9wQXNDbGljayhnLCBldmVudCwgY29udGV4dCk7XG4gIH1cblxuICBjb250ZXh0LnJlZ2lvbldpZHRoID0gcmVnaW9uV2lkdGg7XG4gIGNvbnRleHQucmVnaW9uSGVpZ2h0ID0gcmVnaW9uSGVpZ2h0O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaW4gcmVzcG9uc2UgdG8gYW4gaW50ZXJhY3Rpb24gbW9kZWwgb3BlcmF0aW9uIHRoYXRcbiAqIHNob3VsZCBzdGFydCB0aGUgZGVmYXVsdCBwYW5uaW5nIGJlaGF2aW9yLlxuICpcbiAqIEl0J3MgdXNlZCBpbiB0aGUgZGVmYXVsdCBjYWxsYmFjayBmb3IgXCJtb3VzZWRvd25cIiBvcGVyYXRpb25zLlxuICogQ3VzdG9tIGludGVyYWN0aW9uIG1vZGVsIGJ1aWxkZXJzIGNhbiB1c2UgaXQgdG8gcHJvdmlkZSB0aGUgZGVmYXVsdFxuICogcGFubmluZyBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCB0aGUgZXZlbnQgb2JqZWN0IHdoaWNoIGxlZCB0byB0aGUgc3RhcnRQYW4gY2FsbC5cbiAqIEBwYXJhbSB7RHlncmFwaH0gZyBUaGUgZHlncmFwaCBvbiB3aGljaCB0byBhY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgZHJhZ2dpbmcgY29udGV4dCBvYmplY3QgKHdpdGhcbiAqICAgICBkcmFnU3RhcnRYL2RyYWdTdGFydFkvZXRjLiBwcm9wZXJ0aWVzKS4gVGhpcyBmdW5jdGlvbiBtb2RpZmllcyB0aGVcbiAqICAgICBjb250ZXh0LlxuICovXG5EeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRQYW4gPSBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICB2YXIgaSwgYXhpcztcbiAgY29udGV4dC5pc1Bhbm5pbmcgPSB0cnVlO1xuICB2YXIgeFJhbmdlID0gZy54QXhpc1JhbmdlKCk7XG5cbiAgaWYgKGcuZ2V0T3B0aW9uRm9yQXhpcyhcImxvZ3NjYWxlXCIsIFwieFwiKSkge1xuICAgIGNvbnRleHQuaW5pdGlhbExlZnRtb3N0RGF0ZSA9IHV0aWxzLmxvZzEwKHhSYW5nZVswXSk7XG4gICAgY29udGV4dC5kYXRlUmFuZ2UgPSB1dGlscy5sb2cxMCh4UmFuZ2VbMV0pIC0gdXRpbHMubG9nMTAoeFJhbmdlWzBdKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LmluaXRpYWxMZWZ0bW9zdERhdGUgPSB4UmFuZ2VbMF07XG4gICAgY29udGV4dC5kYXRlUmFuZ2UgPSB4UmFuZ2VbMV0gLSB4UmFuZ2VbMF07XG4gIH1cbiAgY29udGV4dC54VW5pdHNQZXJQaXhlbCA9IGNvbnRleHQuZGF0ZVJhbmdlIC8gKGcucGxvdHRlcl8uYXJlYS53IC0gMSk7XG5cbiAgaWYgKGcuZ2V0TnVtZXJpY09wdGlvbihcInBhbkVkZ2VGcmFjdGlvblwiKSkge1xuICAgIHZhciBtYXhYUGl4ZWxzVG9EcmF3ID0gZy53aWR0aF8gKiBnLmdldE51bWVyaWNPcHRpb24oXCJwYW5FZGdlRnJhY3Rpb25cIik7XG4gICAgdmFyIHhFeHRyZW1lcyA9IGcueEF4aXNFeHRyZW1lcygpOyAvLyBJIFJFQUxMWSBXQU5UIFRPIENBTEwgVEhJUyB4VHJlbWVzIVxuXG4gICAgdmFyIGJvdW5kZWRMZWZ0WCA9IGcudG9Eb21YQ29vcmQoeEV4dHJlbWVzWzBdKSAtIG1heFhQaXhlbHNUb0RyYXc7XG4gICAgdmFyIGJvdW5kZWRSaWdodFggPSBnLnRvRG9tWENvb3JkKHhFeHRyZW1lc1sxXSkgKyBtYXhYUGl4ZWxzVG9EcmF3O1xuXG4gICAgdmFyIGJvdW5kZWRMZWZ0RGF0ZSA9IGcudG9EYXRhWENvb3JkKGJvdW5kZWRMZWZ0WCk7XG4gICAgdmFyIGJvdW5kZWRSaWdodERhdGUgPSBnLnRvRGF0YVhDb29yZChib3VuZGVkUmlnaHRYKTtcbiAgICBjb250ZXh0LmJvdW5kZWREYXRlcyA9IFtib3VuZGVkTGVmdERhdGUsIGJvdW5kZWRSaWdodERhdGVdO1xuXG4gICAgdmFyIGJvdW5kZWRWYWx1ZXMgPSBbXTtcbiAgICB2YXIgbWF4WVBpeGVsc1RvRHJhdyA9IGcuaGVpZ2h0XyAqIGcuZ2V0TnVtZXJpY09wdGlvbihcInBhbkVkZ2VGcmFjdGlvblwiKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBnLmF4ZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICBheGlzID0gZy5heGVzX1tpXTtcbiAgICAgIHZhciB5RXh0cmVtZXMgPSBheGlzLmV4dHJlbWVSYW5nZTtcblxuICAgICAgdmFyIGJvdW5kZWRUb3BZID0gZy50b0RvbVlDb29yZCh5RXh0cmVtZXNbMF0sIGkpICsgbWF4WVBpeGVsc1RvRHJhdztcbiAgICAgIHZhciBib3VuZGVkQm90dG9tWSA9IGcudG9Eb21ZQ29vcmQoeUV4dHJlbWVzWzFdLCBpKSAtIG1heFlQaXhlbHNUb0RyYXc7XG5cbiAgICAgIHZhciBib3VuZGVkVG9wVmFsdWUgPSBnLnRvRGF0YVlDb29yZChib3VuZGVkVG9wWSwgaSk7XG4gICAgICB2YXIgYm91bmRlZEJvdHRvbVZhbHVlID0gZy50b0RhdGFZQ29vcmQoYm91bmRlZEJvdHRvbVksIGkpO1xuXG4gICAgICBib3VuZGVkVmFsdWVzW2ldID0gW2JvdW5kZWRUb3BWYWx1ZSwgYm91bmRlZEJvdHRvbVZhbHVlXTtcbiAgICB9XG4gICAgY29udGV4dC5ib3VuZGVkVmFsdWVzID0gYm91bmRlZFZhbHVlcztcbiAgfVxuXG4gIC8vIFJlY29yZCB0aGUgcmFuZ2Ugb2YgZWFjaCB5LWF4aXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBkcmFnLlxuICAvLyBJZiBhbnkgYXhpcyBoYXMgYSB2YWx1ZVJhbmdlLCB0aGVuIHdlIHdhbnQgYSAyRCBwYW4uXG4gIC8vIFdlIGNhbid0IHN0b3JlIGRhdGEgZGlyZWN0bHkgaW4gZy5heGVzXywgYmVjYXVzZSBpdCBkb2VzIG5vdCBiZWxvbmcgdG8gdXNcbiAgLy8gYW5kIGNvdWxkIGNoYW5nZSBvdXQgZnJvbSB1bmRlciB1cyBkdXJpbmcgYSBwYW4gKHNheSBpZiB0aGVyZSdzIGEgZGF0YVxuICAvLyB1cGRhdGUpLlxuICBjb250ZXh0LmlzMkRQYW4gPSBmYWxzZTtcbiAgY29udGV4dC5heGVzID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCBnLmF4ZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgYXhpcyA9IGcuYXhlc19baV07XG4gICAgdmFyIGF4aXNfZGF0YSA9IHt9O1xuICAgIHZhciB5UmFuZ2UgPSBnLnlBeGlzUmFuZ2UoaSk7XG4gICAgLy8gVE9ETyhrb25pZ3NiZXJnKTogVGhlc2UgdmFsdWVzIHNob3VsZCBiZSBpbiB8Y29udGV4dHwuXG4gICAgLy8gSW4gbG9nIHNjYWxlLCBpbml0aWFsVG9wVmFsdWUsIGRyYWdWYWx1ZVJhbmdlIGFuZCB1bml0c1BlclBpeGVsIGFyZSBsb2cgc2NhbGUuXG4gICAgdmFyIGxvZ3NjYWxlID0gZy5hdHRyaWJ1dGVzXy5nZXRGb3JBeGlzKFwibG9nc2NhbGVcIiwgaSk7XG4gICAgaWYgKGxvZ3NjYWxlKSB7XG4gICAgICBheGlzX2RhdGEuaW5pdGlhbFRvcFZhbHVlID0gdXRpbHMubG9nMTAoeVJhbmdlWzFdKTtcbiAgICAgIGF4aXNfZGF0YS5kcmFnVmFsdWVSYW5nZSA9IHV0aWxzLmxvZzEwKHlSYW5nZVsxXSkgLSB1dGlscy5sb2cxMCh5UmFuZ2VbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBheGlzX2RhdGEuaW5pdGlhbFRvcFZhbHVlID0geVJhbmdlWzFdO1xuICAgICAgYXhpc19kYXRhLmRyYWdWYWx1ZVJhbmdlID0geVJhbmdlWzFdIC0geVJhbmdlWzBdO1xuICAgIH1cbiAgICBheGlzX2RhdGEudW5pdHNQZXJQaXhlbCA9IGF4aXNfZGF0YS5kcmFnVmFsdWVSYW5nZSAvIChnLnBsb3R0ZXJfLmFyZWEuaCAtIDEpO1xuICAgIGNvbnRleHQuYXhlcy5wdXNoKGF4aXNfZGF0YSk7XG5cbiAgICAvLyBXaGlsZSBjYWxjdWxhdGluZyBheGVzLCBzZXQgMmRwYW4uXG4gICAgaWYgKGF4aXMudmFsdWVSYW5nZSkgY29udGV4dC5pczJEUGFuID0gdHJ1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgaW4gcmVzcG9uc2UgdG8gYW4gaW50ZXJhY3Rpb24gbW9kZWwgb3BlcmF0aW9uIHRoYXRcbiAqIHJlc3BvbmRzIHRvIGFuIGV2ZW50IHRoYXQgcGFucyB0aGUgdmlldy5cbiAqXG4gKiBJdCdzIHVzZWQgaW4gdGhlIGRlZmF1bHQgY2FsbGJhY2sgZm9yIFwibW91c2Vtb3ZlXCIgb3BlcmF0aW9ucy5cbiAqIEN1c3RvbSBpbnRlcmFjdGlvbiBtb2RlbCBidWlsZGVycyBjYW4gdXNlIGl0IHRvIHByb3ZpZGUgdGhlIGRlZmF1bHRcbiAqIHBhbm5pbmcgYmVoYXZpb3IuXG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgdGhlIGV2ZW50IG9iamVjdCB3aGljaCBsZWQgdG8gdGhlIG1vdmVQYW4gY2FsbC5cbiAqIEBwYXJhbSB7RHlncmFwaH0gZyBUaGUgZHlncmFwaCBvbiB3aGljaCB0byBhY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgZHJhZ2dpbmcgY29udGV4dCBvYmplY3QgKHdpdGhcbiAqICAgICBkcmFnU3RhcnRYL2RyYWdTdGFydFkvZXRjLiBwcm9wZXJ0aWVzKS4gVGhpcyBmdW5jdGlvbiBtb2RpZmllcyB0aGVcbiAqICAgICBjb250ZXh0LlxuICovXG5EeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVBhbiA9IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gIGNvbnRleHQuZHJhZ0VuZFggPSB1dGlscy5kcmFnR2V0WF8oZXZlbnQsIGNvbnRleHQpO1xuICBjb250ZXh0LmRyYWdFbmRZID0gdXRpbHMuZHJhZ0dldFlfKGV2ZW50LCBjb250ZXh0KTtcblxuICB2YXIgbWluRGF0ZSA9IGNvbnRleHQuaW5pdGlhbExlZnRtb3N0RGF0ZSAtXG4gICAgKGNvbnRleHQuZHJhZ0VuZFggLSBjb250ZXh0LmRyYWdTdGFydFgpICogY29udGV4dC54VW5pdHNQZXJQaXhlbDtcbiAgaWYgKGNvbnRleHQuYm91bmRlZERhdGVzKSB7XG4gICAgbWluRGF0ZSA9IE1hdGgubWF4KG1pbkRhdGUsIGNvbnRleHQuYm91bmRlZERhdGVzWzBdKTtcbiAgfVxuICB2YXIgbWF4RGF0ZSA9IG1pbkRhdGUgKyBjb250ZXh0LmRhdGVSYW5nZTtcbiAgaWYgKGNvbnRleHQuYm91bmRlZERhdGVzKSB7XG4gICAgaWYgKG1heERhdGUgPiBjb250ZXh0LmJvdW5kZWREYXRlc1sxXSkge1xuICAgICAgLy8gQWRqdXN0IG1pbkRhdGUsIGFuZCByZWNvbXB1dGUgbWF4RGF0ZS5cbiAgICAgIG1pbkRhdGUgPSBtaW5EYXRlIC0gKG1heERhdGUgLSBjb250ZXh0LmJvdW5kZWREYXRlc1sxXSk7XG4gICAgICBtYXhEYXRlID0gbWluRGF0ZSArIGNvbnRleHQuZGF0ZVJhbmdlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChnLmdldE9wdGlvbkZvckF4aXMoXCJsb2dzY2FsZVwiLCBcInhcIikpIHtcbiAgICBnLmRhdGVXaW5kb3dfID0gWyBNYXRoLnBvdyh1dGlscy5MT0dfU0NBTEUsIG1pbkRhdGUpLFxuICAgICAgICAgICAgICAgICAgICAgIE1hdGgucG93KHV0aWxzLkxPR19TQ0FMRSwgbWF4RGF0ZSkgXTtcbiAgfSBlbHNlIHtcbiAgICBnLmRhdGVXaW5kb3dfID0gW21pbkRhdGUsIG1heERhdGVdO1xuICB9XG5cbiAgLy8geS1heGlzIHNjYWxpbmcgaXMgYXV0b21hdGljIHVubGVzcyB0aGlzIGlzIGEgZnVsbCAyRCBwYW4uXG4gIGlmIChjb250ZXh0LmlzMkRQYW4pIHtcblxuICAgIHZhciBwaXhlbHNEcmFnZ2VkID0gY29udGV4dC5kcmFnRW5kWSAtIGNvbnRleHQuZHJhZ1N0YXJ0WTtcblxuICAgIC8vIEFkanVzdCBlYWNoIGF4aXMgYXBwcm9wcmlhdGVseS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGcuYXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBheGlzID0gZy5heGVzX1tpXTtcbiAgICAgIHZhciBheGlzX2RhdGEgPSBjb250ZXh0LmF4ZXNbaV07XG4gICAgICB2YXIgdW5pdHNEcmFnZ2VkID0gcGl4ZWxzRHJhZ2dlZCAqIGF4aXNfZGF0YS51bml0c1BlclBpeGVsO1xuXG4gICAgICB2YXIgYm91bmRlZFZhbHVlID0gY29udGV4dC5ib3VuZGVkVmFsdWVzID8gY29udGV4dC5ib3VuZGVkVmFsdWVzW2ldIDogbnVsbDtcblxuICAgICAgLy8gSW4gbG9nIHNjYWxlLCBtYXhWYWx1ZSBhbmQgbWluVmFsdWUgYXJlIHRoZSBsb2dzIG9mIHRob3NlIHZhbHVlcy5cbiAgICAgIHZhciBtYXhWYWx1ZSA9IGF4aXNfZGF0YS5pbml0aWFsVG9wVmFsdWUgKyB1bml0c0RyYWdnZWQ7XG4gICAgICBpZiAoYm91bmRlZFZhbHVlKSB7XG4gICAgICAgIG1heFZhbHVlID0gTWF0aC5taW4obWF4VmFsdWUsIGJvdW5kZWRWYWx1ZVsxXSk7XG4gICAgICB9XG4gICAgICB2YXIgbWluVmFsdWUgPSBtYXhWYWx1ZSAtIGF4aXNfZGF0YS5kcmFnVmFsdWVSYW5nZTtcbiAgICAgIGlmIChib3VuZGVkVmFsdWUpIHtcbiAgICAgICAgaWYgKG1pblZhbHVlIDwgYm91bmRlZFZhbHVlWzBdKSB7XG4gICAgICAgICAgLy8gQWRqdXN0IG1heFZhbHVlLCBhbmQgcmVjb21wdXRlIG1pblZhbHVlLlxuICAgICAgICAgIG1heFZhbHVlID0gbWF4VmFsdWUgLSAobWluVmFsdWUgLSBib3VuZGVkVmFsdWVbMF0pO1xuICAgICAgICAgIG1pblZhbHVlID0gbWF4VmFsdWUgLSBheGlzX2RhdGEuZHJhZ1ZhbHVlUmFuZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChnLmF0dHJpYnV0ZXNfLmdldEZvckF4aXMoXCJsb2dzY2FsZVwiLCBpKSkge1xuICAgICAgICBheGlzLnZhbHVlUmFuZ2UgPSBbIE1hdGgucG93KHV0aWxzLkxPR19TQ0FMRSwgbWluVmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucG93KHV0aWxzLkxPR19TQ0FMRSwgbWF4VmFsdWUpIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBheGlzLnZhbHVlUmFuZ2UgPSBbIG1pblZhbHVlLCBtYXhWYWx1ZSBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGcuZHJhd0dyYXBoXyhmYWxzZSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBpbiByZXNwb25zZSB0byBhbiBpbnRlcmFjdGlvbiBtb2RlbCBvcGVyYXRpb24gdGhhdFxuICogcmVzcG9uZHMgdG8gYW4gZXZlbnQgdGhhdCBlbmRzIHBhbm5pbmcuXG4gKlxuICogSXQncyB1c2VkIGluIHRoZSBkZWZhdWx0IGNhbGxiYWNrIGZvciBcIm1vdXNldXBcIiBvcGVyYXRpb25zLlxuICogQ3VzdG9tIGludGVyYWN0aW9uIG1vZGVsIGJ1aWxkZXJzIGNhbiB1c2UgaXQgdG8gcHJvdmlkZSB0aGUgZGVmYXVsdFxuICogcGFubmluZyBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCB0aGUgZXZlbnQgb2JqZWN0IHdoaWNoIGxlZCB0byB0aGUgZW5kUGFuIGNhbGwuXG4gKiBAcGFyYW0ge0R5Z3JhcGh9IGcgVGhlIGR5Z3JhcGggb24gd2hpY2ggdG8gYWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgVGhlIGRyYWdnaW5nIGNvbnRleHQgb2JqZWN0ICh3aXRoXG4gKiAgICAgZHJhZ1N0YXJ0WC9kcmFnU3RhcnRZL2V0Yy4gcHJvcGVydGllcykuIFRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdGhlXG4gKiAgICAgY29udGV4dC5cbiAqL1xuRHlncmFwaEludGVyYWN0aW9uLmVuZFBhbiA9IER5Z3JhcGhJbnRlcmFjdGlvbi5tYXliZVRyZWF0TW91c2VPcEFzQ2xpY2s7XG5cbi8qKlxuICogQ2FsbGVkIGluIHJlc3BvbnNlIHRvIGFuIGludGVyYWN0aW9uIG1vZGVsIG9wZXJhdGlvbiB0aGF0XG4gKiByZXNwb25kcyB0byBhbiBldmVudCB0aGF0IHN0YXJ0cyB6b29taW5nLlxuICpcbiAqIEl0J3MgdXNlZCBpbiB0aGUgZGVmYXVsdCBjYWxsYmFjayBmb3IgXCJtb3VzZWRvd25cIiBvcGVyYXRpb25zLlxuICogQ3VzdG9tIGludGVyYWN0aW9uIG1vZGVsIGJ1aWxkZXJzIGNhbiB1c2UgaXQgdG8gcHJvdmlkZSB0aGUgZGVmYXVsdFxuICogem9vbWluZyBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCB0aGUgZXZlbnQgb2JqZWN0IHdoaWNoIGxlZCB0byB0aGUgc3RhcnRab29tIGNhbGwuXG4gKiBAcGFyYW0ge0R5Z3JhcGh9IGcgVGhlIGR5Z3JhcGggb24gd2hpY2ggdG8gYWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgVGhlIGRyYWdnaW5nIGNvbnRleHQgb2JqZWN0ICh3aXRoXG4gKiAgICAgZHJhZ1N0YXJ0WC9kcmFnU3RhcnRZL2V0Yy4gcHJvcGVydGllcykuIFRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdGhlXG4gKiAgICAgY29udGV4dC5cbiAqL1xuRHlncmFwaEludGVyYWN0aW9uLnN0YXJ0Wm9vbSA9IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gIGNvbnRleHQuaXNab29taW5nID0gdHJ1ZTtcbiAgY29udGV4dC56b29tTW92ZWQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGluIHJlc3BvbnNlIHRvIGFuIGludGVyYWN0aW9uIG1vZGVsIG9wZXJhdGlvbiB0aGF0XG4gKiByZXNwb25kcyB0byBhbiBldmVudCB0aGF0IGRlZmluZXMgem9vbSBib3VuZGFyaWVzLlxuICpcbiAqIEl0J3MgdXNlZCBpbiB0aGUgZGVmYXVsdCBjYWxsYmFjayBmb3IgXCJtb3VzZW1vdmVcIiBvcGVyYXRpb25zLlxuICogQ3VzdG9tIGludGVyYWN0aW9uIG1vZGVsIGJ1aWxkZXJzIGNhbiB1c2UgaXQgdG8gcHJvdmlkZSB0aGUgZGVmYXVsdFxuICogem9vbWluZyBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCB0aGUgZXZlbnQgb2JqZWN0IHdoaWNoIGxlZCB0byB0aGUgbW92ZVpvb20gY2FsbC5cbiAqIEBwYXJhbSB7RHlncmFwaH0gZyBUaGUgZHlncmFwaCBvbiB3aGljaCB0byBhY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgZHJhZ2dpbmcgY29udGV4dCBvYmplY3QgKHdpdGhcbiAqICAgICBkcmFnU3RhcnRYL2RyYWdTdGFydFkvZXRjLiBwcm9wZXJ0aWVzKS4gVGhpcyBmdW5jdGlvbiBtb2RpZmllcyB0aGVcbiAqICAgICBjb250ZXh0LlxuICovXG5EeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVpvb20gPSBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICBjb250ZXh0Lnpvb21Nb3ZlZCA9IHRydWU7XG4gIGNvbnRleHQuZHJhZ0VuZFggPSB1dGlscy5kcmFnR2V0WF8oZXZlbnQsIGNvbnRleHQpO1xuICBjb250ZXh0LmRyYWdFbmRZID0gdXRpbHMuZHJhZ0dldFlfKGV2ZW50LCBjb250ZXh0KTtcblxuICB2YXIgeERlbHRhID0gTWF0aC5hYnMoY29udGV4dC5kcmFnU3RhcnRYIC0gY29udGV4dC5kcmFnRW5kWCk7XG4gIHZhciB5RGVsdGEgPSBNYXRoLmFicyhjb250ZXh0LmRyYWdTdGFydFkgLSBjb250ZXh0LmRyYWdFbmRZKTtcblxuICAvLyBkcmFnIGRpcmVjdGlvbiB0aHJlc2hvbGQgZm9yIHkgYXhpcyBpcyB0d2ljZSBhcyBsYXJnZSBhcyB4IGF4aXNcbiAgY29udGV4dC5kcmFnRGlyZWN0aW9uID0gKHhEZWx0YSA8IHlEZWx0YSAvIDIpID8gdXRpbHMuVkVSVElDQUwgOiB1dGlscy5IT1JJWk9OVEFMO1xuXG4gIGcuZHJhd1pvb21SZWN0XyhcbiAgICAgIGNvbnRleHQuZHJhZ0RpcmVjdGlvbixcbiAgICAgIGNvbnRleHQuZHJhZ1N0YXJ0WCxcbiAgICAgIGNvbnRleHQuZHJhZ0VuZFgsXG4gICAgICBjb250ZXh0LmRyYWdTdGFydFksXG4gICAgICBjb250ZXh0LmRyYWdFbmRZLFxuICAgICAgY29udGV4dC5wcmV2RHJhZ0RpcmVjdGlvbixcbiAgICAgIGNvbnRleHQucHJldkVuZFgsXG4gICAgICBjb250ZXh0LnByZXZFbmRZKTtcblxuICBjb250ZXh0LnByZXZFbmRYID0gY29udGV4dC5kcmFnRW5kWDtcbiAgY29udGV4dC5wcmV2RW5kWSA9IGNvbnRleHQuZHJhZ0VuZFk7XG4gIGNvbnRleHQucHJldkRyYWdEaXJlY3Rpb24gPSBjb250ZXh0LmRyYWdEaXJlY3Rpb247XG59O1xuXG4vKipcbiAqIFRPRE8oZGFudmspOiBtb3ZlIHRoaXMgbG9naWMgaW50byBkeWdyYXBoLmpzXG4gKiBAcGFyYW0ge0R5Z3JhcGh9IGdcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5EeWdyYXBoSW50ZXJhY3Rpb24udHJlYXRNb3VzZU9wQXNDbGljayA9IGZ1bmN0aW9uKGcsIGV2ZW50LCBjb250ZXh0KSB7XG4gIHZhciBjbGlja0NhbGxiYWNrID0gZy5nZXRGdW5jdGlvbk9wdGlvbignY2xpY2tDYWxsYmFjaycpO1xuICB2YXIgcG9pbnRDbGlja0NhbGxiYWNrID0gZy5nZXRGdW5jdGlvbk9wdGlvbigncG9pbnRDbGlja0NhbGxiYWNrJyk7XG5cbiAgdmFyIHNlbGVjdGVkUG9pbnQgPSBudWxsO1xuXG4gIC8vIEZpbmQgb3V0IGlmIHRoZSBjbGljayBvY2N1cnMgb24gYSBwb2ludC5cbiAgdmFyIGNsb3Nlc3RJZHggPSAtMTtcbiAgdmFyIGNsb3Nlc3REaXN0YW5jZSA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgLy8gY2hlY2sgaWYgdGhlIGNsaWNrIHdhcyBvbiBhIHBhcnRpY3VsYXIgcG9pbnQuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZy5zZWxQb2ludHNfLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBnLnNlbFBvaW50c19baV07XG4gICAgdmFyIGRpc3RhbmNlID0gTWF0aC5wb3cocC5jYW52YXN4IC0gY29udGV4dC5kcmFnRW5kWCwgMikgK1xuICAgICAgICAgICAgICAgICAgIE1hdGgucG93KHAuY2FudmFzeSAtIGNvbnRleHQuZHJhZ0VuZFksIDIpO1xuICAgIGlmICghaXNOYU4oZGlzdGFuY2UpICYmXG4gICAgICAgIChjbG9zZXN0SWR4ID09IC0xIHx8IGRpc3RhbmNlIDwgY2xvc2VzdERpc3RhbmNlKSkge1xuICAgICAgY2xvc2VzdERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICBjbG9zZXN0SWR4ID0gaTtcbiAgICB9XG4gIH1cblxuICAvLyBBbGxvdyBhbnkgY2xpY2sgd2l0aGluIHR3byBwaXhlbHMgb2YgdGhlIGRvdC5cbiAgdmFyIHJhZGl1cyA9IGcuZ2V0TnVtZXJpY09wdGlvbignaGlnaGxpZ2h0Q2lyY2xlU2l6ZScpICsgMjtcbiAgaWYgKGNsb3Nlc3REaXN0YW5jZSA8PSByYWRpdXMgKiByYWRpdXMpIHtcbiAgICBzZWxlY3RlZFBvaW50ID0gZy5zZWxQb2ludHNfW2Nsb3Nlc3RJZHhdO1xuICB9XG5cbiAgaWYgKHNlbGVjdGVkUG9pbnQpIHtcbiAgICB2YXIgZSA9IHtcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBwb2ludDogc2VsZWN0ZWRQb2ludCxcbiAgICAgIGNhbnZhc3g6IGNvbnRleHQuZHJhZ0VuZFgsXG4gICAgICBjYW52YXN5OiBjb250ZXh0LmRyYWdFbmRZXG4gICAgfTtcbiAgICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IGcuY2FzY2FkZUV2ZW50c18oJ3BvaW50Q2xpY2snLCBlKTtcbiAgICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgLy8gTm90ZTogdGhpcyBhbHNvIHByZXZlbnRzIGNsaWNrIC8gY2xpY2tDYWxsYmFjayBmcm9tIGZpcmluZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBvaW50Q2xpY2tDYWxsYmFjaykge1xuICAgICAgcG9pbnRDbGlja0NhbGxiYWNrLmNhbGwoZywgZXZlbnQsIHNlbGVjdGVkUG9pbnQpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlID0ge1xuICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgeHZhbDogZy5sYXN0eF8sICAvLyBjbG9zZXN0IHBvaW50IGJ5IHggdmFsdWVcbiAgICBwdHM6IGcuc2VsUG9pbnRzXyxcbiAgICBjYW52YXN4OiBjb250ZXh0LmRyYWdFbmRYLFxuICAgIGNhbnZhc3k6IGNvbnRleHQuZHJhZ0VuZFlcbiAgfTtcbiAgaWYgKCFnLmNhc2NhZGVFdmVudHNfKCdjbGljaycsIGUpKSB7XG4gICAgaWYgKGNsaWNrQ2FsbGJhY2spIHtcbiAgICAgIC8vIFRPRE8oZGFudmspOiBwYXNzIGFsb25nIG1vcmUgaW5mbyBhYm91dCB0aGUgcG9pbnRzLCBlLmcuICd4J1xuICAgICAgY2xpY2tDYWxsYmFjay5jYWxsKGcsIGV2ZW50LCBnLmxhc3R4XywgZy5zZWxQb2ludHNfKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIGluIHJlc3BvbnNlIHRvIGFuIGludGVyYWN0aW9uIG1vZGVsIG9wZXJhdGlvbiB0aGF0XG4gKiByZXNwb25kcyB0byBhbiBldmVudCB0aGF0IHBlcmZvcm1zIGEgem9vbSBiYXNlZCBvbiBwcmV2aW91c2x5IGRlZmluZWRcbiAqIGJvdW5kcy4uXG4gKlxuICogSXQncyB1c2VkIGluIHRoZSBkZWZhdWx0IGNhbGxiYWNrIGZvciBcIm1vdXNldXBcIiBvcGVyYXRpb25zLlxuICogQ3VzdG9tIGludGVyYWN0aW9uIG1vZGVsIGJ1aWxkZXJzIGNhbiB1c2UgaXQgdG8gcHJvdmlkZSB0aGUgZGVmYXVsdFxuICogem9vbWluZyBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCB0aGUgZXZlbnQgb2JqZWN0IHdoaWNoIGxlZCB0byB0aGUgZW5kWm9vbSBjYWxsLlxuICogQHBhcmFtIHtEeWdyYXBofSBnIFRoZSBkeWdyYXBoIG9uIHdoaWNoIHRvIGVuZCB0aGUgem9vbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBkcmFnZ2luZyBjb250ZXh0IG9iamVjdCAod2l0aFxuICogICAgIGRyYWdTdGFydFgvZHJhZ1N0YXJ0WS9ldGMuIHByb3BlcnRpZXMpLiBUaGlzIGZ1bmN0aW9uIG1vZGlmaWVzIHRoZVxuICogICAgIGNvbnRleHQuXG4gKi9cbkR5Z3JhcGhJbnRlcmFjdGlvbi5lbmRab29tID0gZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgZy5jbGVhclpvb21SZWN0XygpO1xuICBjb250ZXh0LmlzWm9vbWluZyA9IGZhbHNlO1xuICBEeWdyYXBoSW50ZXJhY3Rpb24ubWF5YmVUcmVhdE1vdXNlT3BBc0NsaWNrKGV2ZW50LCBnLCBjb250ZXh0KTtcblxuICAvLyBUaGUgem9vbSByZWN0YW5nbGUgaXMgdmlzaWJseSBjbGlwcGVkIHRvIHRoZSBwbG90IGFyZWEsIHNvIGl0cyBiZWhhdmlvclxuICAvLyBzaG91bGQgYmUgYXMgd2VsbC5cbiAgLy8gU2VlIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9keWdyYXBocy9pc3N1ZXMvZGV0YWlsP2lkPTI4MFxuICB2YXIgcGxvdEFyZWEgPSBnLmdldEFyZWEoKTtcbiAgaWYgKGNvbnRleHQucmVnaW9uV2lkdGggPj0gMTAgJiZcbiAgICAgIGNvbnRleHQuZHJhZ0RpcmVjdGlvbiA9PSB1dGlscy5IT1JJWk9OVEFMKSB7XG4gICAgdmFyIGxlZnQgPSBNYXRoLm1pbihjb250ZXh0LmRyYWdTdGFydFgsIGNvbnRleHQuZHJhZ0VuZFgpLFxuICAgICAgICByaWdodCA9IE1hdGgubWF4KGNvbnRleHQuZHJhZ1N0YXJ0WCwgY29udGV4dC5kcmFnRW5kWCk7XG4gICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIHBsb3RBcmVhLngpO1xuICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIHBsb3RBcmVhLnggKyBwbG90QXJlYS53KTtcbiAgICBpZiAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICBnLmRvWm9vbVhfKGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgY29udGV4dC5jYW5jZWxOZXh0RGJsY2xpY2sgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGNvbnRleHQucmVnaW9uSGVpZ2h0ID49IDEwICYmXG4gICAgICAgICAgICAgY29udGV4dC5kcmFnRGlyZWN0aW9uID09IHV0aWxzLlZFUlRJQ0FMKSB7XG4gICAgdmFyIHRvcCA9IE1hdGgubWluKGNvbnRleHQuZHJhZ1N0YXJ0WSwgY29udGV4dC5kcmFnRW5kWSksXG4gICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KGNvbnRleHQuZHJhZ1N0YXJ0WSwgY29udGV4dC5kcmFnRW5kWSk7XG4gICAgdG9wID0gTWF0aC5tYXgodG9wLCBwbG90QXJlYS55KTtcbiAgICBib3R0b20gPSBNYXRoLm1pbihib3R0b20sIHBsb3RBcmVhLnkgKyBwbG90QXJlYS5oKTtcbiAgICBpZiAodG9wIDwgYm90dG9tKSB7XG4gICAgICBnLmRvWm9vbVlfKHRvcCwgYm90dG9tKTtcbiAgICB9XG4gICAgY29udGV4dC5jYW5jZWxOZXh0RGJsY2xpY2sgPSB0cnVlO1xuICB9XG4gIGNvbnRleHQuZHJhZ1N0YXJ0WCA9IG51bGw7XG4gIGNvbnRleHQuZHJhZ1N0YXJ0WSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhJbnRlcmFjdGlvbi5zdGFydFRvdWNoID0gZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgIC8vIHRvdWNoIGJyb3dzZXJzIGFyZSBhbGwgbmljZS5cbiAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgIC8vIElmIHRoZSB1c2VyIGV2ZXIgcHV0cyB0d28gZmluZ2VycyBkb3duLCBpdCdzIG5vdCBhIGRvdWJsZSB0YXAuXG4gICAgY29udGV4dC5zdGFydFRpbWVGb3JEb3VibGVUYXBNcyA9IG51bGw7XG4gIH1cblxuICB2YXIgdG91Y2hlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50LnRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdCA9IGV2ZW50LnRvdWNoZXNbaV07XG4gICAgLy8gd2UgZGlzcGVuc2Ugd2l0aCAnZHJhZ0dldFhfJyBiZWNhdXNlIGFsbCB0b3VjaEJyb3dzZXJzIHN1cHBvcnQgcGFnZVhcbiAgICB0b3VjaGVzLnB1c2goe1xuICAgICAgcGFnZVg6IHQucGFnZVgsXG4gICAgICBwYWdlWTogdC5wYWdlWSxcbiAgICAgIGRhdGFYOiBnLnRvRGF0YVhDb29yZCh0LnBhZ2VYKSxcbiAgICAgIGRhdGFZOiBnLnRvRGF0YVlDb29yZCh0LnBhZ2VZKVxuICAgICAgLy8gaWRlbnRpZmllcjogdC5pZGVudGlmaWVyXG4gICAgfSk7XG4gIH1cbiAgY29udGV4dC5pbml0aWFsVG91Y2hlcyA9IHRvdWNoZXM7XG5cbiAgaWYgKHRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAvLyBUaGlzIGlzIGp1c3QgYSBzd2lwZS5cbiAgICBjb250ZXh0LmluaXRpYWxQaW5jaENlbnRlciA9IHRvdWNoZXNbMF07XG4gICAgY29udGV4dC50b3VjaERpcmVjdGlvbnMgPSB7IHg6IHRydWUsIHk6IHRydWUgfTtcbiAgfSBlbHNlIGlmICh0b3VjaGVzLmxlbmd0aCA+PSAyKSB7XG4gICAgLy8gSXQncyBiZWNvbWUgYSBwaW5jaCFcbiAgICAvLyBJbiBjYXNlIHRoZXJlIGFyZSAzKyB0b3VjaGVzLCB3ZSBpZ25vcmUgYWxsIGJ1dCB0aGUgXCJmaXJzdFwiIHR3by5cblxuICAgIC8vIG9ubHkgc2NyZWVuIGNvb3JkaW5hdGVzIGNhbiBiZSBhdmVyYWdlZCAoZGF0YSBjb29yZHMgY291bGQgYmUgbG9nIHNjYWxlKS5cbiAgICBjb250ZXh0LmluaXRpYWxQaW5jaENlbnRlciA9IHtcbiAgICAgIHBhZ2VYOiAwLjUgKiAodG91Y2hlc1swXS5wYWdlWCArIHRvdWNoZXNbMV0ucGFnZVgpLFxuICAgICAgcGFnZVk6IDAuNSAqICh0b3VjaGVzWzBdLnBhZ2VZICsgdG91Y2hlc1sxXS5wYWdlWSksXG5cbiAgICAgIC8vIFRPRE8oZGFudmspOiByZW1vdmVcbiAgICAgIGRhdGFYOiAwLjUgKiAodG91Y2hlc1swXS5kYXRhWCArIHRvdWNoZXNbMV0uZGF0YVgpLFxuICAgICAgZGF0YVk6IDAuNSAqICh0b3VjaGVzWzBdLmRhdGFZICsgdG91Y2hlc1sxXS5kYXRhWSlcbiAgICB9O1xuXG4gICAgLy8gTWFrZSBwaW5jaGVzIGluIGEgNDUtZGVncmVlIHN3YXRoIGFyb3VuZCBlaXRoZXIgYXhpcyAxLWRpbWVuc2lvbmFsIHpvb21zLlxuICAgIHZhciBpbml0aWFsQW5nbGUgPSAxODAgLyBNYXRoLlBJICogTWF0aC5hdGFuMihcbiAgICAgICAgY29udGV4dC5pbml0aWFsUGluY2hDZW50ZXIucGFnZVkgLSB0b3VjaGVzWzBdLnBhZ2VZLFxuICAgICAgICB0b3VjaGVzWzBdLnBhZ2VYIC0gY29udGV4dC5pbml0aWFsUGluY2hDZW50ZXIucGFnZVgpO1xuXG4gICAgLy8gdXNlIHN5bW1ldHJ5IHRvIGdldCBpdCBpbnRvIHRoZSBmaXJzdCBxdWFkcmFudC5cbiAgICBpbml0aWFsQW5nbGUgPSBNYXRoLmFicyhpbml0aWFsQW5nbGUpO1xuICAgIGlmIChpbml0aWFsQW5nbGUgPiA5MCkgaW5pdGlhbEFuZ2xlID0gOTAgLSBpbml0aWFsQW5nbGU7XG5cbiAgICBjb250ZXh0LnRvdWNoRGlyZWN0aW9ucyA9IHtcbiAgICAgIHg6IChpbml0aWFsQW5nbGUgPCAoOTAgLSA0NS8yKSksXG4gICAgICB5OiAoaW5pdGlhbEFuZ2xlID4gNDUvMilcbiAgICB9O1xuICB9XG5cbiAgLy8gc2F2ZSB0aGUgZnVsbCB4ICYgeSByYW5nZXMuXG4gIGNvbnRleHQuaW5pdGlhbFJhbmdlID0ge1xuICAgIHg6IGcueEF4aXNSYW5nZSgpLFxuICAgIHk6IGcueUF4aXNSYW5nZSgpXG4gIH07XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhJbnRlcmFjdGlvbi5tb3ZlVG91Y2ggPSBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICAvLyBJZiB0aGUgdGFwIG1vdmVzLCB0aGVuIGl0J3MgZGVmaW5pdGVseSBub3QgcGFydCBvZiBhIGRvdWJsZS10YXAuXG4gIGNvbnRleHQuc3RhcnRUaW1lRm9yRG91YmxlVGFwTXMgPSBudWxsO1xuXG4gIHZhciBpLCB0b3VjaGVzID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCBldmVudC50b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHQgPSBldmVudC50b3VjaGVzW2ldO1xuICAgIHRvdWNoZXMucHVzaCh7XG4gICAgICBwYWdlWDogdC5wYWdlWCxcbiAgICAgIHBhZ2VZOiB0LnBhZ2VZXG4gICAgfSk7XG4gIH1cbiAgdmFyIGluaXRpYWxUb3VjaGVzID0gY29udGV4dC5pbml0aWFsVG91Y2hlcztcblxuICB2YXIgY19ub3c7XG5cbiAgLy8gb2xkIGFuZCBuZXcgY2VudGVycy5cbiAgdmFyIGNfaW5pdCA9IGNvbnRleHQuaW5pdGlhbFBpbmNoQ2VudGVyO1xuICBpZiAodG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgIGNfbm93ID0gdG91Y2hlc1swXTtcbiAgfSBlbHNlIHtcbiAgICBjX25vdyA9IHtcbiAgICAgIHBhZ2VYOiAwLjUgKiAodG91Y2hlc1swXS5wYWdlWCArIHRvdWNoZXNbMV0ucGFnZVgpLFxuICAgICAgcGFnZVk6IDAuNSAqICh0b3VjaGVzWzBdLnBhZ2VZICsgdG91Y2hlc1sxXS5wYWdlWSlcbiAgICB9O1xuICB9XG5cbiAgLy8gdGhpcyBpcyB0aGUgXCJzd2lwZVwiIGNvbXBvbmVudFxuICAvLyB3ZSB0b3NzIGl0IG91dCBmb3Igbm93LCBidXQgY291bGQgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gIHZhciBzd2lwZSA9IHtcbiAgICBwYWdlWDogY19ub3cucGFnZVggLSBjX2luaXQucGFnZVgsXG4gICAgcGFnZVk6IGNfbm93LnBhZ2VZIC0gY19pbml0LnBhZ2VZXG4gIH07XG4gIHZhciBkYXRhV2lkdGggPSBjb250ZXh0LmluaXRpYWxSYW5nZS54WzFdIC0gY29udGV4dC5pbml0aWFsUmFuZ2UueFswXTtcbiAgdmFyIGRhdGFIZWlnaHQgPSBjb250ZXh0LmluaXRpYWxSYW5nZS55WzBdIC0gY29udGV4dC5pbml0aWFsUmFuZ2UueVsxXTtcbiAgc3dpcGUuZGF0YVggPSAoc3dpcGUucGFnZVggLyBnLnBsb3R0ZXJfLmFyZWEudykgKiBkYXRhV2lkdGg7XG4gIHN3aXBlLmRhdGFZID0gKHN3aXBlLnBhZ2VZIC8gZy5wbG90dGVyXy5hcmVhLmgpICogZGF0YUhlaWdodDtcbiAgdmFyIHhTY2FsZSwgeVNjYWxlO1xuXG4gIC8vIFRoZSByZXNpZHVhbCBiaXRzIGFyZSB1c3VhbGx5IHNwbGl0IGludG8gc2NhbGUgJiByb3RhdGUgYml0cywgYnV0IHdlIHNwbGl0XG4gIC8vIHRoZW0gaW50byB4LXNjYWxlIGFuZCB5LXNjYWxlIGJpdHMuXG4gIGlmICh0b3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgeFNjYWxlID0gMS4wO1xuICAgIHlTY2FsZSA9IDEuMDtcbiAgfSBlbHNlIGlmICh0b3VjaGVzLmxlbmd0aCA+PSAyKSB7XG4gICAgdmFyIGluaXRIYWxmV2lkdGggPSAoaW5pdGlhbFRvdWNoZXNbMV0ucGFnZVggLSBjX2luaXQucGFnZVgpO1xuICAgIHhTY2FsZSA9ICh0b3VjaGVzWzFdLnBhZ2VYIC0gY19ub3cucGFnZVgpIC8gaW5pdEhhbGZXaWR0aDtcblxuICAgIHZhciBpbml0SGFsZkhlaWdodCA9IChpbml0aWFsVG91Y2hlc1sxXS5wYWdlWSAtIGNfaW5pdC5wYWdlWSk7XG4gICAgeVNjYWxlID0gKHRvdWNoZXNbMV0ucGFnZVkgLSBjX25vdy5wYWdlWSkgLyBpbml0SGFsZkhlaWdodDtcbiAgfVxuXG4gIC8vIENsaXAgc2NhbGluZyB0byBbMS84LCA4XSB0byBwcmV2ZW50IHRvbyBtdWNoIGJsb3d1cC5cbiAgeFNjYWxlID0gTWF0aC5taW4oOCwgTWF0aC5tYXgoMC4xMjUsIHhTY2FsZSkpO1xuICB5U2NhbGUgPSBNYXRoLm1pbig4LCBNYXRoLm1heCgwLjEyNSwgeVNjYWxlKSk7XG5cbiAgdmFyIGRpZFpvb20gPSBmYWxzZTtcbiAgaWYgKGNvbnRleHQudG91Y2hEaXJlY3Rpb25zLngpIHtcbiAgICBnLmRhdGVXaW5kb3dfID0gW1xuICAgICAgY19pbml0LmRhdGFYIC0gc3dpcGUuZGF0YVggKyAoY29udGV4dC5pbml0aWFsUmFuZ2UueFswXSAtIGNfaW5pdC5kYXRhWCkgLyB4U2NhbGUsXG4gICAgICBjX2luaXQuZGF0YVggLSBzd2lwZS5kYXRhWCArIChjb250ZXh0LmluaXRpYWxSYW5nZS54WzFdIC0gY19pbml0LmRhdGFYKSAvIHhTY2FsZVxuICAgIF07XG4gICAgZGlkWm9vbSA9IHRydWU7XG4gIH1cblxuICBpZiAoY29udGV4dC50b3VjaERpcmVjdGlvbnMueSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCAxICAvKmcuYXhlc18ubGVuZ3RoKi87IGkrKykge1xuICAgICAgdmFyIGF4aXMgPSBnLmF4ZXNfW2ldO1xuICAgICAgdmFyIGxvZ3NjYWxlID0gZy5hdHRyaWJ1dGVzXy5nZXRGb3JBeGlzKFwibG9nc2NhbGVcIiwgaSk7XG4gICAgICBpZiAobG9nc2NhbGUpIHtcbiAgICAgICAgLy8gVE9ETyhkYW52ayk6IGltcGxlbWVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXhpcy52YWx1ZVJhbmdlID0gW1xuICAgICAgICAgIGNfaW5pdC5kYXRhWSAtIHN3aXBlLmRhdGFZICsgKGNvbnRleHQuaW5pdGlhbFJhbmdlLnlbMF0gLSBjX2luaXQuZGF0YVkpIC8geVNjYWxlLFxuICAgICAgICAgIGNfaW5pdC5kYXRhWSAtIHN3aXBlLmRhdGFZICsgKGNvbnRleHQuaW5pdGlhbFJhbmdlLnlbMV0gLSBjX2luaXQuZGF0YVkpIC8geVNjYWxlXG4gICAgICAgIF07XG4gICAgICAgIGRpZFpvb20gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGcuZHJhd0dyYXBoXyhmYWxzZSk7XG5cbiAgLy8gV2Ugb25seSBjYWxsIHpvb21DYWxsYmFjayBvbiB6b29tcywgbm90IHBhbnMsIHRvIG1pcnJvciBkZXNrdG9wIGJlaGF2aW9yLlxuICBpZiAoZGlkWm9vbSAmJiB0b3VjaGVzLmxlbmd0aCA+IDEgJiYgZy5nZXRGdW5jdGlvbk9wdGlvbignem9vbUNhbGxiYWNrJykpIHtcbiAgICB2YXIgdmlld1dpbmRvdyA9IGcueEF4aXNSYW5nZSgpO1xuICAgIGcuZ2V0RnVuY3Rpb25PcHRpb24oXCJ6b29tQ2FsbGJhY2tcIikuY2FsbChnLCB2aWV3V2luZG93WzBdLCB2aWV3V2luZG93WzFdLCBnLnlBeGlzUmFuZ2VzKCkpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhJbnRlcmFjdGlvbi5lbmRUb3VjaCA9IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCAhPT0gMCkge1xuICAgIC8vIHRoaXMgaXMgZWZmZWN0aXZlbHkgYSBcInJlc2V0XCJcbiAgICBEeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRUb3VjaChldmVudCwgZywgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAvLyBDb3VsZCBiZSBwYXJ0IG9mIGEgXCJkb3VibGUgdGFwXCJcbiAgICAvLyBUaGUgaGV1cmlzdGljIGhlcmUgaXMgdGhhdCBpdCdzIGEgZG91YmxlLXRhcCBpZiB0aGUgdHdvIHRvdWNoZW5kIGV2ZW50c1xuICAgIC8vIG9jY3VyIHdpdGhpbiA1MDBtcyBhbmQgd2l0aGluIGEgNTB4NTAgcGl4ZWwgYm94LlxuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgdCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIGlmIChjb250ZXh0LnN0YXJ0VGltZUZvckRvdWJsZVRhcE1zICYmXG4gICAgICAgIG5vdyAtIGNvbnRleHQuc3RhcnRUaW1lRm9yRG91YmxlVGFwTXMgPCA1MDAgJiZcbiAgICAgICAgY29udGV4dC5kb3VibGVUYXBYICYmIE1hdGguYWJzKGNvbnRleHQuZG91YmxlVGFwWCAtIHQuc2NyZWVuWCkgPCA1MCAmJlxuICAgICAgICBjb250ZXh0LmRvdWJsZVRhcFkgJiYgTWF0aC5hYnMoY29udGV4dC5kb3VibGVUYXBZIC0gdC5zY3JlZW5ZKSA8IDUwKSB7XG4gICAgICBnLnJlc2V0Wm9vbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnN0YXJ0VGltZUZvckRvdWJsZVRhcE1zID0gbm93O1xuICAgICAgY29udGV4dC5kb3VibGVUYXBYID0gdC5zY3JlZW5YO1xuICAgICAgY29udGV4dC5kb3VibGVUYXBZID0gdC5zY3JlZW5ZO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSBmcm9tIHggdG8gW2xlZnQsIHJpZ2h0XS5cbnZhciBkaXN0YW5jZUZyb21JbnRlcnZhbCA9IGZ1bmN0aW9uKHgsIGxlZnQsIHJpZ2h0KSB7XG4gIGlmICh4IDwgbGVmdCkge1xuICAgIHJldHVybiBsZWZ0IC0geDtcbiAgfSBlbHNlIGlmICh4ID4gcmlnaHQpIHtcbiAgICByZXR1cm4geCAtIHJpZ2h0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBwaXhlbHMgYnkgd2hpY2ggdGhlIGV2ZW50IGhhcHBlbnMgZnJvbSB0aGUgbmVhcmVzdFxuICogZWRnZSBvZiB0aGUgY2hhcnQuIEZvciBldmVudHMgaW4gdGhlIGludGVyaW9yIG9mIHRoZSBjaGFydCwgdGhpcyByZXR1cm5zIHplcm8uXG4gKi9cbnZhciBkaXN0YW5jZUZyb21DaGFydCA9IGZ1bmN0aW9uKGV2ZW50LCBnKSB7XG4gIHZhciBjaGFydFBvcyA9IHV0aWxzLmZpbmRQb3MoZy5jYW52YXNfKTtcbiAgdmFyIGJveCA9IHtcbiAgICBsZWZ0OiBjaGFydFBvcy54LFxuICAgIHJpZ2h0OiBjaGFydFBvcy54ICsgZy5jYW52YXNfLm9mZnNldFdpZHRoLFxuICAgIHRvcDogY2hhcnRQb3MueSxcbiAgICBib3R0b206IGNoYXJ0UG9zLnkgKyBnLmNhbnZhc18ub2Zmc2V0SGVpZ2h0XG4gIH07XG5cbiAgdmFyIHB0ID0ge1xuICAgIHg6IHV0aWxzLnBhZ2VYKGV2ZW50KSxcbiAgICB5OiB1dGlscy5wYWdlWShldmVudClcbiAgfTtcblxuICB2YXIgZHggPSBkaXN0YW5jZUZyb21JbnRlcnZhbChwdC54LCBib3gubGVmdCwgYm94LnJpZ2h0KSxcbiAgICAgIGR5ID0gZGlzdGFuY2VGcm9tSW50ZXJ2YWwocHQueSwgYm94LnRvcCwgYm94LmJvdHRvbSk7XG4gIHJldHVybiBNYXRoLm1heChkeCwgZHkpO1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IGludGVyYXRpb24gbW9kZWwgZm9yIGR5Z3JhcGhzLiBZb3UgY2FuIHJlZmVyIHRvIHNwZWNpZmljIGVsZW1lbnRzIG9mXG4gKiB0aGlzIHdoZW4gY29uc3RydWN0aW5nIHlvdXIgb3duIGludGVyYWN0aW9uIG1vZGVsLCBlLmcuOlxuICogZy51cGRhdGVPcHRpb25zKCB7XG4gKiAgIGludGVyYWN0aW9uTW9kZWw6IHtcbiAqICAgICBtb3VzZWRvd246IER5Z3JhcGhJbnRlcmFjdGlvbi5kZWZhdWx0SW50ZXJhY3Rpb25Nb2RlbC5tb3VzZWRvd25cbiAqICAgfVxuICogfSApO1xuICovXG5EeWdyYXBoSW50ZXJhY3Rpb24uZGVmYXVsdE1vZGVsID0ge1xuICAvLyBUcmFjayB0aGUgYmVnaW5uaW5nIG9mIGRyYWcgZXZlbnRzXG4gIG1vdXNlZG93bjogZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgICAvLyBSaWdodC1jbGljayBzaG91bGQgbm90IGluaXRpYXRlIGEgem9vbS5cbiAgICBpZiAoZXZlbnQuYnV0dG9uICYmIGV2ZW50LmJ1dHRvbiA9PSAyKSByZXR1cm47XG5cbiAgICBjb250ZXh0LmluaXRpYWxpemVNb3VzZURvd24oZXZlbnQsIGcsIGNvbnRleHQpO1xuXG4gICAgaWYgKGV2ZW50LmFsdEtleSB8fCBldmVudC5zaGlmdEtleSkge1xuICAgICAgRHlncmFwaEludGVyYWN0aW9uLnN0YXJ0UGFuKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgRHlncmFwaEludGVyYWN0aW9uLnN0YXJ0Wm9vbShldmVudCwgZywgY29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gTm90ZTogd2UgcmVnaXN0ZXIgbW91c2Vtb3ZlL21vdXNldXAgb24gZG9jdW1lbnQgdG8gYWxsb3cgc29tZSBsZWV3YXkgZm9yXG4gICAgLy8gZXZlbnRzIHRvIG1vdmUgb3V0c2lkZSBvZiB0aGUgY2hhcnQuIEludGVyYWN0aW9uIG1vZGVsIGV2ZW50cyBnZXRcbiAgICAvLyByZWdpc3RlcmVkIG9uIHRoZSBjYW52YXMsIHdoaWNoIGlzIHRvbyBzbWFsbCB0byBhbGxvdyB0aGlzLlxuICAgIHZhciBtb3VzZW1vdmUgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgaWYgKGNvbnRleHQuaXNab29taW5nKSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIG1vdXNlIG1vdmVzID4yMDBweCBmcm9tIHRoZSBjaGFydCBlZGdlLCBjYW5jZWwgdGhlIHpvb20uXG4gICAgICAgIHZhciBkID0gZGlzdGFuY2VGcm9tQ2hhcnQoZXZlbnQsIGcpO1xuICAgICAgICBpZiAoZCA8IERSQUdfRURHRV9NQVJHSU4pIHtcbiAgICAgICAgICBEeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVpvb20oZXZlbnQsIGcsIGNvbnRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjb250ZXh0LmRyYWdFbmRYICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRyYWdFbmRYID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRleHQuZHJhZ0VuZFkgPSBudWxsO1xuICAgICAgICAgICAgZy5jbGVhclpvb21SZWN0XygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250ZXh0LmlzUGFubmluZykge1xuICAgICAgICBEeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVBhbihldmVudCwgZywgY29udGV4dCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgbW91c2V1cCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAoY29udGV4dC5pc1pvb21pbmcpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuZHJhZ0VuZFggIT09IG51bGwpIHtcbiAgICAgICAgICBEeWdyYXBoSW50ZXJhY3Rpb24uZW5kWm9vbShldmVudCwgZywgY29udGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRHlncmFwaEludGVyYWN0aW9uLm1heWJlVHJlYXRNb3VzZU9wQXNDbGljayhldmVudCwgZywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5pc1Bhbm5pbmcpIHtcbiAgICAgICAgRHlncmFwaEludGVyYWN0aW9uLmVuZFBhbihldmVudCwgZywgY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLnJlbW92ZUV2ZW50KGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbW91c2Vtb3ZlKTtcbiAgICAgIHV0aWxzLnJlbW92ZUV2ZW50KGRvY3VtZW50LCAnbW91c2V1cCcsIG1vdXNldXApO1xuICAgICAgY29udGV4dC5kZXN0cm95KCk7XG4gICAgfTtcblxuICAgIGcuYWRkQW5kVHJhY2tFdmVudChkb2N1bWVudCwgJ21vdXNlbW92ZScsIG1vdXNlbW92ZSk7XG4gICAgZy5hZGRBbmRUcmFja0V2ZW50KGRvY3VtZW50LCAnbW91c2V1cCcsIG1vdXNldXApO1xuICB9LFxuICB3aWxsRGVzdHJveUNvbnRleHRNeXNlbGY6IHRydWUsXG5cbiAgdG91Y2hzdGFydDogZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgICBEeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRUb3VjaChldmVudCwgZywgY29udGV4dCk7XG4gIH0sXG4gIHRvdWNobW92ZTogZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgICBEeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVRvdWNoKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgfSxcbiAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gICAgRHlncmFwaEludGVyYWN0aW9uLmVuZFRvdWNoKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgfSxcblxuICAvLyBEaXNhYmxlIHpvb21pbmcgb3V0IGlmIHBhbm5pbmcuXG4gIGRibGNsaWNrOiBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0LmNhbmNlbE5leHREYmxjbGljaykge1xuICAgICAgY29udGV4dC5jYW5jZWxOZXh0RGJsY2xpY2sgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHaXZlIHBsdWdpbnMgYSBjaGFuY2UgdG8gZ3JhYiB0aGlzIGV2ZW50LlxuICAgIHZhciBlID0ge1xuICAgICAgY2FudmFzeDogY29udGV4dC5kcmFnRW5kWCxcbiAgICAgIGNhbnZhc3k6IGNvbnRleHQuZHJhZ0VuZFksXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgIH07XG4gICAgaWYgKGcuY2FzY2FkZUV2ZW50c18oJ2RibGNsaWNrJywgZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGcucmVzZXRab29tKCk7XG4gIH1cbn07XG5cbi8qXG5EeWdyYXBoLkRFRkFVTFRfQVRUUlMuaW50ZXJhY3Rpb25Nb2RlbCA9IER5Z3JhcGhJbnRlcmFjdGlvbi5kZWZhdWx0TW9kZWw7XG5cbi8vIG9sZCB3YXlzIG9mIGFjY2Vzc2luZyB0aGVzZSBtZXRob2RzL3Byb3BlcnRpZXNcbkR5Z3JhcGguZGVmYXVsdEludGVyYWN0aW9uTW9kZWwgPSBEeWdyYXBoSW50ZXJhY3Rpb24uZGVmYXVsdE1vZGVsO1xuRHlncmFwaC5lbmRab29tID0gRHlncmFwaEludGVyYWN0aW9uLmVuZFpvb207XG5EeWdyYXBoLm1vdmVab29tID0gRHlncmFwaEludGVyYWN0aW9uLm1vdmVab29tO1xuRHlncmFwaC5zdGFydFpvb20gPSBEeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRab29tO1xuRHlncmFwaC5lbmRQYW4gPSBEeWdyYXBoSW50ZXJhY3Rpb24uZW5kUGFuO1xuRHlncmFwaC5tb3ZlUGFuID0gRHlncmFwaEludGVyYWN0aW9uLm1vdmVQYW47XG5EeWdyYXBoLnN0YXJ0UGFuID0gRHlncmFwaEludGVyYWN0aW9uLnN0YXJ0UGFuO1xuKi9cblxuRHlncmFwaEludGVyYWN0aW9uLm5vbkludGVyYWN0aXZlTW9kZWxfID0ge1xuICBtb3VzZWRvd246IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5pbml0aWFsaXplTW91c2VEb3duKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgfSxcbiAgbW91c2V1cDogRHlncmFwaEludGVyYWN0aW9uLm1heWJlVHJlYXRNb3VzZU9wQXNDbGlja1xufTtcblxuLy8gRGVmYXVsdCBpbnRlcmFjdGlvbiBtb2RlbCB3aGVuIHVzaW5nIHRoZSByYW5nZSBzZWxlY3Rvci5cbkR5Z3JhcGhJbnRlcmFjdGlvbi5kcmFnSXNQYW5JbnRlcmFjdGlvbk1vZGVsID0ge1xuICBtb3VzZWRvd246IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5pbml0aWFsaXplTW91c2VEb3duKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgICBEeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRQYW4oZXZlbnQsIGcsIGNvbnRleHQpO1xuICB9LFxuICBtb3VzZW1vdmU6IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQuaXNQYW5uaW5nKSB7XG4gICAgICBEeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVBhbihldmVudCwgZywgY29udGV4dCk7XG4gICAgfVxuICB9LFxuICBtb3VzZXVwOiBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0LmlzUGFubmluZykge1xuICAgICAgRHlncmFwaEludGVyYWN0aW9uLmVuZFBhbihldmVudCwgZywgY29udGV4dCk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEeWdyYXBoSW50ZXJhY3Rpb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLWludGVyYWN0aW9uLW1vZGVsLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return numericLinearTicks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return numericTicks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return dateTicker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return Granularity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return getDateAxis; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__ = __webpack_require__(8);\n/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview Description of this file.\n * @author danvk@google.com (Dan Vanderkam)\n *\n * A ticker is a function with the following interface:\n *\n * function(a, b, pixels, options_view, dygraph, forced_values);\n * -> [ { v: tick1_v, label: tick1_label[, label_v: label_v1] },\n *      { v: tick2_v, label: tick2_label[, label_v: label_v2] },\n *      ...\n *    ]\n *\n * The returned value is called a \"tick list\".\n *\n * Arguments\n * ---------\n *\n * [a, b] is the range of the axis for which ticks are being generated. For a\n * numeric axis, these will simply be numbers. For a date axis, these will be\n * millis since epoch (convertable to Date objects using \"new Date(a)\" and \"new\n * Date(b)\").\n *\n * opts provides access to chart- and axis-specific options. It can be used to\n * access number/date formatting code/options, check for a log scale, etc.\n *\n * pixels is the length of the axis in pixels. opts('pixelsPerLabel') is the\n * minimum amount of space to be allotted to each label. For instance, if\n * pixels=400 and opts('pixelsPerLabel')=40 then the ticker should return\n * between zero and ten (400/40) ticks.\n *\n * dygraph is the Dygraph object for which an axis is being constructed.\n *\n * forced_values is used for secondary y-axes. The tick positions are typically\n * set by the primary y-axis, so the secondary y-axis has no choice in where to\n * put these. It simply has to generate labels for these data values.\n *\n * Tick lists\n * ----------\n * Typically a tick will have both a grid/tick line and a label at one end of\n * that line (at the bottom for an x-axis, at left or right for the y-axis).\n *\n * A tick may be missing one of these two components:\n * - If \"label_v\" is specified instead of \"v\", then there will be no tick or\n *   gridline, just a label.\n * - Similarly, if \"label\" is not specified, then there will be a gridline\n *   without a label.\n *\n * This flexibility is useful in a few situations:\n * - For log scales, some of the tick lines may be too close to all have labels.\n * - For date scales where years are being displayed, it is desirable to display\n *   tick marks at the beginnings of years but labels (e.g. \"2006\") in the\n *   middle of the years.\n */\n\n/*jshint sub:true */\n/*global Dygraph:false */\n\n\n\n\n/** @typedef {Array.<{v:number, label:string, label_v:(string|undefined)}>} */\nvar TickList = undefined; // the ' = undefined' keeps jshint happy.\n\n/** @typedef {function(\n *    number,\n *    number,\n *    number,\n *    function(string):*,\n *    Dygraph=,\n *    Array.<number>=\n *  ): TickList}\n */\nvar Ticker = undefined; // the ' = undefined' keeps jshint happy.\n\n/** @type {Ticker} */\nvar numericLinearTicks = function numericLinearTicks(a, b, pixels, opts, dygraph, vals) {\n  var nonLogscaleOpts = function nonLogscaleOpts(opt) {\n    if (opt === 'logscale') return false;\n    return opts(opt);\n  };\n  return numericTicks(a, b, pixels, nonLogscaleOpts, dygraph, vals);\n};\n\n/** @type {Ticker} */\nvar numericTicks = function numericTicks(a, b, pixels, opts, dygraph, vals) {\n  var pixels_per_tick = /** @type{number} */opts('pixelsPerLabel');\n  var ticks = [];\n  var i, j, tickV, nTicks;\n  if (vals) {\n    for (i = 0; i < vals.length; i++) {\n      ticks.push({ v: vals[i] });\n    }\n  } else {\n    // TODO(danvk): factor this log-scale block out into a separate function.\n    if (opts(\"logscale\")) {\n      nTicks = Math.floor(pixels / pixels_per_tick);\n      var minIdx = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"K\" /* binarySearch */](a, PREFERRED_LOG_TICK_VALUES, 1);\n      var maxIdx = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"K\" /* binarySearch */](b, PREFERRED_LOG_TICK_VALUES, -1);\n      if (minIdx == -1) {\n        minIdx = 0;\n      }\n      if (maxIdx == -1) {\n        maxIdx = PREFERRED_LOG_TICK_VALUES.length - 1;\n      }\n      // Count the number of tick values would appear, if we can get at least\n      // nTicks / 4 accept them.\n      var lastDisplayed = null;\n      if (maxIdx - minIdx >= nTicks / 4) {\n        for (var idx = maxIdx; idx >= minIdx; idx--) {\n          var tickValue = PREFERRED_LOG_TICK_VALUES[idx];\n          var pixel_coord = Math.log(tickValue / a) / Math.log(b / a) * pixels;\n          var tick = { v: tickValue };\n          if (lastDisplayed === null) {\n            lastDisplayed = {\n              tickValue: tickValue,\n              pixel_coord: pixel_coord\n            };\n          } else {\n            if (Math.abs(pixel_coord - lastDisplayed.pixel_coord) >= pixels_per_tick) {\n              lastDisplayed = {\n                tickValue: tickValue,\n                pixel_coord: pixel_coord\n              };\n            } else {\n              tick.label = \"\";\n            }\n          }\n          ticks.push(tick);\n        }\n        // Since we went in backwards order.\n        ticks.reverse();\n      }\n    }\n\n    // ticks.length won't be 0 if the log scale function finds values to insert.\n    if (ticks.length === 0) {\n      // Basic idea:\n      // Try labels every 1, 2, 5, 10, 20, 50, 100, etc.\n      // Calculate the resulting tick spacing (i.e. this.height_ / nTicks).\n      // The first spacing greater than pixelsPerYLabel is what we use.\n      // TODO(danvk): version that works on a log scale.\n      var kmg2 = opts(\"labelsKMG2\");\n      var mults, base;\n      if (kmg2) {\n        mults = [1, 2, 4, 8, 16, 32, 64, 128, 256];\n        base = 16;\n      } else {\n        mults = [1, 2, 5, 10, 20, 50, 100];\n        base = 10;\n      }\n\n      // Get the maximum number of permitted ticks based on the\n      // graph's pixel size and pixels_per_tick setting.\n      var max_ticks = Math.ceil(pixels / pixels_per_tick);\n\n      // Now calculate the data unit equivalent of this tick spacing.\n      // Use abs() since graphs may have a reversed Y axis.\n      var units_per_tick = Math.abs(b - a) / max_ticks;\n\n      // Based on this, get a starting scale which is the largest\n      // integer power of the chosen base (10 or 16) that still remains\n      // below the requested pixels_per_tick spacing.\n      var base_power = Math.floor(Math.log(units_per_tick) / Math.log(base));\n      var base_scale = Math.pow(base, base_power);\n\n      // Now try multiples of the starting scale until we find one\n      // that results in tick marks spaced sufficiently far apart.\n      // The \"mults\" array should cover the range 1 .. base^2 to\n      // adjust for rounding and edge effects.\n      var scale, low_val, high_val, spacing;\n      for (j = 0; j < mults.length; j++) {\n        scale = base_scale * mults[j];\n        low_val = Math.floor(a / scale) * scale;\n        high_val = Math.ceil(b / scale) * scale;\n        nTicks = Math.abs(high_val - low_val) / scale;\n        spacing = pixels / nTicks;\n        if (spacing > pixels_per_tick) break;\n      }\n\n      // Construct the set of ticks.\n      // Allow reverse y-axis if it's explicitly requested.\n      if (low_val > high_val) scale *= -1;\n      for (i = 0; i <= nTicks; i++) {\n        tickV = low_val + i * scale;\n        ticks.push({ v: tickV });\n      }\n    }\n  }\n\n  var formatter = /**@type{AxisLabelFormatter}*/opts('axisLabelFormatter');\n\n  // Add labels to the ticks.\n  for (i = 0; i < ticks.length; i++) {\n    if (ticks[i].label !== undefined) continue; // Use current label.\n    // TODO(danvk): set granularity to something appropriate here.\n    ticks[i].label = formatter.call(dygraph, ticks[i].v, 0, opts, dygraph);\n  }\n\n  return ticks;\n};\n\n/** @type {Ticker} */\nvar dateTicker = function dateTicker(a, b, pixels, opts, dygraph, vals) {\n  var chosen = pickDateTickGranularity(a, b, pixels, opts);\n\n  if (chosen >= 0) {\n    return getDateAxis(a, b, chosen, opts, dygraph);\n  } else {\n    // this can happen if self.width_ is zero.\n    return [];\n  }\n};\n\n// Time granularity enumeration\nvar Granularity = {\n  MILLISECONDLY: 0,\n  TWO_MILLISECONDLY: 1,\n  FIVE_MILLISECONDLY: 2,\n  TEN_MILLISECONDLY: 3,\n  FIFTY_MILLISECONDLY: 4,\n  HUNDRED_MILLISECONDLY: 5,\n  FIVE_HUNDRED_MILLISECONDLY: 6,\n  SECONDLY: 7,\n  TWO_SECONDLY: 8,\n  FIVE_SECONDLY: 9,\n  TEN_SECONDLY: 10,\n  THIRTY_SECONDLY: 11,\n  MINUTELY: 12,\n  TWO_MINUTELY: 13,\n  FIVE_MINUTELY: 14,\n  TEN_MINUTELY: 15,\n  THIRTY_MINUTELY: 16,\n  HOURLY: 17,\n  TWO_HOURLY: 18,\n  SIX_HOURLY: 19,\n  DAILY: 20,\n  TWO_DAILY: 21,\n  WEEKLY: 22,\n  MONTHLY: 23,\n  QUARTERLY: 24,\n  BIANNUAL: 25,\n  ANNUAL: 26,\n  DECADAL: 27,\n  CENTENNIAL: 28,\n  NUM_GRANULARITIES: 29\n\n  // Date components enumeration (in the order of the arguments in Date)\n  // TODO: make this an @enum\n};var DateField = {\n  DATEFIELD_Y: 0,\n  DATEFIELD_M: 1,\n  DATEFIELD_D: 2,\n  DATEFIELD_HH: 3,\n  DATEFIELD_MM: 4,\n  DATEFIELD_SS: 5,\n  DATEFIELD_MS: 6,\n  NUM_DATEFIELDS: 7\n};\n\n/**\n * The value of datefield will start at an even multiple of \"step\", i.e.\n *   if datefield=SS and step=5 then the first tick will be on a multiple of 5s.\n *\n * For granularities <= HOURLY, ticks are generated every `spacing` ms.\n *\n * At coarser granularities, ticks are generated by incrementing `datefield` by\n *   `step`. In this case, the `spacing` value is only used to estimate the\n *   number of ticks. It should roughly correspond to the spacing between\n *   adjacent ticks.\n *\n * @type {Array.<{datefield:number, step:number, spacing:number}>}\n */\nvar TICK_PLACEMENT = [];\nTICK_PLACEMENT[Granularity.MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 1, spacing: 1 };\nTICK_PLACEMENT[Granularity.TWO_MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 2, spacing: 2 };\nTICK_PLACEMENT[Granularity.FIVE_MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 5, spacing: 5 };\nTICK_PLACEMENT[Granularity.TEN_MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 10, spacing: 10 };\nTICK_PLACEMENT[Granularity.FIFTY_MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 50, spacing: 50 };\nTICK_PLACEMENT[Granularity.HUNDRED_MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 100, spacing: 100 };\nTICK_PLACEMENT[Granularity.FIVE_HUNDRED_MILLISECONDLY] = { datefield: DateField.DATEFIELD_MS, step: 500, spacing: 500 };\nTICK_PLACEMENT[Granularity.SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 1, spacing: 1000 * 1 };\nTICK_PLACEMENT[Granularity.TWO_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 2, spacing: 1000 * 2 };\nTICK_PLACEMENT[Granularity.FIVE_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 5, spacing: 1000 * 5 };\nTICK_PLACEMENT[Granularity.TEN_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 10, spacing: 1000 * 10 };\nTICK_PLACEMENT[Granularity.THIRTY_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 30, spacing: 1000 * 30 };\nTICK_PLACEMENT[Granularity.MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 1, spacing: 1000 * 60 };\nTICK_PLACEMENT[Granularity.TWO_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 2, spacing: 1000 * 60 * 2 };\nTICK_PLACEMENT[Granularity.FIVE_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 5, spacing: 1000 * 60 * 5 };\nTICK_PLACEMENT[Granularity.TEN_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 10, spacing: 1000 * 60 * 10 };\nTICK_PLACEMENT[Granularity.THIRTY_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 30, spacing: 1000 * 60 * 30 };\nTICK_PLACEMENT[Granularity.HOURLY] = { datefield: DateField.DATEFIELD_HH, step: 1, spacing: 1000 * 3600 };\nTICK_PLACEMENT[Granularity.TWO_HOURLY] = { datefield: DateField.DATEFIELD_HH, step: 2, spacing: 1000 * 3600 * 2 };\nTICK_PLACEMENT[Granularity.SIX_HOURLY] = { datefield: DateField.DATEFIELD_HH, step: 6, spacing: 1000 * 3600 * 6 };\nTICK_PLACEMENT[Granularity.DAILY] = { datefield: DateField.DATEFIELD_D, step: 1, spacing: 1000 * 86400 };\nTICK_PLACEMENT[Granularity.TWO_DAILY] = { datefield: DateField.DATEFIELD_D, step: 2, spacing: 1000 * 86400 * 2 };\nTICK_PLACEMENT[Granularity.WEEKLY] = { datefield: DateField.DATEFIELD_D, step: 7, spacing: 1000 * 604800 };\nTICK_PLACEMENT[Granularity.MONTHLY] = { datefield: DateField.DATEFIELD_M, step: 1, spacing: 1000 * 7200 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 / 12\nTICK_PLACEMENT[Granularity.QUARTERLY] = { datefield: DateField.DATEFIELD_M, step: 3, spacing: 1000 * 21600 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 / 4\nTICK_PLACEMENT[Granularity.BIANNUAL] = { datefield: DateField.DATEFIELD_M, step: 6, spacing: 1000 * 43200 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 / 2\nTICK_PLACEMENT[Granularity.ANNUAL] = { datefield: DateField.DATEFIELD_Y, step: 1, spacing: 1000 * 86400 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 * 1\nTICK_PLACEMENT[Granularity.DECADAL] = { datefield: DateField.DATEFIELD_Y, step: 10, spacing: 1000 * 864000 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 * 10\nTICK_PLACEMENT[Granularity.CENTENNIAL] = { datefield: DateField.DATEFIELD_Y, step: 100, spacing: 1000 * 8640000 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 * 100\n\n\n/**\n * This is a list of human-friendly values at which to show tick marks on a log\n * scale. It is k * 10^n, where k=1..9 and n=-39..+39, so:\n * ..., 1, 2, 3, 4, 5, ..., 9, 10, 20, 30, ..., 90, 100, 200, 300, ...\n * NOTE: this assumes that utils.LOG_SCALE = 10.\n * @type {Array.<number>}\n */\nvar PREFERRED_LOG_TICK_VALUES = function () {\n  var vals = [];\n  for (var power = -39; power <= 39; power++) {\n    var range = Math.pow(10, power);\n    for (var mult = 1; mult <= 9; mult++) {\n      var val = range * mult;\n      vals.push(val);\n    }\n  }\n  return vals;\n}();\n\n/**\n * Determine the correct granularity of ticks on a date axis.\n *\n * @param {number} a Left edge of the chart (ms)\n * @param {number} b Right edge of the chart (ms)\n * @param {number} pixels Size of the chart in the relevant dimension (width).\n * @param {function(string):*} opts Function mapping from option name -&gt; value.\n * @return {number} The appropriate axis granularity for this chart. See the\n *     enumeration of possible values in dygraph-tickers.js.\n */\nvar pickDateTickGranularity = function pickDateTickGranularity(a, b, pixels, opts) {\n  var pixels_per_tick = /** @type{number} */opts('pixelsPerLabel');\n  for (var i = 0; i < Granularity.NUM_GRANULARITIES; i++) {\n    var num_ticks = numDateTicks(a, b, i);\n    if (pixels / num_ticks >= pixels_per_tick) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/**\n * Compute the number of ticks on a date axis for a given granularity.\n * @param {number} start_time\n * @param {number} end_time\n * @param {number} granularity (one of the granularities enumerated above)\n * @return {number} (Approximate) number of ticks that would result.\n */\nvar numDateTicks = function numDateTicks(start_time, end_time, granularity) {\n  var spacing = TICK_PLACEMENT[granularity].spacing;\n  return Math.round(1.0 * (end_time - start_time) / spacing);\n};\n\n/**\n * Compute the positions and labels of ticks on a date axis for a given granularity.\n * @param {number} start_time\n * @param {number} end_time\n * @param {number} granularity (one of the granularities enumerated above)\n * @param {function(string):*} opts Function mapping from option name -&gt; value.\n * @param {Dygraph=} dg\n * @return {!TickList}\n */\nvar getDateAxis = function getDateAxis(start_time, end_time, granularity, opts, dg) {\n  var formatter = /** @type{AxisLabelFormatter} */opts(\"axisLabelFormatter\");\n  var utc = opts(\"labelsUTC\");\n  var accessors = utc ? __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"L\" /* DateAccessorsUTC */] : __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"M\" /* DateAccessorsLocal */];\n\n  var datefield = TICK_PLACEMENT[granularity].datefield;\n  var step = TICK_PLACEMENT[granularity].step;\n  var spacing = TICK_PLACEMENT[granularity].spacing;\n\n  // Choose a nice tick position before the initial instant.\n  // Currently, this code deals properly with the existent daily granularities:\n  // DAILY (with step of 1) and WEEKLY (with step of 7 but specially handled).\n  // Other daily granularities (say TWO_DAILY) should also be handled specially\n  // by setting the start_date_offset to 0.\n  var start_date = new Date(start_time);\n  var date_array = [];\n  date_array[DateField.DATEFIELD_Y] = accessors.getFullYear(start_date);\n  date_array[DateField.DATEFIELD_M] = accessors.getMonth(start_date);\n  date_array[DateField.DATEFIELD_D] = accessors.getDate(start_date);\n  date_array[DateField.DATEFIELD_HH] = accessors.getHours(start_date);\n  date_array[DateField.DATEFIELD_MM] = accessors.getMinutes(start_date);\n  date_array[DateField.DATEFIELD_SS] = accessors.getSeconds(start_date);\n  date_array[DateField.DATEFIELD_MS] = accessors.getMilliseconds(start_date);\n\n  var start_date_offset = date_array[datefield] % step;\n  if (granularity == Granularity.WEEKLY) {\n    // This will put the ticks on Sundays.\n    start_date_offset = accessors.getDay(start_date);\n  }\n\n  date_array[datefield] -= start_date_offset;\n  for (var df = datefield + 1; df < DateField.NUM_DATEFIELDS; df++) {\n    // The minimum value is 1 for the day of month, and 0 for all other fields.\n    date_array[df] = df === DateField.DATEFIELD_D ? 1 : 0;\n  }\n\n  // Generate the ticks.\n  // For granularities not coarser than HOURLY we use the fact that:\n  //   the number of milliseconds between ticks is constant\n  //   and equal to the defined spacing.\n  // Otherwise we rely on the 'roll over' property of the Date functions:\n  //   when some date field is set to a value outside of its logical range,\n  //   the excess 'rolls over' the next (more significant) field.\n  // However, when using local time with DST transitions,\n  // there are dates that do not represent any time value at all\n  // (those in the hour skipped at the 'spring forward'),\n  // and the JavaScript engines usually return an equivalent value.\n  // Hence we have to check that the date is properly increased at each step,\n  // returning a date at a nice tick position.\n  var ticks = [];\n  var tick_date = accessors.makeDate.apply(null, date_array);\n  var tick_time = tick_date.getTime();\n  if (granularity <= Granularity.HOURLY) {\n    if (tick_time < start_time) {\n      tick_time += spacing;\n      tick_date = new Date(tick_time);\n    }\n    while (tick_time <= end_time) {\n      ticks.push({ v: tick_time,\n        label: formatter.call(dg, tick_date, granularity, opts, dg)\n      });\n      tick_time += spacing;\n      tick_date = new Date(tick_time);\n    }\n  } else {\n    if (tick_time < start_time) {\n      date_array[datefield] += step;\n      tick_date = accessors.makeDate.apply(null, date_array);\n      tick_time = tick_date.getTime();\n    }\n    while (tick_time <= end_time) {\n      if (granularity >= Granularity.DAILY || accessors.getHours(tick_date) % step === 0) {\n        ticks.push({ v: tick_time,\n          label: formatter.call(dg, tick_date, granularity, opts, dg)\n        });\n      }\n      date_array[datefield] += step;\n      tick_date = accessors.makeDate.apply(null, date_array);\n      tick_time = tick_date.getTime();\n    }\n  }\n  return ticks;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLXRpY2tlcnMuanM/MmY0MyJdLCJuYW1lcyI6WyJUaWNrTGlzdCIsInVuZGVmaW5lZCIsIlRpY2tlciIsIm51bWVyaWNMaW5lYXJUaWNrcyIsImEiLCJiIiwicGl4ZWxzIiwib3B0cyIsImR5Z3JhcGgiLCJ2YWxzIiwibm9uTG9nc2NhbGVPcHRzIiwib3B0IiwibnVtZXJpY1RpY2tzIiwicGl4ZWxzX3Blcl90aWNrIiwidGlja3MiLCJpIiwiaiIsInRpY2tWIiwiblRpY2tzIiwibGVuZ3RoIiwicHVzaCIsInYiLCJNYXRoIiwiZmxvb3IiLCJtaW5JZHgiLCJQUkVGRVJSRURfTE9HX1RJQ0tfVkFMVUVTIiwibWF4SWR4IiwibGFzdERpc3BsYXllZCIsImlkeCIsInRpY2tWYWx1ZSIsInBpeGVsX2Nvb3JkIiwibG9nIiwidGljayIsImFicyIsImxhYmVsIiwicmV2ZXJzZSIsImttZzIiLCJtdWx0cyIsImJhc2UiLCJtYXhfdGlja3MiLCJjZWlsIiwidW5pdHNfcGVyX3RpY2siLCJiYXNlX3Bvd2VyIiwiYmFzZV9zY2FsZSIsInBvdyIsInNjYWxlIiwibG93X3ZhbCIsImhpZ2hfdmFsIiwic3BhY2luZyIsImZvcm1hdHRlciIsImNhbGwiLCJkYXRlVGlja2VyIiwiY2hvc2VuIiwicGlja0RhdGVUaWNrR3JhbnVsYXJpdHkiLCJnZXREYXRlQXhpcyIsIkdyYW51bGFyaXR5IiwiTUlMTElTRUNPTkRMWSIsIlRXT19NSUxMSVNFQ09ORExZIiwiRklWRV9NSUxMSVNFQ09ORExZIiwiVEVOX01JTExJU0VDT05ETFkiLCJGSUZUWV9NSUxMSVNFQ09ORExZIiwiSFVORFJFRF9NSUxMSVNFQ09ORExZIiwiRklWRV9IVU5EUkVEX01JTExJU0VDT05ETFkiLCJTRUNPTkRMWSIsIlRXT19TRUNPTkRMWSIsIkZJVkVfU0VDT05ETFkiLCJURU5fU0VDT05ETFkiLCJUSElSVFlfU0VDT05ETFkiLCJNSU5VVEVMWSIsIlRXT19NSU5VVEVMWSIsIkZJVkVfTUlOVVRFTFkiLCJURU5fTUlOVVRFTFkiLCJUSElSVFlfTUlOVVRFTFkiLCJIT1VSTFkiLCJUV09fSE9VUkxZIiwiU0lYX0hPVVJMWSIsIkRBSUxZIiwiVFdPX0RBSUxZIiwiV0VFS0xZIiwiTU9OVEhMWSIsIlFVQVJURVJMWSIsIkJJQU5OVUFMIiwiQU5OVUFMIiwiREVDQURBTCIsIkNFTlRFTk5JQUwiLCJOVU1fR1JBTlVMQVJJVElFUyIsIkRhdGVGaWVsZCIsIkRBVEVGSUVMRF9ZIiwiREFURUZJRUxEX00iLCJEQVRFRklFTERfRCIsIkRBVEVGSUVMRF9ISCIsIkRBVEVGSUVMRF9NTSIsIkRBVEVGSUVMRF9TUyIsIkRBVEVGSUVMRF9NUyIsIk5VTV9EQVRFRklFTERTIiwiVElDS19QTEFDRU1FTlQiLCJkYXRlZmllbGQiLCJzdGVwIiwicG93ZXIiLCJyYW5nZSIsIm11bHQiLCJ2YWwiLCJudW1fdGlja3MiLCJudW1EYXRlVGlja3MiLCJzdGFydF90aW1lIiwiZW5kX3RpbWUiLCJncmFudWxhcml0eSIsInJvdW5kIiwiZGciLCJ1dGMiLCJhY2Nlc3NvcnMiLCJzdGFydF9kYXRlIiwiRGF0ZSIsImRhdGVfYXJyYXkiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXRNaWxsaXNlY29uZHMiLCJzdGFydF9kYXRlX29mZnNldCIsImdldERheSIsImRmIiwidGlja19kYXRlIiwibWFrZURhdGUiLCJhcHBseSIsInRpY2tfdGltZSIsImdldFRpbWUiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFBQTs7Ozs7O0FBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNEQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJQSxXQUFXQyxTQUFmLEMsQ0FBMkI7O0FBRTNCOzs7Ozs7Ozs7QUFTQSxJQUFJQyxTQUFTRCxTQUFi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QVlxQixLQUEzQixJQUNBa0MsVUFBVU8sUUFBVixDQUFtQk8sU0FBbkIsSUFBZ0MzQixJQUFoQyxLQUF5QyxDQUQ3QyxFQUNnRDtBQUM5Q25GLGNBQU1NLElBQU4sQ0FBVyxFQUFFQyxHQUFHMEcsU0FBTDtBQUNFN0YsaUJBQU9lLFVBQVVDLElBQVYsQ0FBZTBELEVBQWYsRUFBbUJnQixTQUFuQixFQUE4QmxCLFdBQTlCLEVBQTJDbkcsSUFBM0MsRUFBaURxRyxFQUFqRDtBQURULFNBQVg7QUFHRDtBQUNESyxpQkFBV2pCLFNBQVgsS0FBeUJDLElBQXpCO0FBQ0EyQixrQkFBWWQsVUFBVWUsUUFBVixDQUFtQkMsS0FBbkIsQ0FBeUIsSUFBekIsRUFBK0JiLFVBQS9CLENBQVo7QUFDQWMsa0JBQVlILFVBQVVJLE9BQVYsRUFBWjtBQUNEO0FBQ0Y7QUFDRCxTQUFPbEgsS0FBUDtBQUNELENBcEZNIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTEgRGFuIFZhbmRlcmthbSAoZGFudmRrQGdtYWlsLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVzY3JpcHRpb24gb2YgdGhpcyBmaWxlLlxuICogQGF1dGhvciBkYW52a0Bnb29nbGUuY29tIChEYW4gVmFuZGVya2FtKVxuICpcbiAqIEEgdGlja2VyIGlzIGEgZnVuY3Rpb24gd2l0aCB0aGUgZm9sbG93aW5nIGludGVyZmFjZTpcbiAqXG4gKiBmdW5jdGlvbihhLCBiLCBwaXhlbHMsIG9wdGlvbnNfdmlldywgZHlncmFwaCwgZm9yY2VkX3ZhbHVlcyk7XG4gKiAtPiBbIHsgdjogdGljazFfdiwgbGFiZWw6IHRpY2sxX2xhYmVsWywgbGFiZWxfdjogbGFiZWxfdjFdIH0sXG4gKiAgICAgIHsgdjogdGljazJfdiwgbGFiZWw6IHRpY2syX2xhYmVsWywgbGFiZWxfdjogbGFiZWxfdjJdIH0sXG4gKiAgICAgIC4uLlxuICogICAgXVxuICpcbiAqIFRoZSByZXR1cm5lZCB2YWx1ZSBpcyBjYWxsZWQgYSBcInRpY2sgbGlzdFwiLlxuICpcbiAqIEFyZ3VtZW50c1xuICogLS0tLS0tLS0tXG4gKlxuICogW2EsIGJdIGlzIHRoZSByYW5nZSBvZiB0aGUgYXhpcyBmb3Igd2hpY2ggdGlja3MgYXJlIGJlaW5nIGdlbmVyYXRlZC4gRm9yIGFcbiAqIG51bWVyaWMgYXhpcywgdGhlc2Ugd2lsbCBzaW1wbHkgYmUgbnVtYmVycy4gRm9yIGEgZGF0ZSBheGlzLCB0aGVzZSB3aWxsIGJlXG4gKiBtaWxsaXMgc2luY2UgZXBvY2ggKGNvbnZlcnRhYmxlIHRvIERhdGUgb2JqZWN0cyB1c2luZyBcIm5ldyBEYXRlKGEpXCIgYW5kIFwibmV3XG4gKiBEYXRlKGIpXCIpLlxuICpcbiAqIG9wdHMgcHJvdmlkZXMgYWNjZXNzIHRvIGNoYXJ0LSBhbmQgYXhpcy1zcGVjaWZpYyBvcHRpb25zLiBJdCBjYW4gYmUgdXNlZCB0b1xuICogYWNjZXNzIG51bWJlci9kYXRlIGZvcm1hdHRpbmcgY29kZS9vcHRpb25zLCBjaGVjayBmb3IgYSBsb2cgc2NhbGUsIGV0Yy5cbiAqXG4gKiBwaXhlbHMgaXMgdGhlIGxlbmd0aCBvZiB0aGUgYXhpcyBpbiBwaXhlbHMuIG9wdHMoJ3BpeGVsc1BlckxhYmVsJykgaXMgdGhlXG4gKiBtaW5pbXVtIGFtb3VudCBvZiBzcGFjZSB0byBiZSBhbGxvdHRlZCB0byBlYWNoIGxhYmVsLiBGb3IgaW5zdGFuY2UsIGlmXG4gKiBwaXhlbHM9NDAwIGFuZCBvcHRzKCdwaXhlbHNQZXJMYWJlbCcpPTQwIHRoZW4gdGhlIHRpY2tlciBzaG91bGQgcmV0dXJuXG4gKiBiZXR3ZWVuIHplcm8gYW5kIHRlbiAoNDAwLzQwKSB0aWNrcy5cbiAqXG4gKiBkeWdyYXBoIGlzIHRoZSBEeWdyYXBoIG9iamVjdCBmb3Igd2hpY2ggYW4gYXhpcyBpcyBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqXG4gKiBmb3JjZWRfdmFsdWVzIGlzIHVzZWQgZm9yIHNlY29uZGFyeSB5LWF4ZXMuIFRoZSB0aWNrIHBvc2l0aW9ucyBhcmUgdHlwaWNhbGx5XG4gKiBzZXQgYnkgdGhlIHByaW1hcnkgeS1heGlzLCBzbyB0aGUgc2Vjb25kYXJ5IHktYXhpcyBoYXMgbm8gY2hvaWNlIGluIHdoZXJlIHRvXG4gKiBwdXQgdGhlc2UuIEl0IHNpbXBseSBoYXMgdG8gZ2VuZXJhdGUgbGFiZWxzIGZvciB0aGVzZSBkYXRhIHZhbHVlcy5cbiAqXG4gKiBUaWNrIGxpc3RzXG4gKiAtLS0tLS0tLS0tXG4gKiBUeXBpY2FsbHkgYSB0aWNrIHdpbGwgaGF2ZSBib3RoIGEgZ3JpZC90aWNrIGxpbmUgYW5kIGEgbGFiZWwgYXQgb25lIGVuZCBvZlxuICogdGhhdCBsaW5lIChhdCB0aGUgYm90dG9tIGZvciBhbiB4LWF4aXMsIGF0IGxlZnQgb3IgcmlnaHQgZm9yIHRoZSB5LWF4aXMpLlxuICpcbiAqIEEgdGljayBtYXkgYmUgbWlzc2luZyBvbmUgb2YgdGhlc2UgdHdvIGNvbXBvbmVudHM6XG4gKiAtIElmIFwibGFiZWxfdlwiIGlzIHNwZWNpZmllZCBpbnN0ZWFkIG9mIFwidlwiLCB0aGVuIHRoZXJlIHdpbGwgYmUgbm8gdGljayBvclxuICogICBncmlkbGluZSwganVzdCBhIGxhYmVsLlxuICogLSBTaW1pbGFybHksIGlmIFwibGFiZWxcIiBpcyBub3Qgc3BlY2lmaWVkLCB0aGVuIHRoZXJlIHdpbGwgYmUgYSBncmlkbGluZVxuICogICB3aXRob3V0IGEgbGFiZWwuXG4gKlxuICogVGhpcyBmbGV4aWJpbGl0eSBpcyB1c2VmdWwgaW4gYSBmZXcgc2l0dWF0aW9uczpcbiAqIC0gRm9yIGxvZyBzY2FsZXMsIHNvbWUgb2YgdGhlIHRpY2sgbGluZXMgbWF5IGJlIHRvbyBjbG9zZSB0byBhbGwgaGF2ZSBsYWJlbHMuXG4gKiAtIEZvciBkYXRlIHNjYWxlcyB3aGVyZSB5ZWFycyBhcmUgYmVpbmcgZGlzcGxheWVkLCBpdCBpcyBkZXNpcmFibGUgdG8gZGlzcGxheVxuICogICB0aWNrIG1hcmtzIGF0IHRoZSBiZWdpbm5pbmdzIG9mIHllYXJzIGJ1dCBsYWJlbHMgKGUuZy4gXCIyMDA2XCIpIGluIHRoZVxuICogICBtaWRkbGUgb2YgdGhlIHllYXJzLlxuICovXG5cbi8qanNoaW50IHN1Yjp0cnVlICovXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi9keWdyYXBoLXV0aWxzJztcblxuLyoqIEB0eXBlZGVmIHtBcnJheS48e3Y6bnVtYmVyLCBsYWJlbDpzdHJpbmcsIGxhYmVsX3Y6KHN0cmluZ3x1bmRlZmluZWQpfT59ICovXG52YXIgVGlja0xpc3QgPSB1bmRlZmluZWQ7ICAvLyB0aGUgJyA9IHVuZGVmaW5lZCcga2VlcHMganNoaW50IGhhcHB5LlxuXG4vKiogQHR5cGVkZWYge2Z1bmN0aW9uKFxuICogICAgbnVtYmVyLFxuICogICAgbnVtYmVyLFxuICogICAgbnVtYmVyLFxuICogICAgZnVuY3Rpb24oc3RyaW5nKToqLFxuICogICAgRHlncmFwaD0sXG4gKiAgICBBcnJheS48bnVtYmVyPj1cbiAqICApOiBUaWNrTGlzdH1cbiAqL1xudmFyIFRpY2tlciA9IHVuZGVmaW5lZDsgIC8vIHRoZSAnID0gdW5kZWZpbmVkJyBrZWVwcyBqc2hpbnQgaGFwcHkuXG5cbi8qKiBAdHlwZSB7VGlja2VyfSAqL1xuZXhwb3J0IHZhciBudW1lcmljTGluZWFyVGlja3MgPSBmdW5jdGlvbihhLCBiLCBwaXhlbHMsIG9wdHMsIGR5Z3JhcGgsIHZhbHMpIHtcbiAgdmFyIG5vbkxvZ3NjYWxlT3B0cyA9IGZ1bmN0aW9uKG9wdCkge1xuICAgIGlmIChvcHQgPT09ICdsb2dzY2FsZScpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gb3B0cyhvcHQpO1xuICB9O1xuICByZXR1cm4gbnVtZXJpY1RpY2tzKGEsIGIsIHBpeGVscywgbm9uTG9nc2NhbGVPcHRzLCBkeWdyYXBoLCB2YWxzKTtcbn07XG5cbi8qKiBAdHlwZSB7VGlja2VyfSAqL1xuZXhwb3J0IHZhciBudW1lcmljVGlja3MgPSBmdW5jdGlvbihhLCBiLCBwaXhlbHMsIG9wdHMsIGR5Z3JhcGgsIHZhbHMpIHtcbiAgdmFyIHBpeGVsc19wZXJfdGljayA9IC8qKiBAdHlwZXtudW1iZXJ9ICovKG9wdHMoJ3BpeGVsc1BlckxhYmVsJykpO1xuICB2YXIgdGlja3MgPSBbXTtcbiAgdmFyIGksIGosIHRpY2tWLCBuVGlja3M7XG4gIGlmICh2YWxzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRpY2tzLnB1c2goe3Y6IHZhbHNbaV19KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVE9ETyhkYW52ayk6IGZhY3RvciB0aGlzIGxvZy1zY2FsZSBibG9jayBvdXQgaW50byBhIHNlcGFyYXRlIGZ1bmN0aW9uLlxuICAgIGlmIChvcHRzKFwibG9nc2NhbGVcIikpIHtcbiAgICAgIG5UaWNrcyAgPSBNYXRoLmZsb29yKHBpeGVscyAvIHBpeGVsc19wZXJfdGljayk7XG4gICAgICB2YXIgbWluSWR4ID0gdXRpbHMuYmluYXJ5U2VhcmNoKGEsIFBSRUZFUlJFRF9MT0dfVElDS19WQUxVRVMsIDEpO1xuICAgICAgdmFyIG1heElkeCA9IHV0aWxzLmJpbmFyeVNlYXJjaChiLCBQUkVGRVJSRURfTE9HX1RJQ0tfVkFMVUVTLCAtMSk7XG4gICAgICBpZiAobWluSWR4ID09IC0xKSB7XG4gICAgICAgIG1pbklkeCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAobWF4SWR4ID09IC0xKSB7XG4gICAgICAgIG1heElkeCA9IFBSRUZFUlJFRF9MT0dfVElDS19WQUxVRVMubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIC8vIENvdW50IHRoZSBudW1iZXIgb2YgdGljayB2YWx1ZXMgd291bGQgYXBwZWFyLCBpZiB3ZSBjYW4gZ2V0IGF0IGxlYXN0XG4gICAgICAvLyBuVGlja3MgLyA0IGFjY2VwdCB0aGVtLlxuICAgICAgdmFyIGxhc3REaXNwbGF5ZWQgPSBudWxsO1xuICAgICAgaWYgKG1heElkeCAtIG1pbklkeCA+PSBuVGlja3MgLyA0KSB7XG4gICAgICAgIGZvciAodmFyIGlkeCA9IG1heElkeDsgaWR4ID49IG1pbklkeDsgaWR4LS0pIHtcbiAgICAgICAgICB2YXIgdGlja1ZhbHVlID0gUFJFRkVSUkVEX0xPR19USUNLX1ZBTFVFU1tpZHhdO1xuICAgICAgICAgIHZhciBwaXhlbF9jb29yZCA9IE1hdGgubG9nKHRpY2tWYWx1ZSAvIGEpIC8gTWF0aC5sb2coYiAvIGEpICogcGl4ZWxzO1xuICAgICAgICAgIHZhciB0aWNrID0geyB2OiB0aWNrVmFsdWUgfTtcbiAgICAgICAgICBpZiAobGFzdERpc3BsYXllZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbGFzdERpc3BsYXllZCA9IHtcbiAgICAgICAgICAgICAgdGlja1ZhbHVlIDogdGlja1ZhbHVlLFxuICAgICAgICAgICAgICBwaXhlbF9jb29yZCA6IHBpeGVsX2Nvb3JkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMocGl4ZWxfY29vcmQgLSBsYXN0RGlzcGxheWVkLnBpeGVsX2Nvb3JkKSA+PSBwaXhlbHNfcGVyX3RpY2spIHtcbiAgICAgICAgICAgICAgbGFzdERpc3BsYXllZCA9IHtcbiAgICAgICAgICAgICAgICB0aWNrVmFsdWUgOiB0aWNrVmFsdWUsXG4gICAgICAgICAgICAgICAgcGl4ZWxfY29vcmQgOiBwaXhlbF9jb29yZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGljay5sYWJlbCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRpY2tzLnB1c2godGljayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2Ugd2Ugd2VudCBpbiBiYWNrd2FyZHMgb3JkZXIuXG4gICAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0aWNrcy5sZW5ndGggd29uJ3QgYmUgMCBpZiB0aGUgbG9nIHNjYWxlIGZ1bmN0aW9uIGZpbmRzIHZhbHVlcyB0byBpbnNlcnQuXG4gICAgaWYgKHRpY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gQmFzaWMgaWRlYTpcbiAgICAgIC8vIFRyeSBsYWJlbHMgZXZlcnkgMSwgMiwgNSwgMTAsIDIwLCA1MCwgMTAwLCBldGMuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIHJlc3VsdGluZyB0aWNrIHNwYWNpbmcgKGkuZS4gdGhpcy5oZWlnaHRfIC8gblRpY2tzKS5cbiAgICAgIC8vIFRoZSBmaXJzdCBzcGFjaW5nIGdyZWF0ZXIgdGhhbiBwaXhlbHNQZXJZTGFiZWwgaXMgd2hhdCB3ZSB1c2UuXG4gICAgICAvLyBUT0RPKGRhbnZrKTogdmVyc2lvbiB0aGF0IHdvcmtzIG9uIGEgbG9nIHNjYWxlLlxuICAgICAgdmFyIGttZzIgPSBvcHRzKFwibGFiZWxzS01HMlwiKTtcbiAgICAgIHZhciBtdWx0cywgYmFzZTtcbiAgICAgIGlmIChrbWcyKSB7XG4gICAgICAgIG11bHRzID0gWzEsIDIsIDQsIDgsIDE2LCAzMiwgNjQsIDEyOCwgMjU2XTtcbiAgICAgICAgYmFzZSA9IDE2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXVsdHMgPSBbMSwgMiwgNSwgMTAsIDIwLCA1MCwgMTAwXTtcbiAgICAgICAgYmFzZSA9IDEwO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHBlcm1pdHRlZCB0aWNrcyBiYXNlZCBvbiB0aGVcbiAgICAgIC8vIGdyYXBoJ3MgcGl4ZWwgc2l6ZSBhbmQgcGl4ZWxzX3Blcl90aWNrIHNldHRpbmcuXG4gICAgICB2YXIgbWF4X3RpY2tzID0gTWF0aC5jZWlsKHBpeGVscyAvIHBpeGVsc19wZXJfdGljayk7XG5cbiAgICAgIC8vIE5vdyBjYWxjdWxhdGUgdGhlIGRhdGEgdW5pdCBlcXVpdmFsZW50IG9mIHRoaXMgdGljayBzcGFjaW5nLlxuICAgICAgLy8gVXNlIGFicygpIHNpbmNlIGdyYXBocyBtYXkgaGF2ZSBhIHJldmVyc2VkIFkgYXhpcy5cbiAgICAgIHZhciB1bml0c19wZXJfdGljayA9IE1hdGguYWJzKGIgLSBhKSAvIG1heF90aWNrcztcblxuICAgICAgLy8gQmFzZWQgb24gdGhpcywgZ2V0IGEgc3RhcnRpbmcgc2NhbGUgd2hpY2ggaXMgdGhlIGxhcmdlc3RcbiAgICAgIC8vIGludGVnZXIgcG93ZXIgb2YgdGhlIGNob3NlbiBiYXNlICgxMCBvciAxNikgdGhhdCBzdGlsbCByZW1haW5zXG4gICAgICAvLyBiZWxvdyB0aGUgcmVxdWVzdGVkIHBpeGVsc19wZXJfdGljayBzcGFjaW5nLlxuICAgICAgdmFyIGJhc2VfcG93ZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nKHVuaXRzX3Blcl90aWNrKSAvIE1hdGgubG9nKGJhc2UpKTtcbiAgICAgIHZhciBiYXNlX3NjYWxlID0gTWF0aC5wb3coYmFzZSwgYmFzZV9wb3dlcik7XG5cbiAgICAgIC8vIE5vdyB0cnkgbXVsdGlwbGVzIG9mIHRoZSBzdGFydGluZyBzY2FsZSB1bnRpbCB3ZSBmaW5kIG9uZVxuICAgICAgLy8gdGhhdCByZXN1bHRzIGluIHRpY2sgbWFya3Mgc3BhY2VkIHN1ZmZpY2llbnRseSBmYXIgYXBhcnQuXG4gICAgICAvLyBUaGUgXCJtdWx0c1wiIGFycmF5IHNob3VsZCBjb3ZlciB0aGUgcmFuZ2UgMSAuLiBiYXNlXjIgdG9cbiAgICAgIC8vIGFkanVzdCBmb3Igcm91bmRpbmcgYW5kIGVkZ2UgZWZmZWN0cy5cbiAgICAgIHZhciBzY2FsZSwgbG93X3ZhbCwgaGlnaF92YWwsIHNwYWNpbmc7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbXVsdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc2NhbGUgPSBiYXNlX3NjYWxlICogbXVsdHNbal07XG4gICAgICAgIGxvd192YWwgPSBNYXRoLmZsb29yKGEgLyBzY2FsZSkgKiBzY2FsZTtcbiAgICAgICAgaGlnaF92YWwgPSBNYXRoLmNlaWwoYiAvIHNjYWxlKSAqIHNjYWxlO1xuICAgICAgICBuVGlja3MgPSBNYXRoLmFicyhoaWdoX3ZhbCAtIGxvd192YWwpIC8gc2NhbGU7XG4gICAgICAgIHNwYWNpbmcgPSBwaXhlbHMgLyBuVGlja3M7XG4gICAgICAgIGlmIChzcGFjaW5nID4gcGl4ZWxzX3Blcl90aWNrKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQ29uc3RydWN0IHRoZSBzZXQgb2YgdGlja3MuXG4gICAgICAvLyBBbGxvdyByZXZlcnNlIHktYXhpcyBpZiBpdCdzIGV4cGxpY2l0bHkgcmVxdWVzdGVkLlxuICAgICAgaWYgKGxvd192YWwgPiBoaWdoX3ZhbCkgc2NhbGUgKj0gLTE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDw9IG5UaWNrczsgaSsrKSB7XG4gICAgICAgIHRpY2tWID0gbG93X3ZhbCArIGkgKiBzY2FsZTtcbiAgICAgICAgdGlja3MucHVzaCgge3Y6IHRpY2tWfSApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBmb3JtYXR0ZXIgPSAvKipAdHlwZXtBeGlzTGFiZWxGb3JtYXR0ZXJ9Ki8ob3B0cygnYXhpc0xhYmVsRm9ybWF0dGVyJykpO1xuXG4gIC8vIEFkZCBsYWJlbHMgdG8gdGhlIHRpY2tzLlxuICBmb3IgKGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGlja3NbaV0ubGFiZWwgIT09IHVuZGVmaW5lZCkgY29udGludWU7ICAvLyBVc2UgY3VycmVudCBsYWJlbC5cbiAgICAvLyBUT0RPKGRhbnZrKTogc2V0IGdyYW51bGFyaXR5IHRvIHNvbWV0aGluZyBhcHByb3ByaWF0ZSBoZXJlLlxuICAgIHRpY2tzW2ldLmxhYmVsID0gZm9ybWF0dGVyLmNhbGwoZHlncmFwaCwgdGlja3NbaV0udiwgMCwgb3B0cywgZHlncmFwaCk7XG4gIH1cblxuICByZXR1cm4gdGlja3M7XG59O1xuXG5cbi8qKiBAdHlwZSB7VGlja2VyfSAqL1xuZXhwb3J0IHZhciBkYXRlVGlja2VyID0gZnVuY3Rpb24oYSwgYiwgcGl4ZWxzLCBvcHRzLCBkeWdyYXBoLCB2YWxzKSB7XG4gIHZhciBjaG9zZW4gPSBwaWNrRGF0ZVRpY2tHcmFudWxhcml0eShhLCBiLCBwaXhlbHMsIG9wdHMpO1xuXG4gIGlmIChjaG9zZW4gPj0gMCkge1xuICAgIHJldHVybiBnZXREYXRlQXhpcyhhLCBiLCBjaG9zZW4sIG9wdHMsIGR5Z3JhcGgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoaXMgY2FuIGhhcHBlbiBpZiBzZWxmLndpZHRoXyBpcyB6ZXJvLlxuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuLy8gVGltZSBncmFudWxhcml0eSBlbnVtZXJhdGlvblxuZXhwb3J0IHZhciBHcmFudWxhcml0eSA9IHtcbiAgTUlMTElTRUNPTkRMWTogMCxcbiAgVFdPX01JTExJU0VDT05ETFk6IDEsXG4gIEZJVkVfTUlMTElTRUNPTkRMWTogMixcbiAgVEVOX01JTExJU0VDT05ETFk6IDMsXG4gIEZJRlRZX01JTExJU0VDT05ETFk6IDQsXG4gIEhVTkRSRURfTUlMTElTRUNPTkRMWTogNSxcbiAgRklWRV9IVU5EUkVEX01JTExJU0VDT05ETFk6IDYsXG4gIFNFQ09ORExZOiA3LFxuICBUV09fU0VDT05ETFk6IDgsXG4gIEZJVkVfU0VDT05ETFk6IDksXG4gIFRFTl9TRUNPTkRMWTogMTAsXG4gIFRISVJUWV9TRUNPTkRMWTogMTEsXG4gIE1JTlVURUxZOiAxMixcbiAgVFdPX01JTlVURUxZOiAxMyxcbiAgRklWRV9NSU5VVEVMWTogMTQsXG4gIFRFTl9NSU5VVEVMWTogMTUsXG4gIFRISVJUWV9NSU5VVEVMWTogMTYsXG4gIEhPVVJMWTogMTcsXG4gIFRXT19IT1VSTFk6IDE4LFxuICBTSVhfSE9VUkxZOiAxOSxcbiAgREFJTFk6IDIwLFxuICBUV09fREFJTFk6IDIxLFxuICBXRUVLTFk6IDIyLFxuICBNT05USExZOiAyMyxcbiAgUVVBUlRFUkxZOiAyNCxcbiAgQklBTk5VQUw6IDI1LFxuICBBTk5VQUw6IDI2LFxuICBERUNBREFMOiAyNyxcbiAgQ0VOVEVOTklBTDogMjgsXG4gIE5VTV9HUkFOVUxBUklUSUVTOiAyOVxufVxuXG4vLyBEYXRlIGNvbXBvbmVudHMgZW51bWVyYXRpb24gKGluIHRoZSBvcmRlciBvZiB0aGUgYXJndW1lbnRzIGluIERhdGUpXG4vLyBUT0RPOiBtYWtlIHRoaXMgYW4gQGVudW1cbnZhciBEYXRlRmllbGQgPSB7XG4gIERBVEVGSUVMRF9ZOiAwLFxuICBEQVRFRklFTERfTTogMSxcbiAgREFURUZJRUxEX0Q6IDIsXG4gIERBVEVGSUVMRF9ISDogMyxcbiAgREFURUZJRUxEX01NOiA0LFxuICBEQVRFRklFTERfU1M6IDUsXG4gIERBVEVGSUVMRF9NUzogNixcbiAgTlVNX0RBVEVGSUVMRFM6IDdcbn07XG5cblxuLyoqXG4gKiBUaGUgdmFsdWUgb2YgZGF0ZWZpZWxkIHdpbGwgc3RhcnQgYXQgYW4gZXZlbiBtdWx0aXBsZSBvZiBcInN0ZXBcIiwgaS5lLlxuICogICBpZiBkYXRlZmllbGQ9U1MgYW5kIHN0ZXA9NSB0aGVuIHRoZSBmaXJzdCB0aWNrIHdpbGwgYmUgb24gYSBtdWx0aXBsZSBvZiA1cy5cbiAqXG4gKiBGb3IgZ3JhbnVsYXJpdGllcyA8PSBIT1VSTFksIHRpY2tzIGFyZSBnZW5lcmF0ZWQgZXZlcnkgYHNwYWNpbmdgIG1zLlxuICpcbiAqIEF0IGNvYXJzZXIgZ3JhbnVsYXJpdGllcywgdGlja3MgYXJlIGdlbmVyYXRlZCBieSBpbmNyZW1lbnRpbmcgYGRhdGVmaWVsZGAgYnlcbiAqICAgYHN0ZXBgLiBJbiB0aGlzIGNhc2UsIHRoZSBgc3BhY2luZ2AgdmFsdWUgaXMgb25seSB1c2VkIHRvIGVzdGltYXRlIHRoZVxuICogICBudW1iZXIgb2YgdGlja3MuIEl0IHNob3VsZCByb3VnaGx5IGNvcnJlc3BvbmQgdG8gdGhlIHNwYWNpbmcgYmV0d2VlblxuICogICBhZGphY2VudCB0aWNrcy5cbiAqXG4gKiBAdHlwZSB7QXJyYXkuPHtkYXRlZmllbGQ6bnVtYmVyLCBzdGVwOm51bWJlciwgc3BhY2luZzpudW1iZXJ9Pn1cbiAqL1xudmFyIFRJQ0tfUExBQ0VNRU5UID0gW107XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5NSUxMSVNFQ09ORExZXSAgICAgICAgICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NUywgc3RlcDogICAxLCBzcGFjaW5nOiAxfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LlRXT19NSUxMSVNFQ09ORExZXSAgICAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX01TLCBzdGVwOiAgIDIsIHNwYWNpbmc6IDJ9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuRklWRV9NSUxMSVNFQ09ORExZXSAgICAgICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfTVMsIHN0ZXA6ICAgNSwgc3BhY2luZzogNX07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5URU5fTUlMTElTRUNPTkRMWV0gICAgICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NUywgc3RlcDogIDEwLCBzcGFjaW5nOiAxMH07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5GSUZUWV9NSUxMSVNFQ09ORExZXSAgICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NUywgc3RlcDogIDUwLCBzcGFjaW5nOiA1MH07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5IVU5EUkVEX01JTExJU0VDT05ETFldICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NUywgc3RlcDogMTAwLCBzcGFjaW5nOiAxMDB9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuRklWRV9IVU5EUkVEX01JTExJU0VDT05ETFldICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfTVMsIHN0ZXA6IDUwMCwgc3BhY2luZzogNTAwfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LlNFQ09ORExZXSAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX1NTLCBzdGVwOiAgIDEsIHNwYWNpbmc6IDEwMDAgKiAxfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LlRXT19TRUNPTkRMWV0gICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX1NTLCBzdGVwOiAgIDIsIHNwYWNpbmc6IDEwMDAgKiAyfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LkZJVkVfU0VDT05ETFldICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX1NTLCBzdGVwOiAgIDUsIHNwYWNpbmc6IDEwMDAgKiA1fTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LlRFTl9TRUNPTkRMWV0gICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX1NTLCBzdGVwOiAgMTAsIHNwYWNpbmc6IDEwMDAgKiAxMH07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5USElSVFlfU0VDT05ETFldID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9TUywgc3RlcDogIDMwLCBzcGFjaW5nOiAxMDAwICogMzB9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuTUlOVVRFTFldICAgICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfTU0sIHN0ZXA6ICAgMSwgc3BhY2luZzogMTAwMCAqIDYwfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LlRXT19NSU5VVEVMWV0gICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX01NLCBzdGVwOiAgIDIsIHNwYWNpbmc6IDEwMDAgKiA2MCAqIDJ9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuRklWRV9NSU5VVEVMWV0gICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfTU0sIHN0ZXA6ICAgNSwgc3BhY2luZzogMTAwMCAqIDYwICogNX07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5URU5fTUlOVVRFTFldICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NTSwgc3RlcDogIDEwLCBzcGFjaW5nOiAxMDAwICogNjAgKiAxMH07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5USElSVFlfTUlOVVRFTFldID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NTSwgc3RlcDogIDMwLCBzcGFjaW5nOiAxMDAwICogNjAgKiAzMH07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5IT1VSTFldICAgICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9ISCwgc3RlcDogICAxLCBzcGFjaW5nOiAxMDAwICogMzYwMH07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5UV09fSE9VUkxZXSAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9ISCwgc3RlcDogICAyLCBzcGFjaW5nOiAxMDAwICogMzYwMCAqIDJ9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuU0lYX0hPVVJMWV0gICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfSEgsIHN0ZXA6ICAgNiwgc3BhY2luZzogMTAwMCAqIDM2MDAgKiA2fTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LkRBSUxZXSAgICAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX0QsICBzdGVwOiAgIDEsIHNwYWNpbmc6IDEwMDAgKiA4NjQwMH07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5UV09fREFJTFldICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9ELCAgc3RlcDogICAyLCBzcGFjaW5nOiAxMDAwICogODY0MDAgKiAyfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LldFRUtMWV0gICAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX0QsICBzdGVwOiAgIDcsIHNwYWNpbmc6IDEwMDAgKiA2MDQ4MDB9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuTU9OVEhMWV0gICAgICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfTSwgIHN0ZXA6ICAgMSwgc3BhY2luZzogMTAwMCAqIDcyMDAgICogMzY1LjI1MjR9OyAvLyAxZTMgKiA2MCAqIDYwICogMjQgKiAzNjUuMjUyNCAvIDEyXG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5RVUFSVEVSTFldICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NLCAgc3RlcDogICAzLCBzcGFjaW5nOiAxMDAwICogMjE2MDAgKiAzNjUuMjUyNH07IC8vIDFlMyAqIDYwICogNjAgKiAyNCAqIDM2NS4yNTI0IC8gNFxuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuQklBTk5VQUxdICAgICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfTSwgIHN0ZXA6ICAgNiwgc3BhY2luZzogMTAwMCAqIDQzMjAwICogMzY1LjI1MjR9OyAvLyAxZTMgKiA2MCAqIDYwICogMjQgKiAzNjUuMjUyNCAvIDJcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LkFOTlVBTF0gICAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX1ksICBzdGVwOiAgIDEsIHNwYWNpbmc6IDEwMDAgKiA4NjQwMCAgICogMzY1LjI1MjR9OyAvLyAxZTMgKiA2MCAqIDYwICogMjQgKiAzNjUuMjUyNCAqIDFcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LkRFQ0FEQUxdICAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX1ksICBzdGVwOiAgMTAsIHNwYWNpbmc6IDEwMDAgKiA4NjQwMDAgICogMzY1LjI1MjR9OyAvLyAxZTMgKiA2MCAqIDYwICogMjQgKiAzNjUuMjUyNCAqIDEwXG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5DRU5URU5OSUFMXSAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9ZLCAgc3RlcDogMTAwLCBzcGFjaW5nOiAxMDAwICogODY0MDAwMCAqIDM2NS4yNTI0fTsgLy8gMWUzICogNjAgKiA2MCAqIDI0ICogMzY1LjI1MjQgKiAxMDBcblxuXG4vKipcbiAqIFRoaXMgaXMgYSBsaXN0IG9mIGh1bWFuLWZyaWVuZGx5IHZhbHVlcyBhdCB3aGljaCB0byBzaG93IHRpY2sgbWFya3Mgb24gYSBsb2dcbiAqIHNjYWxlLiBJdCBpcyBrICogMTBebiwgd2hlcmUgaz0xLi45IGFuZCBuPS0zOS4uKzM5LCBzbzpcbiAqIC4uLiwgMSwgMiwgMywgNCwgNSwgLi4uLCA5LCAxMCwgMjAsIDMwLCAuLi4sIDkwLCAxMDAsIDIwMCwgMzAwLCAuLi5cbiAqIE5PVEU6IHRoaXMgYXNzdW1lcyB0aGF0IHV0aWxzLkxPR19TQ0FMRSA9IDEwLlxuICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICovXG52YXIgUFJFRkVSUkVEX0xPR19USUNLX1ZBTFVFUyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHZhbHMgPSBbXTtcbiAgZm9yICh2YXIgcG93ZXIgPSAtMzk7IHBvd2VyIDw9IDM5OyBwb3dlcisrKSB7XG4gICAgdmFyIHJhbmdlID0gTWF0aC5wb3coMTAsIHBvd2VyKTtcbiAgICBmb3IgKHZhciBtdWx0ID0gMTsgbXVsdCA8PSA5OyBtdWx0KyspIHtcbiAgICAgIHZhciB2YWwgPSByYW5nZSAqIG11bHQ7XG4gICAgICB2YWxzLnB1c2godmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHM7XG59KSgpO1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgY29ycmVjdCBncmFudWxhcml0eSBvZiB0aWNrcyBvbiBhIGRhdGUgYXhpcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYSBMZWZ0IGVkZ2Ugb2YgdGhlIGNoYXJ0IChtcylcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFJpZ2h0IGVkZ2Ugb2YgdGhlIGNoYXJ0IChtcylcbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbHMgU2l6ZSBvZiB0aGUgY2hhcnQgaW4gdGhlIHJlbGV2YW50IGRpbWVuc2lvbiAod2lkdGgpLlxuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpOip9IG9wdHMgRnVuY3Rpb24gbWFwcGluZyBmcm9tIG9wdGlvbiBuYW1lIC0mZ3Q7IHZhbHVlLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYXBwcm9wcmlhdGUgYXhpcyBncmFudWxhcml0eSBmb3IgdGhpcyBjaGFydC4gU2VlIHRoZVxuICogICAgIGVudW1lcmF0aW9uIG9mIHBvc3NpYmxlIHZhbHVlcyBpbiBkeWdyYXBoLXRpY2tlcnMuanMuXG4gKi9cbnZhciBwaWNrRGF0ZVRpY2tHcmFudWxhcml0eSA9IGZ1bmN0aW9uKGEsIGIsIHBpeGVscywgb3B0cykge1xuICB2YXIgcGl4ZWxzX3Blcl90aWNrID0gLyoqIEB0eXBle251bWJlcn0gKi8ob3B0cygncGl4ZWxzUGVyTGFiZWwnKSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgR3JhbnVsYXJpdHkuTlVNX0dSQU5VTEFSSVRJRVM7IGkrKykge1xuICAgIHZhciBudW1fdGlja3MgPSBudW1EYXRlVGlja3MoYSwgYiwgaSk7XG4gICAgaWYgKHBpeGVscyAvIG51bV90aWNrcyA+PSBwaXhlbHNfcGVyX3RpY2spIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIG51bWJlciBvZiB0aWNrcyBvbiBhIGRhdGUgYXhpcyBmb3IgYSBnaXZlbiBncmFudWxhcml0eS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydF90aW1lXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kX3RpbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBncmFudWxhcml0eSAob25lIG9mIHRoZSBncmFudWxhcml0aWVzIGVudW1lcmF0ZWQgYWJvdmUpXG4gKiBAcmV0dXJuIHtudW1iZXJ9IChBcHByb3hpbWF0ZSkgbnVtYmVyIG9mIHRpY2tzIHRoYXQgd291bGQgcmVzdWx0LlxuICovXG52YXIgbnVtRGF0ZVRpY2tzID0gZnVuY3Rpb24oc3RhcnRfdGltZSwgZW5kX3RpbWUsIGdyYW51bGFyaXR5KSB7XG4gIHZhciBzcGFjaW5nID0gVElDS19QTEFDRU1FTlRbZ3JhbnVsYXJpdHldLnNwYWNpbmc7XG4gIHJldHVybiBNYXRoLnJvdW5kKDEuMCAqIChlbmRfdGltZSAtIHN0YXJ0X3RpbWUpIC8gc3BhY2luZyk7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIHBvc2l0aW9ucyBhbmQgbGFiZWxzIG9mIHRpY2tzIG9uIGEgZGF0ZSBheGlzIGZvciBhIGdpdmVuIGdyYW51bGFyaXR5LlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0X3RpbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRfdGltZVxuICogQHBhcmFtIHtudW1iZXJ9IGdyYW51bGFyaXR5IChvbmUgb2YgdGhlIGdyYW51bGFyaXRpZXMgZW51bWVyYXRlZCBhYm92ZSlcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nKToqfSBvcHRzIEZ1bmN0aW9uIG1hcHBpbmcgZnJvbSBvcHRpb24gbmFtZSAtJmd0OyB2YWx1ZS5cbiAqIEBwYXJhbSB7RHlncmFwaD19IGRnXG4gKiBAcmV0dXJuIHshVGlja0xpc3R9XG4gKi9cbmV4cG9ydCB2YXIgZ2V0RGF0ZUF4aXMgPSBmdW5jdGlvbihzdGFydF90aW1lLCBlbmRfdGltZSwgZ3JhbnVsYXJpdHksIG9wdHMsIGRnKSB7XG4gIHZhciBmb3JtYXR0ZXIgPSAvKiogQHR5cGV7QXhpc0xhYmVsRm9ybWF0dGVyfSAqLyhcbiAgICAgIG9wdHMoXCJheGlzTGFiZWxGb3JtYXR0ZXJcIikpO1xuICB2YXIgdXRjID0gb3B0cyhcImxhYmVsc1VUQ1wiKTtcbiAgdmFyIGFjY2Vzc29ycyA9IHV0YyA/IHV0aWxzLkRhdGVBY2Nlc3NvcnNVVEMgOiB1dGlscy5EYXRlQWNjZXNzb3JzTG9jYWw7XG5cbiAgdmFyIGRhdGVmaWVsZCA9IFRJQ0tfUExBQ0VNRU5UW2dyYW51bGFyaXR5XS5kYXRlZmllbGQ7XG4gIHZhciBzdGVwID0gVElDS19QTEFDRU1FTlRbZ3JhbnVsYXJpdHldLnN0ZXA7XG4gIHZhciBzcGFjaW5nID0gVElDS19QTEFDRU1FTlRbZ3JhbnVsYXJpdHldLnNwYWNpbmc7XG5cbiAgLy8gQ2hvb3NlIGEgbmljZSB0aWNrIHBvc2l0aW9uIGJlZm9yZSB0aGUgaW5pdGlhbCBpbnN0YW50LlxuICAvLyBDdXJyZW50bHksIHRoaXMgY29kZSBkZWFscyBwcm9wZXJseSB3aXRoIHRoZSBleGlzdGVudCBkYWlseSBncmFudWxhcml0aWVzOlxuICAvLyBEQUlMWSAod2l0aCBzdGVwIG9mIDEpIGFuZCBXRUVLTFkgKHdpdGggc3RlcCBvZiA3IGJ1dCBzcGVjaWFsbHkgaGFuZGxlZCkuXG4gIC8vIE90aGVyIGRhaWx5IGdyYW51bGFyaXRpZXMgKHNheSBUV09fREFJTFkpIHNob3VsZCBhbHNvIGJlIGhhbmRsZWQgc3BlY2lhbGx5XG4gIC8vIGJ5IHNldHRpbmcgdGhlIHN0YXJ0X2RhdGVfb2Zmc2V0IHRvIDAuXG4gIHZhciBzdGFydF9kYXRlID0gbmV3IERhdGUoc3RhcnRfdGltZSk7XG4gIHZhciBkYXRlX2FycmF5ID0gW107XG4gIGRhdGVfYXJyYXlbRGF0ZUZpZWxkLkRBVEVGSUVMRF9ZXSAgPSBhY2Nlc3NvcnMuZ2V0RnVsbFllYXIoc3RhcnRfZGF0ZSk7XG4gIGRhdGVfYXJyYXlbRGF0ZUZpZWxkLkRBVEVGSUVMRF9NXSAgPSBhY2Nlc3NvcnMuZ2V0TW9udGgoc3RhcnRfZGF0ZSk7XG4gIGRhdGVfYXJyYXlbRGF0ZUZpZWxkLkRBVEVGSUVMRF9EXSAgPSBhY2Nlc3NvcnMuZ2V0RGF0ZShzdGFydF9kYXRlKTtcbiAgZGF0ZV9hcnJheVtEYXRlRmllbGQuREFURUZJRUxEX0hIXSA9IGFjY2Vzc29ycy5nZXRIb3VycyhzdGFydF9kYXRlKTtcbiAgZGF0ZV9hcnJheVtEYXRlRmllbGQuREFURUZJRUxEX01NXSA9IGFjY2Vzc29ycy5nZXRNaW51dGVzKHN0YXJ0X2RhdGUpO1xuICBkYXRlX2FycmF5W0RhdGVGaWVsZC5EQVRFRklFTERfU1NdID0gYWNjZXNzb3JzLmdldFNlY29uZHMoc3RhcnRfZGF0ZSk7XG4gIGRhdGVfYXJyYXlbRGF0ZUZpZWxkLkRBVEVGSUVMRF9NU10gPSBhY2Nlc3NvcnMuZ2V0TWlsbGlzZWNvbmRzKHN0YXJ0X2RhdGUpO1xuXG4gIHZhciBzdGFydF9kYXRlX29mZnNldCA9IGRhdGVfYXJyYXlbZGF0ZWZpZWxkXSAlIHN0ZXA7XG4gIGlmIChncmFudWxhcml0eSA9PSBHcmFudWxhcml0eS5XRUVLTFkpIHtcbiAgICAvLyBUaGlzIHdpbGwgcHV0IHRoZSB0aWNrcyBvbiBTdW5kYXlzLlxuICAgIHN0YXJ0X2RhdGVfb2Zmc2V0ID0gYWNjZXNzb3JzLmdldERheShzdGFydF9kYXRlKTtcbiAgfVxuICBcbiAgZGF0ZV9hcnJheVtkYXRlZmllbGRdIC09IHN0YXJ0X2RhdGVfb2Zmc2V0O1xuICBmb3IgKHZhciBkZiA9IGRhdGVmaWVsZCArIDE7IGRmIDwgRGF0ZUZpZWxkLk5VTV9EQVRFRklFTERTOyBkZisrKSB7XG4gICAgLy8gVGhlIG1pbmltdW0gdmFsdWUgaXMgMSBmb3IgdGhlIGRheSBvZiBtb250aCwgYW5kIDAgZm9yIGFsbCBvdGhlciBmaWVsZHMuXG4gICAgZGF0ZV9hcnJheVtkZl0gPSAoZGYgPT09IERhdGVGaWVsZC5EQVRFRklFTERfRCkgPyAxIDogMDtcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIHRoZSB0aWNrcy5cbiAgLy8gRm9yIGdyYW51bGFyaXRpZXMgbm90IGNvYXJzZXIgdGhhbiBIT1VSTFkgd2UgdXNlIHRoZSBmYWN0IHRoYXQ6XG4gIC8vICAgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYmV0d2VlbiB0aWNrcyBpcyBjb25zdGFudFxuICAvLyAgIGFuZCBlcXVhbCB0byB0aGUgZGVmaW5lZCBzcGFjaW5nLlxuICAvLyBPdGhlcndpc2Ugd2UgcmVseSBvbiB0aGUgJ3JvbGwgb3ZlcicgcHJvcGVydHkgb2YgdGhlIERhdGUgZnVuY3Rpb25zOlxuICAvLyAgIHdoZW4gc29tZSBkYXRlIGZpZWxkIGlzIHNldCB0byBhIHZhbHVlIG91dHNpZGUgb2YgaXRzIGxvZ2ljYWwgcmFuZ2UsXG4gIC8vICAgdGhlIGV4Y2VzcyAncm9sbHMgb3ZlcicgdGhlIG5leHQgKG1vcmUgc2lnbmlmaWNhbnQpIGZpZWxkLlxuICAvLyBIb3dldmVyLCB3aGVuIHVzaW5nIGxvY2FsIHRpbWUgd2l0aCBEU1QgdHJhbnNpdGlvbnMsXG4gIC8vIHRoZXJlIGFyZSBkYXRlcyB0aGF0IGRvIG5vdCByZXByZXNlbnQgYW55IHRpbWUgdmFsdWUgYXQgYWxsXG4gIC8vICh0aG9zZSBpbiB0aGUgaG91ciBza2lwcGVkIGF0IHRoZSAnc3ByaW5nIGZvcndhcmQnKSxcbiAgLy8gYW5kIHRoZSBKYXZhU2NyaXB0IGVuZ2luZXMgdXN1YWxseSByZXR1cm4gYW4gZXF1aXZhbGVudCB2YWx1ZS5cbiAgLy8gSGVuY2Ugd2UgaGF2ZSB0byBjaGVjayB0aGF0IHRoZSBkYXRlIGlzIHByb3Blcmx5IGluY3JlYXNlZCBhdCBlYWNoIHN0ZXAsXG4gIC8vIHJldHVybmluZyBhIGRhdGUgYXQgYSBuaWNlIHRpY2sgcG9zaXRpb24uXG4gIHZhciB0aWNrcyA9IFtdO1xuICB2YXIgdGlja19kYXRlID0gYWNjZXNzb3JzLm1ha2VEYXRlLmFwcGx5KG51bGwsIGRhdGVfYXJyYXkpO1xuICB2YXIgdGlja190aW1lID0gdGlja19kYXRlLmdldFRpbWUoKTtcbiAgaWYgKGdyYW51bGFyaXR5IDw9IEdyYW51bGFyaXR5LkhPVVJMWSkge1xuICAgIGlmICh0aWNrX3RpbWUgPCBzdGFydF90aW1lKSB7XG4gICAgICB0aWNrX3RpbWUgKz0gc3BhY2luZztcbiAgICAgIHRpY2tfZGF0ZSA9IG5ldyBEYXRlKHRpY2tfdGltZSk7XG4gICAgfVxuICAgIHdoaWxlICh0aWNrX3RpbWUgPD0gZW5kX3RpbWUpIHtcbiAgICAgIHRpY2tzLnB1c2goeyB2OiB0aWNrX3RpbWUsXG4gICAgICAgICAgICAgICAgICAgbGFiZWw6IGZvcm1hdHRlci5jYWxsKGRnLCB0aWNrX2RhdGUsIGdyYW51bGFyaXR5LCBvcHRzLCBkZylcbiAgICAgICAgICAgICAgICAgfSk7XG4gICAgICB0aWNrX3RpbWUgKz0gc3BhY2luZztcbiAgICAgIHRpY2tfZGF0ZSA9IG5ldyBEYXRlKHRpY2tfdGltZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0aWNrX3RpbWUgPCBzdGFydF90aW1lKSB7XG4gICAgICBkYXRlX2FycmF5W2RhdGVmaWVsZF0gKz0gc3RlcDtcbiAgICAgIHRpY2tfZGF0ZSA9IGFjY2Vzc29ycy5tYWtlRGF0ZS5hcHBseShudWxsLCBkYXRlX2FycmF5KTtcbiAgICAgIHRpY2tfdGltZSA9IHRpY2tfZGF0ZS5nZXRUaW1lKCk7XG4gICAgfVxuICAgIHdoaWxlICh0aWNrX3RpbWUgPD0gZW5kX3RpbWUpIHtcbiAgICAgIGlmIChncmFudWxhcml0eSA+PSBHcmFudWxhcml0eS5EQUlMWSB8fFxuICAgICAgICAgIGFjY2Vzc29ycy5nZXRIb3Vycyh0aWNrX2RhdGUpICUgc3RlcCA9PT0gMCkge1xuICAgICAgICB0aWNrcy5wdXNoKHsgdjogdGlja190aW1lLFxuICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGZvcm1hdHRlci5jYWxsKGRnLCB0aWNrX2RhdGUsIGdyYW51bGFyaXR5LCBvcHRzLCBkZylcbiAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRhdGVfYXJyYXlbZGF0ZWZpZWxkXSArPSBzdGVwO1xuICAgICAgdGlja19kYXRlID0gYWNjZXNzb3JzLm1ha2VEYXRlLmFwcGx5KG51bGwsIGRhdGVfYXJyYXkpO1xuICAgICAgdGlja190aW1lID0gdGlja19kYXRlLmdldFRpbWUoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZHlncmFwaHMvc3JjL2R5Z3JhcGgtdGlja2Vycy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_layout__ = __webpack_require__(18);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dygraph_canvas__ = __webpack_require__(16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__dygraph_options__ = __webpack_require__(28);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__dygraph_interaction_model__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__dygraph_default_attrs__ = __webpack_require__(17);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__dygraph_options_reference__ = __webpack_require__(19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__iframe_tarp__ = __webpack_require__(20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__datahandler_default__ = __webpack_require__(15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__datahandler_bars_error__ = __webpack_require__(24);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__datahandler_bars_custom__ = __webpack_require__(23);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__datahandler_default_fractions__ = __webpack_require__(26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__datahandler_bars_fractions__ = __webpack_require__(25);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__datahandler_bars__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__plugins_annotations__ = __webpack_require__(29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__plugins_axes__ = __webpack_require__(30);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__plugins_chart_labels__ = __webpack_require__(31);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__plugins_grid__ = __webpack_require__(32);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__plugins_legend__ = __webpack_require__(33);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__plugins_range_selector__ = __webpack_require__(34);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__dygraph_gviz__ = __webpack_require__(27);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * @license\n * Copyright 2006 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview Creates an interactive, zoomable graph based on a CSV file or\n * string. Dygraph can handle multiple series with or without error bars. The\n * date/value ranges will be automatically set. Dygraph uses the\n * &lt;canvas&gt; tag, so it only works in FF1.5+.\n * @author danvdk@gmail.com (Dan Vanderkam)\n\n  Usage:\n   <div id=\"graphdiv\" style=\"width:800px; height:500px;\"></div>\n   <script type=\"text/javascript\">\n     new Dygraph(document.getElementById(\"graphdiv\"),\n                 \"datafile.csv\",  // CSV file with headers\n                 { }); // options\n   </script>\n\n The CSV file is of the form\n\n   Date,SeriesA,SeriesB,SeriesC\n   YYYYMMDD,A1,B1,C1\n   YYYYMMDD,A2,B2,C2\n\n If the 'errorBars' option is set in the constructor, the input should be of\n the form\n   Date,SeriesA,SeriesB,...\n   YYYYMMDD,A1,sigmaA1,B1,sigmaB1,...\n   YYYYMMDD,A2,sigmaA2,B2,sigmaB2,...\n\n If the 'fractions' option is set, the input should be of the form:\n\n   Date,SeriesA,SeriesB,...\n   YYYYMMDD,A1/B1,A2/B2,...\n   YYYYMMDD,A1/B1,A2/B2,...\n\n And error bars will be calculated automatically using a binomial distribution.\n\n For further documentation and examples, see http://dygraphs.com/\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"use strict\";\n\n/**\n * Creates an interactive, zoomable chart.\n *\n * @constructor\n * @param {div | String} div A div or the id of a div into which to construct\n * the chart.\n * @param {String | Function} file A file containing CSV data or a function\n * that returns this data. The most basic expected format for each line is\n * \"YYYY/MM/DD,val1,val2,...\". For more information, see\n * http://dygraphs.com/data.html.\n * @param {Object} attrs Various other attributes, e.g. errorBars determines\n * whether the input data contains error ranges. For a complete list of\n * options, see http://dygraphs.com/options.html.\n */\nvar Dygraph = function Dygraph(div, data, opts) {\n  this.__init__(div, data, opts);\n};\n\nDygraph.NAME = \"Dygraph\";\nDygraph.VERSION = \"2.0.0\";\n\n// Various default values\nDygraph.DEFAULT_ROLL_PERIOD = 1;\nDygraph.DEFAULT_WIDTH = 480;\nDygraph.DEFAULT_HEIGHT = 320;\n\n// For max 60 Hz. animation:\nDygraph.ANIMATION_STEPS = 12;\nDygraph.ANIMATION_DURATION = 200;\n\n/**\n * Standard plotters. These may be used by clients.\n * Available plotters are:\n * - Dygraph.Plotters.linePlotter: draws central lines (most common)\n * - Dygraph.Plotters.errorPlotter: draws error bars\n * - Dygraph.Plotters.fillPlotter: draws fills under lines (used with fillGraph)\n *\n * By default, the plotter is [fillPlotter, errorPlotter, linePlotter].\n * This causes all the lines to be drawn over all the fills/error bars.\n */\nDygraph.Plotters = __WEBPACK_IMPORTED_MODULE_1__dygraph_canvas__[\"a\" /* default */]._Plotters;\n\n// Used for initializing annotation CSS rules only once.\nDygraph.addedAnnotationCSS = false;\n\n/**\n * Initializes the Dygraph. This creates a new DIV and constructs the PlotKit\n * and context &lt;canvas&gt; inside of it. See the constructor for details.\n * on the parameters.\n * @param {Element} div the Element to render the graph into.\n * @param {string | Function} file Source data\n * @param {Object} attrs Miscellaneous other options\n * @private\n */\nDygraph.prototype.__init__ = function (div, file, attrs) {\n  this.is_initial_draw_ = true;\n  this.readyFns_ = [];\n\n  // Support two-argument constructor\n  if (attrs === null || attrs === undefined) {\n    attrs = {};\n  }\n\n  attrs = Dygraph.copyUserAttrs_(attrs);\n\n  if (typeof div == 'string') {\n    div = document.getElementById(div);\n  }\n\n  if (!div) {\n    throw new Error('Constructing dygraph with a non-existent div!');\n  }\n\n  // Copy the important bits into the object\n  // TODO(danvk): most of these should just stay in the attrs_ dictionary.\n  this.maindiv_ = div;\n  this.file_ = file;\n  this.rollPeriod_ = attrs.rollPeriod || Dygraph.DEFAULT_ROLL_PERIOD;\n  this.previousVerticalX_ = -1;\n  this.fractions_ = attrs.fractions || false;\n  this.dateWindow_ = attrs.dateWindow || null;\n\n  this.annotations_ = [];\n\n  // Clear the div. This ensure that, if multiple dygraphs are passed the same\n  // div, then only one will be drawn.\n  div.innerHTML = \"\";\n\n  // For historical reasons, the 'width' and 'height' options trump all CSS\n  // rules _except_ for an explicit 'width' or 'height' on the div.\n  // As an added convenience, if the div has zero height (like <div></div> does\n  // without any styles), then we use a default height/width.\n  if (div.style.width === '' && attrs.width) {\n    div.style.width = attrs.width + \"px\";\n  }\n  if (div.style.height === '' && attrs.height) {\n    div.style.height = attrs.height + \"px\";\n  }\n  if (div.style.height === '' && div.clientHeight === 0) {\n    div.style.height = Dygraph.DEFAULT_HEIGHT + \"px\";\n    if (div.style.width === '') {\n      div.style.width = Dygraph.DEFAULT_WIDTH + \"px\";\n    }\n  }\n  // These will be zero if the dygraph's div is hidden. In that case,\n  // use the user-specified attributes if present. If not, use zero\n  // and assume the user will call resize to fix things later.\n  this.width_ = div.clientWidth || attrs.width || 0;\n  this.height_ = div.clientHeight || attrs.height || 0;\n\n  // TODO(danvk): set fillGraph to be part of attrs_ here, not user_attrs_.\n  if (attrs.stackedGraph) {\n    attrs.fillGraph = true;\n    // TODO(nikhilk): Add any other stackedGraph checks here.\n  }\n\n  // DEPRECATION WARNING: All option processing should be moved from\n  // attrs_ and user_attrs_ to options_, which holds all this information.\n  //\n  // Dygraphs has many options, some of which interact with one another.\n  // To keep track of everything, we maintain two sets of options:\n  //\n  //  this.user_attrs_   only options explicitly set by the user.\n  //  this.attrs_        defaults, options derived from user_attrs_, data.\n  //\n  // Options are then accessed this.attr_('attr'), which first looks at\n  // user_attrs_ and then computed attrs_. This way Dygraphs can set intelligent\n  // defaults without overriding behavior that the user specifically asks for.\n  this.user_attrs_ = {};\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"a\" /* update */](this.user_attrs_, attrs);\n\n  // This sequence ensures that Dygraph.DEFAULT_ATTRS is never modified.\n  this.attrs_ = {};\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"b\" /* updateDeep */](this.attrs_, __WEBPACK_IMPORTED_MODULE_6__dygraph_default_attrs__[\"a\" /* default */]);\n\n  this.boundaryIds_ = [];\n  this.setIndexByName_ = {};\n  this.datasetIndex_ = [];\n\n  this.registeredEvents_ = [];\n  this.eventListeners_ = {};\n\n  this.attributes_ = new __WEBPACK_IMPORTED_MODULE_2__dygraph_options__[\"a\" /* default */](this);\n\n  // Create the containing DIV and other interactive elements\n  this.createInterface_();\n\n  // Activate plugins.\n  this.plugins_ = [];\n  var plugins = Dygraph.PLUGINS.concat(this.getOption('plugins'));\n  for (var i = 0; i < plugins.length; i++) {\n    // the plugins option may contain either plugin classes or instances.\n    // Plugin instances contain an activate method.\n    var Plugin = plugins[i]; // either a constructor or an instance.\n    var pluginInstance;\n    if (typeof Plugin.activate !== 'undefined') {\n      pluginInstance = Plugin;\n    } else {\n      pluginInstance = new Plugin();\n    }\n\n    var pluginDict = {\n      plugin: pluginInstance,\n      events: {},\n      options: {},\n      pluginOptions: {}\n    };\n\n    var handlers = pluginInstance.activate(this);\n    for (var eventName in handlers) {\n      if (!handlers.hasOwnProperty(eventName)) continue;\n      // TODO(danvk): validate eventName.\n      pluginDict.events[eventName] = handlers[eventName];\n    }\n\n    this.plugins_.push(pluginDict);\n  }\n\n  // At this point, plugins can no longer register event handlers.\n  // Construct a map from event -> ordered list of [callback, plugin].\n  for (var i = 0; i < this.plugins_.length; i++) {\n    var plugin_dict = this.plugins_[i];\n    for (var eventName in plugin_dict.events) {\n      if (!plugin_dict.events.hasOwnProperty(eventName)) continue;\n      var callback = plugin_dict.events[eventName];\n\n      var pair = [plugin_dict.plugin, callback];\n      if (!(eventName in this.eventListeners_)) {\n        this.eventListeners_[eventName] = [pair];\n      } else {\n        this.eventListeners_[eventName].push(pair);\n      }\n    }\n  }\n\n  this.createDragInterface_();\n\n  this.start_();\n};\n\n/**\n * Triggers a cascade of events to the various plugins which are interested in them.\n * Returns true if the \"default behavior\" should be prevented, i.e. if one\n * of the event listeners called event.preventDefault().\n * @private\n */\nDygraph.prototype.cascadeEvents_ = function (name, extra_props) {\n  if (!(name in this.eventListeners_)) return false;\n\n  // QUESTION: can we use objects & prototypes to speed this up?\n  var e = {\n    dygraph: this,\n    cancelable: false,\n    defaultPrevented: false,\n    preventDefault: function preventDefault() {\n      if (!e.cancelable) throw \"Cannot call preventDefault on non-cancelable event.\";\n      e.defaultPrevented = true;\n    },\n    propagationStopped: false,\n    stopPropagation: function stopPropagation() {\n      e.propagationStopped = true;\n    }\n  };\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"a\" /* update */](e, extra_props);\n\n  var callback_plugin_pairs = this.eventListeners_[name];\n  if (callback_plugin_pairs) {\n    for (var i = callback_plugin_pairs.length - 1; i >= 0; i--) {\n      var plugin = callback_plugin_pairs[i][0];\n      var callback = callback_plugin_pairs[i][1];\n      callback.call(plugin, e);\n      if (e.propagationStopped) break;\n    }\n  }\n  return e.defaultPrevented;\n};\n\n/**\n * Fetch a plugin instance of a particular class. Only for testing.\n * @private\n * @param {!Class} type The type of the plugin.\n * @return {Object} Instance of the plugin, or null if there is none.\n */\nDygraph.prototype.getPluginInstance_ = function (type) {\n  for (var i = 0; i < this.plugins_.length; i++) {\n    var p = this.plugins_[i];\n    if (p.plugin instanceof type) {\n      return p.plugin;\n    }\n  }\n  return null;\n};\n\n/**\n * Returns the zoomed status of the chart for one or both axes.\n *\n * Axis is an optional parameter. Can be set to 'x' or 'y'.\n *\n * The zoomed status for an axis is set whenever a user zooms using the mouse\n * or when the dateWindow or valueRange are updated. Double-clicking or calling\n * resetZoom() resets the zoom status for the chart.\n */\nDygraph.prototype.isZoomed = function (axis) {\n  var isZoomedX = !!this.dateWindow_;\n  if (axis === 'x') return isZoomedX;\n\n  var isZoomedY = this.axes_.map(function (axis) {\n    return !!axis.valueRange;\n  }).indexOf(true) >= 0;\n  if (axis === null || axis === undefined) {\n    return isZoomedX || isZoomedY;\n  }\n  if (axis === 'y') return isZoomedY;\n\n  throw new Error('axis parameter is [' + axis + '] must be null, \\'x\\' or \\'y\\'.');\n};\n\n/**\n * Returns information about the Dygraph object, including its containing ID.\n */\nDygraph.prototype.toString = function () {\n  var maindiv = this.maindiv_;\n  var id = maindiv && maindiv.id ? maindiv.id : maindiv;\n  return \"[Dygraph \" + id + \"]\";\n};\n\n/**\n * @private\n * Returns the value of an option. This may be set by the user (either in the\n * constructor or by calling updateOptions) or by dygraphs, and may be set to a\n * per-series value.\n * @param {string} name The name of the option, e.g. 'rollPeriod'.\n * @param {string} [seriesName] The name of the series to which the option\n * will be applied. If no per-series value of this option is available, then\n * the global value is returned. This is optional.\n * @return { ... } The value of the option.\n */\nDygraph.prototype.attr_ = function (name, seriesName) {\n  // For \"production\" code, this gets removed by uglifyjs.\n  if (typeof process !== 'undefined') {\n    if (process.env.NODE_ENV != 'production') {\n      if (typeof __WEBPACK_IMPORTED_MODULE_7__dygraph_options_reference__[\"a\" /* default */] === 'undefined') {\n        console.error('Must include options reference JS for testing');\n      } else if (!__WEBPACK_IMPORTED_MODULE_7__dygraph_options_reference__[\"a\" /* default */].hasOwnProperty(name)) {\n        console.error('Dygraphs is using property ' + name + ', which has no ' + 'entry in the Dygraphs.OPTIONS_REFERENCE listing.');\n        // Only log this error once.\n        __WEBPACK_IMPORTED_MODULE_7__dygraph_options_reference__[\"a\" /* default */][name] = true;\n      }\n    }\n  }\n  return seriesName ? this.attributes_.getForSeries(name, seriesName) : this.attributes_.get(name);\n};\n\n/**\n * Returns the current value for an option, as set in the constructor or via\n * updateOptions. You may pass in an (optional) series name to get per-series\n * values for the option.\n *\n * All values returned by this method should be considered immutable. If you\n * modify them, there is no guarantee that the changes will be honored or that\n * dygraphs will remain in a consistent state. If you want to modify an option,\n * use updateOptions() instead.\n *\n * @param {string} name The name of the option (e.g. 'strokeWidth')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {*} The value of the option.\n */\nDygraph.prototype.getOption = function (name, opt_seriesName) {\n  return this.attr_(name, opt_seriesName);\n};\n\n/**\n * Like getOption(), but specifically returns a number.\n * This is a convenience function for working with the Closure Compiler.\n * @param {string} name The name of the option (e.g. 'strokeWidth')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {number} The value of the option.\n * @private\n */\nDygraph.prototype.getNumericOption = function (name, opt_seriesName) {\n  return (/** @type{number} */this.getOption(name, opt_seriesName)\n  );\n};\n\n/**\n * Like getOption(), but specifically returns a string.\n * This is a convenience function for working with the Closure Compiler.\n * @param {string} name The name of the option (e.g. 'strokeWidth')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {string} The value of the option.\n * @private\n */\nDygraph.prototype.getStringOption = function (name, opt_seriesName) {\n  return (/** @type{string} */this.getOption(name, opt_seriesName)\n  );\n};\n\n/**\n * Like getOption(), but specifically returns a boolean.\n * This is a convenience function for working with the Closure Compiler.\n * @param {string} name The name of the option (e.g. 'strokeWidth')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {boolean} The value of the option.\n * @private\n */\nDygraph.prototype.getBooleanOption = function (name, opt_seriesName) {\n  return (/** @type{boolean} */this.getOption(name, opt_seriesName)\n  );\n};\n\n/**\n * Like getOption(), but specifically returns a function.\n * This is a convenience function for working with the Closure Compiler.\n * @param {string} name The name of the option (e.g. 'strokeWidth')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {function(...)} The value of the option.\n * @private\n */\nDygraph.prototype.getFunctionOption = function (name, opt_seriesName) {\n  return (/** @type{function(...)} */this.getOption(name, opt_seriesName)\n  );\n};\n\nDygraph.prototype.getOptionForAxis = function (name, axis) {\n  return this.attributes_.getForAxis(name, axis);\n};\n\n/**\n * @private\n * @param {string} axis The name of the axis (i.e. 'x', 'y' or 'y2')\n * @return { ... } A function mapping string -> option value\n */\nDygraph.prototype.optionsViewForAxis_ = function (axis) {\n  var self = this;\n  return function (opt) {\n    var axis_opts = self.user_attrs_.axes;\n    if (axis_opts && axis_opts[axis] && axis_opts[axis].hasOwnProperty(opt)) {\n      return axis_opts[axis][opt];\n    }\n\n    // I don't like that this is in a second spot.\n    if (axis === 'x' && opt === 'logscale') {\n      // return the default value.\n      // TODO(konigsberg): pull the default from a global default.\n      return false;\n    }\n\n    // user-specified attributes always trump defaults, even if they're less\n    // specific.\n    if (typeof self.user_attrs_[opt] != 'undefined') {\n      return self.user_attrs_[opt];\n    }\n\n    axis_opts = self.attrs_.axes;\n    if (axis_opts && axis_opts[axis] && axis_opts[axis].hasOwnProperty(opt)) {\n      return axis_opts[axis][opt];\n    }\n    // check old-style axis options\n    // TODO(danvk): add a deprecation warning if either of these match.\n    if (axis == 'y' && self.axes_[0].hasOwnProperty(opt)) {\n      return self.axes_[0][opt];\n    } else if (axis == 'y2' && self.axes_[1].hasOwnProperty(opt)) {\n      return self.axes_[1][opt];\n    }\n    return self.attr_(opt);\n  };\n};\n\n/**\n * Returns the current rolling period, as set by the user or an option.\n * @return {number} The number of points in the rolling window\n */\nDygraph.prototype.rollPeriod = function () {\n  return this.rollPeriod_;\n};\n\n/**\n * Returns the currently-visible x-range. This can be affected by zooming,\n * panning or a call to updateOptions.\n * Returns a two-element array: [left, right].\n * If the Dygraph has dates on the x-axis, these will be millis since epoch.\n */\nDygraph.prototype.xAxisRange = function () {\n  return this.dateWindow_ ? this.dateWindow_ : this.xAxisExtremes();\n};\n\n/**\n * Returns the lower- and upper-bound x-axis values of the data set.\n */\nDygraph.prototype.xAxisExtremes = function () {\n  var pad = this.getNumericOption('xRangePad') / this.plotter_.area.w;\n  if (this.numRows() === 0) {\n    return [0 - pad, 1 + pad];\n  }\n  var left = this.rawData_[0][0];\n  var right = this.rawData_[this.rawData_.length - 1][0];\n  if (pad) {\n    // Must keep this in sync with dygraph-layout _evaluateLimits()\n    var range = right - left;\n    left -= range * pad;\n    right += range * pad;\n  }\n  return [left, right];\n};\n\n/**\n * Returns the lower- and upper-bound y-axis values for each axis. These are\n * the ranges you'll get if you double-click to zoom out or call resetZoom().\n * The return value is an array of [low, high] tuples, one for each y-axis.\n */\nDygraph.prototype.yAxisExtremes = function () {\n  // TODO(danvk): this is pretty inefficient\n  var packed = this.gatherDatasets_(this.rolledSeries_, null);\n  var extremes = packed.extremes;\n\n  var saveAxes = this.axes_;\n  this.computeYAxisRanges_(extremes);\n  var newAxes = this.axes_;\n  this.axes_ = saveAxes;\n  return newAxes.map(function (axis) {\n    return axis.extremeRange;\n  });\n};\n\n/**\n * Returns the currently-visible y-range for an axis. This can be affected by\n * zooming, panning or a call to updateOptions. Axis indices are zero-based. If\n * called with no arguments, returns the range of the first axis.\n * Returns a two-element array: [bottom, top].\n */\nDygraph.prototype.yAxisRange = function (idx) {\n  if (typeof idx == \"undefined\") idx = 0;\n  if (idx < 0 || idx >= this.axes_.length) {\n    return null;\n  }\n  var axis = this.axes_[idx];\n  return [axis.computedValueRange[0], axis.computedValueRange[1]];\n};\n\n/**\n * Returns the currently-visible y-ranges for each axis. This can be affected by\n * zooming, panning, calls to updateOptions, etc.\n * Returns an array of [bottom, top] pairs, one for each y-axis.\n */\nDygraph.prototype.yAxisRanges = function () {\n  var ret = [];\n  for (var i = 0; i < this.axes_.length; i++) {\n    ret.push(this.yAxisRange(i));\n  }\n  return ret;\n};\n\n// TODO(danvk): use these functions throughout dygraphs.\n/**\n * Convert from data coordinates to canvas/div X/Y coordinates.\n * If specified, do this conversion for the coordinate system of a particular\n * axis. Uses the first axis by default.\n * Returns a two-element array: [X, Y]\n *\n * Note: use toDomXCoord instead of toDomCoords(x, null) and use toDomYCoord\n * instead of toDomCoords(null, y, axis).\n */\nDygraph.prototype.toDomCoords = function (x, y, axis) {\n  return [this.toDomXCoord(x), this.toDomYCoord(y, axis)];\n};\n\n/**\n * Convert from data x coordinates to canvas/div X coordinate.\n * If specified, do this conversion for the coordinate system of a particular\n * axis.\n * Returns a single value or null if x is null.\n */\nDygraph.prototype.toDomXCoord = function (x) {\n  if (x === null) {\n    return null;\n  }\n\n  var area = this.plotter_.area;\n  var xRange = this.xAxisRange();\n  return area.x + (x - xRange[0]) / (xRange[1] - xRange[0]) * area.w;\n};\n\n/**\n * Convert from data x coordinates to canvas/div Y coordinate and optional\n * axis. Uses the first axis by default.\n *\n * returns a single value or null if y is null.\n */\nDygraph.prototype.toDomYCoord = function (y, axis) {\n  var pct = this.toPercentYCoord(y, axis);\n\n  if (pct === null) {\n    return null;\n  }\n  var area = this.plotter_.area;\n  return area.y + pct * area.h;\n};\n\n/**\n * Convert from canvas/div coords to data coordinates.\n * If specified, do this conversion for the coordinate system of a particular\n * axis. Uses the first axis by default.\n * Returns a two-element array: [X, Y].\n *\n * Note: use toDataXCoord instead of toDataCoords(x, null) and use toDataYCoord\n * instead of toDataCoords(null, y, axis).\n */\nDygraph.prototype.toDataCoords = function (x, y, axis) {\n  return [this.toDataXCoord(x), this.toDataYCoord(y, axis)];\n};\n\n/**\n * Convert from canvas/div x coordinate to data coordinate.\n *\n * If x is null, this returns null.\n */\nDygraph.prototype.toDataXCoord = function (x) {\n  if (x === null) {\n    return null;\n  }\n\n  var area = this.plotter_.area;\n  var xRange = this.xAxisRange();\n\n  if (!this.attributes_.getForAxis(\"logscale\", 'x')) {\n    return xRange[0] + (x - area.x) / area.w * (xRange[1] - xRange[0]);\n  } else {\n    var pct = (x - area.x) / area.w;\n    return __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"c\" /* logRangeFraction */](xRange[0], xRange[1], pct);\n  }\n};\n\n/**\n * Convert from canvas/div y coord to value.\n *\n * If y is null, this returns null.\n * if axis is null, this uses the first axis.\n */\nDygraph.prototype.toDataYCoord = function (y, axis) {\n  if (y === null) {\n    return null;\n  }\n\n  var area = this.plotter_.area;\n  var yRange = this.yAxisRange(axis);\n\n  if (typeof axis == \"undefined\") axis = 0;\n  if (!this.attributes_.getForAxis(\"logscale\", axis)) {\n    return yRange[0] + (area.y + area.h - y) / area.h * (yRange[1] - yRange[0]);\n  } else {\n    // Computing the inverse of toDomCoord.\n    var pct = (y - area.y) / area.h;\n    // Note reversed yRange, y1 is on top with pct==0.\n    return __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"c\" /* logRangeFraction */](yRange[1], yRange[0], pct);\n  }\n};\n\n/**\n * Converts a y for an axis to a percentage from the top to the\n * bottom of the drawing area.\n *\n * If the coordinate represents a value visible on the canvas, then\n * the value will be between 0 and 1, where 0 is the top of the canvas.\n * However, this method will return values outside the range, as\n * values can fall outside the canvas.\n *\n * If y is null, this returns null.\n * if axis is null, this uses the first axis.\n *\n * @param {number} y The data y-coordinate.\n * @param {number} [axis] The axis number on which the data coordinate lives.\n * @return {number} A fraction in [0, 1] where 0 = the top edge.\n */\nDygraph.prototype.toPercentYCoord = function (y, axis) {\n  if (y === null) {\n    return null;\n  }\n  if (typeof axis == \"undefined\") axis = 0;\n\n  var yRange = this.yAxisRange(axis);\n\n  var pct;\n  var logscale = this.attributes_.getForAxis(\"logscale\", axis);\n  if (logscale) {\n    var logr0 = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"d\" /* log10 */](yRange[0]);\n    var logr1 = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"d\" /* log10 */](yRange[1]);\n    pct = (logr1 - __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"d\" /* log10 */](y)) / (logr1 - logr0);\n  } else {\n    // yRange[1] - y is unit distance from the bottom.\n    // yRange[1] - yRange[0] is the scale of the range.\n    // (yRange[1] - y) / (yRange[1] - yRange[0]) is the % from the bottom.\n    pct = (yRange[1] - y) / (yRange[1] - yRange[0]);\n  }\n  return pct;\n};\n\n/**\n * Converts an x value to a percentage from the left to the right of\n * the drawing area.\n *\n * If the coordinate represents a value visible on the canvas, then\n * the value will be between 0 and 1, where 0 is the left of the canvas.\n * However, this method will return values outside the range, as\n * values can fall outside the canvas.\n *\n * If x is null, this returns null.\n * @param {number} x The data x-coordinate.\n * @return {number} A fraction in [0, 1] where 0 = the left edge.\n */\nDygraph.prototype.toPercentXCoord = function (x) {\n  if (x === null) {\n    return null;\n  }\n\n  var xRange = this.xAxisRange();\n  var pct;\n  var logscale = this.attributes_.getForAxis(\"logscale\", 'x');\n  if (logscale === true) {\n    // logscale can be null so we test for true explicitly.\n    var logr0 = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"d\" /* log10 */](xRange[0]);\n    var logr1 = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"d\" /* log10 */](xRange[1]);\n    pct = (__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"d\" /* log10 */](x) - logr0) / (logr1 - logr0);\n  } else {\n    // x - xRange[0] is unit distance from the left.\n    // xRange[1] - xRange[0] is the scale of the range.\n    // The full expression below is the % from the left.\n    pct = (x - xRange[0]) / (xRange[1] - xRange[0]);\n  }\n  return pct;\n};\n\n/**\n * Returns the number of columns (including the independent variable).\n * @return {number} The number of columns.\n */\nDygraph.prototype.numColumns = function () {\n  if (!this.rawData_) return 0;\n  return this.rawData_[0] ? this.rawData_[0].length : this.attr_(\"labels\").length;\n};\n\n/**\n * Returns the number of rows (excluding any header/label row).\n * @return {number} The number of rows, less any header.\n */\nDygraph.prototype.numRows = function () {\n  if (!this.rawData_) return 0;\n  return this.rawData_.length;\n};\n\n/**\n * Returns the value in the given row and column. If the row and column exceed\n * the bounds on the data, returns null. Also returns null if the value is\n * missing.\n * @param {number} row The row number of the data (0-based). Row 0 is the\n *     first row of data, not a header row.\n * @param {number} col The column number of the data (0-based)\n * @return {number} The value in the specified cell or null if the row/col\n *     were out of range.\n */\nDygraph.prototype.getValue = function (row, col) {\n  if (row < 0 || row > this.rawData_.length) return null;\n  if (col < 0 || col > this.rawData_[row].length) return null;\n\n  return this.rawData_[row][col];\n};\n\n/**\n * Generates interface elements for the Dygraph: a containing div, a div to\n * display the current point, and a textbox to adjust the rolling average\n * period. Also creates the Renderer/Layout elements.\n * @private\n */\nDygraph.prototype.createInterface_ = function () {\n  // Create the all-enclosing graph div\n  var enclosing = this.maindiv_;\n\n  this.graphDiv = document.createElement(\"div\");\n\n  // TODO(danvk): any other styles that are useful to set here?\n  this.graphDiv.style.textAlign = 'left'; // This is a CSS \"reset\"\n  this.graphDiv.style.position = 'relative';\n  enclosing.appendChild(this.graphDiv);\n\n  // Create the canvas for interactive parts of the chart.\n  this.canvas_ = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"e\" /* createCanvas */]();\n  this.canvas_.style.position = \"absolute\";\n\n  // ... and for static parts of the chart.\n  this.hidden_ = this.createPlotKitCanvas_(this.canvas_);\n\n  this.canvas_ctx_ = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"f\" /* getContext */](this.canvas_);\n  this.hidden_ctx_ = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"f\" /* getContext */](this.hidden_);\n\n  this.resizeElements_();\n\n  // The interactive parts of the graph are drawn on top of the chart.\n  this.graphDiv.appendChild(this.hidden_);\n  this.graphDiv.appendChild(this.canvas_);\n  this.mouseEventElement_ = this.createMouseEventElement_();\n\n  // Create the grapher\n  this.layout_ = new __WEBPACK_IMPORTED_MODULE_0__dygraph_layout__[\"a\" /* default */](this);\n\n  var dygraph = this;\n\n  this.mouseMoveHandler_ = function (e) {\n    dygraph.mouseMove_(e);\n  };\n\n  this.mouseOutHandler_ = function (e) {\n    // The mouse has left the chart if:\n    // 1. e.target is inside the chart\n    // 2. e.relatedTarget is outside the chart\n    var target = e.target || e.fromElement;\n    var relatedTarget = e.relatedTarget || e.toElement;\n    if (__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"g\" /* isNodeContainedBy */](target, dygraph.graphDiv) && !__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"g\" /* isNodeContainedBy */](relatedTarget, dygraph.graphDiv)) {\n      dygraph.mouseOut_(e);\n    }\n  };\n\n  this.addAndTrackEvent(window, 'mouseout', this.mouseOutHandler_);\n  this.addAndTrackEvent(this.mouseEventElement_, 'mousemove', this.mouseMoveHandler_);\n\n  // Don't recreate and register the resize handler on subsequent calls.\n  // This happens when the graph is resized.\n  if (!this.resizeHandler_) {\n    this.resizeHandler_ = function (e) {\n      dygraph.resize();\n    };\n\n    // Update when the window is resized.\n    // TODO(danvk): drop frames depending on complexity of the chart.\n    this.addAndTrackEvent(window, 'resize', this.resizeHandler_);\n  }\n};\n\nDygraph.prototype.resizeElements_ = function () {\n  this.graphDiv.style.width = this.width_ + \"px\";\n  this.graphDiv.style.height = this.height_ + \"px\";\n\n  var pixelRatioOption = this.getNumericOption('pixelRatio');\n\n  var canvasScale = pixelRatioOption || __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"h\" /* getContextPixelRatio */](this.canvas_ctx_);\n  this.canvas_.width = this.width_ * canvasScale;\n  this.canvas_.height = this.height_ * canvasScale;\n  this.canvas_.style.width = this.width_ + \"px\"; // for IE\n  this.canvas_.style.height = this.height_ + \"px\"; // for IE\n  if (canvasScale !== 1) {\n    this.canvas_ctx_.scale(canvasScale, canvasScale);\n  }\n\n  var hiddenScale = pixelRatioOption || __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"h\" /* getContextPixelRatio */](this.hidden_ctx_);\n  this.hidden_.width = this.width_ * hiddenScale;\n  this.hidden_.height = this.height_ * hiddenScale;\n  this.hidden_.style.width = this.width_ + \"px\"; // for IE\n  this.hidden_.style.height = this.height_ + \"px\"; // for IE\n  if (hiddenScale !== 1) {\n    this.hidden_ctx_.scale(hiddenScale, hiddenScale);\n  }\n};\n\n/**\n * Detach DOM elements in the dygraph and null out all data references.\n * Calling this when you're done with a dygraph can dramatically reduce memory\n * usage. See, e.g., the tests/perf.html example.\n */\nDygraph.prototype.destroy = function () {\n  this.canvas_ctx_.restore();\n  this.hidden_ctx_.restore();\n\n  // Destroy any plugins, in the reverse order that they were registered.\n  for (var i = this.plugins_.length - 1; i >= 0; i--) {\n    var p = this.plugins_.pop();\n    if (p.plugin.destroy) p.plugin.destroy();\n  }\n\n  var removeRecursive = function removeRecursive(node) {\n    while (node.hasChildNodes()) {\n      removeRecursive(node.firstChild);\n      node.removeChild(node.firstChild);\n    }\n  };\n\n  this.removeTrackedEvents_();\n\n  // remove mouse event handlers (This may not be necessary anymore)\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"i\" /* removeEvent */](window, 'mouseout', this.mouseOutHandler_);\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"i\" /* removeEvent */](this.mouseEventElement_, 'mousemove', this.mouseMoveHandler_);\n\n  // remove window handlers\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"i\" /* removeEvent */](window, 'resize', this.resizeHandler_);\n  this.resizeHandler_ = null;\n\n  removeRecursive(this.maindiv_);\n\n  var nullOut = function nullOut(obj) {\n    for (var n in obj) {\n      if (_typeof(obj[n]) === 'object') {\n        obj[n] = null;\n      }\n    }\n  };\n  // These may not all be necessary, but it can't hurt...\n  nullOut(this.layout_);\n  nullOut(this.plotter_);\n  nullOut(this);\n};\n\n/**\n * Creates the canvas on which the chart will be drawn. Only the Renderer ever\n * draws on this particular canvas. All Dygraph work (i.e. drawing hover dots\n * or the zoom rectangles) is done on this.canvas_.\n * @param {Object} canvas The Dygraph canvas over which to overlay the plot\n * @return {Object} The newly-created canvas\n * @private\n */\nDygraph.prototype.createPlotKitCanvas_ = function (canvas) {\n  var h = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"e\" /* createCanvas */]();\n  h.style.position = \"absolute\";\n  // TODO(danvk): h should be offset from canvas. canvas needs to include\n  // some extra area to make it easier to zoom in on the far left and far\n  // right. h needs to be precisely the plot area, so that clipping occurs.\n  h.style.top = canvas.style.top;\n  h.style.left = canvas.style.left;\n  h.width = this.width_;\n  h.height = this.height_;\n  h.style.width = this.width_ + \"px\"; // for IE\n  h.style.height = this.height_ + \"px\"; // for IE\n  return h;\n};\n\n/**\n * Creates an overlay element used to handle mouse events.\n * @return {Object} The mouse event element.\n * @private\n */\nDygraph.prototype.createMouseEventElement_ = function () {\n  return this.canvas_;\n};\n\n/**\n * Generate a set of distinct colors for the data series. This is done with a\n * color wheel. Saturation/Value are customizable, and the hue is\n * equally-spaced around the color wheel. If a custom set of colors is\n * specified, that is used instead.\n * @private\n */\nDygraph.prototype.setColors_ = function () {\n  var labels = this.getLabels();\n  var num = labels.length - 1;\n  this.colors_ = [];\n  this.colorsMap_ = {};\n\n  // These are used for when no custom colors are specified.\n  var sat = this.getNumericOption('colorSaturation') || 1.0;\n  var val = this.getNumericOption('colorValue') || 0.5;\n  var half = Math.ceil(num / 2);\n\n  var colors = this.getOption('colors');\n  var visibility = this.visibility();\n  for (var i = 0; i < num; i++) {\n    if (!visibility[i]) {\n      continue;\n    }\n    var label = labels[i + 1];\n    var colorStr = this.attributes_.getForSeries('color', label);\n    if (!colorStr) {\n      if (colors) {\n        colorStr = colors[i % colors.length];\n      } else {\n        // alternate colors for high contrast.\n        var idx = i % 2 ? half + (i + 1) / 2 : Math.ceil((i + 1) / 2);\n        var hue = 1.0 * idx / (1 + num);\n        colorStr = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"j\" /* hsvToRGB */](hue, sat, val);\n      }\n    }\n    this.colors_.push(colorStr);\n    this.colorsMap_[label] = colorStr;\n  }\n};\n\n/**\n * Return the list of colors. This is either the list of colors passed in the\n * attributes or the autogenerated list of rgb(r,g,b) strings.\n * This does not return colors for invisible series.\n * @return {Array.<string>} The list of colors.\n */\nDygraph.prototype.getColors = function () {\n  return this.colors_;\n};\n\n/**\n * Returns a few attributes of a series, i.e. its color, its visibility, which\n * axis it's assigned to, and its column in the original data.\n * Returns null if the series does not exist.\n * Otherwise, returns an object with column, visibility, color and axis properties.\n * The \"axis\" property will be set to 1 for y1 and 2 for y2.\n * The \"column\" property can be fed back into getValue(row, column) to get\n * values for this series.\n */\nDygraph.prototype.getPropertiesForSeries = function (series_name) {\n  var idx = -1;\n  var labels = this.getLabels();\n  for (var i = 1; i < labels.length; i++) {\n    if (labels[i] == series_name) {\n      idx = i;\n      break;\n    }\n  }\n  if (idx == -1) return null;\n\n  return {\n    name: series_name,\n    column: idx,\n    visible: this.visibility()[idx - 1],\n    color: this.colorsMap_[series_name],\n    axis: 1 + this.attributes_.axisForSeries(series_name)\n  };\n};\n\n/**\n * Create the text box to adjust the averaging period\n * @private\n */\nDygraph.prototype.createRollInterface_ = function () {\n  var _this = this;\n\n  // Create a roller if one doesn't exist already.\n  var roller = this.roller_;\n  if (!roller) {\n    this.roller_ = roller = document.createElement(\"input\");\n    roller.type = \"text\";\n    roller.style.display = \"none\";\n    roller.className = 'dygraph-roller';\n    this.graphDiv.appendChild(roller);\n  }\n\n  var display = this.getBooleanOption('showRoller') ? 'block' : 'none';\n\n  var area = this.getArea();\n  var textAttr = {\n    \"top\": area.y + area.h - 25 + \"px\",\n    \"left\": area.x + 1 + \"px\",\n    \"display\": display\n  };\n  roller.size = \"2\";\n  roller.value = this.rollPeriod_;\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"a\" /* update */](roller.style, textAttr);\n\n  roller.onchange = function () {\n    return _this.adjustRoll(roller.value);\n  };\n};\n\n/**\n * Set up all the mouse handlers needed to capture dragging behavior for zoom\n * events.\n * @private\n */\nDygraph.prototype.createDragInterface_ = function () {\n  var context = {\n    // Tracks whether the mouse is down right now\n    isZooming: false,\n    isPanning: false, // is this drag part of a pan?\n    is2DPan: false, // if so, is that pan 1- or 2-dimensional?\n    dragStartX: null, // pixel coordinates\n    dragStartY: null, // pixel coordinates\n    dragEndX: null, // pixel coordinates\n    dragEndY: null, // pixel coordinates\n    dragDirection: null,\n    prevEndX: null, // pixel coordinates\n    prevEndY: null, // pixel coordinates\n    prevDragDirection: null,\n    cancelNextDblclick: false, // see comment in dygraph-interaction-model.js\n\n    // The value on the left side of the graph when a pan operation starts.\n    initialLeftmostDate: null,\n\n    // The number of units each pixel spans. (This won't be valid for log\n    // scales)\n    xUnitsPerPixel: null,\n\n    // TODO(danvk): update this comment\n    // The range in second/value units that the viewport encompasses during a\n    // panning operation.\n    dateRange: null,\n\n    // Top-left corner of the canvas, in DOM coords\n    // TODO(konigsberg): Rename topLeftCanvasX, topLeftCanvasY.\n    px: 0,\n    py: 0,\n\n    // Values for use with panEdgeFraction, which limit how far outside the\n    // graph's data boundaries it can be panned.\n    boundedDates: null, // [minDate, maxDate]\n    boundedValues: null, // [[minValue, maxValue] ...]\n\n    // We cover iframes during mouse interactions. See comments in\n    // dygraph-utils.js for more info on why this is a good idea.\n    tarp: new __WEBPACK_IMPORTED_MODULE_8__iframe_tarp__[\"a\" /* default */](),\n\n    // contextB is the same thing as this context object but renamed.\n    initializeMouseDown: function initializeMouseDown(event, g, contextB) {\n      // prevents mouse drags from selecting page text.\n      if (event.preventDefault) {\n        event.preventDefault(); // Firefox, Chrome, etc.\n      } else {\n        event.returnValue = false; // IE\n        event.cancelBubble = true;\n      }\n\n      var canvasPos = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"k\" /* findPos */](g.canvas_);\n      contextB.px = canvasPos.x;\n      contextB.py = canvasPos.y;\n      contextB.dragStartX = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"l\" /* dragGetX_ */](event, contextB);\n      contextB.dragStartY = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"m\" /* dragGetY_ */](event, contextB);\n      contextB.cancelNextDblclick = false;\n      contextB.tarp.cover();\n    },\n    destroy: function destroy() {\n      var context = this;\n      if (context.isZooming || context.isPanning) {\n        context.isZooming = false;\n        context.dragStartX = null;\n        context.dragStartY = null;\n      }\n\n      if (context.isPanning) {\n        context.isPanning = false;\n        context.draggingDate = null;\n        context.dateRange = null;\n        for (var i = 0; i < self.axes_.length; i++) {\n          delete self.axes_[i].draggingValue;\n          delete self.axes_[i].dragValueRange;\n        }\n      }\n\n      context.tarp.uncover();\n    }\n  };\n\n  var interactionModel = this.getOption(\"interactionModel\");\n\n  // Self is the graph.\n  var self = this;\n\n  // Function that binds the graph and context to the handler.\n  var bindHandler = function bindHandler(handler) {\n    return function (event) {\n      handler(event, self, context);\n    };\n  };\n\n  for (var eventName in interactionModel) {\n    if (!interactionModel.hasOwnProperty(eventName)) continue;\n    this.addAndTrackEvent(this.mouseEventElement_, eventName, bindHandler(interactionModel[eventName]));\n  }\n\n  // If the user releases the mouse button during a drag, but not over the\n  // canvas, then it doesn't count as a zooming action.\n  if (!interactionModel.willDestroyContextMyself) {\n    var mouseUpHandler = function mouseUpHandler(event) {\n      context.destroy();\n    };\n\n    this.addAndTrackEvent(document, 'mouseup', mouseUpHandler);\n  }\n};\n\n/**\n * Draw a gray zoom rectangle over the desired area of the canvas. Also clears\n * up any previous zoom rectangles that were drawn. This could be optimized to\n * avoid extra redrawing, but it's tricky to avoid interactions with the status\n * dots.\n *\n * @param {number} direction the direction of the zoom rectangle. Acceptable\n *     values are utils.HORIZONTAL and utils.VERTICAL.\n * @param {number} startX The X position where the drag started, in canvas\n *     coordinates.\n * @param {number} endX The current X position of the drag, in canvas coords.\n * @param {number} startY The Y position where the drag started, in canvas\n *     coordinates.\n * @param {number} endY The current Y position of the drag, in canvas coords.\n * @param {number} prevDirection the value of direction on the previous call to\n *     this function. Used to avoid excess redrawing\n * @param {number} prevEndX The value of endX on the previous call to this\n *     function. Used to avoid excess redrawing\n * @param {number} prevEndY The value of endY on the previous call to this\n *     function. Used to avoid excess redrawing\n * @private\n */\nDygraph.prototype.drawZoomRect_ = function (direction, startX, endX, startY, endY, prevDirection, prevEndX, prevEndY) {\n  var ctx = this.canvas_ctx_;\n\n  // Clean up from the previous rect if necessary\n  if (prevDirection == __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"n\" /* HORIZONTAL */]) {\n    ctx.clearRect(Math.min(startX, prevEndX), this.layout_.getPlotArea().y, Math.abs(startX - prevEndX), this.layout_.getPlotArea().h);\n  } else if (prevDirection == __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"o\" /* VERTICAL */]) {\n    ctx.clearRect(this.layout_.getPlotArea().x, Math.min(startY, prevEndY), this.layout_.getPlotArea().w, Math.abs(startY - prevEndY));\n  }\n\n  // Draw a light-grey rectangle to show the new viewing area\n  if (direction == __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"n\" /* HORIZONTAL */]) {\n    if (endX && startX) {\n      ctx.fillStyle = \"rgba(128,128,128,0.33)\";\n      ctx.fillRect(Math.min(startX, endX), this.layout_.getPlotArea().y, Math.abs(endX - startX), this.layout_.getPlotArea().h);\n    }\n  } else if (direction == __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"o\" /* VERTICAL */]) {\n    if (endY && startY) {\n      ctx.fillStyle = \"rgba(128,128,128,0.33)\";\n      ctx.fillRect(this.layout_.getPlotArea().x, Math.min(startY, endY), this.layout_.getPlotArea().w, Math.abs(endY - startY));\n    }\n  }\n};\n\n/**\n * Clear the zoom rectangle (and perform no zoom).\n * @private\n */\nDygraph.prototype.clearZoomRect_ = function () {\n  this.currentZoomRectArgs_ = null;\n  this.canvas_ctx_.clearRect(0, 0, this.width_, this.height_);\n};\n\n/**\n * Zoom to something containing [lowX, highX]. These are pixel coordinates in\n * the canvas. The exact zoom window may be slightly larger if there are no data\n * points near lowX or highX. Don't confuse this function with doZoomXDates,\n * which accepts dates that match the raw data. This function redraws the graph.\n *\n * @param {number} lowX The leftmost pixel value that should be visible.\n * @param {number} highX The rightmost pixel value that should be visible.\n * @private\n */\nDygraph.prototype.doZoomX_ = function (lowX, highX) {\n  this.currentZoomRectArgs_ = null;\n  // Find the earliest and latest dates contained in this canvasx range.\n  // Convert the call to date ranges of the raw data.\n  var minDate = this.toDataXCoord(lowX);\n  var maxDate = this.toDataXCoord(highX);\n  this.doZoomXDates_(minDate, maxDate);\n};\n\n/**\n * Zoom to something containing [minDate, maxDate] values. Don't confuse this\n * method with doZoomX which accepts pixel coordinates. This function redraws\n * the graph.\n *\n * @param {number} minDate The minimum date that should be visible.\n * @param {number} maxDate The maximum date that should be visible.\n * @private\n */\nDygraph.prototype.doZoomXDates_ = function (minDate, maxDate) {\n  var _this2 = this;\n\n  // TODO(danvk): when xAxisRange is null (i.e. \"fit to data\", the animation\n  // can produce strange effects. Rather than the x-axis transitioning slowly\n  // between values, it can jerk around.)\n  var old_window = this.xAxisRange();\n  var new_window = [minDate, maxDate];\n  var zoomCallback = this.getFunctionOption('zoomCallback');\n  this.doAnimatedZoom(old_window, new_window, null, null, function () {\n    if (zoomCallback) {\n      zoomCallback.call(_this2, minDate, maxDate, _this2.yAxisRanges());\n    }\n  });\n};\n\n/**\n * Zoom to something containing [lowY, highY]. These are pixel coordinates in\n * the canvas. This function redraws the graph.\n *\n * @param {number} lowY The topmost pixel value that should be visible.\n * @param {number} highY The lowest pixel value that should be visible.\n * @private\n */\nDygraph.prototype.doZoomY_ = function (lowY, highY) {\n  var _this3 = this;\n\n  this.currentZoomRectArgs_ = null;\n  // Find the highest and lowest values in pixel range for each axis.\n  // Note that lowY (in pixels) corresponds to the max Value (in data coords).\n  // This is because pixels increase as you go down on the screen, whereas data\n  // coordinates increase as you go up the screen.\n  var oldValueRanges = this.yAxisRanges();\n  var newValueRanges = [];\n  for (var i = 0; i < this.axes_.length; i++) {\n    var hi = this.toDataYCoord(lowY, i);\n    var low = this.toDataYCoord(highY, i);\n    newValueRanges.push([low, hi]);\n  }\n\n  var zoomCallback = this.getFunctionOption('zoomCallback');\n  this.doAnimatedZoom(null, null, oldValueRanges, newValueRanges, function () {\n    if (zoomCallback) {\n      var _xAxisRange = _this3.xAxisRange(),\n          _xAxisRange2 = _slicedToArray(_xAxisRange, 2),\n          minX = _xAxisRange2[0],\n          maxX = _xAxisRange2[1];\n\n      zoomCallback.call(_this3, minX, maxX, _this3.yAxisRanges());\n    }\n  });\n};\n\n/**\n * Transition function to use in animations. Returns values between 0.0\n * (totally old values) and 1.0 (totally new values) for each frame.\n * @private\n */\nDygraph.zoomAnimationFunction = function (frame, numFrames) {\n  var k = 1.5;\n  return (1.0 - Math.pow(k, -frame)) / (1.0 - Math.pow(k, -numFrames));\n};\n\n/**\n * Reset the zoom to the original view coordinates. This is the same as\n * double-clicking on the graph.\n */\nDygraph.prototype.resetZoom = function () {\n  var _this4 = this;\n\n  var dirtyX = this.isZoomed('x');\n  var dirtyY = this.isZoomed('y');\n  var dirty = dirtyX || dirtyY;\n\n  // Clear any selection, since it's likely to be drawn in the wrong place.\n  this.clearSelection();\n\n  if (!dirty) return;\n\n  // Calculate extremes to avoid lack of padding on reset.\n\n  var _xAxisExtremes = this.xAxisExtremes(),\n      _xAxisExtremes2 = _slicedToArray(_xAxisExtremes, 2),\n      minDate = _xAxisExtremes2[0],\n      maxDate = _xAxisExtremes2[1];\n\n  var animatedZooms = this.getBooleanOption('animatedZooms');\n  var zoomCallback = this.getFunctionOption('zoomCallback');\n\n  // TODO(danvk): merge this block w/ the code below.\n  // TODO(danvk): factor out a generic, public zoomTo method.\n  if (!animatedZooms) {\n    this.dateWindow_ = null;\n    this.axes_.forEach(function (axis) {\n      if (axis.valueRange) delete axis.valueRange;\n    });\n\n    this.drawGraph_();\n    if (zoomCallback) {\n      zoomCallback.call(this, minDate, maxDate, this.yAxisRanges());\n    }\n    return;\n  }\n\n  var oldWindow = null,\n      newWindow = null,\n      oldValueRanges = null,\n      newValueRanges = null;\n  if (dirtyX) {\n    oldWindow = this.xAxisRange();\n    newWindow = [minDate, maxDate];\n  }\n\n  if (dirtyY) {\n    oldValueRanges = this.yAxisRanges();\n    newValueRanges = this.yAxisExtremes();\n  }\n\n  this.doAnimatedZoom(oldWindow, newWindow, oldValueRanges, newValueRanges, function () {\n    _this4.dateWindow_ = null;\n    _this4.axes_.forEach(function (axis) {\n      if (axis.valueRange) delete axis.valueRange;\n    });\n    if (zoomCallback) {\n      zoomCallback.call(_this4, minDate, maxDate, _this4.yAxisRanges());\n    }\n  });\n};\n\n/**\n * Combined animation logic for all zoom functions.\n * either the x parameters or y parameters may be null.\n * @private\n */\nDygraph.prototype.doAnimatedZoom = function (oldXRange, newXRange, oldYRanges, newYRanges, callback) {\n  var _this5 = this;\n\n  var steps = this.getBooleanOption(\"animatedZooms\") ? Dygraph.ANIMATION_STEPS : 1;\n\n  var windows = [];\n  var valueRanges = [];\n  var step, frac;\n\n  if (oldXRange !== null && newXRange !== null) {\n    for (step = 1; step <= steps; step++) {\n      frac = Dygraph.zoomAnimationFunction(step, steps);\n      windows[step - 1] = [oldXRange[0] * (1 - frac) + frac * newXRange[0], oldXRange[1] * (1 - frac) + frac * newXRange[1]];\n    }\n  }\n\n  if (oldYRanges !== null && newYRanges !== null) {\n    for (step = 1; step <= steps; step++) {\n      frac = Dygraph.zoomAnimationFunction(step, steps);\n      var thisRange = [];\n      for (var j = 0; j < this.axes_.length; j++) {\n        thisRange.push([oldYRanges[j][0] * (1 - frac) + frac * newYRanges[j][0], oldYRanges[j][1] * (1 - frac) + frac * newYRanges[j][1]]);\n      }\n      valueRanges[step - 1] = thisRange;\n    }\n  }\n\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"p\" /* repeatAndCleanup */](function (step) {\n    if (valueRanges.length) {\n      for (var i = 0; i < _this5.axes_.length; i++) {\n        var w = valueRanges[step][i];\n        _this5.axes_[i].valueRange = [w[0], w[1]];\n      }\n    }\n    if (windows.length) {\n      _this5.dateWindow_ = windows[step];\n    }\n    _this5.drawGraph_();\n  }, steps, Dygraph.ANIMATION_DURATION / steps, callback);\n};\n\n/**\n * Get the current graph's area object.\n *\n * Returns: {x, y, w, h}\n */\nDygraph.prototype.getArea = function () {\n  return this.plotter_.area;\n};\n\n/**\n * Convert a mouse event to DOM coordinates relative to the graph origin.\n *\n * Returns a two-element array: [X, Y].\n */\nDygraph.prototype.eventToDomCoords = function (event) {\n  if (event.offsetX && event.offsetY) {\n    return [event.offsetX, event.offsetY];\n  } else {\n    var eventElementPos = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"k\" /* findPos */](this.mouseEventElement_);\n    var canvasx = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"q\" /* pageX */](event) - eventElementPos.x;\n    var canvasy = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"r\" /* pageY */](event) - eventElementPos.y;\n    return [canvasx, canvasy];\n  }\n};\n\n/**\n * Given a canvas X coordinate, find the closest row.\n * @param {number} domX graph-relative DOM X coordinate\n * Returns {number} row number.\n * @private\n */\nDygraph.prototype.findClosestRow = function (domX) {\n  var minDistX = Infinity;\n  var closestRow = -1;\n  var sets = this.layout_.points;\n  for (var i = 0; i < sets.length; i++) {\n    var points = sets[i];\n    var len = points.length;\n    for (var j = 0; j < len; j++) {\n      var point = points[j];\n      if (!__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"s\" /* isValidPoint */](point, true)) continue;\n      var dist = Math.abs(point.canvasx - domX);\n      if (dist < minDistX) {\n        minDistX = dist;\n        closestRow = point.idx;\n      }\n    }\n  }\n\n  return closestRow;\n};\n\n/**\n * Given canvas X,Y coordinates, find the closest point.\n *\n * This finds the individual data point across all visible series\n * that's closest to the supplied DOM coordinates using the standard\n * Euclidean X,Y distance.\n *\n * @param {number} domX graph-relative DOM X coordinate\n * @param {number} domY graph-relative DOM Y coordinate\n * Returns: {row, seriesName, point}\n * @private\n */\nDygraph.prototype.findClosestPoint = function (domX, domY) {\n  var minDist = Infinity;\n  var dist, dx, dy, point, closestPoint, closestSeries, closestRow;\n  for (var setIdx = this.layout_.points.length - 1; setIdx >= 0; --setIdx) {\n    var points = this.layout_.points[setIdx];\n    for (var i = 0; i < points.length; ++i) {\n      point = points[i];\n      if (!__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"s\" /* isValidPoint */](point)) continue;\n      dx = point.canvasx - domX;\n      dy = point.canvasy - domY;\n      dist = dx * dx + dy * dy;\n      if (dist < minDist) {\n        minDist = dist;\n        closestPoint = point;\n        closestSeries = setIdx;\n        closestRow = point.idx;\n      }\n    }\n  }\n  var name = this.layout_.setNames[closestSeries];\n  return {\n    row: closestRow,\n    seriesName: name,\n    point: closestPoint\n  };\n};\n\n/**\n * Given canvas X,Y coordinates, find the touched area in a stacked graph.\n *\n * This first finds the X data point closest to the supplied DOM X coordinate,\n * then finds the series which puts the Y coordinate on top of its filled area,\n * using linear interpolation between adjacent point pairs.\n *\n * @param {number} domX graph-relative DOM X coordinate\n * @param {number} domY graph-relative DOM Y coordinate\n * Returns: {row, seriesName, point}\n * @private\n */\nDygraph.prototype.findStackedPoint = function (domX, domY) {\n  var row = this.findClosestRow(domX);\n  var closestPoint, closestSeries;\n  for (var setIdx = 0; setIdx < this.layout_.points.length; ++setIdx) {\n    var boundary = this.getLeftBoundary_(setIdx);\n    var rowIdx = row - boundary;\n    var points = this.layout_.points[setIdx];\n    if (rowIdx >= points.length) continue;\n    var p1 = points[rowIdx];\n    if (!__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"s\" /* isValidPoint */](p1)) continue;\n    var py = p1.canvasy;\n    if (domX > p1.canvasx && rowIdx + 1 < points.length) {\n      // interpolate series Y value using next point\n      var p2 = points[rowIdx + 1];\n      if (__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"s\" /* isValidPoint */](p2)) {\n        var dx = p2.canvasx - p1.canvasx;\n        if (dx > 0) {\n          var r = (domX - p1.canvasx) / dx;\n          py += r * (p2.canvasy - p1.canvasy);\n        }\n      }\n    } else if (domX < p1.canvasx && rowIdx > 0) {\n      // interpolate series Y value using previous point\n      var p0 = points[rowIdx - 1];\n      if (__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"s\" /* isValidPoint */](p0)) {\n        var dx = p1.canvasx - p0.canvasx;\n        if (dx > 0) {\n          var r = (p1.canvasx - domX) / dx;\n          py += r * (p0.canvasy - p1.canvasy);\n        }\n      }\n    }\n    // Stop if the point (domX, py) is above this series' upper edge\n    if (setIdx === 0 || py < domY) {\n      closestPoint = p1;\n      closestSeries = setIdx;\n    }\n  }\n  var name = this.layout_.setNames[closestSeries];\n  return {\n    row: row,\n    seriesName: name,\n    point: closestPoint\n  };\n};\n\n/**\n * When the mouse moves in the canvas, display information about a nearby data\n * point and draw dots over those points in the data series. This function\n * takes care of cleanup of previously-drawn dots.\n * @param {Object} event The mousemove event from the browser.\n * @private\n */\nDygraph.prototype.mouseMove_ = function (event) {\n  // This prevents JS errors when mousing over the canvas before data loads.\n  var points = this.layout_.points;\n  if (points === undefined || points === null) return;\n\n  var canvasCoords = this.eventToDomCoords(event);\n  var canvasx = canvasCoords[0];\n  var canvasy = canvasCoords[1];\n\n  var highlightSeriesOpts = this.getOption(\"highlightSeriesOpts\");\n  var selectionChanged = false;\n  if (highlightSeriesOpts && !this.isSeriesLocked()) {\n    var closest;\n    if (this.getBooleanOption(\"stackedGraph\")) {\n      closest = this.findStackedPoint(canvasx, canvasy);\n    } else {\n      closest = this.findClosestPoint(canvasx, canvasy);\n    }\n    selectionChanged = this.setSelection(closest.row, closest.seriesName);\n  } else {\n    var idx = this.findClosestRow(canvasx);\n    selectionChanged = this.setSelection(idx);\n  }\n\n  var callback = this.getFunctionOption(\"highlightCallback\");\n  if (callback && selectionChanged) {\n    callback.call(this, event, this.lastx_, this.selPoints_, this.lastRow_, this.highlightSet_);\n  }\n};\n\n/**\n * Fetch left offset from the specified set index or if not passed, the\n * first defined boundaryIds record (see bug #236).\n * @private\n */\nDygraph.prototype.getLeftBoundary_ = function (setIdx) {\n  if (this.boundaryIds_[setIdx]) {\n    return this.boundaryIds_[setIdx][0];\n  } else {\n    for (var i = 0; i < this.boundaryIds_.length; i++) {\n      if (this.boundaryIds_[i] !== undefined) {\n        return this.boundaryIds_[i][0];\n      }\n    }\n    return 0;\n  }\n};\n\nDygraph.prototype.animateSelection_ = function (direction) {\n  var totalSteps = 10;\n  var millis = 30;\n  if (this.fadeLevel === undefined) this.fadeLevel = 0;\n  if (this.animateId === undefined) this.animateId = 0;\n  var start = this.fadeLevel;\n  var steps = direction < 0 ? start : totalSteps - start;\n  if (steps <= 0) {\n    if (this.fadeLevel) {\n      this.updateSelection_(1.0);\n    }\n    return;\n  }\n\n  var thisId = ++this.animateId;\n  var that = this;\n  var cleanupIfClearing = function cleanupIfClearing() {\n    // if we haven't reached fadeLevel 0 in the max frame time,\n    // ensure that the clear happens and just go to 0\n    if (that.fadeLevel !== 0 && direction < 0) {\n      that.fadeLevel = 0;\n      that.clearSelection();\n    }\n  };\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"p\" /* repeatAndCleanup */](function (n) {\n    // ignore simultaneous animations\n    if (that.animateId != thisId) return;\n\n    that.fadeLevel += direction;\n    if (that.fadeLevel === 0) {\n      that.clearSelection();\n    } else {\n      that.updateSelection_(that.fadeLevel / totalSteps);\n    }\n  }, steps, millis, cleanupIfClearing);\n};\n\n/**\n * Draw dots over the selectied points in the data series. This function\n * takes care of cleanup of previously-drawn dots.\n * @private\n */\nDygraph.prototype.updateSelection_ = function (opt_animFraction) {\n  /*var defaultPrevented = */\n  this.cascadeEvents_('select', {\n    selectedRow: this.lastRow_ === -1 ? undefined : this.lastRow_,\n    selectedX: this.lastx_ === -1 ? undefined : this.lastx_,\n    selectedPoints: this.selPoints_\n  });\n  // TODO(danvk): use defaultPrevented here?\n\n  // Clear the previously drawn vertical, if there is one\n  var i;\n  var ctx = this.canvas_ctx_;\n  if (this.getOption('highlightSeriesOpts')) {\n    ctx.clearRect(0, 0, this.width_, this.height_);\n    var alpha = 1.0 - this.getNumericOption('highlightSeriesBackgroundAlpha');\n    var backgroundColor = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"t\" /* toRGB_ */](this.getOption('highlightSeriesBackgroundColor'));\n\n    if (alpha) {\n      // Activating background fade includes an animation effect for a gradual\n      // fade. TODO(klausw): make this independently configurable if it causes\n      // issues? Use a shared preference to control animations?\n      var animateBackgroundFade = true;\n      if (animateBackgroundFade) {\n        if (opt_animFraction === undefined) {\n          // start a new animation\n          this.animateSelection_(1);\n          return;\n        }\n        alpha *= opt_animFraction;\n      }\n      ctx.fillStyle = 'rgba(' + backgroundColor.r + ',' + backgroundColor.g + ',' + backgroundColor.b + ',' + alpha + ')';\n      ctx.fillRect(0, 0, this.width_, this.height_);\n    }\n\n    // Redraw only the highlighted series in the interactive canvas (not the\n    // static plot canvas, which is where series are usually drawn).\n    this.plotter_._renderLineChart(this.highlightSet_, ctx);\n  } else if (this.previousVerticalX_ >= 0) {\n    // Determine the maximum highlight circle size.\n    var maxCircleSize = 0;\n    var labels = this.attr_('labels');\n    for (i = 1; i < labels.length; i++) {\n      var r = this.getNumericOption('highlightCircleSize', labels[i]);\n      if (r > maxCircleSize) maxCircleSize = r;\n    }\n    var px = this.previousVerticalX_;\n    ctx.clearRect(px - maxCircleSize - 1, 0, 2 * maxCircleSize + 2, this.height_);\n  }\n\n  if (this.selPoints_.length > 0) {\n    // Draw colored circles over the center of each selected point\n    var canvasx = this.selPoints_[0].canvasx;\n    ctx.save();\n    for (i = 0; i < this.selPoints_.length; i++) {\n      var pt = this.selPoints_[i];\n      if (isNaN(pt.canvasy)) continue;\n\n      var circleSize = this.getNumericOption('highlightCircleSize', pt.name);\n      var callback = this.getFunctionOption(\"drawHighlightPointCallback\", pt.name);\n      var color = this.plotter_.colors[pt.name];\n      if (!callback) {\n        callback = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"u\" /* Circles */].DEFAULT;\n      }\n      ctx.lineWidth = this.getNumericOption('strokeWidth', pt.name);\n      ctx.strokeStyle = color;\n      ctx.fillStyle = color;\n      callback.call(this, this, pt.name, ctx, canvasx, pt.canvasy, color, circleSize, pt.idx);\n    }\n    ctx.restore();\n\n    this.previousVerticalX_ = canvasx;\n  }\n};\n\n/**\n * Manually set the selected points and display information about them in the\n * legend. The selection can be cleared using clearSelection() and queried\n * using getSelection().\n *\n * To set a selected series but not a selected point, call setSelection with\n * row=false and the selected series name.\n *\n * @param {number} row Row number that should be highlighted (i.e. appear with\n * hover dots on the chart).\n * @param {seriesName} optional series name to highlight that series with the\n * the highlightSeriesOpts setting.\n * @param { locked } optional If true, keep seriesName selected when mousing\n * over the graph, disabling closest-series highlighting. Call clearSelection()\n * to unlock it.\n */\nDygraph.prototype.setSelection = function (row, opt_seriesName, opt_locked) {\n  // Extract the points we've selected\n  this.selPoints_ = [];\n\n  var changed = false;\n  if (row !== false && row >= 0) {\n    if (row != this.lastRow_) changed = true;\n    this.lastRow_ = row;\n    for (var setIdx = 0; setIdx < this.layout_.points.length; ++setIdx) {\n      var points = this.layout_.points[setIdx];\n      // Check if the point at the appropriate index is the point we're looking\n      // for.  If it is, just use it, otherwise search the array for a point\n      // in the proper place.\n      var setRow = row - this.getLeftBoundary_(setIdx);\n      if (setRow >= 0 && setRow < points.length && points[setRow].idx == row) {\n        var point = points[setRow];\n        if (point.yval !== null) this.selPoints_.push(point);\n      } else {\n        for (var pointIdx = 0; pointIdx < points.length; ++pointIdx) {\n          var point = points[pointIdx];\n          if (point.idx == row) {\n            if (point.yval !== null) {\n              this.selPoints_.push(point);\n            }\n            break;\n          }\n        }\n      }\n    }\n  } else {\n    if (this.lastRow_ >= 0) changed = true;\n    this.lastRow_ = -1;\n  }\n\n  if (this.selPoints_.length) {\n    this.lastx_ = this.selPoints_[0].xval;\n  } else {\n    this.lastx_ = -1;\n  }\n\n  if (opt_seriesName !== undefined) {\n    if (this.highlightSet_ !== opt_seriesName) changed = true;\n    this.highlightSet_ = opt_seriesName;\n  }\n\n  if (opt_locked !== undefined) {\n    this.lockedSet_ = opt_locked;\n  }\n\n  if (changed) {\n    this.updateSelection_(undefined);\n  }\n  return changed;\n};\n\n/**\n * The mouse has left the canvas. Clear out whatever artifacts remain\n * @param {Object} event the mouseout event from the browser.\n * @private\n */\nDygraph.prototype.mouseOut_ = function (event) {\n  if (this.getFunctionOption(\"unhighlightCallback\")) {\n    this.getFunctionOption(\"unhighlightCallback\").call(this, event);\n  }\n\n  if (this.getBooleanOption(\"hideOverlayOnMouseOut\") && !this.lockedSet_) {\n    this.clearSelection();\n  }\n};\n\n/**\n * Clears the current selection (i.e. points that were highlighted by moving\n * the mouse over the chart).\n */\nDygraph.prototype.clearSelection = function () {\n  this.cascadeEvents_('deselect', {});\n\n  this.lockedSet_ = false;\n  // Get rid of the overlay data\n  if (this.fadeLevel) {\n    this.animateSelection_(-1);\n    return;\n  }\n  this.canvas_ctx_.clearRect(0, 0, this.width_, this.height_);\n  this.fadeLevel = 0;\n  this.selPoints_ = [];\n  this.lastx_ = -1;\n  this.lastRow_ = -1;\n  this.highlightSet_ = null;\n};\n\n/**\n * Returns the number of the currently selected row. To get data for this row,\n * you can use the getValue method.\n * @return {number} row number, or -1 if nothing is selected\n */\nDygraph.prototype.getSelection = function () {\n  if (!this.selPoints_ || this.selPoints_.length < 1) {\n    return -1;\n  }\n\n  for (var setIdx = 0; setIdx < this.layout_.points.length; setIdx++) {\n    var points = this.layout_.points[setIdx];\n    for (var row = 0; row < points.length; row++) {\n      if (points[row].x == this.selPoints_[0].x) {\n        return points[row].idx;\n      }\n    }\n  }\n  return -1;\n};\n\n/**\n * Returns the name of the currently-highlighted series.\n * Only available when the highlightSeriesOpts option is in use.\n */\nDygraph.prototype.getHighlightSeries = function () {\n  return this.highlightSet_;\n};\n\n/**\n * Returns true if the currently-highlighted series was locked\n * via setSelection(..., seriesName, true).\n */\nDygraph.prototype.isSeriesLocked = function () {\n  return this.lockedSet_;\n};\n\n/**\n * Fires when there's data available to be graphed.\n * @param {string} data Raw CSV data to be plotted\n * @private\n */\nDygraph.prototype.loadedEvent_ = function (data) {\n  this.rawData_ = this.parseCSV_(data);\n  this.cascadeDataDidUpdateEvent_();\n  this.predraw_();\n};\n\n/**\n * Add ticks on the x-axis representing years, months, quarters, weeks, or days\n * @private\n */\nDygraph.prototype.addXTicks_ = function () {\n  // Determine the correct ticks scale on the x-axis: quarterly, monthly, ...\n  var range;\n  if (this.dateWindow_) {\n    range = [this.dateWindow_[0], this.dateWindow_[1]];\n  } else {\n    range = this.xAxisExtremes();\n  }\n\n  var xAxisOptionsView = this.optionsViewForAxis_('x');\n  var xTicks = xAxisOptionsView('ticker')(range[0], range[1], this.plotter_.area.w, // TODO(danvk): should be area.width\n  xAxisOptionsView, this);\n  // var msg = 'ticker(' + range[0] + ', ' + range[1] + ', ' + this.width_ + ', ' + this.attr_('pixelsPerXLabel') + ') -> ' + JSON.stringify(xTicks);\n  // console.log(msg);\n  this.layout_.setXTicks(xTicks);\n};\n\n/**\n * Returns the correct handler class for the currently set options.\n * @private\n */\nDygraph.prototype.getHandlerClass_ = function () {\n  var handlerClass;\n  if (this.attr_('dataHandler')) {\n    handlerClass = this.attr_('dataHandler');\n  } else if (this.fractions_) {\n    if (this.getBooleanOption('errorBars')) {\n      handlerClass = __WEBPACK_IMPORTED_MODULE_13__datahandler_bars_fractions__[\"a\" /* default */];\n    } else {\n      handlerClass = __WEBPACK_IMPORTED_MODULE_12__datahandler_default_fractions__[\"a\" /* default */];\n    }\n  } else if (this.getBooleanOption('customBars')) {\n    handlerClass = __WEBPACK_IMPORTED_MODULE_11__datahandler_bars_custom__[\"a\" /* default */];\n  } else if (this.getBooleanOption('errorBars')) {\n    handlerClass = __WEBPACK_IMPORTED_MODULE_10__datahandler_bars_error__[\"a\" /* default */];\n  } else {\n    handlerClass = __WEBPACK_IMPORTED_MODULE_9__datahandler_default__[\"a\" /* default */];\n  }\n  return handlerClass;\n};\n\n/**\n * @private\n * This function is called once when the chart's data is changed or the options\n * dictionary is updated. It is _not_ called when the user pans or zooms. The\n * idea is that values derived from the chart's data can be computed here,\n * rather than every time the chart is drawn. This includes things like the\n * number of axes, rolling averages, etc.\n */\nDygraph.prototype.predraw_ = function () {\n  var start = new Date();\n\n  // Create the correct dataHandler\n  this.dataHandler_ = new (this.getHandlerClass_())();\n\n  this.layout_.computePlotArea();\n\n  // TODO(danvk): move more computations out of drawGraph_ and into here.\n  this.computeYAxes_();\n\n  if (!this.is_initial_draw_) {\n    this.canvas_ctx_.restore();\n    this.hidden_ctx_.restore();\n  }\n\n  this.canvas_ctx_.save();\n  this.hidden_ctx_.save();\n\n  // Create a new plotter.\n  this.plotter_ = new __WEBPACK_IMPORTED_MODULE_1__dygraph_canvas__[\"a\" /* default */](this, this.hidden_, this.hidden_ctx_, this.layout_);\n\n  // The roller sits in the bottom left corner of the chart. We don't know where\n  // this will be until the options are available, so it's positioned here.\n  this.createRollInterface_();\n\n  this.cascadeEvents_('predraw');\n\n  // Convert the raw data (a 2D array) into the internal format and compute\n  // rolling averages.\n  this.rolledSeries_ = [null]; // x-axis is the first series and it's special\n  for (var i = 1; i < this.numColumns(); i++) {\n    // var logScale = this.attr_('logscale', i); // TODO(klausw): this looks wrong // konigsberg thinks so too.\n    var series = this.dataHandler_.extractSeries(this.rawData_, i, this.attributes_);\n    if (this.rollPeriod_ > 1) {\n      series = this.dataHandler_.rollingAverage(series, this.rollPeriod_, this.attributes_);\n    }\n\n    this.rolledSeries_.push(series);\n  }\n\n  // If the data or options have changed, then we'd better redraw.\n  this.drawGraph_();\n\n  // This is used to determine whether to do various animations.\n  var end = new Date();\n  this.drawingTimeMs_ = end - start;\n};\n\n/**\n * Point structure.\n *\n * xval_* and yval_* are the original unscaled data values,\n * while x_* and y_* are scaled to the range (0.0-1.0) for plotting.\n * yval_stacked is the cumulative Y value used for stacking graphs,\n * and bottom/top/minus/plus are used for error bar graphs.\n *\n * @typedef {{\n *     idx: number,\n *     name: string,\n *     x: ?number,\n *     xval: ?number,\n *     y_bottom: ?number,\n *     y: ?number,\n *     y_stacked: ?number,\n *     y_top: ?number,\n *     yval_minus: ?number,\n *     yval: ?number,\n *     yval_plus: ?number,\n *     yval_stacked\n * }}\n */\nDygraph.PointType = undefined;\n\n/**\n * Calculates point stacking for stackedGraph=true.\n *\n * For stacking purposes, interpolate or extend neighboring data across\n * NaN values based on stackedGraphNaNFill settings. This is for display\n * only, the underlying data value as shown in the legend remains NaN.\n *\n * @param {Array.<Dygraph.PointType>} points Point array for a single series.\n *     Updates each Point's yval_stacked property.\n * @param {Array.<number>} cumulativeYval Accumulated top-of-graph stacked Y\n *     values for the series seen so far. Index is the row number. Updated\n *     based on the current series's values.\n * @param {Array.<number>} seriesExtremes Min and max values, updated\n *     to reflect the stacked values.\n * @param {string} fillMethod Interpolation method, one of 'all', 'inside', or\n *     'none'.\n * @private\n */\nDygraph.stackPoints_ = function (points, cumulativeYval, seriesExtremes, fillMethod) {\n  var lastXval = null;\n  var prevPoint = null;\n  var nextPoint = null;\n  var nextPointIdx = -1;\n\n  // Find the next stackable point starting from the given index.\n  var updateNextPoint = function updateNextPoint(idx) {\n    // If we've previously found a non-NaN point and haven't gone past it yet,\n    // just use that.\n    if (nextPointIdx >= idx) return;\n\n    // We haven't found a non-NaN point yet or have moved past it,\n    // look towards the right to find a non-NaN point.\n    for (var j = idx; j < points.length; ++j) {\n      // Clear out a previously-found point (if any) since it's no longer\n      // valid, we shouldn't use it for interpolation anymore.\n      nextPoint = null;\n      if (!isNaN(points[j].yval) && points[j].yval !== null) {\n        nextPointIdx = j;\n        nextPoint = points[j];\n        break;\n      }\n    }\n  };\n\n  for (var i = 0; i < points.length; ++i) {\n    var point = points[i];\n    var xval = point.xval;\n    if (cumulativeYval[xval] === undefined) {\n      cumulativeYval[xval] = 0;\n    }\n\n    var actualYval = point.yval;\n    if (isNaN(actualYval) || actualYval === null) {\n      if (fillMethod == 'none') {\n        actualYval = 0;\n      } else {\n        // Interpolate/extend for stacking purposes if possible.\n        updateNextPoint(i);\n        if (prevPoint && nextPoint && fillMethod != 'none') {\n          // Use linear interpolation between prevPoint and nextPoint.\n          actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) * ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n        } else if (prevPoint && fillMethod == 'all') {\n          actualYval = prevPoint.yval;\n        } else if (nextPoint && fillMethod == 'all') {\n          actualYval = nextPoint.yval;\n        } else {\n          actualYval = 0;\n        }\n      }\n    } else {\n      prevPoint = point;\n    }\n\n    var stackedYval = cumulativeYval[xval];\n    if (lastXval != xval) {\n      // If an x-value is repeated, we ignore the duplicates.\n      stackedYval += actualYval;\n      cumulativeYval[xval] = stackedYval;\n    }\n    lastXval = xval;\n\n    point.yval_stacked = stackedYval;\n\n    if (stackedYval > seriesExtremes[1]) {\n      seriesExtremes[1] = stackedYval;\n    }\n    if (stackedYval < seriesExtremes[0]) {\n      seriesExtremes[0] = stackedYval;\n    }\n  }\n};\n\n/**\n * Loop over all fields and create datasets, calculating extreme y-values for\n * each series and extreme x-indices as we go.\n *\n * dateWindow is passed in as an explicit parameter so that we can compute\n * extreme values \"speculatively\", i.e. without actually setting state on the\n * dygraph.\n *\n * @param {Array.<Array.<Array.<(number|Array<number>)>>} rolledSeries, where\n *     rolledSeries[seriesIndex][row] = raw point, where\n *     seriesIndex is the column number starting with 1, and\n *     rawPoint is [x,y] or [x, [y, err]] or [x, [y, yminus, yplus]].\n * @param {?Array.<number>} dateWindow [xmin, xmax] pair, or null.\n * @return {{\n *     points: Array.<Array.<Dygraph.PointType>>,\n *     seriesExtremes: Array.<Array.<number>>,\n *     boundaryIds: Array.<number>}}\n * @private\n */\nDygraph.prototype.gatherDatasets_ = function (rolledSeries, dateWindow) {\n  var boundaryIds = [];\n  var points = [];\n  var cumulativeYval = []; // For stacked series.\n  var extremes = {}; // series name -> [low, high]\n  var seriesIdx, sampleIdx;\n  var firstIdx, lastIdx;\n  var axisIdx;\n\n  // Loop over the fields (series).  Go from the last to the first,\n  // because if they're stacked that's how we accumulate the values.\n  var num_series = rolledSeries.length - 1;\n  var series;\n  for (seriesIdx = num_series; seriesIdx >= 1; seriesIdx--) {\n    if (!this.visibility()[seriesIdx - 1]) continue;\n\n    // Prune down to the desired range, if necessary (for zooming)\n    // Because there can be lines going to points outside of the visible area,\n    // we actually prune to visible points, plus one on either side.\n    if (dateWindow) {\n      series = rolledSeries[seriesIdx];\n      var low = dateWindow[0];\n      var high = dateWindow[1];\n\n      // TODO(danvk): do binary search instead of linear search.\n      // TODO(danvk): pass firstIdx and lastIdx directly to the renderer.\n      firstIdx = null;\n      lastIdx = null;\n      for (sampleIdx = 0; sampleIdx < series.length; sampleIdx++) {\n        if (series[sampleIdx][0] >= low && firstIdx === null) {\n          firstIdx = sampleIdx;\n        }\n        if (series[sampleIdx][0] <= high) {\n          lastIdx = sampleIdx;\n        }\n      }\n\n      if (firstIdx === null) firstIdx = 0;\n      var correctedFirstIdx = firstIdx;\n      var isInvalidValue = true;\n      while (isInvalidValue && correctedFirstIdx > 0) {\n        correctedFirstIdx--;\n        // check if the y value is null.\n        isInvalidValue = series[correctedFirstIdx][1] === null;\n      }\n\n      if (lastIdx === null) lastIdx = series.length - 1;\n      var correctedLastIdx = lastIdx;\n      isInvalidValue = true;\n      while (isInvalidValue && correctedLastIdx < series.length - 1) {\n        correctedLastIdx++;\n        isInvalidValue = series[correctedLastIdx][1] === null;\n      }\n\n      if (correctedFirstIdx !== firstIdx) {\n        firstIdx = correctedFirstIdx;\n      }\n      if (correctedLastIdx !== lastIdx) {\n        lastIdx = correctedLastIdx;\n      }\n\n      boundaryIds[seriesIdx - 1] = [firstIdx, lastIdx];\n\n      // .slice's end is exclusive, we want to include lastIdx.\n      series = series.slice(firstIdx, lastIdx + 1);\n    } else {\n      series = rolledSeries[seriesIdx];\n      boundaryIds[seriesIdx - 1] = [0, series.length - 1];\n    }\n\n    var seriesName = this.attr_(\"labels\")[seriesIdx];\n    var seriesExtremes = this.dataHandler_.getExtremeYValues(series, dateWindow, this.getBooleanOption(\"stepPlot\", seriesName));\n\n    var seriesPoints = this.dataHandler_.seriesToPoints(series, seriesName, boundaryIds[seriesIdx - 1][0]);\n\n    if (this.getBooleanOption(\"stackedGraph\")) {\n      axisIdx = this.attributes_.axisForSeries(seriesName);\n      if (cumulativeYval[axisIdx] === undefined) {\n        cumulativeYval[axisIdx] = [];\n      }\n      Dygraph.stackPoints_(seriesPoints, cumulativeYval[axisIdx], seriesExtremes, this.getBooleanOption(\"stackedGraphNaNFill\"));\n    }\n\n    extremes[seriesName] = seriesExtremes;\n    points[seriesIdx] = seriesPoints;\n  }\n\n  return { points: points, extremes: extremes, boundaryIds: boundaryIds };\n};\n\n/**\n * Update the graph with new data. This method is called when the viewing area\n * has changed. If the underlying data or options have changed, predraw_ will\n * be called before drawGraph_ is called.\n *\n * @private\n */\nDygraph.prototype.drawGraph_ = function () {\n  var start = new Date();\n\n  // This is used to set the second parameter to drawCallback, below.\n  var is_initial_draw = this.is_initial_draw_;\n  this.is_initial_draw_ = false;\n\n  this.layout_.removeAllDatasets();\n  this.setColors_();\n  this.attrs_.pointSize = 0.5 * this.getNumericOption('highlightCircleSize');\n\n  var packed = this.gatherDatasets_(this.rolledSeries_, this.dateWindow_);\n  var points = packed.points;\n  var extremes = packed.extremes;\n  this.boundaryIds_ = packed.boundaryIds;\n\n  this.setIndexByName_ = {};\n  var labels = this.attr_(\"labels\");\n  var dataIdx = 0;\n  for (var i = 1; i < points.length; i++) {\n    if (!this.visibility()[i - 1]) continue;\n    this.layout_.addDataset(labels[i], points[i]);\n    this.datasetIndex_[i] = dataIdx++;\n  }\n  for (var i = 0; i < labels.length; i++) {\n    this.setIndexByName_[labels[i]] = i;\n  }\n\n  this.computeYAxisRanges_(extremes);\n  this.layout_.setYAxes(this.axes_);\n\n  this.addXTicks_();\n\n  // Tell PlotKit to use this new data and render itself\n  this.layout_.evaluate();\n  this.renderGraph_(is_initial_draw);\n\n  if (this.getStringOption(\"timingName\")) {\n    var end = new Date();\n    console.log(this.getStringOption(\"timingName\") + \" - drawGraph: \" + (end - start) + \"ms\");\n  }\n};\n\n/**\n * This does the work of drawing the chart. It assumes that the layout and axis\n * scales have already been set (e.g. by predraw_).\n *\n * @private\n */\nDygraph.prototype.renderGraph_ = function (is_initial_draw) {\n  this.cascadeEvents_('clearChart');\n  this.plotter_.clear();\n\n  var underlayCallback = this.getFunctionOption('underlayCallback');\n  if (underlayCallback) {\n    // NOTE: we pass the dygraph object to this callback twice to avoid breaking\n    // users who expect a deprecated form of this callback.\n    underlayCallback.call(this, this.hidden_ctx_, this.layout_.getPlotArea(), this, this);\n  }\n\n  var e = {\n    canvas: this.hidden_,\n    drawingContext: this.hidden_ctx_\n  };\n  this.cascadeEvents_('willDrawChart', e);\n  this.plotter_.render();\n  this.cascadeEvents_('didDrawChart', e);\n  this.lastRow_ = -1; // because plugins/legend.js clears the legend\n\n  // TODO(danvk): is this a performance bottleneck when panning?\n  // The interaction canvas should already be empty in that situation.\n  this.canvas_.getContext('2d').clearRect(0, 0, this.width_, this.height_);\n\n  var drawCallback = this.getFunctionOption(\"drawCallback\");\n  if (drawCallback !== null) {\n    drawCallback.call(this, this, is_initial_draw);\n  }\n  if (is_initial_draw) {\n    this.readyFired_ = true;\n    while (this.readyFns_.length > 0) {\n      var fn = this.readyFns_.pop();\n      fn(this);\n    }\n  }\n};\n\n/**\n * @private\n * Determine properties of the y-axes which are independent of the data\n * currently being displayed. This includes things like the number of axes and\n * the style of the axes. It does not include the range of each axis and its\n * tick marks.\n * This fills in this.axes_.\n * axes_ = [ { options } ]\n *   indices are into the axes_ array.\n */\nDygraph.prototype.computeYAxes_ = function () {\n  var axis, index, opts, v;\n\n  // this.axes_ doesn't match this.attributes_.axes_.options. It's used for\n  // data computation as well as options storage.\n  // Go through once and add all the axes.\n  this.axes_ = [];\n\n  for (axis = 0; axis < this.attributes_.numAxes(); axis++) {\n    // Add a new axis, making a copy of its per-axis options.\n    opts = { g: this };\n    __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"a\" /* update */](opts, this.attributes_.axisOptions(axis));\n    this.axes_[axis] = opts;\n  }\n\n  for (axis = 0; axis < this.axes_.length; axis++) {\n    if (axis === 0) {\n      opts = this.optionsViewForAxis_('y' + (axis ? '2' : ''));\n      v = opts(\"valueRange\");\n      if (v) this.axes_[axis].valueRange = v;\n    } else {\n      // To keep old behavior\n      var axes = this.user_attrs_.axes;\n      if (axes && axes.y2) {\n        v = axes.y2.valueRange;\n        if (v) this.axes_[axis].valueRange = v;\n      }\n    }\n  }\n};\n\n/**\n * Returns the number of y-axes on the chart.\n * @return {number} the number of axes.\n */\nDygraph.prototype.numAxes = function () {\n  return this.attributes_.numAxes();\n};\n\n/**\n * @private\n * Returns axis properties for the given series.\n * @param {string} setName The name of the series for which to get axis\n * properties, e.g. 'Y1'.\n * @return {Object} The axis properties.\n */\nDygraph.prototype.axisPropertiesForSeries = function (series) {\n  // TODO(danvk): handle errors.\n  return this.axes_[this.attributes_.axisForSeries(series)];\n};\n\n/**\n * @private\n * Determine the value range and tick marks for each axis.\n * @param {Object} extremes A mapping from seriesName -> [low, high]\n * This fills in the valueRange and ticks fields in each entry of this.axes_.\n */\nDygraph.prototype.computeYAxisRanges_ = function (extremes) {\n  var isNullUndefinedOrNaN = function isNullUndefinedOrNaN(num) {\n    return isNaN(parseFloat(num));\n  };\n  var numAxes = this.attributes_.numAxes();\n  var ypadCompat, span, series, ypad;\n\n  var p_axis;\n\n  // Compute extreme values, a span and tick marks for each axis.\n  for (var i = 0; i < numAxes; i++) {\n    var axis = this.axes_[i];\n    var logscale = this.attributes_.getForAxis(\"logscale\", i);\n    var includeZero = this.attributes_.getForAxis(\"includeZero\", i);\n    var independentTicks = this.attributes_.getForAxis(\"independentTicks\", i);\n    series = this.attributes_.seriesForAxis(i);\n\n    // Add some padding. This supports two Y padding operation modes:\n    //\n    // - backwards compatible (yRangePad not set):\n    //   10% padding for automatic Y ranges, but not for user-supplied\n    //   ranges, and move a close-to-zero edge to zero, since drawing at the edge\n    //   results in invisible lines. Unfortunately lines drawn at the edge of a\n    //   user-supplied range will still be invisible. If logscale is\n    //   set, add a variable amount of padding at the top but\n    //   none at the bottom.\n    //\n    // - new-style (yRangePad set by the user):\n    //   always add the specified Y padding.\n    //\n    ypadCompat = true;\n    ypad = 0.1; // add 10%\n    var yRangePad = this.getNumericOption('yRangePad');\n    if (yRangePad !== null) {\n      ypadCompat = false;\n      // Convert pixel padding to ratio\n      ypad = yRangePad / this.plotter_.area.h;\n    }\n\n    if (series.length === 0) {\n      // If no series are defined or visible then use a reasonable default\n      axis.extremeRange = [0, 1];\n    } else {\n      // Calculate the extremes of extremes.\n      var minY = Infinity; // extremes[series[0]][0];\n      var maxY = -Infinity; // extremes[series[0]][1];\n      var extremeMinY, extremeMaxY;\n\n      for (var j = 0; j < series.length; j++) {\n        // this skips invisible series\n        if (!extremes.hasOwnProperty(series[j])) continue;\n\n        // Only use valid extremes to stop null data series' from corrupting the scale.\n        extremeMinY = extremes[series[j]][0];\n        if (extremeMinY !== null) {\n          minY = Math.min(extremeMinY, minY);\n        }\n        extremeMaxY = extremes[series[j]][1];\n        if (extremeMaxY !== null) {\n          maxY = Math.max(extremeMaxY, maxY);\n        }\n      }\n\n      // Include zero if requested by the user.\n      if (includeZero && !logscale) {\n        if (minY > 0) minY = 0;\n        if (maxY < 0) maxY = 0;\n      }\n\n      // Ensure we have a valid scale, otherwise default to [0, 1] for safety.\n      if (minY == Infinity) minY = 0;\n      if (maxY == -Infinity) maxY = 1;\n\n      span = maxY - minY;\n      // special case: if we have no sense of scale, center on the sole value.\n      if (span === 0) {\n        if (maxY !== 0) {\n          span = Math.abs(maxY);\n        } else {\n          // ... and if the sole value is zero, use range 0-1.\n          maxY = 1;\n          span = 1;\n        }\n      }\n\n      var maxAxisY = maxY,\n          minAxisY = minY;\n      if (ypadCompat) {\n        if (logscale) {\n          maxAxisY = maxY + ypad * span;\n          minAxisY = minY;\n        } else {\n          maxAxisY = maxY + ypad * span;\n          minAxisY = minY - ypad * span;\n\n          // Backwards-compatible behavior: Move the span to start or end at zero if it's\n          // close to zero.\n          if (minAxisY < 0 && minY >= 0) minAxisY = 0;\n          if (maxAxisY > 0 && maxY <= 0) maxAxisY = 0;\n        }\n      }\n      axis.extremeRange = [minAxisY, maxAxisY];\n    }\n    if (axis.valueRange) {\n      // This is a user-set value range for this axis.\n      var y0 = isNullUndefinedOrNaN(axis.valueRange[0]) ? axis.extremeRange[0] : axis.valueRange[0];\n      var y1 = isNullUndefinedOrNaN(axis.valueRange[1]) ? axis.extremeRange[1] : axis.valueRange[1];\n      axis.computedValueRange = [y0, y1];\n    } else {\n      axis.computedValueRange = axis.extremeRange;\n    }\n    if (!ypadCompat) {\n      // When using yRangePad, adjust the upper/lower bounds to add\n      // padding unless the user has zoomed/panned the Y axis range.\n      if (logscale) {\n        y0 = axis.computedValueRange[0];\n        y1 = axis.computedValueRange[1];\n        var y0pct = ypad / (2 * ypad - 1);\n        var y1pct = (ypad - 1) / (2 * ypad - 1);\n        axis.computedValueRange[0] = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"c\" /* logRangeFraction */](y0, y1, y0pct);\n        axis.computedValueRange[1] = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"c\" /* logRangeFraction */](y0, y1, y1pct);\n      } else {\n        y0 = axis.computedValueRange[0];\n        y1 = axis.computedValueRange[1];\n        span = y1 - y0;\n        axis.computedValueRange[0] = y0 - span * ypad;\n        axis.computedValueRange[1] = y1 + span * ypad;\n      }\n    }\n\n    if (independentTicks) {\n      axis.independentTicks = independentTicks;\n      var opts = this.optionsViewForAxis_('y' + (i ? '2' : ''));\n      var ticker = opts('ticker');\n      axis.ticks = ticker(axis.computedValueRange[0], axis.computedValueRange[1], this.plotter_.area.h, opts, this);\n      // Define the first independent axis as primary axis.\n      if (!p_axis) p_axis = axis;\n    }\n  }\n  if (p_axis === undefined) {\n    throw \"Configuration Error: At least one axis has to have the \\\"independentTicks\\\" option activated.\";\n  }\n  // Add ticks. By default, all axes inherit the tick positions of the\n  // primary axis. However, if an axis is specifically marked as having\n  // independent ticks, then that is permissible as well.\n  for (var i = 0; i < numAxes; i++) {\n    var axis = this.axes_[i];\n\n    if (!axis.independentTicks) {\n      var opts = this.optionsViewForAxis_('y' + (i ? '2' : ''));\n      var ticker = opts('ticker');\n      var p_ticks = p_axis.ticks;\n      var p_scale = p_axis.computedValueRange[1] - p_axis.computedValueRange[0];\n      var scale = axis.computedValueRange[1] - axis.computedValueRange[0];\n      var tick_values = [];\n      for (var k = 0; k < p_ticks.length; k++) {\n        var y_frac = (p_ticks[k].v - p_axis.computedValueRange[0]) / p_scale;\n        var y_val = axis.computedValueRange[0] + y_frac * scale;\n        tick_values.push(y_val);\n      }\n\n      axis.ticks = ticker(axis.computedValueRange[0], axis.computedValueRange[1], this.plotter_.area.h, opts, this, tick_values);\n    }\n  }\n};\n\n/**\n * Detects the type of the str (date or numeric) and sets the various\n * formatting attributes in this.attrs_ based on this type.\n * @param {string} str An x value.\n * @private\n */\nDygraph.prototype.detectTypeFromString_ = function (str) {\n  var isDate = false;\n  var dashPos = str.indexOf('-'); // could be 2006-01-01 _or_ 1.0e-2\n  if (dashPos > 0 && str[dashPos - 1] != 'e' && str[dashPos - 1] != 'E' || str.indexOf('/') >= 0 || isNaN(parseFloat(str))) {\n    isDate = true;\n  } else if (str.length == 8 && str > '19700101' && str < '20371231') {\n    // TODO(danvk): remove support for this format.\n    isDate = true;\n  }\n\n  this.setXAxisOptions_(isDate);\n};\n\nDygraph.prototype.setXAxisOptions_ = function (isDate) {\n  if (isDate) {\n    this.attrs_.xValueParser = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"v\" /* dateParser */];\n    this.attrs_.axes.x.valueFormatter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"w\" /* dateValueFormatter */];\n    this.attrs_.axes.x.ticker = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"a\" /* dateTicker */];\n    this.attrs_.axes.x.axisLabelFormatter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"x\" /* dateAxisLabelFormatter */];\n  } else {\n    /** @private (shut up, jsdoc!) */\n    this.attrs_.xValueParser = function (x) {\n      return parseFloat(x);\n    };\n    // TODO(danvk): use Dygraph.numberValueFormatter here?\n    /** @private (shut up, jsdoc!) */\n    this.attrs_.axes.x.valueFormatter = function (x) {\n      return x;\n    };\n    this.attrs_.axes.x.ticker = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"b\" /* numericTicks */];\n    this.attrs_.axes.x.axisLabelFormatter = this.attrs_.axes.x.valueFormatter;\n  }\n};\n\n/**\n * @private\n * Parses a string in a special csv format.  We expect a csv file where each\n * line is a date point, and the first field in each line is the date string.\n * We also expect that all remaining fields represent series.\n * if the errorBars attribute is set, then interpret the fields as:\n * date, series1, stddev1, series2, stddev2, ...\n * @param {[Object]} data See above.\n *\n * @return [Object] An array with one entry for each row. These entries\n * are an array of cells in that row. The first entry is the parsed x-value for\n * the row. The second, third, etc. are the y-values. These can take on one of\n * three forms, depending on the CSV and constructor parameters:\n * 1. numeric value\n * 2. [ value, stddev ]\n * 3. [ low value, center value, high value ]\n */\nDygraph.prototype.parseCSV_ = function (data) {\n  var ret = [];\n  var line_delimiter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"y\" /* detectLineDelimiter */](data);\n  var lines = data.split(line_delimiter || \"\\n\");\n  var vals, j;\n\n  // Use the default delimiter or fall back to a tab if that makes sense.\n  var delim = this.getStringOption('delimiter');\n  if (lines[0].indexOf(delim) == -1 && lines[0].indexOf('\\t') >= 0) {\n    delim = '\\t';\n  }\n\n  var start = 0;\n  if (!('labels' in this.user_attrs_)) {\n    // User hasn't explicitly set labels, so they're (presumably) in the CSV.\n    start = 1;\n    this.attrs_.labels = lines[0].split(delim); // NOTE: _not_ user_attrs_.\n    this.attributes_.reparseSeries();\n  }\n  var line_no = 0;\n\n  var xParser;\n  var defaultParserSet = false; // attempt to auto-detect x value type\n  var expectedCols = this.attr_(\"labels\").length;\n  var outOfOrder = false;\n  for (var i = start; i < lines.length; i++) {\n    var line = lines[i];\n    line_no = i;\n    if (line.length === 0) continue; // skip blank lines\n    if (line[0] == '#') continue; // skip comment lines\n    var inFields = line.split(delim);\n    if (inFields.length < 2) continue;\n\n    var fields = [];\n    if (!defaultParserSet) {\n      this.detectTypeFromString_(inFields[0]);\n      xParser = this.getFunctionOption(\"xValueParser\");\n      defaultParserSet = true;\n    }\n    fields[0] = xParser(inFields[0], this);\n\n    // If fractions are expected, parse the numbers as \"A/B\"\n    if (this.fractions_) {\n      for (j = 1; j < inFields.length; j++) {\n        // TODO(danvk): figure out an appropriate way to flag parse errors.\n        vals = inFields[j].split(\"/\");\n        if (vals.length != 2) {\n          console.error('Expected fractional \"num/den\" values in CSV data ' + \"but found a value '\" + inFields[j] + \"' on line \" + (1 + i) + \" ('\" + line + \"') which is not of this form.\");\n          fields[j] = [0, 0];\n        } else {\n          fields[j] = [__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"z\" /* parseFloat_ */](vals[0], i, line), __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"z\" /* parseFloat_ */](vals[1], i, line)];\n        }\n      }\n    } else if (this.getBooleanOption(\"errorBars\")) {\n      // If there are error bars, values are (value, stddev) pairs\n      if (inFields.length % 2 != 1) {\n        console.error('Expected alternating (value, stdev.) pairs in CSV data ' + 'but line ' + (1 + i) + ' has an odd number of values (' + (inFields.length - 1) + \"): '\" + line + \"'\");\n      }\n      for (j = 1; j < inFields.length; j += 2) {\n        fields[(j + 1) / 2] = [__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"z\" /* parseFloat_ */](inFields[j], i, line), __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"z\" /* parseFloat_ */](inFields[j + 1], i, line)];\n      }\n    } else if (this.getBooleanOption(\"customBars\")) {\n      // Bars are a low;center;high tuple\n      for (j = 1; j < inFields.length; j++) {\n        var val = inFields[j];\n        if (/^ *$/.test(val)) {\n          fields[j] = [null, null, null];\n        } else {\n          vals = val.split(\";\");\n          if (vals.length == 3) {\n            fields[j] = [__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"z\" /* parseFloat_ */](vals[0], i, line), __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"z\" /* parseFloat_ */](vals[1], i, line), __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"z\" /* parseFloat_ */](vals[2], i, line)];\n          } else {\n            console.warn('When using customBars, values must be either blank ' + 'or \"low;center;high\" tuples (got \"' + val + '\" on line ' + (1 + i));\n          }\n        }\n      }\n    } else {\n      // Values are just numbers\n      for (j = 1; j < inFields.length; j++) {\n        fields[j] = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"z\" /* parseFloat_ */](inFields[j], i, line);\n      }\n    }\n    if (ret.length > 0 && fields[0] < ret[ret.length - 1][0]) {\n      outOfOrder = true;\n    }\n\n    if (fields.length != expectedCols) {\n      console.error(\"Number of columns in line \" + i + \" (\" + fields.length + \") does not agree with number of labels (\" + expectedCols + \") \" + line);\n    }\n\n    // If the user specified the 'labels' option and none of the cells of the\n    // first row parsed correctly, then they probably double-specified the\n    // labels. We go with the values set in the option, discard this row and\n    // log a warning to the JS console.\n    if (i === 0 && this.attr_('labels')) {\n      var all_null = true;\n      for (j = 0; all_null && j < fields.length; j++) {\n        if (fields[j]) all_null = false;\n      }\n      if (all_null) {\n        console.warn(\"The dygraphs 'labels' option is set, but the first row \" + \"of CSV data ('\" + line + \"') appears to also contain \" + \"labels. Will drop the CSV labels and use the option \" + \"labels.\");\n        continue;\n      }\n    }\n    ret.push(fields);\n  }\n\n  if (outOfOrder) {\n    console.warn(\"CSV is out of order; order it correctly to speed loading.\");\n    ret.sort(function (a, b) {\n      return a[0] - b[0];\n    });\n  }\n\n  return ret;\n};\n\n// In native format, all values must be dates or numbers.\n// This check isn't perfect but will catch most mistaken uses of strings.\nfunction validateNativeFormat(data) {\n  var firstRow = data[0];\n  var firstX = firstRow[0];\n  if (typeof firstX !== 'number' && !__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"A\" /* isDateLike */](firstX)) {\n    throw new Error('Expected number or date but got ' + (typeof firstX === 'undefined' ? 'undefined' : _typeof(firstX)) + ': ' + firstX + '.');\n  }\n  for (var i = 1; i < firstRow.length; i++) {\n    var val = firstRow[i];\n    if (val === null || val === undefined) continue;\n    if (typeof val === 'number') continue;\n    if (__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"B\" /* isArrayLike */](val)) continue; // e.g. error bars or custom bars.\n    throw new Error('Expected number or array but got ' + (typeof val === 'undefined' ? 'undefined' : _typeof(val)) + ': ' + val + '.');\n  }\n}\n\n/**\n * The user has provided their data as a pre-packaged JS array. If the x values\n * are numeric, this is the same as dygraphs' internal format. If the x values\n * are dates, we need to convert them from Date objects to ms since epoch.\n * @param {!Array} data\n * @return {Object} data with numeric x values.\n * @private\n */\nDygraph.prototype.parseArray_ = function (data) {\n  // Peek at the first x value to see if it's numeric.\n  if (data.length === 0) {\n    console.error(\"Can't plot empty data set\");\n    return null;\n  }\n  if (data[0].length === 0) {\n    console.error(\"Data set cannot contain an empty row\");\n    return null;\n  }\n\n  validateNativeFormat(data);\n\n  var i;\n  if (this.attr_(\"labels\") === null) {\n    console.warn(\"Using default labels. Set labels explicitly via 'labels' \" + \"in the options parameter\");\n    this.attrs_.labels = [\"X\"];\n    for (i = 1; i < data[0].length; i++) {\n      this.attrs_.labels.push(\"Y\" + i); // Not user_attrs_.\n    }\n    this.attributes_.reparseSeries();\n  } else {\n    var num_labels = this.attr_(\"labels\");\n    if (num_labels.length != data[0].length) {\n      console.error(\"Mismatch between number of labels (\" + num_labels + \")\" + \" and number of columns in array (\" + data[0].length + \")\");\n      return null;\n    }\n  }\n\n  if (__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"A\" /* isDateLike */](data[0][0])) {\n    // Some intelligent defaults for a date x-axis.\n    this.attrs_.axes.x.valueFormatter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"w\" /* dateValueFormatter */];\n    this.attrs_.axes.x.ticker = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"a\" /* dateTicker */];\n    this.attrs_.axes.x.axisLabelFormatter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"x\" /* dateAxisLabelFormatter */];\n\n    // Assume they're all dates.\n    var parsedData = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"C\" /* clone */](data);\n    for (i = 0; i < data.length; i++) {\n      if (parsedData[i].length === 0) {\n        console.error(\"Row \" + (1 + i) + \" of data is empty\");\n        return null;\n      }\n      if (parsedData[i][0] === null || typeof parsedData[i][0].getTime != 'function' || isNaN(parsedData[i][0].getTime())) {\n        console.error(\"x value in row \" + (1 + i) + \" is not a Date\");\n        return null;\n      }\n      parsedData[i][0] = parsedData[i][0].getTime();\n    }\n    return parsedData;\n  } else {\n    // Some intelligent defaults for a numeric x-axis.\n    /** @private (shut up, jsdoc!) */\n    this.attrs_.axes.x.valueFormatter = function (x) {\n      return x;\n    };\n    this.attrs_.axes.x.ticker = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"b\" /* numericTicks */];\n    this.attrs_.axes.x.axisLabelFormatter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"D\" /* numberAxisLabelFormatter */];\n    return data;\n  }\n};\n\n/**\n * Parses a DataTable object from gviz.\n * The data is expected to have a first column that is either a date or a\n * number. All subsequent columns must be numbers. If there is a clear mismatch\n * between this.xValueParser_ and the type of the first column, it will be\n * fixed. Fills out rawData_.\n * @param {!google.visualization.DataTable} data See above.\n * @private\n */\nDygraph.prototype.parseDataTable_ = function (data) {\n  var shortTextForAnnotationNum = function shortTextForAnnotationNum(num) {\n    // converts [0-9]+ [A-Z][a-z]*\n    // example: 0=A, 1=B, 25=Z, 26=Aa, 27=Ab\n    // and continues like.. Ba Bb .. Za .. Zz..Aaa...Zzz Aaaa Zzzz\n    var shortText = String.fromCharCode(65 /* A */ + num % 26);\n    num = Math.floor(num / 26);\n    while (num > 0) {\n      shortText = String.fromCharCode(65 /* A */ + (num - 1) % 26) + shortText.toLowerCase();\n      num = Math.floor((num - 1) / 26);\n    }\n    return shortText;\n  };\n\n  var cols = data.getNumberOfColumns();\n  var rows = data.getNumberOfRows();\n\n  var indepType = data.getColumnType(0);\n  if (indepType == 'date' || indepType == 'datetime') {\n    this.attrs_.xValueParser = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"v\" /* dateParser */];\n    this.attrs_.axes.x.valueFormatter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"w\" /* dateValueFormatter */];\n    this.attrs_.axes.x.ticker = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"a\" /* dateTicker */];\n    this.attrs_.axes.x.axisLabelFormatter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"x\" /* dateAxisLabelFormatter */];\n  } else if (indepType == 'number') {\n    this.attrs_.xValueParser = function (x) {\n      return parseFloat(x);\n    };\n    this.attrs_.axes.x.valueFormatter = function (x) {\n      return x;\n    };\n    this.attrs_.axes.x.ticker = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"b\" /* numericTicks */];\n    this.attrs_.axes.x.axisLabelFormatter = this.attrs_.axes.x.valueFormatter;\n  } else {\n    throw new Error(\"only 'date', 'datetime' and 'number' types are supported \" + \"for column 1 of DataTable input (Got '\" + indepType + \"')\");\n  }\n\n  // Array of the column indices which contain data (and not annotations).\n  var colIdx = [];\n  var annotationCols = {}; // data index -> [annotation cols]\n  var hasAnnotations = false;\n  var i, j;\n  for (i = 1; i < cols; i++) {\n    var type = data.getColumnType(i);\n    if (type == 'number') {\n      colIdx.push(i);\n    } else if (type == 'string' && this.getBooleanOption('displayAnnotations')) {\n      // This is OK -- it's an annotation column.\n      var dataIdx = colIdx[colIdx.length - 1];\n      if (!annotationCols.hasOwnProperty(dataIdx)) {\n        annotationCols[dataIdx] = [i];\n      } else {\n        annotationCols[dataIdx].push(i);\n      }\n      hasAnnotations = true;\n    } else {\n      throw new Error(\"Only 'number' is supported as a dependent type with Gviz.\" + \" 'string' is only supported if displayAnnotations is true\");\n    }\n  }\n\n  // Read column labels\n  // TODO(danvk): add support back for errorBars\n  var labels = [data.getColumnLabel(0)];\n  for (i = 0; i < colIdx.length; i++) {\n    labels.push(data.getColumnLabel(colIdx[i]));\n    if (this.getBooleanOption(\"errorBars\")) i += 1;\n  }\n  this.attrs_.labels = labels;\n  cols = labels.length;\n\n  var ret = [];\n  var outOfOrder = false;\n  var annotations = [];\n  for (i = 0; i < rows; i++) {\n    var row = [];\n    if (typeof data.getValue(i, 0) === 'undefined' || data.getValue(i, 0) === null) {\n      console.warn(\"Ignoring row \" + i + \" of DataTable because of undefined or null first column.\");\n      continue;\n    }\n\n    if (indepType == 'date' || indepType == 'datetime') {\n      row.push(data.getValue(i, 0).getTime());\n    } else {\n      row.push(data.getValue(i, 0));\n    }\n    if (!this.getBooleanOption(\"errorBars\")) {\n      for (j = 0; j < colIdx.length; j++) {\n        var col = colIdx[j];\n        row.push(data.getValue(i, col));\n        if (hasAnnotations && annotationCols.hasOwnProperty(col) && data.getValue(i, annotationCols[col][0]) !== null) {\n          var ann = {};\n          ann.series = data.getColumnLabel(col);\n          ann.xval = row[0];\n          ann.shortText = shortTextForAnnotationNum(annotations.length);\n          ann.text = '';\n          for (var k = 0; k < annotationCols[col].length; k++) {\n            if (k) ann.text += \"\\n\";\n            ann.text += data.getValue(i, annotationCols[col][k]);\n          }\n          annotations.push(ann);\n        }\n      }\n\n      // Strip out infinities, which give dygraphs problems later on.\n      for (j = 0; j < row.length; j++) {\n        if (!isFinite(row[j])) row[j] = null;\n      }\n    } else {\n      for (j = 0; j < cols - 1; j++) {\n        row.push([data.getValue(i, 1 + 2 * j), data.getValue(i, 2 + 2 * j)]);\n      }\n    }\n    if (ret.length > 0 && row[0] < ret[ret.length - 1][0]) {\n      outOfOrder = true;\n    }\n    ret.push(row);\n  }\n\n  if (outOfOrder) {\n    console.warn(\"DataTable is out of order; order it correctly to speed loading.\");\n    ret.sort(function (a, b) {\n      return a[0] - b[0];\n    });\n  }\n  this.rawData_ = ret;\n\n  if (annotations.length > 0) {\n    this.setAnnotations(annotations, true);\n  }\n  this.attributes_.reparseSeries();\n};\n\n/**\n * Signals to plugins that the chart data has updated.\n * This happens after the data has updated but before the chart has redrawn.\n * @private\n */\nDygraph.prototype.cascadeDataDidUpdateEvent_ = function () {\n  // TODO(danvk): there are some issues checking xAxisRange() and using\n  // toDomCoords from handlers of this event. The visible range should be set\n  // when the chart is drawn, not derived from the data.\n  this.cascadeEvents_('dataDidUpdate', {});\n};\n\n/**\n * Get the CSV data. If it's in a function, call that function. If it's in a\n * file, do an XMLHttpRequest to get it.\n * @private\n */\nDygraph.prototype.start_ = function () {\n  var data = this.file_;\n\n  // Functions can return references of all other types.\n  if (typeof data == 'function') {\n    data = data();\n  }\n\n  if (__WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"B\" /* isArrayLike */](data)) {\n    this.rawData_ = this.parseArray_(data);\n    this.cascadeDataDidUpdateEvent_();\n    this.predraw_();\n  } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) == 'object' && typeof data.getColumnRange == 'function') {\n    // must be a DataTable from gviz.\n    this.parseDataTable_(data);\n    this.cascadeDataDidUpdateEvent_();\n    this.predraw_();\n  } else if (typeof data == 'string') {\n    // Heuristic: a newline means it's CSV data. Otherwise it's an URL.\n    var line_delimiter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"y\" /* detectLineDelimiter */](data);\n    if (line_delimiter) {\n      this.loadedEvent_(data);\n    } else {\n      // REMOVE_FOR_IE\n      var req;\n      if (window.XMLHttpRequest) {\n        // Firefox, Opera, IE7, and other browsers will use the native object\n        req = new XMLHttpRequest();\n      } else {\n        // IE 5 and 6 will use the ActiveX control\n        req = new ActiveXObject(\"Microsoft.XMLHTTP\");\n      }\n\n      var caller = this;\n      req.onreadystatechange = function () {\n        if (req.readyState == 4) {\n          if (req.status === 200 || // Normal http\n          req.status === 0) {\n            // Chrome w/ --allow-file-access-from-files\n            caller.loadedEvent_(req.responseText);\n          }\n        }\n      };\n\n      req.open(\"GET\", data, true);\n      req.send(null);\n    }\n  } else {\n    console.error(\"Unknown data format: \" + (typeof data === 'undefined' ? 'undefined' : _typeof(data)));\n  }\n};\n\n/**\n * Changes various properties of the graph. These can include:\n * <ul>\n * <li>file: changes the source data for the graph</li>\n * <li>errorBars: changes whether the data contains stddev</li>\n * </ul>\n *\n * There's a huge variety of options that can be passed to this method. For a\n * full list, see http://dygraphs.com/options.html.\n *\n * @param {Object} input_attrs The new properties and values\n * @param {boolean} block_redraw Usually the chart is redrawn after every\n *     call to updateOptions(). If you know better, you can pass true to\n *     explicitly block the redraw. This can be useful for chaining\n *     updateOptions() calls, avoiding the occasional infinite loop and\n *     preventing redraws when it's not necessary (e.g. when updating a\n *     callback).\n */\nDygraph.prototype.updateOptions = function (input_attrs, block_redraw) {\n  if (typeof block_redraw == 'undefined') block_redraw = false;\n\n  // copyUserAttrs_ drops the \"file\" parameter as a convenience to us.\n  var file = input_attrs.file;\n  var attrs = Dygraph.copyUserAttrs_(input_attrs);\n\n  // TODO(danvk): this is a mess. Move these options into attr_.\n  if ('rollPeriod' in attrs) {\n    this.rollPeriod_ = attrs.rollPeriod;\n  }\n  if ('dateWindow' in attrs) {\n    this.dateWindow_ = attrs.dateWindow;\n  }\n\n  // TODO(danvk): validate per-series options.\n  // Supported:\n  // strokeWidth\n  // pointSize\n  // drawPoints\n  // highlightCircleSize\n\n  // Check if this set options will require new points.\n  var requiresNewPoints = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"E\" /* isPixelChangingOptionList */](this.attr_(\"labels\"), attrs);\n\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"b\" /* updateDeep */](this.user_attrs_, attrs);\n\n  this.attributes_.reparseSeries();\n\n  if (file) {\n    // This event indicates that the data is about to change, but hasn't yet.\n    // TODO(danvk): support cancellation of the update via this event.\n    this.cascadeEvents_('dataWillUpdate', {});\n\n    this.file_ = file;\n    if (!block_redraw) this.start_();\n  } else {\n    if (!block_redraw) {\n      if (requiresNewPoints) {\n        this.predraw_();\n      } else {\n        this.renderGraph_(false);\n      }\n    }\n  }\n};\n\n/**\n * Make a copy of input attributes, removing file as a convenience.\n * @private\n */\nDygraph.copyUserAttrs_ = function (attrs) {\n  var my_attrs = {};\n  for (var k in attrs) {\n    if (!attrs.hasOwnProperty(k)) continue;\n    if (k == 'file') continue;\n    if (attrs.hasOwnProperty(k)) my_attrs[k] = attrs[k];\n  }\n  return my_attrs;\n};\n\n/**\n * Resizes the dygraph. If no parameters are specified, resizes to fill the\n * containing div (which has presumably changed size since the dygraph was\n * instantiated. If the width/height are specified, the div will be resized.\n *\n * This is far more efficient than destroying and re-instantiating a\n * Dygraph, since it doesn't have to reparse the underlying data.\n *\n * @param {number} width Width (in pixels)\n * @param {number} height Height (in pixels)\n */\nDygraph.prototype.resize = function (width, height) {\n  if (this.resize_lock) {\n    return;\n  }\n  this.resize_lock = true;\n\n  if (width === null != (height === null)) {\n    console.warn(\"Dygraph.resize() should be called with zero parameters or \" + \"two non-NULL parameters. Pretending it was zero.\");\n    width = height = null;\n  }\n\n  var old_width = this.width_;\n  var old_height = this.height_;\n\n  if (width) {\n    this.maindiv_.style.width = width + \"px\";\n    this.maindiv_.style.height = height + \"px\";\n    this.width_ = width;\n    this.height_ = height;\n  } else {\n    this.width_ = this.maindiv_.clientWidth;\n    this.height_ = this.maindiv_.clientHeight;\n  }\n\n  if (old_width != this.width_ || old_height != this.height_) {\n    // Resizing a canvas erases it, even when the size doesn't change, so\n    // any resize needs to be followed by a redraw.\n    this.resizeElements_();\n    this.predraw_();\n  }\n\n  this.resize_lock = false;\n};\n\n/**\n * Adjusts the number of points in the rolling average. Updates the graph to\n * reflect the new averaging period.\n * @param {number} length Number of points over which to average the data.\n */\nDygraph.prototype.adjustRoll = function (length) {\n  this.rollPeriod_ = length;\n  this.predraw_();\n};\n\n/**\n * Returns a boolean array of visibility statuses.\n */\nDygraph.prototype.visibility = function () {\n  // Do lazy-initialization, so that this happens after we know the number of\n  // data series.\n  if (!this.getOption(\"visibility\")) {\n    this.attrs_.visibility = [];\n  }\n  // TODO(danvk): it looks like this could go into an infinite loop w/ user_attrs.\n  while (this.getOption(\"visibility\").length < this.numColumns() - 1) {\n    this.attrs_.visibility.push(true);\n  }\n  return this.getOption(\"visibility\");\n};\n\n/**\n * Changes the visibility of one or more series.\n *\n * @param {number|number[]|object} num the series index or an array of series indices\n *                                     or a boolean array of visibility states by index\n *                                     or an object mapping series numbers, as keys, to\n *                                     visibility state (boolean values)\n * @param {boolean} value the visibility state expressed as a boolean\n */\nDygraph.prototype.setVisibility = function (num, value) {\n  var x = this.visibility();\n  var numIsObject = false;\n\n  if (!Array.isArray(num)) {\n    if (num !== null && (typeof num === 'undefined' ? 'undefined' : _typeof(num)) === 'object') {\n      numIsObject = true;\n    } else {\n      num = [num];\n    }\n  }\n\n  if (numIsObject) {\n    for (var i in num) {\n      if (num.hasOwnProperty(i)) {\n        if (i < 0 || i >= x.length) {\n          console.warn(\"Invalid series number in setVisibility: \" + i);\n        } else {\n          x[i] = num[i];\n        }\n      }\n    }\n  } else {\n    for (var i = 0; i < num.length; i++) {\n      if (typeof num[i] === 'boolean') {\n        if (i >= x.length) {\n          console.warn(\"Invalid series number in setVisibility: \" + i);\n        } else {\n          x[i] = num[i];\n        }\n      } else {\n        if (num[i] < 0 || num[i] >= x.length) {\n          console.warn(\"Invalid series number in setVisibility: \" + num[i]);\n        } else {\n          x[num[i]] = value;\n        }\n      }\n    }\n  }\n\n  this.predraw_();\n};\n\n/**\n * How large of an area will the dygraph render itself in?\n * This is used for testing.\n * @return A {width: w, height: h} object.\n * @private\n */\nDygraph.prototype.size = function () {\n  return { width: this.width_, height: this.height_ };\n};\n\n/**\n * Update the list of annotations and redraw the chart.\n * See dygraphs.com/annotations.html for more info on how to use annotations.\n * @param ann {Array} An array of annotation objects.\n * @param suppressDraw {Boolean} Set to \"true\" to block chart redraw (optional).\n */\nDygraph.prototype.setAnnotations = function (ann, suppressDraw) {\n  // Only add the annotation CSS rule once we know it will be used.\n  this.annotations_ = ann;\n  if (!this.layout_) {\n    console.warn(\"Tried to setAnnotations before dygraph was ready. \" + \"Try setting them in a ready() block. See \" + \"dygraphs.com/tests/annotation.html\");\n    return;\n  }\n\n  this.layout_.setAnnotations(this.annotations_);\n  if (!suppressDraw) {\n    this.predraw_();\n  }\n};\n\n/**\n * Return the list of annotations.\n */\nDygraph.prototype.annotations = function () {\n  return this.annotations_;\n};\n\n/**\n * Get the list of label names for this graph. The first column is the\n * x-axis, so the data series names start at index 1.\n *\n * Returns null when labels have not yet been defined.\n */\nDygraph.prototype.getLabels = function () {\n  var labels = this.attr_(\"labels\");\n  return labels ? labels.slice() : null;\n};\n\n/**\n * Get the index of a series (column) given its name. The first column is the\n * x-axis, so the data series start with index 1.\n */\nDygraph.prototype.indexFromSetName = function (name) {\n  return this.setIndexByName_[name];\n};\n\n/**\n * Find the row number corresponding to the given x-value.\n * Returns null if there is no such x-value in the data.\n * If there are multiple rows with the same x-value, this will return the\n * first one.\n * @param {number} xVal The x-value to look for (e.g. millis since epoch).\n * @return {?number} The row number, which you can pass to getValue(), or null.\n */\nDygraph.prototype.getRowForX = function (xVal) {\n  var low = 0,\n      high = this.numRows() - 1;\n\n  while (low <= high) {\n    var idx = high + low >> 1;\n    var x = this.getValue(idx, 0);\n    if (x < xVal) {\n      low = idx + 1;\n    } else if (x > xVal) {\n      high = idx - 1;\n    } else if (low != idx) {\n      // equal, but there may be an earlier match.\n      high = idx;\n    } else {\n      return idx;\n    }\n  }\n\n  return null;\n};\n\n/**\n * Trigger a callback when the dygraph has drawn itself and is ready to be\n * manipulated. This is primarily useful when dygraphs has to do an XHR for the\n * data (i.e. a URL is passed as the data source) and the chart is drawn\n * asynchronously. If the chart has already drawn, the callback will fire\n * immediately.\n *\n * This is a good place to call setAnnotation().\n *\n * @param {function(!Dygraph)} callback The callback to trigger when the chart\n *     is ready.\n */\nDygraph.prototype.ready = function (callback) {\n  if (this.is_initial_draw_) {\n    this.readyFns_.push(callback);\n  } else {\n    callback.call(this, this);\n  }\n};\n\n/**\n * Add an event handler. This event handler is kept until the graph is\n * destroyed with a call to graph.destroy().\n *\n * @param {!Node} elem The element to add the event to.\n * @param {string} type The type of the event, e.g. 'click' or 'mousemove'.\n * @param {function(Event):(boolean|undefined)} fn The function to call\n *     on the event. The function takes one parameter: the event object.\n * @private\n */\nDygraph.prototype.addAndTrackEvent = function (elem, type, fn) {\n  __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"F\" /* addEvent */](elem, type, fn);\n  this.registeredEvents_.push({ elem: elem, type: type, fn: fn });\n};\n\nDygraph.prototype.removeTrackedEvents_ = function () {\n  if (this.registeredEvents_) {\n    for (var idx = 0; idx < this.registeredEvents_.length; idx++) {\n      var reg = this.registeredEvents_[idx];\n      __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"i\" /* removeEvent */](reg.elem, reg.type, reg.fn);\n    }\n  }\n\n  this.registeredEvents_ = [];\n};\n\n// Installed plugins, in order of precedence (most-general to most-specific).\nDygraph.PLUGINS = [__WEBPACK_IMPORTED_MODULE_19__plugins_legend__[\"a\" /* default */], __WEBPACK_IMPORTED_MODULE_16__plugins_axes__[\"a\" /* default */], __WEBPACK_IMPORTED_MODULE_20__plugins_range_selector__[\"a\" /* default */], // Has to be before ChartLabels so that its callbacks are called after ChartLabels' callbacks.\n__WEBPACK_IMPORTED_MODULE_17__plugins_chart_labels__[\"a\" /* default */], __WEBPACK_IMPORTED_MODULE_15__plugins_annotations__[\"a\" /* default */], __WEBPACK_IMPORTED_MODULE_18__plugins_grid__[\"a\" /* default */]];\n\n// There are many symbols which have historically been available through the\n// Dygraph class. These are exported here for backwards compatibility.\nDygraph.GVizChart = __WEBPACK_IMPORTED_MODULE_21__dygraph_gviz__[\"a\" /* default */];\nDygraph.DASHED_LINE = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"G\" /* DASHED_LINE */];\nDygraph.DOT_DASH_LINE = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"H\" /* DOT_DASH_LINE */];\nDygraph.dateAxisLabelFormatter = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"x\" /* dateAxisLabelFormatter */];\nDygraph.toRGB_ = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"t\" /* toRGB_ */];\nDygraph.findPos = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"k\" /* findPos */];\nDygraph.pageX = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"q\" /* pageX */];\nDygraph.pageY = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"r\" /* pageY */];\nDygraph.dateString_ = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"I\" /* dateString_ */];\nDygraph.defaultInteractionModel = __WEBPACK_IMPORTED_MODULE_3__dygraph_interaction_model__[\"a\" /* default */].defaultModel;\nDygraph.nonInteractiveModel = Dygraph.nonInteractiveModel_ = __WEBPACK_IMPORTED_MODULE_3__dygraph_interaction_model__[\"a\" /* default */].nonInteractiveModel_;\nDygraph.Circles = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"u\" /* Circles */];\n\nDygraph.Plugins = {\n  Legend: __WEBPACK_IMPORTED_MODULE_19__plugins_legend__[\"a\" /* default */],\n  Axes: __WEBPACK_IMPORTED_MODULE_16__plugins_axes__[\"a\" /* default */],\n  Annotations: __WEBPACK_IMPORTED_MODULE_15__plugins_annotations__[\"a\" /* default */],\n  ChartLabels: __WEBPACK_IMPORTED_MODULE_17__plugins_chart_labels__[\"a\" /* default */],\n  Grid: __WEBPACK_IMPORTED_MODULE_18__plugins_grid__[\"a\" /* default */],\n  RangeSelector: __WEBPACK_IMPORTED_MODULE_20__plugins_range_selector__[\"a\" /* default */]\n};\n\nDygraph.DataHandlers = {\n  DefaultHandler: __WEBPACK_IMPORTED_MODULE_9__datahandler_default__[\"a\" /* default */],\n  BarsHandler: __WEBPACK_IMPORTED_MODULE_14__datahandler_bars__[\"a\" /* default */],\n  CustomBarsHandler: __WEBPACK_IMPORTED_MODULE_11__datahandler_bars_custom__[\"a\" /* default */],\n  DefaultFractionHandler: __WEBPACK_IMPORTED_MODULE_12__datahandler_default_fractions__[\"a\" /* default */],\n  ErrorBarsHandler: __WEBPACK_IMPORTED_MODULE_10__datahandler_bars_error__[\"a\" /* default */],\n  FractionsBarsHandler: __WEBPACK_IMPORTED_MODULE_13__datahandler_bars_fractions__[\"a\" /* default */]\n};\n\nDygraph.startPan = __WEBPACK_IMPORTED_MODULE_3__dygraph_interaction_model__[\"a\" /* default */].startPan;\nDygraph.startZoom = __WEBPACK_IMPORTED_MODULE_3__dygraph_interaction_model__[\"a\" /* default */].startZoom;\nDygraph.movePan = __WEBPACK_IMPORTED_MODULE_3__dygraph_interaction_model__[\"a\" /* default */].movePan;\nDygraph.moveZoom = __WEBPACK_IMPORTED_MODULE_3__dygraph_interaction_model__[\"a\" /* default */].moveZoom;\nDygraph.endPan = __WEBPACK_IMPORTED_MODULE_3__dygraph_interaction_model__[\"a\" /* default */].endPan;\nDygraph.endZoom = __WEBPACK_IMPORTED_MODULE_3__dygraph_interaction_model__[\"a\" /* default */].endZoom;\n\nDygraph.numericLinearTicks = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"c\" /* numericLinearTicks */];\nDygraph.numericTicks = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"b\" /* numericTicks */];\nDygraph.dateTicker = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"a\" /* dateTicker */];\nDygraph.Granularity = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"d\" /* Granularity */];\nDygraph.getDateAxis = __WEBPACK_IMPORTED_MODULE_4__dygraph_tickers__[\"e\" /* getDateAxis */];\nDygraph.floatFormat = __WEBPACK_IMPORTED_MODULE_5__dygraph_utils__[\"J\" /* floatFormat */];\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Dygraph);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(14)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLmpzP2I0MDgiXSwibmFtZXMiOlsiRHlncmFwaCIsImRpdiIsImRhdGEiLCJvcHRzIiwiX19pbml0X18iLCJOQU1FIiwiVkVSU0lPTiIsIkRFRkFVTFRfUk9MTF9QRVJJT0QiLCJERUZBVUxUX1dJRFRIIiwiREVGQVVMVF9IRUlHSFQiLCJBTklNQVRJT05fU1RFUFMiLCJBTklNQVRJT05fRFVSQVRJT04iLCJQbG90dGVycyIsIkR5Z3JhcGhDYW52YXNSZW5kZXJlciIsIl9QbG90dGVycyIsImFkZGVkQW5ub3RhdGlvbkNTUyIsInByb3RvdHlwZSIsImZpbGUiLCJhdHRycyIsImlzX2luaXRpYWxfZHJhd18iLCJyZWFkeUZuc18iLCJ1bmRlZmluZWQiLCJjb3B5VXNlckF0dHJzXyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJFcnJvciIsIm1haW5kaXZfIiwiZmlsZV8iLCJyb2xsUGVyaW9kXyIsInJvbGxQZXJpb2QiLCJwcmV2aW91c1ZlcnRpY2FsWF8iLCJmcmFjdGlvbnNfIiwiZnJhY3Rpb25zIiwiZGF0ZVdpbmRvd18iLCJkYXRlV2luZG93IiwiYW5ub3RhdGlvbnNfIiwiaW5uZXJIVE1MIiwic3R5bGUiLCJ3aWR0aCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsIndpZHRoXyIsImNsaWVudFdpZHRoIiwiaGVpZ2h0XyIsInN0YWNrZWRHcmFwaCIsImZpbGxHcmFwaCIsInVzZXJfYXR0cnNfIiwidXRpbHMiLCJhdHRyc18iLCJib3VuZGFyeUlkc18iLCJzZXRJbmRleEJ5TmFtZV8iLCJkYXRhc2V0SW5kZXhfIiwicmVnaXN0ZXJlZEV2ZW50c18iLCJldmVudExpc3RlbmVyc18iLCJhdHRyaWJ1dGVzXyIsImNyZWF0ZUludGVyZmFjZV8iLCJwbHVnaW5zXyIsInBsdWdpbnMiLCJQTFVHSU5TIiwiY29uY2F0IiwiZ2V0T3B0aW9uIiwiaSIsImxlbmd0aCIsIlBsdWdpbiIsInBsdWdpbkluc3RhbmNlIiwiYWN0aXZhdGUiLCJwbHVnaW5EaWN0IiwicGx1Z2luIiwiZXZlbnRzIiwib3B0aW9ucyIsInBsdWdpbk9wdGlvbnMiLCJoYW5kbGVycyIsImV2ZW50TmFtZSIsImhhc093blByb3BlcnR5IiwicHVzaCIsInBsdWdpbl9kaWN0IiwiY2FsbGJhY2siLCJwYWlyIiwiY3JlYXRlRHJhZ0ludGVyZmFjZV8iLCJzdGFydF8iLCJjYXNjYWRlRXZlbnRzXyIsIm5hbWUiLCJleHRyYV9wcm9wcyIsImUiLCJkeWdyYXBoIiwiY2FuY2VsYWJsZSIsImRlZmF1bHRQcmV2ZW50ZWQiLCJwcmV2ZW50RGVmYXVsdCIsInByb3BhZ2F0aW9uU3RvcHBlZCIsInN0b3BQcm9wYWdhdGlvbiIsImNhbGxiYWNrX3BsdWdpbl9wYWlycyIsImNhbGwiLCJnZXRQbHVnaW5JbnN0YW5jZV8iLCJ0eXBlIiwicCIsImlzWm9vbWVkIiwiYXhpcyIsImlzWm9vbWVkWCIsImlzWm9vbWVkWSIsImF4ZXNfIiwibWFwIiwidmFsdWVSYW5nZSIsImluZGV4T2YiLCJ0b1N0cmluZyIsIm1haW5kaXYiLCJpZCIsImF0dHJfIiwic2VyaWVzTmFtZSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImNvbnNvbGUiLCJlcnJvciIsIk9QVElPTlNfUkVGRVJFTkNFIiwiZ2V0Rm9yU2VyaWVzIiwiZ2V0Iiwib3B0X3Nlcmllc05hbWUiLCJnZXROdW1lcmljT3B0aW9uIiwiZ2V0U3RyaW5nT3B0aW9uIiwiZ2V0Qm9vbGVhbk9wdGlvbiIsImdldEZ1bmN0aW9uT3B0aW9uIiwiZ2V0T3B0aW9uRm9yQXhpcyIsImdldEZvckF4aXMiLCJvcHRpb25zVmlld0ZvckF4aXNfIiwic2VsZiIsIm9wdCIsImF4aXNfb3B0cyIsImF4ZXMiLCJ4QXhpc1JhbmdlIiwieEF4aXNFeHRyZW1lcyIsInBhZCIsInBsb3R0ZXJfIiwiYXJlYSIsInciLCJudW1Sb3dzIiwibGVmdCIsInJhd0RhdGFfIiwicmlnaHQiLCJyYW5nZSIsInlBeGlzRXh0cmVtZXMiLCJwYWNrZWQiLCJnYXRoZXJEYXRhc2V0c18iLCJyb2xsZWRTZXJpZXNfIiwiZXh0cmVtZXMiLCJzYXZlQXhlcyIsImNvbXB1dGVZQXhpc1Jhbmdlc18iLCJuZXdBeGVzIiwiZXh0cmVtZVJhbmdlIiwieUF4aXNSYW5nZSIsImlkeCIsImNvbXB1dGVkVmFsdWVSYW5nZSIsInlBeGlzUmFuZ2VzIiwicmV0IiwidG9Eb21Db29yZHMiLCJ4IiwieSIsInRvRG9tWENvb3JkIiwidG9Eb21ZQ29vcmQiLCJ4UmFuZ2UiLCJwY3QiLCJ0b1BlcmNlbnRZQ29vcmQiLCJoIiwidG9EYXRhQ29vcmRzIiwidG9EYXRhWENvb3JkIiwidG9EYXRhWUNvb3JkIiwieVJhbmdlIiwibG9nc2NhbGUiLCJsb2dyMCIsImxvZ3IxIiwidG9QZXJjZW50WENvb3JkIiwibnVtQ29sdW1ucyIsImdldFZhbHVlIiwicm93IiwiY29sIiwiZW5jbG9zaW5nIiwiZ3JhcGhEaXYiLCJjcmVhdGVFbGVtZW50IiwidGV4dEFsaWduIiwicG9zaXRpb24iLCJhcHBlbmRDaGlsZCIsImNhbnZhc18iLCJoaWRkZW5fIiwiY3JlYXRlUGxvdEtpdENhbnZhc18iLCJjYW52YXNfY3R4XyIsImhpZGRlbl9jdHhfIiwicmVzaXplRWxlbWVudHNfIiwibW91c2VFdmVudEVsZW1lbnRfIiwiY3JlYXRlTW91c2VFdmVudEVsZW1lbnRfIiwibGF5b3V0XyIsIm1vdXNlTW92ZUhhbmRsZXJfIiwibW91c2VNb3ZlXyIsIm1vdXNlT3V0SGFuZGxlcl8iLCJ0YXJnZXQiLCJmcm9tRWxlbWVudCIsInJlbGF0ZWRUYXJnZXQiLCJ0b0VsZW1lbnQiLCJtb3VzZU91dF8iLCJhZGRBbmRUcmFja0V2ZW50Iiwid2luZG93IiwicmVzaXplSGFuZGxlcl8iLCJyZXNpemUiLCJwaXhlbFJhdGlvT3B0aW9uIiwiY2FudmFzU2NhbGUiLCJzY2FsZSIsImhpZGRlblNjYWxlIiwiZGVzdHJveSIsInJlc3RvcmUiLCJwb3AiLCJyZW1vdmVSZWN1cnNpdmUiLCJub2RlIiwiaGFzQ2hpbGROb2RlcyIsImZpcnN0Q2hpbGQiLCJyZW1vdmVDaGlsZCIsInJlbW92ZVRyYWNrZWRFdmVudHNfIiwibnVsbE91dCIsIm9iaiIsIm4iLCJjYW52YXMiLCJ0b3AiLCJzZXRDb2xvcnNfIiwibGFiZWxzIiwiZ2V0TGFiZWxzIiwibnVtIiwiY29sb3JzXyIsImNvbG9yc01hcF8iLCJzYXQiLCJ2YWwiLCJoYWxmIiwiTWF0aCIsImNlaWwiLCJjb2xvcnMiLCJ2aXNpYmlsaXR5IiwibGFiZWwiLCJjb2xvclN0ciIsImh1ZSIsImdldENvbG9ycyIsImdldFByb3BlcnRpZXNGb3JTZXJpZXMiLCJzZXJpZXNfbmFtZSIsImNvbHVtbiIsInZpc2libGUiLCJjb2xvciIsImF4aXNGb3JTZXJpZXMiLCJjcmVhdGVSb2xsSW50ZXJmYWNlXyIsInJvbGxlciIsInJvbGxlcl8iLCJkaXNwbGF5IiwiY2xhc3NOYW1lIiwiZ2V0QXJlYSIsInRleHRBdHRyIiwic2l6ZSIsInZhbHVlIiwib25jaGFuZ2UiLCJhZGp1c3RSb2xsIiwiY29udGV4dCIsImlzWm9vbWluZyIsImlzUGFubmluZyIsImlzMkRQYW4iLCJkcmFnU3RhcnRYIiwiZHJhZ1N0YXJ0WSIsImRyYWdFbmRYIiwiZHJhZ0VuZFkiLCJkcmFnRGlyZWN0aW9uIiwicHJldkVuZFgiLCJwcmV2RW5kWSIsInByZXZEcmFnRGlyZWN0aW9uIiwiY2FuY2VsTmV4dERibGNsaWNrIiwiaW5pdGlhbExlZnRtb3N0RGF0ZSIsInhVbml0c1BlclBpeGVsIiwiZGF0ZVJhbmdlIiwicHgiLCJweSIsImJvdW5kZWREYXRlcyIsImJvdW5kZWRWYWx1ZXMiLCJ0YXJwIiwiaW5pdGlhbGl6ZU1vdXNlRG93biIsImV2ZW50IiwiZyIsImNvbnRleHRCIiwicmV0dXJuVmFsdWUiLCJjYW5jZWxCdWJibGUiLCJjYW52YXNQb3MiLCJjb3ZlciIsImRyYWdnaW5nRGF0ZSIsImRyYWdnaW5nVmFsdWUiLCJkcmFnVmFsdWVSYW5nZSIsInVuY292ZXIiLCJpbnRlcmFjdGlvbk1vZGVsIiwiYmluZEhhbmRsZXIiLCJoYW5kbGVyIiwid2lsbERlc3Ryb3lDb250ZXh0TXlzZWxmIiwibW91c2VVcEhhbmRsZXIiLCJkcmF3Wm9vbVJlY3RfIiwiZGlyZWN0aW9uIiwic3RhcnRYIiwiZW5kWCIsInN0YXJ0WSIsImVuZFkiLCJwcmV2RGlyZWN0aW9uIiwiY3R4IiwiY2xlYXJSZWN0IiwibWluIiwiZ2V0UGxvdEFyZWEiLCJhYnMiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImNsZWFyWm9vbVJlY3RfIiwiY3VycmVudFpvb21SZWN0QXJnc18iLCJkb1pvb21YXyIsImxvd1giLCJoaWdoWCIsIm1pbkRhdGUiLCJtYXhEYXRlIiwiZG9ab29tWERhdGVzXyIsIm9sZF93aW5kb3ciLCJuZXdfd2luZG93Iiwiem9vbUNhbGxiYWNrIiwiZG9BbmltYXRlZFpvb20iLCJkb1pvb21ZXyIsImxvd1kiLCJoaWdoWSIsIm9sZFZhbHVlUmFuZ2VzIiwibmV3VmFsdWVSYW5nZXMiLCJoaSIsImxvdyIsIm1pblgiLCJtYXhYIiwiem9vbUFuaW1hdGlvbkZ1bmN0aW9uIiwiZnJhbWUiLCJudW1GcmFtZXMiLCJrIiwicG93IiwicmVzZXRab29tIiwiZGlydHlYIiwiZGlydHlZIiwiZGlydHkiLCJjbGVhclNlbGVjdGlvbiIsImFuaW1hdGVkWm9vbXMiLCJmb3JFYWNoIiwiZHJhd0dyYXBoXyIsIm9sZFdpbmRvdyIsIm5ld1dpbmRvdyIsIm9sZFhSYW5nZSIsIm5ld1hSYW5nZSIsIm9sZFlSYW5nZXMiLCJuZXdZUmFuZ2VzIiwic3RlcHMiLCJ3aW5kb3dzIiwidmFsdWVSYW5nZXMiLCJzdGVwIiwiZnJhYyIsInRoaXNSYW5nZSIsImoiLCJldmVudFRvRG9tQ29vcmRzIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJldmVudEVsZW1lbnRQb3MiLCJjYW52YXN4IiwiY2FudmFzeSIsImZpbmRDbG9zZXN0Um93IiwiZG9tWCIsIm1pbkRpc3RYIiwiSW5maW5pdHkiLCJjbG9zZXN0Um93Iiwic2V0cyIsInBvaW50cyIsImxlbiIsInBvaW50IiwiZGlzdCIsImZpbmRDbG9zZXN0UG9pbnQiLCJkb21ZIiwibWluRGlzdCIsImR4IiwiZHkiLCJjbG9zZXN0UG9pbnQiLCJjbG9zZXN0U2VyaWVzIiwic2V0SWR4Iiwic2V0TmFtZXMiLCJmaW5kU3RhY2tlZFBvaW50IiwiYm91bmRhcnkiLCJnZXRMZWZ0Qm91bmRhcnlfIiwicm93SWR4IiwicDEiLCJwMiIsInIiLCJwMCIsImNhbnZhc0Nvb3JkcyIsImhpZ2hsaWdodFNlcmllc09wdHMiLCJzZWxlY3Rpb25DaGFuZ2VkIiwiaXNTZXJpZXNMb2NrZWQiLCJjbG9zZXN0Iiwic2V0U2VsZWN0aW9uIiwibGFzdHhfIiwic2VsUG9pbnRzXyIsImxhc3RSb3dfIiwiaGlnaGxpZ2h0U2V0XyIsImFuaW1hdGVTZWxlY3Rpb25fIiwidG90YWxTdGVwcyIsIm1pbGxpcyIsImZhZGVMZXZlbCIsImFuaW1hdGVJZCIsInN0YXJ0IiwidXBkYXRlU2VsZWN0aW9uXyIsInRoaXNJZCIsInRoYXQiLCJjbGVhbnVwSWZDbGVhcmluZyIsIm9wdF9hbmltRnJhY3Rpb24iLCJzZWxlY3RlZFJvdyIsInNlbGVjdGVkWCIsInNlbGVjdGVkUG9pbnRzIiwiYWxwaGEiLCJiYWNrZ3JvdW5kQ29sb3IiLCJhbmltYXRlQmFja2dyb3VuZEZhZGUiLCJiIiwiX3JlbmRlckxpbmVDaGFydCIsIm1heENpcmNsZVNpemUiLCJzYXZlIiwicHQiLCJpc05hTiIsImNpcmNsZVNpemUiLCJERUZBVUxUIiwibGluZVdpZHRoIiwic3Ryb2tlU3R5bGUiLCJvcHRfbG9ja2VkIiwiY2hhbmdlZCIsInNldFJvdyIsInl2YWwiLCJwb2ludElkeCIsInh2YWwiLCJsb2NrZWRTZXRfIiwiZ2V0U2VsZWN0aW9uIiwiZ2V0SGlnaGxpZ2h0U2VyaWVzIiwibG9hZGVkRXZlbnRfIiwicGFyc2VDU1ZfIiwiY2FzY2FkZURhdGFEaWRVcGRhdGVFdmVudF8iLCJwcmVkcmF3XyIsImFkZFhUaWNrc18iLCJ4QXhpc09wdGlvbnNWaWV3IiwieFRpY2tzIiwic2V0WFRpY2tzIiwiZ2V0SGFuZGxlckNsYXNzXyIsImhhbmRsZXJDbGFzcyIsIkRhdGUiLCJkYXRhSGFuZGxlcl8iLCJjb21wdXRlUGxvdEFyZWEiLCJjb21wdXRlWUF4ZXNfIiwic2VyaWVzIiwiZXh0cmFjdFNlcmllcyIsInJvbGxpbmdBdmVyYWdlIiwiZW5kIiwiZHJhd2luZ1RpbWVNc18iLCJQb2ludFR5cGUiLCJzdGFja1BvaW50c18iLCJjdW11bGF0aXZlWXZhbCIsInNlcmllc0V4dHJlbWVzIiwiZmlsbE1ldGhvZCIsImxhc3RYdmFsIiwicHJldlBvaW50IiwibmV4dFBvaW50IiwibmV4dFBvaW50SWR4IiwidXBkYXRlTmV4dFBvaW50IiwiYWN0dWFsWXZhbCIsInN0YWNrZWRZdmFsIiwieXZhbF9zdGFja2VkIiwicm9sbGVkU2VyaWVzIiwiYm91bmRhcnlJZHMiLCJzZXJpZXNJZHgiLCJzYW1wbGVJZHgiLCJmaXJzdElkeCIsImxhc3RJZHgiLCJheGlzSWR4IiwibnVtX3NlcmllcyIsImhpZ2giLCJjb3JyZWN0ZWRGaXJzdElkeCIsImlzSW52YWxpZFZhbHVlIiwiY29ycmVjdGVkTGFzdElkeCIsInNsaWNlIiwiZ2V0RXh0cmVtZVlWYWx1ZXMiLCJzZXJpZXNQb2ludHMiLCJzZXJpZXNUb1BvaW50cyIsImlzX2luaXRpYWxfZHJhdyIsInJlbW92ZUFsbERhdGFzZXRzIiwicG9pbnRTaXplIiwiZGF0YUlkeCIsImFkZERhdGFzZXQiLCJzZXRZQXhlcyIsImV2YWx1YXRlIiwicmVuZGVyR3JhcGhfIiwibG9nIiwiY2xlYXIiLCJ1bmRlcmxheUNhbGxiYWNrIiwiZHJhd2luZ0NvbnRleHQiLCJyZW5kZXIiLCJnZXRDb250ZXh0IiwiZHJhd0NhbGxiYWNrIiwicmVhZHlGaXJlZF8iLCJmbiIsImluZGV4IiwidiIsIm51bUF4ZXMiLCJheGlzT3B0aW9ucyIsInkyIiwiYXhpc1Byb3BlcnRpZXNGb3JTZXJpZXMiLCJpc051bGxVbmRlZmluZWRPck5hTiIsInBhcnNlRmxvYXQiLCJ5cGFkQ29tcGF0Iiwic3BhbiIsInlwYWQiLCJwX2F4aXMiLCJpbmNsdWRlWmVybyIsImluZGVwZW5kZW50VGlja3MiLCJzZXJpZXNGb3JBeGlzIiwieVJhbmdlUGFkIiwibWluWSIsIm1heFkiLCJleHRyZW1lTWluWSIsImV4dHJlbWVNYXhZIiwibWF4IiwibWF4QXhpc1kiLCJtaW5BeGlzWSIsInkwIiwieTEiLCJ5MHBjdCIsInkxcGN0IiwidGlja2VyIiwidGlja3MiLCJwX3RpY2tzIiwicF9zY2FsZSIsInRpY2tfdmFsdWVzIiwieV9mcmFjIiwieV92YWwiLCJkZXRlY3RUeXBlRnJvbVN0cmluZ18iLCJzdHIiLCJpc0RhdGUiLCJkYXNoUG9zIiwic2V0WEF4aXNPcHRpb25zXyIsInhWYWx1ZVBhcnNlciIsInZhbHVlRm9ybWF0dGVyIiwiYXhpc0xhYmVsRm9ybWF0dGVyIiwibGluZV9kZWxpbWl0ZXIiLCJsaW5lcyIsInNwbGl0IiwidmFscyIsImRlbGltIiwicmVwYXJzZVNlcmllcyIsImxpbmVfbm8iLCJ4UGFyc2VyIiwiZGVmYXVsdFBhcnNlclNldCIsImV4cGVjdGVkQ29scyIsIm91dE9mT3JkZXIiLCJsaW5lIiwiaW5GaWVsZHMiLCJmaWVsZHMiLCJ0ZXN0Iiwid2FybiIsImFsbF9udWxsIiwic29ydCIsImEiLCJ2YWxpZGF0ZU5hdGl2ZUZvcm1hdCIsImZpcnN0Um93IiwiZmlyc3RYIiwicGFyc2VBcnJheV8iLCJudW1fbGFiZWxzIiwicGFyc2VkRGF0YSIsImdldFRpbWUiLCJwYXJzZURhdGFUYWJsZV8iLCJzaG9ydFRleHRGb3JBbm5vdGF0aW9uTnVtIiwic2hvcnRUZXh0IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZmxvb3IiLCJ0b0xvd2VyQ2FzZSIsImNvbHMiLCJnZXROdW1iZXJPZkNvbHVtbnMiLCJyb3dzIiwiZ2V0TnVtYmVyT2ZSb3dzIiwiaW5kZXBUeXBlIiwiZ2V0Q29sdW1uVHlwZSIsImNvbElkeCIsImFubm90YXRpb25Db2xzIiwiaGFzQW5ub3RhdGlvbnMiLCJnZXRDb2x1bW5MYWJlbCIsImFubm90YXRpb25zIiwiYW5uIiwidGV4dCIsImlzRmluaXRlIiwic2V0QW5ub3RhdGlvbnMiLCJnZXRDb2x1bW5SYW5nZSIsInJlcSIsIlhNTEh0dHBSZXF1ZXN0IiwiQWN0aXZlWE9iamVjdCIsImNhbGxlciIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJzdGF0dXMiLCJyZXNwb25zZVRleHQiLCJvcGVuIiwic2VuZCIsInVwZGF0ZU9wdGlvbnMiLCJpbnB1dF9hdHRycyIsImJsb2NrX3JlZHJhdyIsInJlcXVpcmVzTmV3UG9pbnRzIiwibXlfYXR0cnMiLCJyZXNpemVfbG9jayIsIm9sZF93aWR0aCIsIm9sZF9oZWlnaHQiLCJzZXRWaXNpYmlsaXR5IiwibnVtSXNPYmplY3QiLCJBcnJheSIsImlzQXJyYXkiLCJzdXBwcmVzc0RyYXciLCJpbmRleEZyb21TZXROYW1lIiwiZ2V0Um93Rm9yWCIsInhWYWwiLCJyZWFkeSIsImVsZW0iLCJyZWciLCJHVml6Q2hhcnQiLCJEQVNIRURfTElORSIsIkRPVF9EQVNIX0xJTkUiLCJkYXRlQXhpc0xhYmVsRm9ybWF0dGVyIiwidG9SR0JfIiwiZmluZFBvcyIsInBhZ2VYIiwicGFnZVkiLCJkYXRlU3RyaW5nXyIsImRlZmF1bHRJbnRlcmFjdGlvbk1vZGVsIiwiRHlncmFwaEludGVyYWN0aW9uIiwiZGVmYXVsdE1vZGVsIiwibm9uSW50ZXJhY3RpdmVNb2RlbCIsIm5vbkludGVyYWN0aXZlTW9kZWxfIiwiQ2lyY2xlcyIsIlBsdWdpbnMiLCJMZWdlbmQiLCJBeGVzIiwiQW5ub3RhdGlvbnMiLCJDaGFydExhYmVscyIsIkdyaWQiLCJSYW5nZVNlbGVjdG9yIiwiUmFuZ2VTZWxlY3RvclBsdWdpbiIsIkRhdGFIYW5kbGVycyIsIkRlZmF1bHRIYW5kbGVyIiwiQmFyc0hhbmRsZXIiLCJDdXN0b21CYXJzSGFuZGxlciIsIkRlZmF1bHRGcmFjdGlvbkhhbmRsZXIiLCJFcnJvckJhcnNIYW5kbGVyIiwiRnJhY3Rpb25zQmFyc0hhbmRsZXIiLCJzdGFydFBhbiIsInN0YXJ0Wm9vbSIsIm1vdmVQYW4iLCJtb3ZlWm9vbSIsImVuZFBhbiIsImVuZFpvb20iLCJudW1lcmljTGluZWFyVGlja3MiLCJudW1lcmljVGlja3MiLCJkYXRlVGlja2VyIiwiR3JhbnVsYXJpdHkiLCJnZXREYXRlQXhpcyIsImZsb2F0Rm9ybWF0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7QUFNQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBY0EsSUFBSUEsVUFBVSxTQUFWQSxPQUFVLENBQVNDLEdBQVQsRUFBY0MsSUFBZCxFQUFvQkMsSUFBcEIsRUFBMEI7QUFDdEMsT0FBS0MsUUFBTCxDQUFjSCxHQUFkLEVBQW1CQyxJQUFuQixFQUF5QkMsSUFBekI7QUFDRCxDQUZEOztBQUlBSCxRQUFRSyxJQUFSLEdBQWUsU0FBZjtBQUNBTCxRQUFRTSxPQUFSLEdBQWtCLE9BQWxCOztBQUVBO0FBQ0FOLFFBQVFPLG1CQUFSLEdBQThCLENBQTlCO0FBQ0FQLFFBQVFRLGFBQVIsR0FBd0IsR0FBeEI7QUFDQVIsUUFBUVMsY0FBUixHQUF5QixHQUF6Qjs7QUFFQTtBQUNBVCxRQUFRVSxlQUFSLEdBQTBCLEVBQTFCO0FBQ0FWLFFBQVFXLGtCQUFSLEdBQTZCLEdBQTdCOztBQUVBOzs7Ozs7Ozs7O0FBVUFYLFFBQVFZLFFBQVIsR0FBbUIsZ0VBQUFDLENBQXNCQyxTQUF6Qzs7QUFHQTtBQUNBZCxRQUFRZSxrQkFBUixHQUE2QixLQUE3Qjs7QUFFQTs7Ozs7Ozs7O0FBU0FmLFFBQVFnQixTQUFSLENBQWtCWixRQUFsQixHQUE2QixVQUFTSCxHQUFULEVBQWNnQixJQUFkLEVBQW9CQyxL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YSx1RUFKRztBQUtoQkMsUUFBTSwrREFMVTtBQU1oQkMsaUJBQWUseUVBQUFDO0FBTkMsQ0FBbEI7O0FBU0E5bkIsUUFBUStuQixZQUFSLEdBQXVCO0FBQ3JCQyxrQkFBQSxxRUFEcUI7QUFFckJDLGVBQUEsbUVBRnFCO0FBR3JCQyxxQkFBQSwwRUFIcUI7QUFJckJDLDBCQUFBLGdGQUpxQjtBQUtyQkMsb0JBQUEseUVBTHFCO0FBTXJCQyx3QkFBQSw2RUFBQUE7QUFOcUIsQ0FBdkI7O0FBU0Fyb0IsUUFBUXNvQixRQUFSLEdBQW1CLDJFQUFBcEIsQ0FBbUJvQixRQUF0QztBQUNBdG9CLFFBQVF1b0IsU0FBUixHQUFvQiwyRUFBQXJCLENBQW1CcUIsU0FBdkM7QUFDQXZvQixRQUFRd29CLE9BQVIsR0FBa0IsMkVBQUF0QixDQUFtQnNCLE9BQXJDO0FBQ0F4b0IsUUFBUXlvQixRQUFSLEdBQW1CLDJFQUFBdkIsQ0FBbUJ1QixRQUF0QztBQUNBem9CLFFBQVEwb0IsTUFBUixHQUFpQiwyRUFBQXhCLENBQW1Cd0IsTUFBcEM7QUFDQTFvQixRQUFRMm9CLE9BQVIsR0FBa0IsMkVBQUF6QixDQUFtQnlCLE9BQXJDOztBQUVBM29CLFFBQVE0b0Isa0JBQVIsR0FBNkIsNEVBQTdCO0FBQ0E1b0IsUUFBUTZvQixZQUFSLEdBQXVCLHNFQUF2QjtBQUNBN29CLFFBQVE4b0IsVUFBUixHQUFxQixvRUFBckI7QUFDQTlvQixRQUFRK29CLFdBQVIsR0FBc0IscUVBQXRCO0FBQ0Evb0IsUUFBUWdwQixXQUFSLEdBQXNCLHFFQUF0QjtBQUNBaHBCLFFBQVFpcEIsV0FBUixHQUFzQixtRUFBdEI7O0FBRUEseURBQWVqcEIsT0FBZixFIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMDYgRGFuIFZhbmRlcmthbSAoZGFudmRrQGdtYWlsLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ3JlYXRlcyBhbiBpbnRlcmFjdGl2ZSwgem9vbWFibGUgZ3JhcGggYmFzZWQgb24gYSBDU1YgZmlsZSBvclxuICogc3RyaW5nLiBEeWdyYXBoIGNhbiBoYW5kbGUgbXVsdGlwbGUgc2VyaWVzIHdpdGggb3Igd2l0aG91dCBlcnJvciBiYXJzLiBUaGVcbiAqIGRhdGUvdmFsdWUgcmFuZ2VzIHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQuIER5Z3JhcGggdXNlcyB0aGVcbiAqICZsdDtjYW52YXMmZ3Q7IHRhZywgc28gaXQgb25seSB3b3JrcyBpbiBGRjEuNSsuXG4gKiBAYXV0aG9yIGRhbnZka0BnbWFpbC5jb20gKERhbiBWYW5kZXJrYW0pXG5cbiAgVXNhZ2U6XG4gICA8ZGl2IGlkPVwiZ3JhcGhkaXZcIiBzdHlsZT1cIndpZHRoOjgwMHB4OyBoZWlnaHQ6NTAwcHg7XCI+PC9kaXY+XG4gICA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIj5cbiAgICAgbmV3IER5Z3JhcGgoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJncmFwaGRpdlwiKSxcbiAgICAgICAgICAgICAgICAgXCJkYXRhZmlsZS5jc3ZcIiwgIC8vIENTViBmaWxlIHdpdGggaGVhZGVyc1xuICAgICAgICAgICAgICAgICB7IH0pOyAvLyBvcHRpb25zXG4gICA8L3NjcmlwdD5cblxuIFRoZSBDU1YgZmlsZSBpcyBvZiB0aGUgZm9ybVxuXG4gICBEYXRlLFNlcmllc0EsU2VyaWVzQixTZXJpZXNDXG4gICBZWVlZTU1ERCxBMSxCMSxDMVxuICAgWVlZWU1NREQsQTIsQjIsQzJcblxuIElmIHRoZSAnZXJyb3JCYXJzJyBvcHRpb24gaXMgc2V0IGluIHRoZSBjb25zdHJ1Y3RvciwgdGhlIGlucHV0IHNob3VsZCBiZSBvZlxuIHRoZSBmb3JtXG4gICBEYXRlLFNlcmllc0EsU2VyaWVzQiwuLi5cbiAgIFlZWVlNTURELEExLHNpZ21hQTEsQjEsc2lnbWFCMSwuLi5cbiAgIFlZWVlNTURELEEyLHNpZ21hQTIsQjIsc2lnbWFCMiwuLi5cblxuIElmIHRoZSAnZnJhY3Rpb25zJyBvcHRpb24gaXMgc2V0LCB0aGUgaW5wdXQgc2hvdWxkIGJlIG9mIHRoZSBmb3JtOlxuXG4gICBEYXRlLFNlcmllc0EsU2VyaWVzQiwuLi5cbiAgIFlZWVlNTURELEExL0IxLEEyL0IyLC4uLlxuICAgWVlZWU1NREQsQTEvQjEsQTIvQjIsLi4uXG5cbiBBbmQgZXJyb3IgYmFycyB3aWxsIGJlIGNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSB1c2luZyBhIGJpbm9taWFsIGRpc3RyaWJ1dGlvbi5cblxuIEZvciBmdXJ0aGVyIGRvY3VtZW50YXRpb24gYW5kIGV4YW1wbGVzLCBzZWUgaHR0cDovL2R5Z3JhcGhzLmNvbS9cbiAqL1xuXG5pbXBvcnQgRHlncmFwaExheW91dCBmcm9tICcuL2R5Z3JhcGgtbGF5b3V0JztcbmltcG9ydCBEeWdyYXBoQ2FudmFzUmVuZGVyZXIgZnJvbSAnLi9keWdyYXBoLWNhbnZhcyc7XG5pbXBvcnQgRHlncmFwaE9wdGlvbnMgZnJvbSAnLi9keWdyYXBoLW9wdGlvbnMnO1xuaW1wb3J0IER5Z3JhcGhJbnRlcmFjdGlvbiBmcm9tICcuL2R5Z3JhcGgtaW50ZXJhY3Rpb24tbW9kZWwnO1xuaW1wb3J0ICogYXMgRHlncmFwaFRpY2tlcnMgZnJvbSAnLi9keWdyYXBoLXRpY2tlcnMnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi9keWdyYXBoLXV0aWxzJztcbmltcG9ydCBERUZBVUxUX0FUVFJTIGZyb20gJy4vZHlncmFwaC1kZWZhdWx0LWF0dHJzJztcbmltcG9ydCBPUFRJT05TX1JFRkVSRU5DRSBmcm9tICcuL2R5Z3JhcGgtb3B0aW9ucy1yZWZlcmVuY2UnO1xuaW1wb3J0IElGcmFtZVRhcnAgZnJvbSAnLi9pZnJhbWUtdGFycCc7XG5cbmltcG9ydCBEZWZhdWx0SGFuZGxlciBmcm9tICcuL2RhdGFoYW5kbGVyL2RlZmF1bHQnO1xuaW1wb3J0IEVycm9yQmFyc0hhbmRsZXIgZnJvbSAnLi9kYXRhaGFuZGxlci9iYXJzLWVycm9yJztcbmltcG9ydCBDdXN0b21CYXJzSGFuZGxlciBmcm9tICcuL2RhdGFoYW5kbGVyL2JhcnMtY3VzdG9tJztcbmltcG9ydCBEZWZhdWx0RnJhY3Rpb25IYW5kbGVyIGZyb20gJy4vZGF0YWhhbmRsZXIvZGVmYXVsdC1mcmFjdGlvbnMnO1xuaW1wb3J0IEZyYWN0aW9uc0JhcnNIYW5kbGVyIGZyb20gJy4vZGF0YWhhbmRsZXIvYmFycy1mcmFjdGlvbnMnO1xuaW1wb3J0IEJhcnNIYW5kbGVyIGZyb20gJy4vZGF0YWhhbmRsZXIvYmFycyc7XG5cbmltcG9ydCBBbm5vdGF0aW9uc1BsdWdpbiBmcm9tICcuL3BsdWdpbnMvYW5ub3RhdGlvbnMnO1xuaW1wb3J0IEF4ZXNQbHVnaW4gZnJvbSAnLi9wbHVnaW5zL2F4ZXMnO1xuaW1wb3J0IENoYXJ0TGFiZWxzUGx1Z2luIGZyb20gJy4vcGx1Z2lucy9jaGFydC1sYWJlbHMnO1xuaW1wb3J0IEdyaWRQbHVnaW4gZnJvbSAnLi9wbHVnaW5zL2dyaWQnO1xuaW1wb3J0IExlZ2VuZFBsdWdpbiBmcm9tICcuL3BsdWdpbnMvbGVnZW5kJztcbmltcG9ydCBSYW5nZVNlbGVjdG9yUGx1Z2luIGZyb20gJy4vcGx1Z2lucy9yYW5nZS1zZWxlY3Rvcic7XG5cbmltcG9ydCBHVml6Q2hhcnQgZnJvbSAnLi9keWdyYXBoLWd2aXonO1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGludGVyYWN0aXZlLCB6b29tYWJsZSBjaGFydC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZGl2IHwgU3RyaW5nfSBkaXYgQSBkaXYgb3IgdGhlIGlkIG9mIGEgZGl2IGludG8gd2hpY2ggdG8gY29uc3RydWN0XG4gKiB0aGUgY2hhcnQuXG4gKiBAcGFyYW0ge1N0cmluZyB8IEZ1bmN0aW9ufSBmaWxlIEEgZmlsZSBjb250YWluaW5nIENTViBkYXRhIG9yIGEgZnVuY3Rpb25cbiAqIHRoYXQgcmV0dXJucyB0aGlzIGRhdGEuIFRoZSBtb3N0IGJhc2ljIGV4cGVjdGVkIGZvcm1hdCBmb3IgZWFjaCBsaW5lIGlzXG4gKiBcIllZWVkvTU0vREQsdmFsMSx2YWwyLC4uLlwiLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4gKiBodHRwOi8vZHlncmFwaHMuY29tL2RhdGEuaHRtbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRycyBWYXJpb3VzIG90aGVyIGF0dHJpYnV0ZXMsIGUuZy4gZXJyb3JCYXJzIGRldGVybWluZXNcbiAqIHdoZXRoZXIgdGhlIGlucHV0IGRhdGEgY29udGFpbnMgZXJyb3IgcmFuZ2VzLiBGb3IgYSBjb21wbGV0ZSBsaXN0IG9mXG4gKiBvcHRpb25zLCBzZWUgaHR0cDovL2R5Z3JhcGhzLmNvbS9vcHRpb25zLmh0bWwuXG4gKi9cbnZhciBEeWdyYXBoID0gZnVuY3Rpb24oZGl2LCBkYXRhLCBvcHRzKSB7XG4gIHRoaXMuX19pbml0X18oZGl2LCBkYXRhLCBvcHRzKTtcbn07XG5cbkR5Z3JhcGguTkFNRSA9IFwiRHlncmFwaFwiO1xuRHlncmFwaC5WRVJTSU9OID0gXCIyLjAuMFwiO1xuXG4vLyBWYXJpb3VzIGRlZmF1bHQgdmFsdWVzXG5EeWdyYXBoLkRFRkFVTFRfUk9MTF9QRVJJT0QgPSAxO1xuRHlncmFwaC5ERUZBVUxUX1dJRFRIID0gNDgwO1xuRHlncmFwaC5ERUZBVUxUX0hFSUdIVCA9IDMyMDtcblxuLy8gRm9yIG1heCA2MCBIei4gYW5pbWF0aW9uOlxuRHlncmFwaC5BTklNQVRJT05fU1RFUFMgPSAxMjtcbkR5Z3JhcGguQU5JTUFUSU9OX0RVUkFUSU9OID0gMjAwO1xuXG4vKipcbiAqIFN0YW5kYXJkIHBsb3R0ZXJzLiBUaGVzZSBtYXkgYmUgdXNlZCBieSBjbGllbnRzLlxuICogQXZhaWxhYmxlIHBsb3R0ZXJzIGFyZTpcbiAqIC0gRHlncmFwaC5QbG90dGVycy5saW5lUGxvdHRlcjogZHJhd3MgY2VudHJhbCBsaW5lcyAobW9zdCBjb21tb24pXG4gKiAtIER5Z3JhcGguUGxvdHRlcnMuZXJyb3JQbG90dGVyOiBkcmF3cyBlcnJvciBiYXJzXG4gKiAtIER5Z3JhcGguUGxvdHRlcnMuZmlsbFBsb3R0ZXI6IGRyYXdzIGZpbGxzIHVuZGVyIGxpbmVzICh1c2VkIHdpdGggZmlsbEdyYXBoKVxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoZSBwbG90dGVyIGlzIFtmaWxsUGxvdHRlciwgZXJyb3JQbG90dGVyLCBsaW5lUGxvdHRlcl0uXG4gKiBUaGlzIGNhdXNlcyBhbGwgdGhlIGxpbmVzIHRvIGJlIGRyYXduIG92ZXIgYWxsIHRoZSBmaWxscy9lcnJvciBiYXJzLlxuICovXG5EeWdyYXBoLlBsb3R0ZXJzID0gRHlncmFwaENhbnZhc1JlbmRlcmVyLl9QbG90dGVycztcblxuXG4vLyBVc2VkIGZvciBpbml0aWFsaXppbmcgYW5ub3RhdGlvbiBDU1MgcnVsZXMgb25seSBvbmNlLlxuRHlncmFwaC5hZGRlZEFubm90YXRpb25DU1MgPSBmYWxzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgRHlncmFwaC4gVGhpcyBjcmVhdGVzIGEgbmV3IERJViBhbmQgY29uc3RydWN0cyB0aGUgUGxvdEtpdFxuICogYW5kIGNvbnRleHQgJmx0O2NhbnZhcyZndDsgaW5zaWRlIG9mIGl0LiBTZWUgdGhlIGNvbnN0cnVjdG9yIGZvciBkZXRhaWxzLlxuICogb24gdGhlIHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRpdiB0aGUgRWxlbWVudCB0byByZW5kZXIgdGhlIGdyYXBoIGludG8uXG4gKiBAcGFyYW0ge3N0cmluZyB8IEZ1bmN0aW9ufSBmaWxlIFNvdXJjZSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cnMgTWlzY2VsbGFuZW91cyBvdGhlciBvcHRpb25zXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5fX2luaXRfXyA9IGZ1bmN0aW9uKGRpdiwgZmlsZSwgYXR0cnMpIHtcbiAgdGhpcy5pc19pbml0aWFsX2RyYXdfID0gdHJ1ZTtcbiAgdGhpcy5yZWFkeUZuc18gPSBbXTtcblxuICAvLyBTdXBwb3J0IHR3by1hcmd1bWVudCBjb25zdHJ1Y3RvclxuICBpZiAoYXR0cnMgPT09IG51bGwgfHwgYXR0cnMgPT09IHVuZGVmaW5lZCkgeyBhdHRycyA9IHt9OyB9XG5cbiAgYXR0cnMgPSBEeWdyYXBoLmNvcHlVc2VyQXR0cnNfKGF0dHJzKTtcblxuICBpZiAodHlwZW9mKGRpdikgPT0gJ3N0cmluZycpIHtcbiAgICBkaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkaXYpO1xuICB9XG5cbiAgaWYgKCFkaXYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnN0cnVjdGluZyBkeWdyYXBoIHdpdGggYSBub24tZXhpc3RlbnQgZGl2IScpO1xuICB9XG5cbiAgLy8gQ29weSB0aGUgaW1wb3J0YW50IGJpdHMgaW50byB0aGUgb2JqZWN0XG4gIC8vIFRPRE8oZGFudmspOiBtb3N0IG9mIHRoZXNlIHNob3VsZCBqdXN0IHN0YXkgaW4gdGhlIGF0dHJzXyBkaWN0aW9uYXJ5LlxuICB0aGlzLm1haW5kaXZfID0gZGl2O1xuICB0aGlzLmZpbGVfID0gZmlsZTtcbiAgdGhpcy5yb2xsUGVyaW9kXyA9IGF0dHJzLnJvbGxQZXJpb2QgfHwgRHlncmFwaC5ERUZBVUxUX1JPTExfUEVSSU9EO1xuICB0aGlzLnByZXZpb3VzVmVydGljYWxYXyA9IC0xO1xuICB0aGlzLmZyYWN0aW9uc18gPSBhdHRycy5mcmFjdGlvbnMgfHwgZmFsc2U7XG4gIHRoaXMuZGF0ZVdpbmRvd18gPSBhdHRycy5kYXRlV2luZG93IHx8IG51bGw7XG5cbiAgdGhpcy5hbm5vdGF0aW9uc18gPSBbXTtcblxuICAvLyBDbGVhciB0aGUgZGl2LiBUaGlzIGVuc3VyZSB0aGF0LCBpZiBtdWx0aXBsZSBkeWdyYXBocyBhcmUgcGFzc2VkIHRoZSBzYW1lXG4gIC8vIGRpdiwgdGhlbiBvbmx5IG9uZSB3aWxsIGJlIGRyYXduLlxuICBkaXYuaW5uZXJIVE1MID0gXCJcIjtcblxuICAvLyBGb3IgaGlzdG9yaWNhbCByZWFzb25zLCB0aGUgJ3dpZHRoJyBhbmQgJ2hlaWdodCcgb3B0aW9ucyB0cnVtcCBhbGwgQ1NTXG4gIC8vIHJ1bGVzIF9leGNlcHRfIGZvciBhbiBleHBsaWNpdCAnd2lkdGgnIG9yICdoZWlnaHQnIG9uIHRoZSBkaXYuXG4gIC8vIEFzIGFuIGFkZGVkIGNvbnZlbmllbmNlLCBpZiB0aGUgZGl2IGhhcyB6ZXJvIGhlaWdodCAobGlrZSA8ZGl2PjwvZGl2PiBkb2VzXG4gIC8vIHdpdGhvdXQgYW55IHN0eWxlcyksIHRoZW4gd2UgdXNlIGEgZGVmYXVsdCBoZWlnaHQvd2lkdGguXG4gIGlmIChkaXYuc3R5bGUud2lkdGggPT09ICcnICYmIGF0dHJzLndpZHRoKSB7XG4gICAgZGl2LnN0eWxlLndpZHRoID0gYXR0cnMud2lkdGggKyBcInB4XCI7XG4gIH1cbiAgaWYgKGRpdi5zdHlsZS5oZWlnaHQgPT09ICcnICYmIGF0dHJzLmhlaWdodCkge1xuICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBhdHRycy5oZWlnaHQgKyBcInB4XCI7XG4gIH1cbiAgaWYgKGRpdi5zdHlsZS5oZWlnaHQgPT09ICcnICYmIGRpdi5jbGllbnRIZWlnaHQgPT09IDApIHtcbiAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gRHlncmFwaC5ERUZBVUxUX0hFSUdIVCArIFwicHhcIjtcbiAgICBpZiAoZGl2LnN0eWxlLndpZHRoID09PSAnJykge1xuICAgICAgZGl2LnN0eWxlLndpZHRoID0gRHlncmFwaC5ERUZBVUxUX1dJRFRIICsgXCJweFwiO1xuICAgIH1cbiAgfVxuICAvLyBUaGVzZSB3aWxsIGJlIHplcm8gaWYgdGhlIGR5Z3JhcGgncyBkaXYgaXMgaGlkZGVuLiBJbiB0aGF0IGNhc2UsXG4gIC8vIHVzZSB0aGUgdXNlci1zcGVjaWZpZWQgYXR0cmlidXRlcyBpZiBwcmVzZW50LiBJZiBub3QsIHVzZSB6ZXJvXG4gIC8vIGFuZCBhc3N1bWUgdGhlIHVzZXIgd2lsbCBjYWxsIHJlc2l6ZSB0byBmaXggdGhpbmdzIGxhdGVyLlxuICB0aGlzLndpZHRoXyA9IGRpdi5jbGllbnRXaWR0aCB8fCBhdHRycy53aWR0aCB8fCAwO1xuICB0aGlzLmhlaWdodF8gPSBkaXYuY2xpZW50SGVpZ2h0IHx8IGF0dHJzLmhlaWdodCB8fCAwO1xuXG4gIC8vIFRPRE8oZGFudmspOiBzZXQgZmlsbEdyYXBoIHRvIGJlIHBhcnQgb2YgYXR0cnNfIGhlcmUsIG5vdCB1c2VyX2F0dHJzXy5cbiAgaWYgKGF0dHJzLnN0YWNrZWRHcmFwaCkge1xuICAgIGF0dHJzLmZpbGxHcmFwaCA9IHRydWU7XG4gICAgLy8gVE9ETyhuaWtoaWxrKTogQWRkIGFueSBvdGhlciBzdGFja2VkR3JhcGggY2hlY2tzIGhlcmUuXG4gIH1cblxuICAvLyBERVBSRUNBVElPTiBXQVJOSU5HOiBBbGwgb3B0aW9uIHByb2Nlc3Npbmcgc2hvdWxkIGJlIG1vdmVkIGZyb21cbiAgLy8gYXR0cnNfIGFuZCB1c2VyX2F0dHJzXyB0byBvcHRpb25zXywgd2hpY2ggaG9sZHMgYWxsIHRoaXMgaW5mb3JtYXRpb24uXG4gIC8vXG4gIC8vIER5Z3JhcGhzIGhhcyBtYW55IG9wdGlvbnMsIHNvbWUgb2Ygd2hpY2ggaW50ZXJhY3Qgd2l0aCBvbmUgYW5vdGhlci5cbiAgLy8gVG8ga2VlcCB0cmFjayBvZiBldmVyeXRoaW5nLCB3ZSBtYWludGFpbiB0d28gc2V0cyBvZiBvcHRpb25zOlxuICAvL1xuICAvLyAgdGhpcy51c2VyX2F0dHJzXyAgIG9ubHkgb3B0aW9ucyBleHBsaWNpdGx5IHNldCBieSB0aGUgdXNlci5cbiAgLy8gIHRoaXMuYXR0cnNfICAgICAgICBkZWZhdWx0cywgb3B0aW9ucyBkZXJpdmVkIGZyb20gdXNlcl9hdHRyc18sIGRhdGEuXG4gIC8vXG4gIC8vIE9wdGlvbnMgYXJlIHRoZW4gYWNjZXNzZWQgdGhpcy5hdHRyXygnYXR0cicpLCB3aGljaCBmaXJzdCBsb29rcyBhdFxuICAvLyB1c2VyX2F0dHJzXyBhbmQgdGhlbiBjb21wdXRlZCBhdHRyc18uIFRoaXMgd2F5IER5Z3JhcGhzIGNhbiBzZXQgaW50ZWxsaWdlbnRcbiAgLy8gZGVmYXVsdHMgd2l0aG91dCBvdmVycmlkaW5nIGJlaGF2aW9yIHRoYXQgdGhlIHVzZXIgc3BlY2lmaWNhbGx5IGFza3MgZm9yLlxuICB0aGlzLnVzZXJfYXR0cnNfID0ge307XG4gIHV0aWxzLnVwZGF0ZSh0aGlzLnVzZXJfYXR0cnNfLCBhdHRycyk7XG5cbiAgLy8gVGhpcyBzZXF1ZW5jZSBlbnN1cmVzIHRoYXQgRHlncmFwaC5ERUZBVUxUX0FUVFJTIGlzIG5ldmVyIG1vZGlmaWVkLlxuICB0aGlzLmF0dHJzXyA9IHt9O1xuICB1dGlscy51cGRhdGVEZWVwKHRoaXMuYXR0cnNfLCBERUZBVUxUX0FUVFJTKTtcblxuICB0aGlzLmJvdW5kYXJ5SWRzXyA9IFtdO1xuICB0aGlzLnNldEluZGV4QnlOYW1lXyA9IHt9O1xuICB0aGlzLmRhdGFzZXRJbmRleF8gPSBbXTtcblxuICB0aGlzLnJlZ2lzdGVyZWRFdmVudHNfID0gW107XG4gIHRoaXMuZXZlbnRMaXN0ZW5lcnNfID0ge307XG5cbiAgdGhpcy5hdHRyaWJ1dGVzXyA9IG5ldyBEeWdyYXBoT3B0aW9ucyh0aGlzKTtcblxuICAvLyBDcmVhdGUgdGhlIGNvbnRhaW5pbmcgRElWIGFuZCBvdGhlciBpbnRlcmFjdGl2ZSBlbGVtZW50c1xuICB0aGlzLmNyZWF0ZUludGVyZmFjZV8oKTtcblxuICAvLyBBY3RpdmF0ZSBwbHVnaW5zLlxuICB0aGlzLnBsdWdpbnNfID0gW107XG4gIHZhciBwbHVnaW5zID0gRHlncmFwaC5QTFVHSU5TLmNvbmNhdCh0aGlzLmdldE9wdGlvbigncGx1Z2lucycpKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gdGhlIHBsdWdpbnMgb3B0aW9uIG1heSBjb250YWluIGVpdGhlciBwbHVnaW4gY2xhc3NlcyBvciBpbnN0YW5jZXMuXG4gICAgLy8gUGx1Z2luIGluc3RhbmNlcyBjb250YWluIGFuIGFjdGl2YXRlIG1ldGhvZC5cbiAgICB2YXIgUGx1Z2luID0gcGx1Z2luc1tpXTsgIC8vIGVpdGhlciBhIGNvbnN0cnVjdG9yIG9yIGFuIGluc3RhbmNlLlxuICAgIHZhciBwbHVnaW5JbnN0YW5jZTtcbiAgICBpZiAodHlwZW9mKFBsdWdpbi5hY3RpdmF0ZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwbHVnaW5JbnN0YW5jZSA9IFBsdWdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcGx1Z2luSW5zdGFuY2UgPSBuZXcgUGx1Z2luKCk7XG4gICAgfVxuXG4gICAgdmFyIHBsdWdpbkRpY3QgPSB7XG4gICAgICBwbHVnaW46IHBsdWdpbkluc3RhbmNlLFxuICAgICAgZXZlbnRzOiB7fSxcbiAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgcGx1Z2luT3B0aW9uczoge31cbiAgICB9O1xuXG4gICAgdmFyIGhhbmRsZXJzID0gcGx1Z2luSW5zdGFuY2UuYWN0aXZhdGUodGhpcyk7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGhhbmRsZXJzKSB7XG4gICAgICBpZiAoIWhhbmRsZXJzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIGNvbnRpbnVlO1xuICAgICAgLy8gVE9ETyhkYW52ayk6IHZhbGlkYXRlIGV2ZW50TmFtZS5cbiAgICAgIHBsdWdpbkRpY3QuZXZlbnRzW2V2ZW50TmFtZV0gPSBoYW5kbGVyc1tldmVudE5hbWVdO1xuICAgIH1cblxuICAgIHRoaXMucGx1Z2luc18ucHVzaChwbHVnaW5EaWN0KTtcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQsIHBsdWdpbnMgY2FuIG5vIGxvbmdlciByZWdpc3RlciBldmVudCBoYW5kbGVycy5cbiAgLy8gQ29uc3RydWN0IGEgbWFwIGZyb20gZXZlbnQgLT4gb3JkZXJlZCBsaXN0IG9mIFtjYWxsYmFjaywgcGx1Z2luXS5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBsdWdpbnNfLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsdWdpbl9kaWN0ID0gdGhpcy5wbHVnaW5zX1tpXTtcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcGx1Z2luX2RpY3QuZXZlbnRzKSB7XG4gICAgICBpZiAoIXBsdWdpbl9kaWN0LmV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSBjb250aW51ZTtcbiAgICAgIHZhciBjYWxsYmFjayA9IHBsdWdpbl9kaWN0LmV2ZW50c1tldmVudE5hbWVdO1xuXG4gICAgICB2YXIgcGFpciA9IFtwbHVnaW5fZGljdC5wbHVnaW4sIGNhbGxiYWNrXTtcbiAgICAgIGlmICghKGV2ZW50TmFtZSBpbiB0aGlzLmV2ZW50TGlzdGVuZXJzXykpIHtcbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyc19bZXZlbnROYW1lXSA9IFtwYWlyXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNfW2V2ZW50TmFtZV0ucHVzaChwYWlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmNyZWF0ZURyYWdJbnRlcmZhY2VfKCk7XG5cbiAgdGhpcy5zdGFydF8oKTtcbn07XG5cbi8qKlxuICogVHJpZ2dlcnMgYSBjYXNjYWRlIG9mIGV2ZW50cyB0byB0aGUgdmFyaW91cyBwbHVnaW5zIHdoaWNoIGFyZSBpbnRlcmVzdGVkIGluIHRoZW0uXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIFwiZGVmYXVsdCBiZWhhdmlvclwiIHNob3VsZCBiZSBwcmV2ZW50ZWQsIGkuZS4gaWYgb25lXG4gKiBvZiB0aGUgZXZlbnQgbGlzdGVuZXJzIGNhbGxlZCBldmVudC5wcmV2ZW50RGVmYXVsdCgpLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuY2FzY2FkZUV2ZW50c18gPSBmdW5jdGlvbihuYW1lLCBleHRyYV9wcm9wcykge1xuICBpZiAoIShuYW1lIGluIHRoaXMuZXZlbnRMaXN0ZW5lcnNfKSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFFVRVNUSU9OOiBjYW4gd2UgdXNlIG9iamVjdHMgJiBwcm90b3R5cGVzIHRvIHNwZWVkIHRoaXMgdXA/XG4gIHZhciBlID0ge1xuICAgIGR5Z3JhcGg6IHRoaXMsXG4gICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgZGVmYXVsdFByZXZlbnRlZDogZmFsc2UsXG4gICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFlLmNhbmNlbGFibGUpIHRocm93IFwiQ2Fubm90IGNhbGwgcHJldmVudERlZmF1bHQgb24gbm9uLWNhbmNlbGFibGUgZXZlbnQuXCI7XG4gICAgICBlLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgcHJvcGFnYXRpb25TdG9wcGVkOiBmYWxzZSxcbiAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgZS5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgdXRpbHMudXBkYXRlKGUsIGV4dHJhX3Byb3BzKTtcblxuICB2YXIgY2FsbGJhY2tfcGx1Z2luX3BhaXJzID0gdGhpcy5ldmVudExpc3RlbmVyc19bbmFtZV07XG4gIGlmIChjYWxsYmFja19wbHVnaW5fcGFpcnMpIHtcbiAgICBmb3IgKHZhciBpID0gY2FsbGJhY2tfcGx1Z2luX3BhaXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgcGx1Z2luID0gY2FsbGJhY2tfcGx1Z2luX3BhaXJzW2ldWzBdO1xuICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tfcGx1Z2luX3BhaXJzW2ldWzFdO1xuICAgICAgY2FsbGJhY2suY2FsbChwbHVnaW4sIGUpO1xuICAgICAgaWYgKGUucHJvcGFnYXRpb25TdG9wcGVkKSBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGUuZGVmYXVsdFByZXZlbnRlZDtcbn07XG5cbi8qKlxuICogRmV0Y2ggYSBwbHVnaW4gaW5zdGFuY2Ugb2YgYSBwYXJ0aWN1bGFyIGNsYXNzLiBPbmx5IGZvciB0ZXN0aW5nLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7IUNsYXNzfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBwbHVnaW4uXG4gKiBAcmV0dXJuIHtPYmplY3R9IEluc3RhbmNlIG9mIHRoZSBwbHVnaW4sIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9uZS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0UGx1Z2luSW5zdGFuY2VfID0gZnVuY3Rpb24odHlwZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGx1Z2luc18ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IHRoaXMucGx1Z2luc19baV07XG4gICAgaWYgKHAucGx1Z2luIGluc3RhbmNlb2YgdHlwZSkge1xuICAgICAgcmV0dXJuIHAucGx1Z2luO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgem9vbWVkIHN0YXR1cyBvZiB0aGUgY2hhcnQgZm9yIG9uZSBvciBib3RoIGF4ZXMuXG4gKlxuICogQXhpcyBpcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIuIENhbiBiZSBzZXQgdG8gJ3gnIG9yICd5Jy5cbiAqXG4gKiBUaGUgem9vbWVkIHN0YXR1cyBmb3IgYW4gYXhpcyBpcyBzZXQgd2hlbmV2ZXIgYSB1c2VyIHpvb21zIHVzaW5nIHRoZSBtb3VzZVxuICogb3Igd2hlbiB0aGUgZGF0ZVdpbmRvdyBvciB2YWx1ZVJhbmdlIGFyZSB1cGRhdGVkLiBEb3VibGUtY2xpY2tpbmcgb3IgY2FsbGluZ1xuICogcmVzZXRab29tKCkgcmVzZXRzIHRoZSB6b29tIHN0YXR1cyBmb3IgdGhlIGNoYXJ0LlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5pc1pvb21lZCA9IGZ1bmN0aW9uKGF4aXMpIHtcbiAgY29uc3QgaXNab29tZWRYID0gISF0aGlzLmRhdGVXaW5kb3dfO1xuICBpZiAoYXhpcyA9PT0gJ3gnKSByZXR1cm4gaXNab29tZWRYO1xuXG4gIGNvbnN0IGlzWm9vbWVkWSA9IHRoaXMuYXhlc18ubWFwKGF4aXMgPT4gISFheGlzLnZhbHVlUmFuZ2UpLmluZGV4T2YodHJ1ZSkgPj0gMDtcbiAgaWYgKGF4aXMgPT09IG51bGwgfHwgYXhpcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGlzWm9vbWVkWCB8fCBpc1pvb21lZFk7XG4gIH1cbiAgaWYgKGF4aXMgPT09ICd5JykgcmV0dXJuIGlzWm9vbWVkWTtcblxuICB0aHJvdyBuZXcgRXJyb3IoYGF4aXMgcGFyYW1ldGVyIGlzIFske2F4aXN9XSBtdXN0IGJlIG51bGwsICd4JyBvciAneScuYCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIER5Z3JhcGggb2JqZWN0LCBpbmNsdWRpbmcgaXRzIGNvbnRhaW5pbmcgSUQuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtYWluZGl2ID0gdGhpcy5tYWluZGl2XztcbiAgdmFyIGlkID0gKG1haW5kaXYgJiYgbWFpbmRpdi5pZCkgPyBtYWluZGl2LmlkIDogbWFpbmRpdjtcbiAgcmV0dXJuIFwiW0R5Z3JhcGggXCIgKyBpZCArIFwiXVwiO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYW4gb3B0aW9uLiBUaGlzIG1heSBiZSBzZXQgYnkgdGhlIHVzZXIgKGVpdGhlciBpbiB0aGVcbiAqIGNvbnN0cnVjdG9yIG9yIGJ5IGNhbGxpbmcgdXBkYXRlT3B0aW9ucykgb3IgYnkgZHlncmFwaHMsIGFuZCBtYXkgYmUgc2V0IHRvIGFcbiAqIHBlci1zZXJpZXMgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgb3B0aW9uLCBlLmcuICdyb2xsUGVyaW9kJy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2VyaWVzTmFtZV0gVGhlIG5hbWUgb2YgdGhlIHNlcmllcyB0byB3aGljaCB0aGUgb3B0aW9uXG4gKiB3aWxsIGJlIGFwcGxpZWQuIElmIG5vIHBlci1zZXJpZXMgdmFsdWUgb2YgdGhpcyBvcHRpb24gaXMgYXZhaWxhYmxlLCB0aGVuXG4gKiB0aGUgZ2xvYmFsIHZhbHVlIGlzIHJldHVybmVkLiBUaGlzIGlzIG9wdGlvbmFsLlxuICogQHJldHVybiB7IC4uLiB9IFRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5hdHRyXyA9IGZ1bmN0aW9uKG5hbWUsIHNlcmllc05hbWUpIHtcbiAgLy8gRm9yIFwicHJvZHVjdGlvblwiIGNvZGUsIHRoaXMgZ2V0cyByZW1vdmVkIGJ5IHVnbGlmeWpzLlxuICBpZiAodHlwZW9mKHByb2Nlc3MpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YoT1BUSU9OU19SRUZFUkVOQ0UpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdNdXN0IGluY2x1ZGUgb3B0aW9ucyByZWZlcmVuY2UgSlMgZm9yIHRlc3RpbmcnKTtcbiAgICAgIH0gZWxzZSBpZiAoIU9QVElPTlNfUkVGRVJFTkNFLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0R5Z3JhcGhzIGlzIHVzaW5nIHByb3BlcnR5ICcgKyBuYW1lICsgJywgd2hpY2ggaGFzIG5vICcgK1xuICAgICAgICAgICAgICAgICAgICAgICdlbnRyeSBpbiB0aGUgRHlncmFwaHMuT1BUSU9OU19SRUZFUkVOQ0UgbGlzdGluZy4nKTtcbiAgICAgICAgLy8gT25seSBsb2cgdGhpcyBlcnJvciBvbmNlLlxuICAgICAgICBPUFRJT05TX1JFRkVSRU5DRVtuYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpZXNOYW1lID8gdGhpcy5hdHRyaWJ1dGVzXy5nZXRGb3JTZXJpZXMobmFtZSwgc2VyaWVzTmFtZSkgOiB0aGlzLmF0dHJpYnV0ZXNfLmdldChuYW1lKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBmb3IgYW4gb3B0aW9uLCBhcyBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yIG9yIHZpYVxuICogdXBkYXRlT3B0aW9ucy4gWW91IG1heSBwYXNzIGluIGFuIChvcHRpb25hbCkgc2VyaWVzIG5hbWUgdG8gZ2V0IHBlci1zZXJpZXNcbiAqIHZhbHVlcyBmb3IgdGhlIG9wdGlvbi5cbiAqXG4gKiBBbGwgdmFsdWVzIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kIHNob3VsZCBiZSBjb25zaWRlcmVkIGltbXV0YWJsZS4gSWYgeW91XG4gKiBtb2RpZnkgdGhlbSwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIGNoYW5nZXMgd2lsbCBiZSBob25vcmVkIG9yIHRoYXRcbiAqIGR5Z3JhcGhzIHdpbGwgcmVtYWluIGluIGEgY29uc2lzdGVudCBzdGF0ZS4gSWYgeW91IHdhbnQgdG8gbW9kaWZ5IGFuIG9wdGlvbixcbiAqIHVzZSB1cGRhdGVPcHRpb25zKCkgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgb3B0aW9uIChlLmcuICdzdHJva2VXaWR0aCcpXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zZXJpZXNOYW1lIFNlcmllcyBuYW1lIHRvIGdldCBwZXItc2VyaWVzIHZhbHVlcy5cbiAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRPcHRpb24gPSBmdW5jdGlvbihuYW1lLCBvcHRfc2VyaWVzTmFtZSkge1xuICByZXR1cm4gdGhpcy5hdHRyXyhuYW1lLCBvcHRfc2VyaWVzTmFtZSk7XG59O1xuXG4vKipcbiAqIExpa2UgZ2V0T3B0aW9uKCksIGJ1dCBzcGVjaWZpY2FsbHkgcmV0dXJucyBhIG51bWJlci5cbiAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3Igd29ya2luZyB3aXRoIHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIG9wdGlvbiAoZS5nLiAnc3Ryb2tlV2lkdGgnKVxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfc2VyaWVzTmFtZSBTZXJpZXMgbmFtZSB0byBnZXQgcGVyLXNlcmllcyB2YWx1ZXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0TnVtZXJpY09wdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIG9wdF9zZXJpZXNOYW1lKSB7XG4gIHJldHVybiAvKiogQHR5cGV7bnVtYmVyfSAqLyh0aGlzLmdldE9wdGlvbihuYW1lLCBvcHRfc2VyaWVzTmFtZSkpO1xufTtcblxuLyoqXG4gKiBMaWtlIGdldE9wdGlvbigpLCBidXQgc3BlY2lmaWNhbGx5IHJldHVybnMgYSBzdHJpbmcuXG4gKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIHdvcmtpbmcgd2l0aCB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBvcHRpb24gKGUuZy4gJ3N0cm9rZVdpZHRoJylcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Nlcmllc05hbWUgU2VyaWVzIG5hbWUgdG8gZ2V0IHBlci1zZXJpZXMgdmFsdWVzLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmFsdWUgb2YgdGhlIG9wdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldFN0cmluZ09wdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIG9wdF9zZXJpZXNOYW1lKSB7XG4gIHJldHVybiAvKiogQHR5cGV7c3RyaW5nfSAqLyh0aGlzLmdldE9wdGlvbihuYW1lLCBvcHRfc2VyaWVzTmFtZSkpO1xufTtcblxuLyoqXG4gKiBMaWtlIGdldE9wdGlvbigpLCBidXQgc3BlY2lmaWNhbGx5IHJldHVybnMgYSBib29sZWFuLlxuICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciB3b3JraW5nIHdpdGggdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgb3B0aW9uIChlLmcuICdzdHJva2VXaWR0aCcpXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zZXJpZXNOYW1lIFNlcmllcyBuYW1lIHRvIGdldCBwZXItc2VyaWVzIHZhbHVlcy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0Qm9vbGVhbk9wdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIG9wdF9zZXJpZXNOYW1lKSB7XG4gIHJldHVybiAvKiogQHR5cGV7Ym9vbGVhbn0gKi8odGhpcy5nZXRPcHRpb24obmFtZSwgb3B0X3Nlcmllc05hbWUpKTtcbn07XG5cbi8qKlxuICogTGlrZSBnZXRPcHRpb24oKSwgYnV0IHNwZWNpZmljYWxseSByZXR1cm5zIGEgZnVuY3Rpb24uXG4gKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIHdvcmtpbmcgd2l0aCB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBvcHRpb24gKGUuZy4gJ3N0cm9rZVdpZHRoJylcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Nlcmllc05hbWUgU2VyaWVzIG5hbWUgdG8gZ2V0IHBlci1zZXJpZXMgdmFsdWVzLlxuICogQHJldHVybiB7ZnVuY3Rpb24oLi4uKX0gVGhlIHZhbHVlIG9mIHRoZSBvcHRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRGdW5jdGlvbk9wdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIG9wdF9zZXJpZXNOYW1lKSB7XG4gIHJldHVybiAvKiogQHR5cGV7ZnVuY3Rpb24oLi4uKX0gKi8odGhpcy5nZXRPcHRpb24obmFtZSwgb3B0X3Nlcmllc05hbWUpKTtcbn07XG5cbkR5Z3JhcGgucHJvdG90eXBlLmdldE9wdGlvbkZvckF4aXMgPSBmdW5jdGlvbihuYW1lLCBheGlzKSB7XG4gIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNfLmdldEZvckF4aXMobmFtZSwgYXhpcyk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyBUaGUgbmFtZSBvZiB0aGUgYXhpcyAoaS5lLiAneCcsICd5JyBvciAneTInKVxuICogQHJldHVybiB7IC4uLiB9IEEgZnVuY3Rpb24gbWFwcGluZyBzdHJpbmcgLT4gb3B0aW9uIHZhbHVlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLm9wdGlvbnNWaWV3Rm9yQXhpc18gPSBmdW5jdGlvbihheGlzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uKG9wdCkge1xuICAgIHZhciBheGlzX29wdHMgPSBzZWxmLnVzZXJfYXR0cnNfLmF4ZXM7XG4gICAgaWYgKGF4aXNfb3B0cyAmJiBheGlzX29wdHNbYXhpc10gJiYgYXhpc19vcHRzW2F4aXNdLmhhc093blByb3BlcnR5KG9wdCkpIHtcbiAgICAgIHJldHVybiBheGlzX29wdHNbYXhpc11bb3B0XTtcbiAgICB9XG5cbiAgICAvLyBJIGRvbid0IGxpa2UgdGhhdCB0aGlzIGlzIGluIGEgc2Vjb25kIHNwb3QuXG4gICAgaWYgKGF4aXMgPT09ICd4JyAmJiBvcHQgPT09ICdsb2dzY2FsZScpIHtcbiAgICAgIC8vIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgIC8vIFRPRE8oa29uaWdzYmVyZyk6IHB1bGwgdGhlIGRlZmF1bHQgZnJvbSBhIGdsb2JhbCBkZWZhdWx0LlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHVzZXItc3BlY2lmaWVkIGF0dHJpYnV0ZXMgYWx3YXlzIHRydW1wIGRlZmF1bHRzLCBldmVuIGlmIHRoZXkncmUgbGVzc1xuICAgIC8vIHNwZWNpZmljLlxuICAgIGlmICh0eXBlb2Yoc2VsZi51c2VyX2F0dHJzX1tvcHRdKSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHNlbGYudXNlcl9hdHRyc19bb3B0XTtcbiAgICB9XG5cbiAgICBheGlzX29wdHMgPSBzZWxmLmF0dHJzXy5heGVzO1xuICAgIGlmIChheGlzX29wdHMgJiYgYXhpc19vcHRzW2F4aXNdICYmIGF4aXNfb3B0c1theGlzXS5oYXNPd25Qcm9wZXJ0eShvcHQpKSB7XG4gICAgICByZXR1cm4gYXhpc19vcHRzW2F4aXNdW29wdF07XG4gICAgfVxuICAgIC8vIGNoZWNrIG9sZC1zdHlsZSBheGlzIG9wdGlvbnNcbiAgICAvLyBUT0RPKGRhbnZrKTogYWRkIGEgZGVwcmVjYXRpb24gd2FybmluZyBpZiBlaXRoZXIgb2YgdGhlc2UgbWF0Y2guXG4gICAgaWYgKGF4aXMgPT0gJ3knICYmIHNlbGYuYXhlc19bMF0uaGFzT3duUHJvcGVydHkob3B0KSkge1xuICAgICAgcmV0dXJuIHNlbGYuYXhlc19bMF1bb3B0XTtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT0gJ3kyJyAmJiBzZWxmLmF4ZXNfWzFdLmhhc093blByb3BlcnR5KG9wdCkpIHtcbiAgICAgIHJldHVybiBzZWxmLmF4ZXNfWzFdW29wdF07XG4gICAgfVxuICAgIHJldHVybiBzZWxmLmF0dHJfKG9wdCk7XG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgcm9sbGluZyBwZXJpb2QsIGFzIHNldCBieSB0aGUgdXNlciBvciBhbiBvcHRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgcG9pbnRzIGluIHRoZSByb2xsaW5nIHdpbmRvd1xuICovXG5EeWdyYXBoLnByb3RvdHlwZS5yb2xsUGVyaW9kID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJvbGxQZXJpb2RfO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50bHktdmlzaWJsZSB4LXJhbmdlLiBUaGlzIGNhbiBiZSBhZmZlY3RlZCBieSB6b29taW5nLFxuICogcGFubmluZyBvciBhIGNhbGwgdG8gdXBkYXRlT3B0aW9ucy5cbiAqIFJldHVybnMgYSB0d28tZWxlbWVudCBhcnJheTogW2xlZnQsIHJpZ2h0XS5cbiAqIElmIHRoZSBEeWdyYXBoIGhhcyBkYXRlcyBvbiB0aGUgeC1heGlzLCB0aGVzZSB3aWxsIGJlIG1pbGxpcyBzaW5jZSBlcG9jaC5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUueEF4aXNSYW5nZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRlV2luZG93XyA/IHRoaXMuZGF0ZVdpbmRvd18gOiB0aGlzLnhBeGlzRXh0cmVtZXMoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbG93ZXItIGFuZCB1cHBlci1ib3VuZCB4LWF4aXMgdmFsdWVzIG9mIHRoZSBkYXRhIHNldC5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUueEF4aXNFeHRyZW1lcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFkID0gdGhpcy5nZXROdW1lcmljT3B0aW9uKCd4UmFuZ2VQYWQnKSAvIHRoaXMucGxvdHRlcl8uYXJlYS53O1xuICBpZiAodGhpcy5udW1Sb3dzKCkgPT09IDApIHtcbiAgICByZXR1cm4gWzAgLSBwYWQsIDEgKyBwYWRdO1xuICB9XG4gIHZhciBsZWZ0ID0gdGhpcy5yYXdEYXRhX1swXVswXTtcbiAgdmFyIHJpZ2h0ID0gdGhpcy5yYXdEYXRhX1t0aGlzLnJhd0RhdGFfLmxlbmd0aCAtIDFdWzBdO1xuICBpZiAocGFkKSB7XG4gICAgLy8gTXVzdCBrZWVwIHRoaXMgaW4gc3luYyB3aXRoIGR5Z3JhcGgtbGF5b3V0IF9ldmFsdWF0ZUxpbWl0cygpXG4gICAgdmFyIHJhbmdlID0gcmlnaHQgLSBsZWZ0O1xuICAgIGxlZnQgLT0gcmFuZ2UgKiBwYWQ7XG4gICAgcmlnaHQgKz0gcmFuZ2UgKiBwYWQ7XG4gIH1cbiAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGxvd2VyLSBhbmQgdXBwZXItYm91bmQgeS1heGlzIHZhbHVlcyBmb3IgZWFjaCBheGlzLiBUaGVzZSBhcmVcbiAqIHRoZSByYW5nZXMgeW91J2xsIGdldCBpZiB5b3UgZG91YmxlLWNsaWNrIHRvIHpvb20gb3V0IG9yIGNhbGwgcmVzZXRab29tKCkuXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIGFuIGFycmF5IG9mIFtsb3csIGhpZ2hdIHR1cGxlcywgb25lIGZvciBlYWNoIHktYXhpcy5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUueUF4aXNFeHRyZW1lcyA9IGZ1bmN0aW9uKCkge1xuICAvLyBUT0RPKGRhbnZrKTogdGhpcyBpcyBwcmV0dHkgaW5lZmZpY2llbnRcbiAgY29uc3QgcGFja2VkID0gdGhpcy5nYXRoZXJEYXRhc2V0c18odGhpcy5yb2xsZWRTZXJpZXNfLCBudWxsKTtcbiAgY29uc3QgeyBleHRyZW1lcyB9ID0gcGFja2VkO1xuICBjb25zdCBzYXZlQXhlcyA9IHRoaXMuYXhlc187XG4gIHRoaXMuY29tcHV0ZVlBeGlzUmFuZ2VzXyhleHRyZW1lcyk7XG4gIGNvbnN0IG5ld0F4ZXMgPSB0aGlzLmF4ZXNfO1xuICB0aGlzLmF4ZXNfID0gc2F2ZUF4ZXM7XG4gIHJldHVybiBuZXdBeGVzLm1hcChheGlzID0+IGF4aXMuZXh0cmVtZVJhbmdlKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50bHktdmlzaWJsZSB5LXJhbmdlIGZvciBhbiBheGlzLiBUaGlzIGNhbiBiZSBhZmZlY3RlZCBieVxuICogem9vbWluZywgcGFubmluZyBvciBhIGNhbGwgdG8gdXBkYXRlT3B0aW9ucy4gQXhpcyBpbmRpY2VzIGFyZSB6ZXJvLWJhc2VkLiBJZlxuICogY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzLCByZXR1cm5zIHRoZSByYW5nZSBvZiB0aGUgZmlyc3QgYXhpcy5cbiAqIFJldHVybnMgYSB0d28tZWxlbWVudCBhcnJheTogW2JvdHRvbSwgdG9wXS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUueUF4aXNSYW5nZSA9IGZ1bmN0aW9uKGlkeCkge1xuICBpZiAodHlwZW9mKGlkeCkgPT0gXCJ1bmRlZmluZWRcIikgaWR4ID0gMDtcbiAgaWYgKGlkeCA8IDAgfHwgaWR4ID49IHRoaXMuYXhlc18ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGF4aXMgPSB0aGlzLmF4ZXNfW2lkeF07XG4gIHJldHVybiBbIGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdLCBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVsxXSBdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50bHktdmlzaWJsZSB5LXJhbmdlcyBmb3IgZWFjaCBheGlzLiBUaGlzIGNhbiBiZSBhZmZlY3RlZCBieVxuICogem9vbWluZywgcGFubmluZywgY2FsbHMgdG8gdXBkYXRlT3B0aW9ucywgZXRjLlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBbYm90dG9tLCB0b3BdIHBhaXJzLCBvbmUgZm9yIGVhY2ggeS1heGlzLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS55QXhpc1JhbmdlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5heGVzXy5sZW5ndGg7IGkrKykge1xuICAgIHJldC5wdXNoKHRoaXMueUF4aXNSYW5nZShpKSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8vIFRPRE8oZGFudmspOiB1c2UgdGhlc2UgZnVuY3Rpb25zIHRocm91Z2hvdXQgZHlncmFwaHMuXG4vKipcbiAqIENvbnZlcnQgZnJvbSBkYXRhIGNvb3JkaW5hdGVzIHRvIGNhbnZhcy9kaXYgWC9ZIGNvb3JkaW5hdGVzLlxuICogSWYgc3BlY2lmaWVkLCBkbyB0aGlzIGNvbnZlcnNpb24gZm9yIHRoZSBjb29yZGluYXRlIHN5c3RlbSBvZiBhIHBhcnRpY3VsYXJcbiAqIGF4aXMuIFVzZXMgdGhlIGZpcnN0IGF4aXMgYnkgZGVmYXVsdC5cbiAqIFJldHVybnMgYSB0d28tZWxlbWVudCBhcnJheTogW1gsIFldXG4gKlxuICogTm90ZTogdXNlIHRvRG9tWENvb3JkIGluc3RlYWQgb2YgdG9Eb21Db29yZHMoeCwgbnVsbCkgYW5kIHVzZSB0b0RvbVlDb29yZFxuICogaW5zdGVhZCBvZiB0b0RvbUNvb3JkcyhudWxsLCB5LCBheGlzKS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUudG9Eb21Db29yZHMgPSBmdW5jdGlvbih4LCB5LCBheGlzKSB7XG4gIHJldHVybiBbIHRoaXMudG9Eb21YQ29vcmQoeCksIHRoaXMudG9Eb21ZQ29vcmQoeSwgYXhpcykgXTtcbn07XG5cbi8qKlxuICogQ29udmVydCBmcm9tIGRhdGEgeCBjb29yZGluYXRlcyB0byBjYW52YXMvZGl2IFggY29vcmRpbmF0ZS5cbiAqIElmIHNwZWNpZmllZCwgZG8gdGhpcyBjb252ZXJzaW9uIGZvciB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gb2YgYSBwYXJ0aWN1bGFyXG4gKiBheGlzLlxuICogUmV0dXJucyBhIHNpbmdsZSB2YWx1ZSBvciBudWxsIGlmIHggaXMgbnVsbC5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUudG9Eb21YQ29vcmQgPSBmdW5jdGlvbih4KSB7XG4gIGlmICh4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYXJlYSA9IHRoaXMucGxvdHRlcl8uYXJlYTtcbiAgdmFyIHhSYW5nZSA9IHRoaXMueEF4aXNSYW5nZSgpO1xuICByZXR1cm4gYXJlYS54ICsgKHggLSB4UmFuZ2VbMF0pIC8gKHhSYW5nZVsxXSAtIHhSYW5nZVswXSkgKiBhcmVhLnc7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgZnJvbSBkYXRhIHggY29vcmRpbmF0ZXMgdG8gY2FudmFzL2RpdiBZIGNvb3JkaW5hdGUgYW5kIG9wdGlvbmFsXG4gKiBheGlzLiBVc2VzIHRoZSBmaXJzdCBheGlzIGJ5IGRlZmF1bHQuXG4gKlxuICogcmV0dXJucyBhIHNpbmdsZSB2YWx1ZSBvciBudWxsIGlmIHkgaXMgbnVsbC5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUudG9Eb21ZQ29vcmQgPSBmdW5jdGlvbih5LCBheGlzKSB7XG4gIHZhciBwY3QgPSB0aGlzLnRvUGVyY2VudFlDb29yZCh5LCBheGlzKTtcblxuICBpZiAocGN0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGFyZWEgPSB0aGlzLnBsb3R0ZXJfLmFyZWE7XG4gIHJldHVybiBhcmVhLnkgKyBwY3QgKiBhcmVhLmg7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgZnJvbSBjYW52YXMvZGl2IGNvb3JkcyB0byBkYXRhIGNvb3JkaW5hdGVzLlxuICogSWYgc3BlY2lmaWVkLCBkbyB0aGlzIGNvbnZlcnNpb24gZm9yIHRoZSBjb29yZGluYXRlIHN5c3RlbSBvZiBhIHBhcnRpY3VsYXJcbiAqIGF4aXMuIFVzZXMgdGhlIGZpcnN0IGF4aXMgYnkgZGVmYXVsdC5cbiAqIFJldHVybnMgYSB0d28tZWxlbWVudCBhcnJheTogW1gsIFldLlxuICpcbiAqIE5vdGU6IHVzZSB0b0RhdGFYQ29vcmQgaW5zdGVhZCBvZiB0b0RhdGFDb29yZHMoeCwgbnVsbCkgYW5kIHVzZSB0b0RhdGFZQ29vcmRcbiAqIGluc3RlYWQgb2YgdG9EYXRhQ29vcmRzKG51bGwsIHksIGF4aXMpLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS50b0RhdGFDb29yZHMgPSBmdW5jdGlvbih4LCB5LCBheGlzKSB7XG4gIHJldHVybiBbIHRoaXMudG9EYXRhWENvb3JkKHgpLCB0aGlzLnRvRGF0YVlDb29yZCh5LCBheGlzKSBdO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGZyb20gY2FudmFzL2RpdiB4IGNvb3JkaW5hdGUgdG8gZGF0YSBjb29yZGluYXRlLlxuICpcbiAqIElmIHggaXMgbnVsbCwgdGhpcyByZXR1cm5zIG51bGwuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnRvRGF0YVhDb29yZCA9IGZ1bmN0aW9uKHgpIHtcbiAgaWYgKHggPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhcmVhID0gdGhpcy5wbG90dGVyXy5hcmVhO1xuICB2YXIgeFJhbmdlID0gdGhpcy54QXhpc1JhbmdlKCk7XG5cbiAgaWYgKCF0aGlzLmF0dHJpYnV0ZXNfLmdldEZvckF4aXMoXCJsb2dzY2FsZVwiLCAneCcpKSB7XG4gICAgcmV0dXJuIHhSYW5nZVswXSArICh4IC0gYXJlYS54KSAvIGFyZWEudyAqICh4UmFuZ2VbMV0gLSB4UmFuZ2VbMF0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBwY3QgPSAoeCAtIGFyZWEueCkgLyBhcmVhLnc7XG4gICAgcmV0dXJuIHV0aWxzLmxvZ1JhbmdlRnJhY3Rpb24oeFJhbmdlWzBdLCB4UmFuZ2VbMV0sIHBjdCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ29udmVydCBmcm9tIGNhbnZhcy9kaXYgeSBjb29yZCB0byB2YWx1ZS5cbiAqXG4gKiBJZiB5IGlzIG51bGwsIHRoaXMgcmV0dXJucyBudWxsLlxuICogaWYgYXhpcyBpcyBudWxsLCB0aGlzIHVzZXMgdGhlIGZpcnN0IGF4aXMuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnRvRGF0YVlDb29yZCA9IGZ1bmN0aW9uKHksIGF4aXMpIHtcbiAgaWYgKHkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhcmVhID0gdGhpcy5wbG90dGVyXy5hcmVhO1xuICB2YXIgeVJhbmdlID0gdGhpcy55QXhpc1JhbmdlKGF4aXMpO1xuXG4gIGlmICh0eXBlb2YoYXhpcykgPT0gXCJ1bmRlZmluZWRcIikgYXhpcyA9IDA7XG4gIGlmICghdGhpcy5hdHRyaWJ1dGVzXy5nZXRGb3JBeGlzKFwibG9nc2NhbGVcIiwgYXhpcykpIHtcbiAgICByZXR1cm4geVJhbmdlWzBdICsgKGFyZWEueSArIGFyZWEuaCAtIHkpIC8gYXJlYS5oICogKHlSYW5nZVsxXSAtIHlSYW5nZVswXSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcHV0aW5nIHRoZSBpbnZlcnNlIG9mIHRvRG9tQ29vcmQuXG4gICAgdmFyIHBjdCA9ICh5IC0gYXJlYS55KSAvIGFyZWEuaDtcbiAgICAvLyBOb3RlIHJldmVyc2VkIHlSYW5nZSwgeTEgaXMgb24gdG9wIHdpdGggcGN0PT0wLlxuICAgIHJldHVybiB1dGlscy5sb2dSYW5nZUZyYWN0aW9uKHlSYW5nZVsxXSwgeVJhbmdlWzBdLCBwY3QpO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgeSBmb3IgYW4gYXhpcyB0byBhIHBlcmNlbnRhZ2UgZnJvbSB0aGUgdG9wIHRvIHRoZVxuICogYm90dG9tIG9mIHRoZSBkcmF3aW5nIGFyZWEuXG4gKlxuICogSWYgdGhlIGNvb3JkaW5hdGUgcmVwcmVzZW50cyBhIHZhbHVlIHZpc2libGUgb24gdGhlIGNhbnZhcywgdGhlblxuICogdGhlIHZhbHVlIHdpbGwgYmUgYmV0d2VlbiAwIGFuZCAxLCB3aGVyZSAwIGlzIHRoZSB0b3Agb2YgdGhlIGNhbnZhcy5cbiAqIEhvd2V2ZXIsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHZhbHVlcyBvdXRzaWRlIHRoZSByYW5nZSwgYXNcbiAqIHZhbHVlcyBjYW4gZmFsbCBvdXRzaWRlIHRoZSBjYW52YXMuXG4gKlxuICogSWYgeSBpcyBudWxsLCB0aGlzIHJldHVybnMgbnVsbC5cbiAqIGlmIGF4aXMgaXMgbnVsbCwgdGhpcyB1c2VzIHRoZSBmaXJzdCBheGlzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSBkYXRhIHktY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXhpc10gVGhlIGF4aXMgbnVtYmVyIG9uIHdoaWNoIHRoZSBkYXRhIGNvb3JkaW5hdGUgbGl2ZXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgZnJhY3Rpb24gaW4gWzAsIDFdIHdoZXJlIDAgPSB0aGUgdG9wIGVkZ2UuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnRvUGVyY2VudFlDb29yZCA9IGZ1bmN0aW9uKHksIGF4aXMpIHtcbiAgaWYgKHkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodHlwZW9mKGF4aXMpID09IFwidW5kZWZpbmVkXCIpIGF4aXMgPSAwO1xuXG4gIHZhciB5UmFuZ2UgPSB0aGlzLnlBeGlzUmFuZ2UoYXhpcyk7XG5cbiAgdmFyIHBjdDtcbiAgdmFyIGxvZ3NjYWxlID0gdGhpcy5hdHRyaWJ1dGVzXy5nZXRGb3JBeGlzKFwibG9nc2NhbGVcIiwgYXhpcyk7XG4gIGlmIChsb2dzY2FsZSkge1xuICAgIHZhciBsb2dyMCA9IHV0aWxzLmxvZzEwKHlSYW5nZVswXSk7XG4gICAgdmFyIGxvZ3IxID0gdXRpbHMubG9nMTAoeVJhbmdlWzFdKTtcbiAgICBwY3QgPSAobG9ncjEgLSB1dGlscy5sb2cxMCh5KSkgLyAobG9ncjEgLSBsb2dyMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8geVJhbmdlWzFdIC0geSBpcyB1bml0IGRpc3RhbmNlIGZyb20gdGhlIGJvdHRvbS5cbiAgICAvLyB5UmFuZ2VbMV0gLSB5UmFuZ2VbMF0gaXMgdGhlIHNjYWxlIG9mIHRoZSByYW5nZS5cbiAgICAvLyAoeVJhbmdlWzFdIC0geSkgLyAoeVJhbmdlWzFdIC0geVJhbmdlWzBdKSBpcyB0aGUgJSBmcm9tIHRoZSBib3R0b20uXG4gICAgcGN0ID0gKHlSYW5nZVsxXSAtIHkpIC8gKHlSYW5nZVsxXSAtIHlSYW5nZVswXSk7XG4gIH1cbiAgcmV0dXJuIHBjdDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4geCB2YWx1ZSB0byBhIHBlcmNlbnRhZ2UgZnJvbSB0aGUgbGVmdCB0byB0aGUgcmlnaHQgb2ZcbiAqIHRoZSBkcmF3aW5nIGFyZWEuXG4gKlxuICogSWYgdGhlIGNvb3JkaW5hdGUgcmVwcmVzZW50cyBhIHZhbHVlIHZpc2libGUgb24gdGhlIGNhbnZhcywgdGhlblxuICogdGhlIHZhbHVlIHdpbGwgYmUgYmV0d2VlbiAwIGFuZCAxLCB3aGVyZSAwIGlzIHRoZSBsZWZ0IG9mIHRoZSBjYW52YXMuXG4gKiBIb3dldmVyLCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB2YWx1ZXMgb3V0c2lkZSB0aGUgcmFuZ2UsIGFzXG4gKiB2YWx1ZXMgY2FuIGZhbGwgb3V0c2lkZSB0aGUgY2FudmFzLlxuICpcbiAqIElmIHggaXMgbnVsbCwgdGhpcyByZXR1cm5zIG51bGwuXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgZGF0YSB4LWNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgZnJhY3Rpb24gaW4gWzAsIDFdIHdoZXJlIDAgPSB0aGUgbGVmdCBlZGdlLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS50b1BlcmNlbnRYQ29vcmQgPSBmdW5jdGlvbih4KSB7XG4gIGlmICh4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgeFJhbmdlID0gdGhpcy54QXhpc1JhbmdlKCk7XG4gIHZhciBwY3Q7XG4gIHZhciBsb2dzY2FsZSA9IHRoaXMuYXR0cmlidXRlc18uZ2V0Rm9yQXhpcyhcImxvZ3NjYWxlXCIsICd4JykgO1xuICBpZiAobG9nc2NhbGUgPT09IHRydWUpIHsgIC8vIGxvZ3NjYWxlIGNhbiBiZSBudWxsIHNvIHdlIHRlc3QgZm9yIHRydWUgZXhwbGljaXRseS5cbiAgICB2YXIgbG9ncjAgPSB1dGlscy5sb2cxMCh4UmFuZ2VbMF0pO1xuICAgIHZhciBsb2dyMSA9IHV0aWxzLmxvZzEwKHhSYW5nZVsxXSk7XG4gICAgcGN0ID0gKHV0aWxzLmxvZzEwKHgpIC0gbG9ncjApIC8gKGxvZ3IxIC0gbG9ncjApO1xuICB9IGVsc2Uge1xuICAgIC8vIHggLSB4UmFuZ2VbMF0gaXMgdW5pdCBkaXN0YW5jZSBmcm9tIHRoZSBsZWZ0LlxuICAgIC8vIHhSYW5nZVsxXSAtIHhSYW5nZVswXSBpcyB0aGUgc2NhbGUgb2YgdGhlIHJhbmdlLlxuICAgIC8vIFRoZSBmdWxsIGV4cHJlc3Npb24gYmVsb3cgaXMgdGhlICUgZnJvbSB0aGUgbGVmdC5cbiAgICBwY3QgPSAoeCAtIHhSYW5nZVswXSkgLyAoeFJhbmdlWzFdIC0geFJhbmdlWzBdKTtcbiAgfVxuICByZXR1cm4gcGN0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY29sdW1ucyAoaW5jbHVkaW5nIHRoZSBpbmRlcGVuZGVudCB2YXJpYWJsZSkuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY29sdW1ucy5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUubnVtQ29sdW1ucyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMucmF3RGF0YV8pIHJldHVybiAwO1xuICByZXR1cm4gdGhpcy5yYXdEYXRhX1swXSA/IHRoaXMucmF3RGF0YV9bMF0ubGVuZ3RoIDogdGhpcy5hdHRyXyhcImxhYmVsc1wiKS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzIChleGNsdWRpbmcgYW55IGhlYWRlci9sYWJlbCByb3cpLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHJvd3MsIGxlc3MgYW55IGhlYWRlci5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUubnVtUm93cyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMucmF3RGF0YV8pIHJldHVybiAwO1xuICByZXR1cm4gdGhpcy5yYXdEYXRhXy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIGluIHRoZSBnaXZlbiByb3cgYW5kIGNvbHVtbi4gSWYgdGhlIHJvdyBhbmQgY29sdW1uIGV4Y2VlZFxuICogdGhlIGJvdW5kcyBvbiB0aGUgZGF0YSwgcmV0dXJucyBudWxsLiBBbHNvIHJldHVybnMgbnVsbCBpZiB0aGUgdmFsdWUgaXNcbiAqIG1pc3NpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0gcm93IFRoZSByb3cgbnVtYmVyIG9mIHRoZSBkYXRhICgwLWJhc2VkKS4gUm93IDAgaXMgdGhlXG4gKiAgICAgZmlyc3Qgcm93IG9mIGRhdGEsIG5vdCBhIGhlYWRlciByb3cuXG4gKiBAcGFyYW0ge251bWJlcn0gY29sIFRoZSBjb2x1bW4gbnVtYmVyIG9mIHRoZSBkYXRhICgwLWJhc2VkKVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUgaW4gdGhlIHNwZWNpZmllZCBjZWxsIG9yIG51bGwgaWYgdGhlIHJvdy9jb2xcbiAqICAgICB3ZXJlIG91dCBvZiByYW5nZS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbihyb3csIGNvbCkge1xuICBpZiAocm93IDwgMCB8fCByb3cgPiB0aGlzLnJhd0RhdGFfLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gIGlmIChjb2wgPCAwIHx8IGNvbCA+IHRoaXMucmF3RGF0YV9bcm93XS5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gIHJldHVybiB0aGlzLnJhd0RhdGFfW3Jvd11bY29sXTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGludGVyZmFjZSBlbGVtZW50cyBmb3IgdGhlIER5Z3JhcGg6IGEgY29udGFpbmluZyBkaXYsIGEgZGl2IHRvXG4gKiBkaXNwbGF5IHRoZSBjdXJyZW50IHBvaW50LCBhbmQgYSB0ZXh0Ym94IHRvIGFkanVzdCB0aGUgcm9sbGluZyBhdmVyYWdlXG4gKiBwZXJpb2QuIEFsc28gY3JlYXRlcyB0aGUgUmVuZGVyZXIvTGF5b3V0IGVsZW1lbnRzLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuY3JlYXRlSW50ZXJmYWNlXyA9IGZ1bmN0aW9uKCkge1xuICAvLyBDcmVhdGUgdGhlIGFsbC1lbmNsb3NpbmcgZ3JhcGggZGl2XG4gIHZhciBlbmNsb3NpbmcgPSB0aGlzLm1haW5kaXZfO1xuXG4gIHRoaXMuZ3JhcGhEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gIC8vIFRPRE8oZGFudmspOiBhbnkgb3RoZXIgc3R5bGVzIHRoYXQgYXJlIHVzZWZ1bCB0byBzZXQgaGVyZT9cbiAgdGhpcy5ncmFwaERpdi5zdHlsZS50ZXh0QWxpZ24gPSAnbGVmdCc7ICAvLyBUaGlzIGlzIGEgQ1NTIFwicmVzZXRcIlxuICB0aGlzLmdyYXBoRGl2LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgZW5jbG9zaW5nLmFwcGVuZENoaWxkKHRoaXMuZ3JhcGhEaXYpO1xuXG4gIC8vIENyZWF0ZSB0aGUgY2FudmFzIGZvciBpbnRlcmFjdGl2ZSBwYXJ0cyBvZiB0aGUgY2hhcnQuXG4gIHRoaXMuY2FudmFzXyA9IHV0aWxzLmNyZWF0ZUNhbnZhcygpO1xuICB0aGlzLmNhbnZhc18uc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cbiAgLy8gLi4uIGFuZCBmb3Igc3RhdGljIHBhcnRzIG9mIHRoZSBjaGFydC5cbiAgdGhpcy5oaWRkZW5fID0gdGhpcy5jcmVhdGVQbG90S2l0Q2FudmFzXyh0aGlzLmNhbnZhc18pO1xuXG4gIHRoaXMuY2FudmFzX2N0eF8gPSB1dGlscy5nZXRDb250ZXh0KHRoaXMuY2FudmFzXyk7XG4gIHRoaXMuaGlkZGVuX2N0eF8gPSB1dGlscy5nZXRDb250ZXh0KHRoaXMuaGlkZGVuXyk7XG5cbiAgdGhpcy5yZXNpemVFbGVtZW50c18oKTtcblxuICAvLyBUaGUgaW50ZXJhY3RpdmUgcGFydHMgb2YgdGhlIGdyYXBoIGFyZSBkcmF3biBvbiB0b3Agb2YgdGhlIGNoYXJ0LlxuICB0aGlzLmdyYXBoRGl2LmFwcGVuZENoaWxkKHRoaXMuaGlkZGVuXyk7XG4gIHRoaXMuZ3JhcGhEaXYuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXNfKTtcbiAgdGhpcy5tb3VzZUV2ZW50RWxlbWVudF8gPSB0aGlzLmNyZWF0ZU1vdXNlRXZlbnRFbGVtZW50XygpO1xuXG4gIC8vIENyZWF0ZSB0aGUgZ3JhcGhlclxuICB0aGlzLmxheW91dF8gPSBuZXcgRHlncmFwaExheW91dCh0aGlzKTtcblxuICB2YXIgZHlncmFwaCA9IHRoaXM7XG5cbiAgdGhpcy5tb3VzZU1vdmVIYW5kbGVyXyA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkeWdyYXBoLm1vdXNlTW92ZV8oZSk7XG4gIH07XG5cbiAgdGhpcy5tb3VzZU91dEhhbmRsZXJfID0gZnVuY3Rpb24oZSkge1xuICAgIC8vIFRoZSBtb3VzZSBoYXMgbGVmdCB0aGUgY2hhcnQgaWY6XG4gICAgLy8gMS4gZS50YXJnZXQgaXMgaW5zaWRlIHRoZSBjaGFydFxuICAgIC8vIDIuIGUucmVsYXRlZFRhcmdldCBpcyBvdXRzaWRlIHRoZSBjaGFydFxuICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLmZyb21FbGVtZW50O1xuICAgIHZhciByZWxhdGVkVGFyZ2V0ID0gZS5yZWxhdGVkVGFyZ2V0IHx8IGUudG9FbGVtZW50O1xuICAgIGlmICh1dGlscy5pc05vZGVDb250YWluZWRCeSh0YXJnZXQsIGR5Z3JhcGguZ3JhcGhEaXYpICYmXG4gICAgICAgICF1dGlscy5pc05vZGVDb250YWluZWRCeShyZWxhdGVkVGFyZ2V0LCBkeWdyYXBoLmdyYXBoRGl2KSkge1xuICAgICAgZHlncmFwaC5tb3VzZU91dF8oZSk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuYWRkQW5kVHJhY2tFdmVudCh3aW5kb3csICdtb3VzZW91dCcsIHRoaXMubW91c2VPdXRIYW5kbGVyXyk7XG4gIHRoaXMuYWRkQW5kVHJhY2tFdmVudCh0aGlzLm1vdXNlRXZlbnRFbGVtZW50XywgJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlSGFuZGxlcl8pO1xuXG4gIC8vIERvbid0IHJlY3JlYXRlIGFuZCByZWdpc3RlciB0aGUgcmVzaXplIGhhbmRsZXIgb24gc3Vic2VxdWVudCBjYWxscy5cbiAgLy8gVGhpcyBoYXBwZW5zIHdoZW4gdGhlIGdyYXBoIGlzIHJlc2l6ZWQuXG4gIGlmICghdGhpcy5yZXNpemVIYW5kbGVyXykge1xuICAgIHRoaXMucmVzaXplSGFuZGxlcl8gPSBmdW5jdGlvbihlKSB7XG4gICAgICBkeWdyYXBoLnJlc2l6ZSgpO1xuICAgIH07XG5cbiAgICAvLyBVcGRhdGUgd2hlbiB0aGUgd2luZG93IGlzIHJlc2l6ZWQuXG4gICAgLy8gVE9ETyhkYW52ayk6IGRyb3AgZnJhbWVzIGRlcGVuZGluZyBvbiBjb21wbGV4aXR5IG9mIHRoZSBjaGFydC5cbiAgICB0aGlzLmFkZEFuZFRyYWNrRXZlbnQod2luZG93LCAncmVzaXplJywgdGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gIH1cbn07XG5cbkR5Z3JhcGgucHJvdG90eXBlLnJlc2l6ZUVsZW1lbnRzXyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdyYXBoRGl2LnN0eWxlLndpZHRoID0gdGhpcy53aWR0aF8gKyBcInB4XCI7XG4gIHRoaXMuZ3JhcGhEaXYuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHRfICsgXCJweFwiO1xuXG4gIHZhciBwaXhlbFJhdGlvT3B0aW9uID0gdGhpcy5nZXROdW1lcmljT3B0aW9uKCdwaXhlbFJhdGlvJylcblxuICB2YXIgY2FudmFzU2NhbGUgPSBwaXhlbFJhdGlvT3B0aW9uIHx8IHV0aWxzLmdldENvbnRleHRQaXhlbFJhdGlvKHRoaXMuY2FudmFzX2N0eF8pO1xuICB0aGlzLmNhbnZhc18ud2lkdGggPSB0aGlzLndpZHRoXyAqIGNhbnZhc1NjYWxlO1xuICB0aGlzLmNhbnZhc18uaGVpZ2h0ID0gdGhpcy5oZWlnaHRfICogY2FudmFzU2NhbGU7XG4gIHRoaXMuY2FudmFzXy5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGhfICsgXCJweFwiOyAgICAvLyBmb3IgSUVcbiAgdGhpcy5jYW52YXNfLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0XyArIFwicHhcIjsgIC8vIGZvciBJRVxuICBpZiAoY2FudmFzU2NhbGUgIT09IDEpIHtcbiAgICB0aGlzLmNhbnZhc19jdHhfLnNjYWxlKGNhbnZhc1NjYWxlLCBjYW52YXNTY2FsZSk7XG4gIH1cblxuICB2YXIgaGlkZGVuU2NhbGUgPSBwaXhlbFJhdGlvT3B0aW9uIHx8IHV0aWxzLmdldENvbnRleHRQaXhlbFJhdGlvKHRoaXMuaGlkZGVuX2N0eF8pO1xuICB0aGlzLmhpZGRlbl8ud2lkdGggPSB0aGlzLndpZHRoXyAqIGhpZGRlblNjYWxlO1xuICB0aGlzLmhpZGRlbl8uaGVpZ2h0ID0gdGhpcy5oZWlnaHRfICogaGlkZGVuU2NhbGU7XG4gIHRoaXMuaGlkZGVuXy5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGhfICsgXCJweFwiOyAgICAvLyBmb3IgSUVcbiAgdGhpcy5oaWRkZW5fLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0XyArIFwicHhcIjsgIC8vIGZvciBJRVxuICBpZiAoaGlkZGVuU2NhbGUgIT09IDEpIHtcbiAgICB0aGlzLmhpZGRlbl9jdHhfLnNjYWxlKGhpZGRlblNjYWxlLCBoaWRkZW5TY2FsZSk7XG4gIH1cbn07XG5cbi8qKlxuICogRGV0YWNoIERPTSBlbGVtZW50cyBpbiB0aGUgZHlncmFwaCBhbmQgbnVsbCBvdXQgYWxsIGRhdGEgcmVmZXJlbmNlcy5cbiAqIENhbGxpbmcgdGhpcyB3aGVuIHlvdSdyZSBkb25lIHdpdGggYSBkeWdyYXBoIGNhbiBkcmFtYXRpY2FsbHkgcmVkdWNlIG1lbW9yeVxuICogdXNhZ2UuIFNlZSwgZS5nLiwgdGhlIHRlc3RzL3BlcmYuaHRtbCBleGFtcGxlLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY2FudmFzX2N0eF8ucmVzdG9yZSgpO1xuICB0aGlzLmhpZGRlbl9jdHhfLnJlc3RvcmUoKTtcblxuICAvLyBEZXN0cm95IGFueSBwbHVnaW5zLCBpbiB0aGUgcmV2ZXJzZSBvcmRlciB0aGF0IHRoZXkgd2VyZSByZWdpc3RlcmVkLlxuICBmb3IgKHZhciBpID0gdGhpcy5wbHVnaW5zXy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBwID0gdGhpcy5wbHVnaW5zXy5wb3AoKTtcbiAgICBpZiAocC5wbHVnaW4uZGVzdHJveSkgcC5wbHVnaW4uZGVzdHJveSgpO1xuICB9XG5cbiAgdmFyIHJlbW92ZVJlY3Vyc2l2ZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIHJlbW92ZVJlY3Vyc2l2ZShub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLnJlbW92ZVRyYWNrZWRFdmVudHNfKCk7XG5cbiAgLy8gcmVtb3ZlIG1vdXNlIGV2ZW50IGhhbmRsZXJzIChUaGlzIG1heSBub3QgYmUgbmVjZXNzYXJ5IGFueW1vcmUpXG4gIHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ21vdXNlb3V0JywgdGhpcy5tb3VzZU91dEhhbmRsZXJfKTtcbiAgdXRpbHMucmVtb3ZlRXZlbnQodGhpcy5tb3VzZUV2ZW50RWxlbWVudF8sICdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlTW92ZUhhbmRsZXJfKTtcblxuICAvLyByZW1vdmUgd2luZG93IGhhbmRsZXJzXG4gIHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywncmVzaXplJywgdGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gIHRoaXMucmVzaXplSGFuZGxlcl8gPSBudWxsO1xuXG4gIHJlbW92ZVJlY3Vyc2l2ZSh0aGlzLm1haW5kaXZfKTtcblxuICB2YXIgbnVsbE91dCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGZvciAodmFyIG4gaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mKG9ialtuXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9ialtuXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBUaGVzZSBtYXkgbm90IGFsbCBiZSBuZWNlc3NhcnksIGJ1dCBpdCBjYW4ndCBodXJ0Li4uXG4gIG51bGxPdXQodGhpcy5sYXlvdXRfKTtcbiAgbnVsbE91dCh0aGlzLnBsb3R0ZXJfKTtcbiAgbnVsbE91dCh0aGlzKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgY2FudmFzIG9uIHdoaWNoIHRoZSBjaGFydCB3aWxsIGJlIGRyYXduLiBPbmx5IHRoZSBSZW5kZXJlciBldmVyXG4gKiBkcmF3cyBvbiB0aGlzIHBhcnRpY3VsYXIgY2FudmFzLiBBbGwgRHlncmFwaCB3b3JrIChpLmUuIGRyYXdpbmcgaG92ZXIgZG90c1xuICogb3IgdGhlIHpvb20gcmVjdGFuZ2xlcykgaXMgZG9uZSBvbiB0aGlzLmNhbnZhc18uXG4gKiBAcGFyYW0ge09iamVjdH0gY2FudmFzIFRoZSBEeWdyYXBoIGNhbnZhcyBvdmVyIHdoaWNoIHRvIG92ZXJsYXkgdGhlIHBsb3RcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ld2x5LWNyZWF0ZWQgY2FudmFzXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5jcmVhdGVQbG90S2l0Q2FudmFzXyA9IGZ1bmN0aW9uKGNhbnZhcykge1xuICB2YXIgaCA9IHV0aWxzLmNyZWF0ZUNhbnZhcygpO1xuICBoLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAvLyBUT0RPKGRhbnZrKTogaCBzaG91bGQgYmUgb2Zmc2V0IGZyb20gY2FudmFzLiBjYW52YXMgbmVlZHMgdG8gaW5jbHVkZVxuICAvLyBzb21lIGV4dHJhIGFyZWEgdG8gbWFrZSBpdCBlYXNpZXIgdG8gem9vbSBpbiBvbiB0aGUgZmFyIGxlZnQgYW5kIGZhclxuICAvLyByaWdodC4gaCBuZWVkcyB0byBiZSBwcmVjaXNlbHkgdGhlIHBsb3QgYXJlYSwgc28gdGhhdCBjbGlwcGluZyBvY2N1cnMuXG4gIGguc3R5bGUudG9wID0gY2FudmFzLnN0eWxlLnRvcDtcbiAgaC5zdHlsZS5sZWZ0ID0gY2FudmFzLnN0eWxlLmxlZnQ7XG4gIGgud2lkdGggPSB0aGlzLndpZHRoXztcbiAgaC5oZWlnaHQgPSB0aGlzLmhlaWdodF87XG4gIGguc3R5bGUud2lkdGggPSB0aGlzLndpZHRoXyArIFwicHhcIjsgICAgLy8gZm9yIElFXG4gIGguc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHRfICsgXCJweFwiOyAgLy8gZm9yIElFXG4gIHJldHVybiBoO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG92ZXJsYXkgZWxlbWVudCB1c2VkIHRvIGhhbmRsZSBtb3VzZSBldmVudHMuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtb3VzZSBldmVudCBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuY3JlYXRlTW91c2VFdmVudEVsZW1lbnRfID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNhbnZhc187XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc2V0IG9mIGRpc3RpbmN0IGNvbG9ycyBmb3IgdGhlIGRhdGEgc2VyaWVzLiBUaGlzIGlzIGRvbmUgd2l0aCBhXG4gKiBjb2xvciB3aGVlbC4gU2F0dXJhdGlvbi9WYWx1ZSBhcmUgY3VzdG9taXphYmxlLCBhbmQgdGhlIGh1ZSBpc1xuICogZXF1YWxseS1zcGFjZWQgYXJvdW5kIHRoZSBjb2xvciB3aGVlbC4gSWYgYSBjdXN0b20gc2V0IG9mIGNvbG9ycyBpc1xuICogc3BlY2lmaWVkLCB0aGF0IGlzIHVzZWQgaW5zdGVhZC5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnNldENvbG9yc18gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gIHZhciBudW0gPSBsYWJlbHMubGVuZ3RoIC0gMTtcbiAgdGhpcy5jb2xvcnNfID0gW107XG4gIHRoaXMuY29sb3JzTWFwXyA9IHt9O1xuXG4gIC8vIFRoZXNlIGFyZSB1c2VkIGZvciB3aGVuIG5vIGN1c3RvbSBjb2xvcnMgYXJlIHNwZWNpZmllZC5cbiAgdmFyIHNhdCA9IHRoaXMuZ2V0TnVtZXJpY09wdGlvbignY29sb3JTYXR1cmF0aW9uJykgfHwgMS4wO1xuICB2YXIgdmFsID0gdGhpcy5nZXROdW1lcmljT3B0aW9uKCdjb2xvclZhbHVlJykgfHwgMC41O1xuICB2YXIgaGFsZiA9IE1hdGguY2VpbChudW0gLyAyKTtcblxuICB2YXIgY29sb3JzID0gdGhpcy5nZXRPcHRpb24oJ2NvbG9ycycpO1xuICB2YXIgdmlzaWJpbGl0eSA9IHRoaXMudmlzaWJpbGl0eSgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgaWYgKCF2aXNpYmlsaXR5W2ldKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGxhYmVsID0gbGFiZWxzW2kgKyAxXTtcbiAgICB2YXIgY29sb3JTdHIgPSB0aGlzLmF0dHJpYnV0ZXNfLmdldEZvclNlcmllcygnY29sb3InLCBsYWJlbCk7XG4gICAgaWYgKCFjb2xvclN0cikge1xuICAgICAgaWYgKGNvbG9ycykge1xuICAgICAgICBjb2xvclN0ciA9IGNvbG9yc1tpICUgY29sb3JzLmxlbmd0aF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhbHRlcm5hdGUgY29sb3JzIGZvciBoaWdoIGNvbnRyYXN0LlxuICAgICAgICB2YXIgaWR4ID0gaSAlIDIgPyAoaGFsZiArIChpICsgMSkvIDIpIDogTWF0aC5jZWlsKChpICsgMSkgLyAyKTtcbiAgICAgICAgdmFyIGh1ZSA9ICgxLjAgKiBpZHggLyAoMSArIG51bSkpO1xuICAgICAgICBjb2xvclN0ciA9IHV0aWxzLmhzdlRvUkdCKGh1ZSwgc2F0LCB2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbG9yc18ucHVzaChjb2xvclN0cik7XG4gICAgdGhpcy5jb2xvcnNNYXBfW2xhYmVsXSA9IGNvbG9yU3RyO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdCBvZiBjb2xvcnMuIFRoaXMgaXMgZWl0aGVyIHRoZSBsaXN0IG9mIGNvbG9ycyBwYXNzZWQgaW4gdGhlXG4gKiBhdHRyaWJ1dGVzIG9yIHRoZSBhdXRvZ2VuZXJhdGVkIGxpc3Qgb2YgcmdiKHIsZyxiKSBzdHJpbmdzLlxuICogVGhpcyBkb2VzIG5vdCByZXR1cm4gY29sb3JzIGZvciBpbnZpc2libGUgc2VyaWVzLlxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IFRoZSBsaXN0IG9mIGNvbG9ycy5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0Q29sb3JzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvbG9yc187XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmZXcgYXR0cmlidXRlcyBvZiBhIHNlcmllcywgaS5lLiBpdHMgY29sb3IsIGl0cyB2aXNpYmlsaXR5LCB3aGljaFxuICogYXhpcyBpdCdzIGFzc2lnbmVkIHRvLCBhbmQgaXRzIGNvbHVtbiBpbiB0aGUgb3JpZ2luYWwgZGF0YS5cbiAqIFJldHVybnMgbnVsbCBpZiB0aGUgc2VyaWVzIGRvZXMgbm90IGV4aXN0LlxuICogT3RoZXJ3aXNlLCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGNvbHVtbiwgdmlzaWJpbGl0eSwgY29sb3IgYW5kIGF4aXMgcHJvcGVydGllcy5cbiAqIFRoZSBcImF4aXNcIiBwcm9wZXJ0eSB3aWxsIGJlIHNldCB0byAxIGZvciB5MSBhbmQgMiBmb3IgeTIuXG4gKiBUaGUgXCJjb2x1bW5cIiBwcm9wZXJ0eSBjYW4gYmUgZmVkIGJhY2sgaW50byBnZXRWYWx1ZShyb3csIGNvbHVtbikgdG8gZ2V0XG4gKiB2YWx1ZXMgZm9yIHRoaXMgc2VyaWVzLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRQcm9wZXJ0aWVzRm9yU2VyaWVzID0gZnVuY3Rpb24oc2VyaWVzX25hbWUpIHtcbiAgdmFyIGlkeCA9IC0xO1xuICB2YXIgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobGFiZWxzW2ldID09IHNlcmllc19uYW1lKSB7XG4gICAgICBpZHggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChpZHggPT0gLTEpIHJldHVybiBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogc2VyaWVzX25hbWUsXG4gICAgY29sdW1uOiBpZHgsXG4gICAgdmlzaWJsZTogdGhpcy52aXNpYmlsaXR5KClbaWR4IC0gMV0sXG4gICAgY29sb3I6IHRoaXMuY29sb3JzTWFwX1tzZXJpZXNfbmFtZV0sXG4gICAgYXhpczogMSArIHRoaXMuYXR0cmlidXRlc18uYXhpc0ZvclNlcmllcyhzZXJpZXNfbmFtZSlcbiAgfTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSB0ZXh0IGJveCB0byBhZGp1c3QgdGhlIGF2ZXJhZ2luZyBwZXJpb2RcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmNyZWF0ZVJvbGxJbnRlcmZhY2VfID0gZnVuY3Rpb24oKSB7XG4gIC8vIENyZWF0ZSBhIHJvbGxlciBpZiBvbmUgZG9lc24ndCBleGlzdCBhbHJlYWR5LlxuICB2YXIgcm9sbGVyID0gdGhpcy5yb2xsZXJfO1xuICBpZiAoIXJvbGxlcikge1xuICAgIHRoaXMucm9sbGVyXyA9IHJvbGxlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICByb2xsZXIudHlwZSA9IFwidGV4dFwiO1xuICAgIHJvbGxlci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgcm9sbGVyLmNsYXNzTmFtZSA9ICdkeWdyYXBoLXJvbGxlcic7XG4gICAgdGhpcy5ncmFwaERpdi5hcHBlbmRDaGlsZChyb2xsZXIpO1xuICB9XG5cbiAgdmFyIGRpc3BsYXkgPSB0aGlzLmdldEJvb2xlYW5PcHRpb24oJ3Nob3dSb2xsZXInKSA/ICdibG9jaycgOiAnbm9uZSc7XG5cbiAgdmFyIGFyZWEgPSB0aGlzLmdldEFyZWEoKTtcbiAgdmFyIHRleHRBdHRyID0ge1xuICAgICAgICAgICAgICAgICAgIFwidG9wXCI6IChhcmVhLnkgKyBhcmVhLmggLSAyNSkgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgICAgXCJsZWZ0XCI6IChhcmVhLnggKyAxKSArIFwicHhcIixcbiAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogZGlzcGxheVxuICAgICAgICAgICAgICAgICB9O1xuICByb2xsZXIuc2l6ZSA9IFwiMlwiO1xuICByb2xsZXIudmFsdWUgPSB0aGlzLnJvbGxQZXJpb2RfO1xuICB1dGlscy51cGRhdGUocm9sbGVyLnN0eWxlLCB0ZXh0QXR0cik7XG5cbiAgcm9sbGVyLm9uY2hhbmdlID0gKCkgPT4gdGhpcy5hZGp1c3RSb2xsKHJvbGxlci52YWx1ZSk7XG59O1xuXG4vKipcbiAqIFNldCB1cCBhbGwgdGhlIG1vdXNlIGhhbmRsZXJzIG5lZWRlZCB0byBjYXB0dXJlIGRyYWdnaW5nIGJlaGF2aW9yIGZvciB6b29tXG4gKiBldmVudHMuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5jcmVhdGVEcmFnSW50ZXJmYWNlXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29udGV4dCA9IHtcbiAgICAvLyBUcmFja3Mgd2hldGhlciB0aGUgbW91c2UgaXMgZG93biByaWdodCBub3dcbiAgICBpc1pvb21pbmc6IGZhbHNlLFxuICAgIGlzUGFubmluZzogZmFsc2UsICAvLyBpcyB0aGlzIGRyYWcgcGFydCBvZiBhIHBhbj9cbiAgICBpczJEUGFuOiBmYWxzZSwgICAgLy8gaWYgc28sIGlzIHRoYXQgcGFuIDEtIG9yIDItZGltZW5zaW9uYWw/XG4gICAgZHJhZ1N0YXJ0WDogbnVsbCwgLy8gcGl4ZWwgY29vcmRpbmF0ZXNcbiAgICBkcmFnU3RhcnRZOiBudWxsLCAvLyBwaXhlbCBjb29yZGluYXRlc1xuICAgIGRyYWdFbmRYOiBudWxsLCAvLyBwaXhlbCBjb29yZGluYXRlc1xuICAgIGRyYWdFbmRZOiBudWxsLCAvLyBwaXhlbCBjb29yZGluYXRlc1xuICAgIGRyYWdEaXJlY3Rpb246IG51bGwsXG4gICAgcHJldkVuZFg6IG51bGwsIC8vIHBpeGVsIGNvb3JkaW5hdGVzXG4gICAgcHJldkVuZFk6IG51bGwsIC8vIHBpeGVsIGNvb3JkaW5hdGVzXG4gICAgcHJldkRyYWdEaXJlY3Rpb246IG51bGwsXG4gICAgY2FuY2VsTmV4dERibGNsaWNrOiBmYWxzZSwgIC8vIHNlZSBjb21tZW50IGluIGR5Z3JhcGgtaW50ZXJhY3Rpb24tbW9kZWwuanNcblxuICAgIC8vIFRoZSB2YWx1ZSBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBncmFwaCB3aGVuIGEgcGFuIG9wZXJhdGlvbiBzdGFydHMuXG4gICAgaW5pdGlhbExlZnRtb3N0RGF0ZTogbnVsbCxcblxuICAgIC8vIFRoZSBudW1iZXIgb2YgdW5pdHMgZWFjaCBwaXhlbCBzcGFucy4gKFRoaXMgd29uJ3QgYmUgdmFsaWQgZm9yIGxvZ1xuICAgIC8vIHNjYWxlcylcbiAgICB4VW5pdHNQZXJQaXhlbDogbnVsbCxcblxuICAgIC8vIFRPRE8oZGFudmspOiB1cGRhdGUgdGhpcyBjb21tZW50XG4gICAgLy8gVGhlIHJhbmdlIGluIHNlY29uZC92YWx1ZSB1bml0cyB0aGF0IHRoZSB2aWV3cG9ydCBlbmNvbXBhc3NlcyBkdXJpbmcgYVxuICAgIC8vIHBhbm5pbmcgb3BlcmF0aW9uLlxuICAgIGRhdGVSYW5nZTogbnVsbCxcblxuICAgIC8vIFRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzLCBpbiBET00gY29vcmRzXG4gICAgLy8gVE9ETyhrb25pZ3NiZXJnKTogUmVuYW1lIHRvcExlZnRDYW52YXNYLCB0b3BMZWZ0Q2FudmFzWS5cbiAgICBweDogMCxcbiAgICBweTogMCxcblxuICAgIC8vIFZhbHVlcyBmb3IgdXNlIHdpdGggcGFuRWRnZUZyYWN0aW9uLCB3aGljaCBsaW1pdCBob3cgZmFyIG91dHNpZGUgdGhlXG4gICAgLy8gZ3JhcGgncyBkYXRhIGJvdW5kYXJpZXMgaXQgY2FuIGJlIHBhbm5lZC5cbiAgICBib3VuZGVkRGF0ZXM6IG51bGwsIC8vIFttaW5EYXRlLCBtYXhEYXRlXVxuICAgIGJvdW5kZWRWYWx1ZXM6IG51bGwsIC8vIFtbbWluVmFsdWUsIG1heFZhbHVlXSAuLi5dXG5cbiAgICAvLyBXZSBjb3ZlciBpZnJhbWVzIGR1cmluZyBtb3VzZSBpbnRlcmFjdGlvbnMuIFNlZSBjb21tZW50cyBpblxuICAgIC8vIGR5Z3JhcGgtdXRpbHMuanMgZm9yIG1vcmUgaW5mbyBvbiB3aHkgdGhpcyBpcyBhIGdvb2QgaWRlYS5cbiAgICB0YXJwOiBuZXcgSUZyYW1lVGFycCgpLFxuXG4gICAgLy8gY29udGV4dEIgaXMgdGhlIHNhbWUgdGhpbmcgYXMgdGhpcyBjb250ZXh0IG9iamVjdCBidXQgcmVuYW1lZC5cbiAgICBpbml0aWFsaXplTW91c2VEb3duOiBmdW5jdGlvbihldmVudCwgZywgY29udGV4dEIpIHtcbiAgICAgIC8vIHByZXZlbnRzIG1vdXNlIGRyYWdzIGZyb20gc2VsZWN0aW5nIHBhZ2UgdGV4dC5cbiAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAgLy8gRmlyZWZveCwgQ2hyb21lLCBldGMuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlOyAgLy8gSUVcbiAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhbnZhc1BvcyA9IHV0aWxzLmZpbmRQb3MoZy5jYW52YXNfKTtcbiAgICAgIGNvbnRleHRCLnB4ID0gY2FudmFzUG9zLng7XG4gICAgICBjb250ZXh0Qi5weSA9IGNhbnZhc1Bvcy55O1xuICAgICAgY29udGV4dEIuZHJhZ1N0YXJ0WCA9IHV0aWxzLmRyYWdHZXRYXyhldmVudCwgY29udGV4dEIpO1xuICAgICAgY29udGV4dEIuZHJhZ1N0YXJ0WSA9IHV0aWxzLmRyYWdHZXRZXyhldmVudCwgY29udGV4dEIpO1xuICAgICAgY29udGV4dEIuY2FuY2VsTmV4dERibGNsaWNrID0gZmFsc2U7XG4gICAgICBjb250ZXh0Qi50YXJwLmNvdmVyKCk7XG4gICAgfSxcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGlmIChjb250ZXh0LmlzWm9vbWluZyB8fCBjb250ZXh0LmlzUGFubmluZykge1xuICAgICAgICBjb250ZXh0LmlzWm9vbWluZyA9IGZhbHNlO1xuICAgICAgICBjb250ZXh0LmRyYWdTdGFydFggPSBudWxsO1xuICAgICAgICBjb250ZXh0LmRyYWdTdGFydFkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGV4dC5pc1Bhbm5pbmcpIHtcbiAgICAgICAgY29udGV4dC5pc1Bhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgY29udGV4dC5kcmFnZ2luZ0RhdGUgPSBudWxsO1xuICAgICAgICBjb250ZXh0LmRhdGVSYW5nZSA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5heGVzXy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRlbGV0ZSBzZWxmLmF4ZXNfW2ldLmRyYWdnaW5nVmFsdWU7XG4gICAgICAgICAgZGVsZXRlIHNlbGYuYXhlc19baV0uZHJhZ1ZhbHVlUmFuZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29udGV4dC50YXJwLnVuY292ZXIoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGludGVyYWN0aW9uTW9kZWwgPSB0aGlzLmdldE9wdGlvbihcImludGVyYWN0aW9uTW9kZWxcIik7XG5cbiAgLy8gU2VsZiBpcyB0aGUgZ3JhcGguXG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBGdW5jdGlvbiB0aGF0IGJpbmRzIHRoZSBncmFwaCBhbmQgY29udGV4dCB0byB0aGUgaGFuZGxlci5cbiAgdmFyIGJpbmRIYW5kbGVyID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICAgIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgICAgaGFuZGxlcihldmVudCwgc2VsZiwgY29udGV4dCk7XG4gICAgfTtcbiAgfTtcblxuICBmb3IgKHZhciBldmVudE5hbWUgaW4gaW50ZXJhY3Rpb25Nb2RlbCkge1xuICAgIGlmICghaW50ZXJhY3Rpb25Nb2RlbC5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSBjb250aW51ZTtcbiAgICB0aGlzLmFkZEFuZFRyYWNrRXZlbnQodGhpcy5tb3VzZUV2ZW50RWxlbWVudF8sIGV2ZW50TmFtZSxcbiAgICAgICAgYmluZEhhbmRsZXIoaW50ZXJhY3Rpb25Nb2RlbFtldmVudE5hbWVdKSk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciByZWxlYXNlcyB0aGUgbW91c2UgYnV0dG9uIGR1cmluZyBhIGRyYWcsIGJ1dCBub3Qgb3ZlciB0aGVcbiAgLy8gY2FudmFzLCB0aGVuIGl0IGRvZXNuJ3QgY291bnQgYXMgYSB6b29taW5nIGFjdGlvbi5cbiAgaWYgKCFpbnRlcmFjdGlvbk1vZGVsLndpbGxEZXN0cm95Q29udGV4dE15c2VsZikge1xuICAgIHZhciBtb3VzZVVwSGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBjb250ZXh0LmRlc3Ryb3koKTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRBbmRUcmFja0V2ZW50KGRvY3VtZW50LCAnbW91c2V1cCcsIG1vdXNlVXBIYW5kbGVyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEcmF3IGEgZ3JheSB6b29tIHJlY3RhbmdsZSBvdmVyIHRoZSBkZXNpcmVkIGFyZWEgb2YgdGhlIGNhbnZhcy4gQWxzbyBjbGVhcnNcbiAqIHVwIGFueSBwcmV2aW91cyB6b29tIHJlY3RhbmdsZXMgdGhhdCB3ZXJlIGRyYXduLiBUaGlzIGNvdWxkIGJlIG9wdGltaXplZCB0b1xuICogYXZvaWQgZXh0cmEgcmVkcmF3aW5nLCBidXQgaXQncyB0cmlja3kgdG8gYXZvaWQgaW50ZXJhY3Rpb25zIHdpdGggdGhlIHN0YXR1c1xuICogZG90cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZGlyZWN0aW9uIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHpvb20gcmVjdGFuZ2xlLiBBY2NlcHRhYmxlXG4gKiAgICAgdmFsdWVzIGFyZSB1dGlscy5IT1JJWk9OVEFMIGFuZCB1dGlscy5WRVJUSUNBTC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFggVGhlIFggcG9zaXRpb24gd2hlcmUgdGhlIGRyYWcgc3RhcnRlZCwgaW4gY2FudmFzXG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kWCBUaGUgY3VycmVudCBYIHBvc2l0aW9uIG9mIHRoZSBkcmFnLCBpbiBjYW52YXMgY29vcmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0WSBUaGUgWSBwb3NpdGlvbiB3aGVyZSB0aGUgZHJhZyBzdGFydGVkLCBpbiBjYW52YXNcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRZIFRoZSBjdXJyZW50IFkgcG9zaXRpb24gb2YgdGhlIGRyYWcsIGluIGNhbnZhcyBjb29yZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gcHJldkRpcmVjdGlvbiB0aGUgdmFsdWUgb2YgZGlyZWN0aW9uIG9uIHRoZSBwcmV2aW91cyBjYWxsIHRvXG4gKiAgICAgdGhpcyBmdW5jdGlvbi4gVXNlZCB0byBhdm9pZCBleGNlc3MgcmVkcmF3aW5nXG4gKiBAcGFyYW0ge251bWJlcn0gcHJldkVuZFggVGhlIHZhbHVlIG9mIGVuZFggb24gdGhlIHByZXZpb3VzIGNhbGwgdG8gdGhpc1xuICogICAgIGZ1bmN0aW9uLiBVc2VkIHRvIGF2b2lkIGV4Y2VzcyByZWRyYXdpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcmV2RW5kWSBUaGUgdmFsdWUgb2YgZW5kWSBvbiB0aGUgcHJldmlvdXMgY2FsbCB0byB0aGlzXG4gKiAgICAgZnVuY3Rpb24uIFVzZWQgdG8gYXZvaWQgZXhjZXNzIHJlZHJhd2luZ1xuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZHJhd1pvb21SZWN0XyA9IGZ1bmN0aW9uKGRpcmVjdGlvbiwgc3RhcnRYLCBlbmRYLCBzdGFydFksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kWSwgcHJldkRpcmVjdGlvbiwgcHJldkVuZFgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldkVuZFkpIHtcbiAgdmFyIGN0eCA9IHRoaXMuY2FudmFzX2N0eF87XG5cbiAgLy8gQ2xlYW4gdXAgZnJvbSB0aGUgcHJldmlvdXMgcmVjdCBpZiBuZWNlc3NhcnlcbiAgaWYgKHByZXZEaXJlY3Rpb24gPT0gdXRpbHMuSE9SSVpPTlRBTCkge1xuICAgIGN0eC5jbGVhclJlY3QoTWF0aC5taW4oc3RhcnRYLCBwcmV2RW5kWCksIHRoaXMubGF5b3V0Xy5nZXRQbG90QXJlYSgpLnksXG4gICAgICAgICAgICAgICAgICBNYXRoLmFicyhzdGFydFggLSBwcmV2RW5kWCksIHRoaXMubGF5b3V0Xy5nZXRQbG90QXJlYSgpLmgpO1xuICB9IGVsc2UgaWYgKHByZXZEaXJlY3Rpb24gPT0gdXRpbHMuVkVSVElDQUwpIHtcbiAgICBjdHguY2xlYXJSZWN0KHRoaXMubGF5b3V0Xy5nZXRQbG90QXJlYSgpLngsIE1hdGgubWluKHN0YXJ0WSwgcHJldkVuZFkpLFxuICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXRfLmdldFBsb3RBcmVhKCkudywgTWF0aC5hYnMoc3RhcnRZIC0gcHJldkVuZFkpKTtcbiAgfVxuXG4gIC8vIERyYXcgYSBsaWdodC1ncmV5IHJlY3RhbmdsZSB0byBzaG93IHRoZSBuZXcgdmlld2luZyBhcmVhXG4gIGlmIChkaXJlY3Rpb24gPT0gdXRpbHMuSE9SSVpPTlRBTCkge1xuICAgIGlmIChlbmRYICYmIHN0YXJ0WCkge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYSgxMjgsMTI4LDEyOCwwLjMzKVwiO1xuICAgICAgY3R4LmZpbGxSZWN0KE1hdGgubWluKHN0YXJ0WCwgZW5kWCksIHRoaXMubGF5b3V0Xy5nZXRQbG90QXJlYSgpLnksXG4gICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoZW5kWCAtIHN0YXJ0WCksIHRoaXMubGF5b3V0Xy5nZXRQbG90QXJlYSgpLmgpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gdXRpbHMuVkVSVElDQUwpIHtcbiAgICBpZiAoZW5kWSAmJiBzdGFydFkpIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMTI4LDEyOCwxMjgsMC4zMylcIjtcbiAgICAgIGN0eC5maWxsUmVjdCh0aGlzLmxheW91dF8uZ2V0UGxvdEFyZWEoKS54LCBNYXRoLm1pbihzdGFydFksIGVuZFkpLFxuICAgICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0Xy5nZXRQbG90QXJlYSgpLncsIE1hdGguYWJzKGVuZFkgLSBzdGFydFkpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIHpvb20gcmVjdGFuZ2xlIChhbmQgcGVyZm9ybSBubyB6b29tKS5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmNsZWFyWm9vbVJlY3RfID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3VycmVudFpvb21SZWN0QXJnc18gPSBudWxsO1xuICB0aGlzLmNhbnZhc19jdHhfLmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoXywgdGhpcy5oZWlnaHRfKTtcbn07XG5cbi8qKlxuICogWm9vbSB0byBzb21ldGhpbmcgY29udGFpbmluZyBbbG93WCwgaGlnaFhdLiBUaGVzZSBhcmUgcGl4ZWwgY29vcmRpbmF0ZXMgaW5cbiAqIHRoZSBjYW52YXMuIFRoZSBleGFjdCB6b29tIHdpbmRvdyBtYXkgYmUgc2xpZ2h0bHkgbGFyZ2VyIGlmIHRoZXJlIGFyZSBubyBkYXRhXG4gKiBwb2ludHMgbmVhciBsb3dYIG9yIGhpZ2hYLiBEb24ndCBjb25mdXNlIHRoaXMgZnVuY3Rpb24gd2l0aCBkb1pvb21YRGF0ZXMsXG4gKiB3aGljaCBhY2NlcHRzIGRhdGVzIHRoYXQgbWF0Y2ggdGhlIHJhdyBkYXRhLiBUaGlzIGZ1bmN0aW9uIHJlZHJhd3MgdGhlIGdyYXBoLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dYIFRoZSBsZWZ0bW9zdCBwaXhlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB2aXNpYmxlLlxuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hYIFRoZSByaWdodG1vc3QgcGl4ZWwgdmFsdWUgdGhhdCBzaG91bGQgYmUgdmlzaWJsZS5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmRvWm9vbVhfID0gZnVuY3Rpb24obG93WCwgaGlnaFgpIHtcbiAgdGhpcy5jdXJyZW50Wm9vbVJlY3RBcmdzXyA9IG51bGw7XG4gIC8vIEZpbmQgdGhlIGVhcmxpZXN0IGFuZCBsYXRlc3QgZGF0ZXMgY29udGFpbmVkIGluIHRoaXMgY2FudmFzeCByYW5nZS5cbiAgLy8gQ29udmVydCB0aGUgY2FsbCB0byBkYXRlIHJhbmdlcyBvZiB0aGUgcmF3IGRhdGEuXG4gIHZhciBtaW5EYXRlID0gdGhpcy50b0RhdGFYQ29vcmQobG93WCk7XG4gIHZhciBtYXhEYXRlID0gdGhpcy50b0RhdGFYQ29vcmQoaGlnaFgpO1xuICB0aGlzLmRvWm9vbVhEYXRlc18obWluRGF0ZSwgbWF4RGF0ZSk7XG59O1xuXG4vKipcbiAqIFpvb20gdG8gc29tZXRoaW5nIGNvbnRhaW5pbmcgW21pbkRhdGUsIG1heERhdGVdIHZhbHVlcy4gRG9uJ3QgY29uZnVzZSB0aGlzXG4gKiBtZXRob2Qgd2l0aCBkb1pvb21YIHdoaWNoIGFjY2VwdHMgcGl4ZWwgY29vcmRpbmF0ZXMuIFRoaXMgZnVuY3Rpb24gcmVkcmF3c1xuICogdGhlIGdyYXBoLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5EYXRlIFRoZSBtaW5pbXVtIGRhdGUgdGhhdCBzaG91bGQgYmUgdmlzaWJsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhEYXRlIFRoZSBtYXhpbXVtIGRhdGUgdGhhdCBzaG91bGQgYmUgdmlzaWJsZS5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmRvWm9vbVhEYXRlc18gPSBmdW5jdGlvbihtaW5EYXRlLCBtYXhEYXRlKSB7XG4gIC8vIFRPRE8oZGFudmspOiB3aGVuIHhBeGlzUmFuZ2UgaXMgbnVsbCAoaS5lLiBcImZpdCB0byBkYXRhXCIsIHRoZSBhbmltYXRpb25cbiAgLy8gY2FuIHByb2R1Y2Ugc3RyYW5nZSBlZmZlY3RzLiBSYXRoZXIgdGhhbiB0aGUgeC1heGlzIHRyYW5zaXRpb25pbmcgc2xvd2x5XG4gIC8vIGJldHdlZW4gdmFsdWVzLCBpdCBjYW4gamVyayBhcm91bmQuKVxuICB2YXIgb2xkX3dpbmRvdyA9IHRoaXMueEF4aXNSYW5nZSgpO1xuICB2YXIgbmV3X3dpbmRvdyA9IFttaW5EYXRlLCBtYXhEYXRlXTtcbiAgY29uc3Qgem9vbUNhbGxiYWNrID0gdGhpcy5nZXRGdW5jdGlvbk9wdGlvbignem9vbUNhbGxiYWNrJyk7XG4gIHRoaXMuZG9BbmltYXRlZFpvb20ob2xkX3dpbmRvdywgbmV3X3dpbmRvdywgbnVsbCwgbnVsbCwgKCkgPT4ge1xuICAgIGlmICh6b29tQ2FsbGJhY2spIHtcbiAgICAgIHpvb21DYWxsYmFjay5jYWxsKHRoaXMsIG1pbkRhdGUsIG1heERhdGUsIHRoaXMueUF4aXNSYW5nZXMoKSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogWm9vbSB0byBzb21ldGhpbmcgY29udGFpbmluZyBbbG93WSwgaGlnaFldLiBUaGVzZSBhcmUgcGl4ZWwgY29vcmRpbmF0ZXMgaW5cbiAqIHRoZSBjYW52YXMuIFRoaXMgZnVuY3Rpb24gcmVkcmF3cyB0aGUgZ3JhcGguXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGxvd1kgVGhlIHRvcG1vc3QgcGl4ZWwgdmFsdWUgdGhhdCBzaG91bGQgYmUgdmlzaWJsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoWSBUaGUgbG93ZXN0IHBpeGVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHZpc2libGUuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5kb1pvb21ZXyA9IGZ1bmN0aW9uKGxvd1ksIGhpZ2hZKSB7XG4gIHRoaXMuY3VycmVudFpvb21SZWN0QXJnc18gPSBudWxsO1xuICAvLyBGaW5kIHRoZSBoaWdoZXN0IGFuZCBsb3dlc3QgdmFsdWVzIGluIHBpeGVsIHJhbmdlIGZvciBlYWNoIGF4aXMuXG4gIC8vIE5vdGUgdGhhdCBsb3dZIChpbiBwaXhlbHMpIGNvcnJlc3BvbmRzIHRvIHRoZSBtYXggVmFsdWUgKGluIGRhdGEgY29vcmRzKS5cbiAgLy8gVGhpcyBpcyBiZWNhdXNlIHBpeGVscyBpbmNyZWFzZSBhcyB5b3UgZ28gZG93biBvbiB0aGUgc2NyZWVuLCB3aGVyZWFzIGRhdGFcbiAgLy8gY29vcmRpbmF0ZXMgaW5jcmVhc2UgYXMgeW91IGdvIHVwIHRoZSBzY3JlZW4uXG4gIHZhciBvbGRWYWx1ZVJhbmdlcyA9IHRoaXMueUF4aXNSYW5nZXMoKTtcbiAgdmFyIG5ld1ZhbHVlUmFuZ2VzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5heGVzXy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBoaSA9IHRoaXMudG9EYXRhWUNvb3JkKGxvd1ksIGkpO1xuICAgIHZhciBsb3cgPSB0aGlzLnRvRGF0YVlDb29yZChoaWdoWSwgaSk7XG4gICAgbmV3VmFsdWVSYW5nZXMucHVzaChbbG93LCBoaV0pO1xuICB9XG5cbiAgY29uc3Qgem9vbUNhbGxiYWNrID0gdGhpcy5nZXRGdW5jdGlvbk9wdGlvbignem9vbUNhbGxiYWNrJyk7XG4gIHRoaXMuZG9BbmltYXRlZFpvb20obnVsbCwgbnVsbCwgb2xkVmFsdWVSYW5nZXMsIG5ld1ZhbHVlUmFuZ2VzLCAoKSA9PiB7XG4gICAgaWYgKHpvb21DYWxsYmFjaykge1xuICAgICAgY29uc3QgW21pblgsIG1heFhdID0gdGhpcy54QXhpc1JhbmdlKCk7XG4gICAgICB6b29tQ2FsbGJhY2suY2FsbCh0aGlzLCBtaW5YLCBtYXhYLCB0aGlzLnlBeGlzUmFuZ2VzKCkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFRyYW5zaXRpb24gZnVuY3Rpb24gdG8gdXNlIGluIGFuaW1hdGlvbnMuIFJldHVybnMgdmFsdWVzIGJldHdlZW4gMC4wXG4gKiAodG90YWxseSBvbGQgdmFsdWVzKSBhbmQgMS4wICh0b3RhbGx5IG5ldyB2YWx1ZXMpIGZvciBlYWNoIGZyYW1lLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC56b29tQW5pbWF0aW9uRnVuY3Rpb24gPSBmdW5jdGlvbihmcmFtZSwgbnVtRnJhbWVzKSB7XG4gIHZhciBrID0gMS41O1xuICByZXR1cm4gKDEuMCAtIE1hdGgucG93KGssIC1mcmFtZSkpIC8gKDEuMCAtIE1hdGgucG93KGssIC1udW1GcmFtZXMpKTtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIHpvb20gdG8gdGhlIG9yaWdpbmFsIHZpZXcgY29vcmRpbmF0ZXMuIFRoaXMgaXMgdGhlIHNhbWUgYXNcbiAqIGRvdWJsZS1jbGlja2luZyBvbiB0aGUgZ3JhcGguXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnJlc2V0Wm9vbSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBkaXJ0eVggPSB0aGlzLmlzWm9vbWVkKCd4Jyk7XG4gIGNvbnN0IGRpcnR5WSA9IHRoaXMuaXNab29tZWQoJ3knKTtcbiAgY29uc3QgZGlydHkgPSBkaXJ0eVggfHwgZGlydHlZO1xuXG4gIC8vIENsZWFyIGFueSBzZWxlY3Rpb24sIHNpbmNlIGl0J3MgbGlrZWx5IHRvIGJlIGRyYXduIGluIHRoZSB3cm9uZyBwbGFjZS5cbiAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuXG4gIGlmICghZGlydHkpIHJldHVybjtcblxuICAvLyBDYWxjdWxhdGUgZXh0cmVtZXMgdG8gYXZvaWQgbGFjayBvZiBwYWRkaW5nIG9uIHJlc2V0LlxuICBjb25zdCBbbWluRGF0ZSwgbWF4RGF0ZV0gPSB0aGlzLnhBeGlzRXh0cmVtZXMoKTtcblxuICBjb25zdCBhbmltYXRlZFpvb21zID0gdGhpcy5nZXRCb29sZWFuT3B0aW9uKCdhbmltYXRlZFpvb21zJyk7XG4gIGNvbnN0IHpvb21DYWxsYmFjayA9IHRoaXMuZ2V0RnVuY3Rpb25PcHRpb24oJ3pvb21DYWxsYmFjaycpO1xuXG4gIC8vIFRPRE8oZGFudmspOiBtZXJnZSB0aGlzIGJsb2NrIHcvIHRoZSBjb2RlIGJlbG93LlxuICAvLyBUT0RPKGRhbnZrKTogZmFjdG9yIG91dCBhIGdlbmVyaWMsIHB1YmxpYyB6b29tVG8gbWV0aG9kLlxuICBpZiAoIWFuaW1hdGVkWm9vbXMpIHtcbiAgICB0aGlzLmRhdGVXaW5kb3dfID0gbnVsbDtcbiAgICB0aGlzLmF4ZXNfLmZvckVhY2goYXhpcyA9PiB7XG4gICAgICBpZiAoYXhpcy52YWx1ZVJhbmdlKSBkZWxldGUgYXhpcy52YWx1ZVJhbmdlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5kcmF3R3JhcGhfKCk7XG4gICAgaWYgKHpvb21DYWxsYmFjaykge1xuICAgICAgem9vbUNhbGxiYWNrLmNhbGwodGhpcywgbWluRGF0ZSwgbWF4RGF0ZSwgdGhpcy55QXhpc1JhbmdlcygpKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9sZFdpbmRvdz1udWxsLCBuZXdXaW5kb3c9bnVsbCwgb2xkVmFsdWVSYW5nZXM9bnVsbCwgbmV3VmFsdWVSYW5nZXM9bnVsbDtcbiAgaWYgKGRpcnR5WCkge1xuICAgIG9sZFdpbmRvdyA9IHRoaXMueEF4aXNSYW5nZSgpO1xuICAgIG5ld1dpbmRvdyA9IFttaW5EYXRlLCBtYXhEYXRlXTtcbiAgfVxuXG4gIGlmIChkaXJ0eVkpIHtcbiAgICBvbGRWYWx1ZVJhbmdlcyA9IHRoaXMueUF4aXNSYW5nZXMoKTtcbiAgICBuZXdWYWx1ZVJhbmdlcyA9IHRoaXMueUF4aXNFeHRyZW1lcygpO1xuICB9XG5cbiAgdGhpcy5kb0FuaW1hdGVkWm9vbShvbGRXaW5kb3csIG5ld1dpbmRvdywgb2xkVmFsdWVSYW5nZXMsIG5ld1ZhbHVlUmFuZ2VzLFxuICAgICAgKCkgPT4ge1xuICAgICAgICB0aGlzLmRhdGVXaW5kb3dfID0gbnVsbDtcbiAgICAgICAgdGhpcy5heGVzXy5mb3JFYWNoKGF4aXMgPT4ge1xuICAgICAgICAgIGlmIChheGlzLnZhbHVlUmFuZ2UpIGRlbGV0ZSBheGlzLnZhbHVlUmFuZ2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoem9vbUNhbGxiYWNrKSB7XG4gICAgICAgICAgem9vbUNhbGxiYWNrLmNhbGwodGhpcywgbWluRGF0ZSwgbWF4RGF0ZSwgdGhpcy55QXhpc1JhbmdlcygpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG59O1xuXG4vKipcbiAqIENvbWJpbmVkIGFuaW1hdGlvbiBsb2dpYyBmb3IgYWxsIHpvb20gZnVuY3Rpb25zLlxuICogZWl0aGVyIHRoZSB4IHBhcmFtZXRlcnMgb3IgeSBwYXJhbWV0ZXJzIG1heSBiZSBudWxsLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZG9BbmltYXRlZFpvb20gPSBmdW5jdGlvbihvbGRYUmFuZ2UsIG5ld1hSYW5nZSwgb2xkWVJhbmdlcywgbmV3WVJhbmdlcywgY2FsbGJhY2spIHtcbiAgdmFyIHN0ZXBzID0gdGhpcy5nZXRCb29sZWFuT3B0aW9uKFwiYW5pbWF0ZWRab29tc1wiKSA/XG4gICAgICBEeWdyYXBoLkFOSU1BVElPTl9TVEVQUyA6IDE7XG5cbiAgdmFyIHdpbmRvd3MgPSBbXTtcbiAgdmFyIHZhbHVlUmFuZ2VzID0gW107XG4gIHZhciBzdGVwLCBmcmFjO1xuXG4gIGlmIChvbGRYUmFuZ2UgIT09IG51bGwgJiYgbmV3WFJhbmdlICE9PSBudWxsKSB7XG4gICAgZm9yIChzdGVwID0gMTsgc3RlcCA8PSBzdGVwczsgc3RlcCsrKSB7XG4gICAgICBmcmFjID0gRHlncmFwaC56b29tQW5pbWF0aW9uRnVuY3Rpb24oc3RlcCwgc3RlcHMpO1xuICAgICAgd2luZG93c1tzdGVwLTFdID0gW29sZFhSYW5nZVswXSooMS1mcmFjKSArIGZyYWMqbmV3WFJhbmdlWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFhSYW5nZVsxXSooMS1mcmFjKSArIGZyYWMqbmV3WFJhbmdlWzFdXTtcbiAgICB9XG4gIH1cblxuICBpZiAob2xkWVJhbmdlcyAhPT0gbnVsbCAmJiBuZXdZUmFuZ2VzICE9PSBudWxsKSB7XG4gICAgZm9yIChzdGVwID0gMTsgc3RlcCA8PSBzdGVwczsgc3RlcCsrKSB7XG4gICAgICBmcmFjID0gRHlncmFwaC56b29tQW5pbWF0aW9uRnVuY3Rpb24oc3RlcCwgc3RlcHMpO1xuICAgICAgdmFyIHRoaXNSYW5nZSA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmF4ZXNfLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHRoaXNSYW5nZS5wdXNoKFtvbGRZUmFuZ2VzW2pdWzBdKigxLWZyYWMpICsgZnJhYypuZXdZUmFuZ2VzW2pdWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkWVJhbmdlc1tqXVsxXSooMS1mcmFjKSArIGZyYWMqbmV3WVJhbmdlc1tqXVsxXV0pO1xuICAgICAgfVxuICAgICAgdmFsdWVSYW5nZXNbc3RlcC0xXSA9IHRoaXNSYW5nZTtcbiAgICB9XG4gIH1cblxuICB1dGlscy5yZXBlYXRBbmRDbGVhbnVwKHN0ZXAgPT4ge1xuICAgIGlmICh2YWx1ZVJhbmdlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5heGVzXy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdyA9IHZhbHVlUmFuZ2VzW3N0ZXBdW2ldO1xuICAgICAgICB0aGlzLmF4ZXNfW2ldLnZhbHVlUmFuZ2UgPSBbd1swXSwgd1sxXV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh3aW5kb3dzLmxlbmd0aCkge1xuICAgICAgdGhpcy5kYXRlV2luZG93XyA9IHdpbmRvd3Nbc3RlcF07XG4gICAgfVxuICAgIHRoaXMuZHJhd0dyYXBoXygpO1xuICB9LCBzdGVwcywgRHlncmFwaC5BTklNQVRJT05fRFVSQVRJT04gLyBzdGVwcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgZ3JhcGgncyBhcmVhIG9iamVjdC5cbiAqXG4gKiBSZXR1cm5zOiB7eCwgeSwgdywgaH1cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0QXJlYSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wbG90dGVyXy5hcmVhO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgbW91c2UgZXZlbnQgdG8gRE9NIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRoZSBncmFwaCBvcmlnaW4uXG4gKlxuICogUmV0dXJucyBhIHR3by1lbGVtZW50IGFycmF5OiBbWCwgWV0uXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmV2ZW50VG9Eb21Db29yZHMgPSBmdW5jdGlvbihldmVudCkge1xuICBpZiAoZXZlbnQub2Zmc2V0WCAmJiBldmVudC5vZmZzZXRZKSB7XG4gICAgcmV0dXJuIFsgZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSBdO1xuICB9IGVsc2Uge1xuICAgIHZhciBldmVudEVsZW1lbnRQb3MgPSB1dGlscy5maW5kUG9zKHRoaXMubW91c2VFdmVudEVsZW1lbnRfKTtcbiAgICB2YXIgY2FudmFzeCA9IHV0aWxzLnBhZ2VYKGV2ZW50KSAtIGV2ZW50RWxlbWVudFBvcy54O1xuICAgIHZhciBjYW52YXN5ID0gdXRpbHMucGFnZVkoZXZlbnQpIC0gZXZlbnRFbGVtZW50UG9zLnk7XG4gICAgcmV0dXJuIFtjYW52YXN4LCBjYW52YXN5XTtcbiAgfVxufTtcblxuLyoqXG4gKiBHaXZlbiBhIGNhbnZhcyBYIGNvb3JkaW5hdGUsIGZpbmQgdGhlIGNsb3Nlc3Qgcm93LlxuICogQHBhcmFtIHtudW1iZXJ9IGRvbVggZ3JhcGgtcmVsYXRpdmUgRE9NIFggY29vcmRpbmF0ZVxuICogUmV0dXJucyB7bnVtYmVyfSByb3cgbnVtYmVyLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZmluZENsb3Nlc3RSb3cgPSBmdW5jdGlvbihkb21YKSB7XG4gIHZhciBtaW5EaXN0WCA9IEluZmluaXR5O1xuICB2YXIgY2xvc2VzdFJvdyA9IC0xO1xuICB2YXIgc2V0cyA9IHRoaXMubGF5b3V0Xy5wb2ludHM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwb2ludHMgPSBzZXRzW2ldO1xuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHZhciBwb2ludCA9IHBvaW50c1tqXTtcbiAgICAgIGlmICghdXRpbHMuaXNWYWxpZFBvaW50KHBvaW50LCB0cnVlKSkgY29udGludWU7XG4gICAgICB2YXIgZGlzdCA9IE1hdGguYWJzKHBvaW50LmNhbnZhc3ggLSBkb21YKTtcbiAgICAgIGlmIChkaXN0IDwgbWluRGlzdFgpIHtcbiAgICAgICAgbWluRGlzdFggPSBkaXN0O1xuICAgICAgICBjbG9zZXN0Um93ID0gcG9pbnQuaWR4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbG9zZXN0Um93O1xufTtcblxuLyoqXG4gKiBHaXZlbiBjYW52YXMgWCxZIGNvb3JkaW5hdGVzLCBmaW5kIHRoZSBjbG9zZXN0IHBvaW50LlxuICpcbiAqIFRoaXMgZmluZHMgdGhlIGluZGl2aWR1YWwgZGF0YSBwb2ludCBhY3Jvc3MgYWxsIHZpc2libGUgc2VyaWVzXG4gKiB0aGF0J3MgY2xvc2VzdCB0byB0aGUgc3VwcGxpZWQgRE9NIGNvb3JkaW5hdGVzIHVzaW5nIHRoZSBzdGFuZGFyZFxuICogRXVjbGlkZWFuIFgsWSBkaXN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZG9tWCBncmFwaC1yZWxhdGl2ZSBET00gWCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZG9tWSBncmFwaC1yZWxhdGl2ZSBET00gWSBjb29yZGluYXRlXG4gKiBSZXR1cm5zOiB7cm93LCBzZXJpZXNOYW1lLCBwb2ludH1cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmZpbmRDbG9zZXN0UG9pbnQgPSBmdW5jdGlvbihkb21YLCBkb21ZKSB7XG4gIHZhciBtaW5EaXN0ID0gSW5maW5pdHk7XG4gIHZhciBkaXN0LCBkeCwgZHksIHBvaW50LCBjbG9zZXN0UG9pbnQsIGNsb3Nlc3RTZXJpZXMsIGNsb3Nlc3RSb3c7XG4gIGZvciAoIHZhciBzZXRJZHggPSB0aGlzLmxheW91dF8ucG9pbnRzLmxlbmd0aCAtIDEgOyBzZXRJZHggPj0gMCA7IC0tc2V0SWR4ICkge1xuICAgIHZhciBwb2ludHMgPSB0aGlzLmxheW91dF8ucG9pbnRzW3NldElkeF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgaWYgKCF1dGlscy5pc1ZhbGlkUG9pbnQocG9pbnQpKSBjb250aW51ZTtcbiAgICAgIGR4ID0gcG9pbnQuY2FudmFzeCAtIGRvbVg7XG4gICAgICBkeSA9IHBvaW50LmNhbnZhc3kgLSBkb21ZO1xuICAgICAgZGlzdCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICBjbG9zZXN0UG9pbnQgPSBwb2ludDtcbiAgICAgICAgY2xvc2VzdFNlcmllcyA9IHNldElkeDtcbiAgICAgICAgY2xvc2VzdFJvdyA9IHBvaW50LmlkeDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIG5hbWUgPSB0aGlzLmxheW91dF8uc2V0TmFtZXNbY2xvc2VzdFNlcmllc107XG4gIHJldHVybiB7XG4gICAgcm93OiBjbG9zZXN0Um93LFxuICAgIHNlcmllc05hbWU6IG5hbWUsXG4gICAgcG9pbnQ6IGNsb3Nlc3RQb2ludFxuICB9O1xufTtcblxuLyoqXG4gKiBHaXZlbiBjYW52YXMgWCxZIGNvb3JkaW5hdGVzLCBmaW5kIHRoZSB0b3VjaGVkIGFyZWEgaW4gYSBzdGFja2VkIGdyYXBoLlxuICpcbiAqIFRoaXMgZmlyc3QgZmluZHMgdGhlIFggZGF0YSBwb2ludCBjbG9zZXN0IHRvIHRoZSBzdXBwbGllZCBET00gWCBjb29yZGluYXRlLFxuICogdGhlbiBmaW5kcyB0aGUgc2VyaWVzIHdoaWNoIHB1dHMgdGhlIFkgY29vcmRpbmF0ZSBvbiB0b3Agb2YgaXRzIGZpbGxlZCBhcmVhLFxuICogdXNpbmcgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiBhZGphY2VudCBwb2ludCBwYWlycy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZG9tWCBncmFwaC1yZWxhdGl2ZSBET00gWCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZG9tWSBncmFwaC1yZWxhdGl2ZSBET00gWSBjb29yZGluYXRlXG4gKiBSZXR1cm5zOiB7cm93LCBzZXJpZXNOYW1lLCBwb2ludH1cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmZpbmRTdGFja2VkUG9pbnQgPSBmdW5jdGlvbihkb21YLCBkb21ZKSB7XG4gIHZhciByb3cgPSB0aGlzLmZpbmRDbG9zZXN0Um93KGRvbVgpO1xuICB2YXIgY2xvc2VzdFBvaW50LCBjbG9zZXN0U2VyaWVzO1xuICBmb3IgKHZhciBzZXRJZHggPSAwOyBzZXRJZHggPCB0aGlzLmxheW91dF8ucG9pbnRzLmxlbmd0aDsgKytzZXRJZHgpIHtcbiAgICB2YXIgYm91bmRhcnkgPSB0aGlzLmdldExlZnRCb3VuZGFyeV8oc2V0SWR4KTtcbiAgICB2YXIgcm93SWR4ID0gcm93IC0gYm91bmRhcnk7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMubGF5b3V0Xy5wb2ludHNbc2V0SWR4XTtcbiAgICBpZiAocm93SWR4ID49IHBvaW50cy5sZW5ndGgpIGNvbnRpbnVlO1xuICAgIHZhciBwMSA9IHBvaW50c1tyb3dJZHhdO1xuICAgIGlmICghdXRpbHMuaXNWYWxpZFBvaW50KHAxKSkgY29udGludWU7XG4gICAgdmFyIHB5ID0gcDEuY2FudmFzeTtcbiAgICBpZiAoZG9tWCA+IHAxLmNhbnZhc3ggJiYgcm93SWR4ICsgMSA8IHBvaW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGludGVycG9sYXRlIHNlcmllcyBZIHZhbHVlIHVzaW5nIG5leHQgcG9pbnRcbiAgICAgIHZhciBwMiA9IHBvaW50c1tyb3dJZHggKyAxXTtcbiAgICAgIGlmICh1dGlscy5pc1ZhbGlkUG9pbnQocDIpKSB7XG4gICAgICAgIHZhciBkeCA9IHAyLmNhbnZhc3ggLSBwMS5jYW52YXN4O1xuICAgICAgICBpZiAoZHggPiAwKSB7XG4gICAgICAgICAgdmFyIHIgPSAoZG9tWCAtIHAxLmNhbnZhc3gpIC8gZHg7XG4gICAgICAgICAgcHkgKz0gciAqIChwMi5jYW52YXN5IC0gcDEuY2FudmFzeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRvbVggPCBwMS5jYW52YXN4ICYmIHJvd0lkeCA+IDApIHtcbiAgICAgIC8vIGludGVycG9sYXRlIHNlcmllcyBZIHZhbHVlIHVzaW5nIHByZXZpb3VzIHBvaW50XG4gICAgICB2YXIgcDAgPSBwb2ludHNbcm93SWR4IC0gMV07XG4gICAgICBpZiAodXRpbHMuaXNWYWxpZFBvaW50KHAwKSkge1xuICAgICAgICB2YXIgZHggPSBwMS5jYW52YXN4IC0gcDAuY2FudmFzeDtcbiAgICAgICAgaWYgKGR4ID4gMCkge1xuICAgICAgICAgIHZhciByID0gKHAxLmNhbnZhc3ggLSBkb21YKSAvIGR4O1xuICAgICAgICAgIHB5ICs9IHIgKiAocDAuY2FudmFzeSAtIHAxLmNhbnZhc3kpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFN0b3AgaWYgdGhlIHBvaW50IChkb21YLCBweSkgaXMgYWJvdmUgdGhpcyBzZXJpZXMnIHVwcGVyIGVkZ2VcbiAgICBpZiAoc2V0SWR4ID09PSAwIHx8IHB5IDwgZG9tWSkge1xuICAgICAgY2xvc2VzdFBvaW50ID0gcDE7XG4gICAgICBjbG9zZXN0U2VyaWVzID0gc2V0SWR4O1xuICAgIH1cbiAgfVxuICB2YXIgbmFtZSA9IHRoaXMubGF5b3V0Xy5zZXROYW1lc1tjbG9zZXN0U2VyaWVzXTtcbiAgcmV0dXJuIHtcbiAgICByb3c6IHJvdyxcbiAgICBzZXJpZXNOYW1lOiBuYW1lLFxuICAgIHBvaW50OiBjbG9zZXN0UG9pbnRcbiAgfTtcbn07XG5cbi8qKlxuICogV2hlbiB0aGUgbW91c2UgbW92ZXMgaW4gdGhlIGNhbnZhcywgZGlzcGxheSBpbmZvcm1hdGlvbiBhYm91dCBhIG5lYXJieSBkYXRhXG4gKiBwb2ludCBhbmQgZHJhdyBkb3RzIG92ZXIgdGhvc2UgcG9pbnRzIGluIHRoZSBkYXRhIHNlcmllcy4gVGhpcyBmdW5jdGlvblxuICogdGFrZXMgY2FyZSBvZiBjbGVhbnVwIG9mIHByZXZpb3VzbHktZHJhd24gZG90cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgbW91c2Vtb3ZlIGV2ZW50IGZyb20gdGhlIGJyb3dzZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5tb3VzZU1vdmVfID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgLy8gVGhpcyBwcmV2ZW50cyBKUyBlcnJvcnMgd2hlbiBtb3VzaW5nIG92ZXIgdGhlIGNhbnZhcyBiZWZvcmUgZGF0YSBsb2Fkcy5cbiAgdmFyIHBvaW50cyA9IHRoaXMubGF5b3V0Xy5wb2ludHM7XG4gIGlmIChwb2ludHMgPT09IHVuZGVmaW5lZCB8fCBwb2ludHMgPT09IG51bGwpIHJldHVybjtcblxuICB2YXIgY2FudmFzQ29vcmRzID0gdGhpcy5ldmVudFRvRG9tQ29vcmRzKGV2ZW50KTtcbiAgdmFyIGNhbnZhc3ggPSBjYW52YXNDb29yZHNbMF07XG4gIHZhciBjYW52YXN5ID0gY2FudmFzQ29vcmRzWzFdO1xuXG4gIHZhciBoaWdobGlnaHRTZXJpZXNPcHRzID0gdGhpcy5nZXRPcHRpb24oXCJoaWdobGlnaHRTZXJpZXNPcHRzXCIpO1xuICB2YXIgc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICBpZiAoaGlnaGxpZ2h0U2VyaWVzT3B0cyAmJiAhdGhpcy5pc1Nlcmllc0xvY2tlZCgpKSB7XG4gICAgdmFyIGNsb3Nlc3Q7XG4gICAgaWYgKHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbihcInN0YWNrZWRHcmFwaFwiKSkge1xuICAgICAgY2xvc2VzdCA9IHRoaXMuZmluZFN0YWNrZWRQb2ludChjYW52YXN4LCBjYW52YXN5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2VzdCA9IHRoaXMuZmluZENsb3Nlc3RQb2ludChjYW52YXN4LCBjYW52YXN5KTtcbiAgICB9XG4gICAgc2VsZWN0aW9uQ2hhbmdlZCA9IHRoaXMuc2V0U2VsZWN0aW9uKGNsb3Nlc3Qucm93LCBjbG9zZXN0LnNlcmllc05hbWUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBpZHggPSB0aGlzLmZpbmRDbG9zZXN0Um93KGNhbnZhc3gpO1xuICAgIHNlbGVjdGlvbkNoYW5nZWQgPSB0aGlzLnNldFNlbGVjdGlvbihpZHgpO1xuICB9XG5cbiAgdmFyIGNhbGxiYWNrID0gdGhpcy5nZXRGdW5jdGlvbk9wdGlvbihcImhpZ2hsaWdodENhbGxiYWNrXCIpO1xuICBpZiAoY2FsbGJhY2sgJiYgc2VsZWN0aW9uQ2hhbmdlZCkge1xuICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZXZlbnQsXG4gICAgICAgIHRoaXMubGFzdHhfLFxuICAgICAgICB0aGlzLnNlbFBvaW50c18sXG4gICAgICAgIHRoaXMubGFzdFJvd18sXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0U2V0Xyk7XG4gIH1cbn07XG5cbi8qKlxuICogRmV0Y2ggbGVmdCBvZmZzZXQgZnJvbSB0aGUgc3BlY2lmaWVkIHNldCBpbmRleCBvciBpZiBub3QgcGFzc2VkLCB0aGVcbiAqIGZpcnN0IGRlZmluZWQgYm91bmRhcnlJZHMgcmVjb3JkIChzZWUgYnVnICMyMzYpLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0TGVmdEJvdW5kYXJ5XyA9IGZ1bmN0aW9uKHNldElkeCkge1xuICBpZiAodGhpcy5ib3VuZGFyeUlkc19bc2V0SWR4XSkge1xuICAgICAgcmV0dXJuIHRoaXMuYm91bmRhcnlJZHNfW3NldElkeF1bMF07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvdW5kYXJ5SWRzXy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuYm91bmRhcnlJZHNfW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRhcnlJZHNfW2ldWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuRHlncmFwaC5wcm90b3R5cGUuYW5pbWF0ZVNlbGVjdGlvbl8gPSBmdW5jdGlvbihkaXJlY3Rpb24pIHtcbiAgdmFyIHRvdGFsU3RlcHMgPSAxMDtcbiAgdmFyIG1pbGxpcyA9IDMwO1xuICBpZiAodGhpcy5mYWRlTGV2ZWwgPT09IHVuZGVmaW5lZCkgdGhpcy5mYWRlTGV2ZWwgPSAwO1xuICBpZiAodGhpcy5hbmltYXRlSWQgPT09IHVuZGVmaW5lZCkgdGhpcy5hbmltYXRlSWQgPSAwO1xuICB2YXIgc3RhcnQgPSB0aGlzLmZhZGVMZXZlbDtcbiAgdmFyIHN0ZXBzID0gZGlyZWN0aW9uIDwgMCA/IHN0YXJ0IDogdG90YWxTdGVwcyAtIHN0YXJ0O1xuICBpZiAoc3RlcHMgPD0gMCkge1xuICAgIGlmICh0aGlzLmZhZGVMZXZlbCkge1xuICAgICAgdGhpcy51cGRhdGVTZWxlY3Rpb25fKDEuMCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0aGlzSWQgPSArK3RoaXMuYW5pbWF0ZUlkO1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHZhciBjbGVhbnVwSWZDbGVhcmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGlmIHdlIGhhdmVuJ3QgcmVhY2hlZCBmYWRlTGV2ZWwgMCBpbiB0aGUgbWF4IGZyYW1lIHRpbWUsXG4gICAgLy8gZW5zdXJlIHRoYXQgdGhlIGNsZWFyIGhhcHBlbnMgYW5kIGp1c3QgZ28gdG8gMFxuICAgIGlmICh0aGF0LmZhZGVMZXZlbCAhPT0gMCAmJiBkaXJlY3Rpb24gPCAwKSB7XG4gICAgICB0aGF0LmZhZGVMZXZlbCA9IDA7XG4gICAgICB0aGF0LmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfVxuICB9O1xuICB1dGlscy5yZXBlYXRBbmRDbGVhbnVwKFxuICAgIGZ1bmN0aW9uKG4pIHtcbiAgICAgIC8vIGlnbm9yZSBzaW11bHRhbmVvdXMgYW5pbWF0aW9uc1xuICAgICAgaWYgKHRoYXQuYW5pbWF0ZUlkICE9IHRoaXNJZCkgcmV0dXJuO1xuXG4gICAgICB0aGF0LmZhZGVMZXZlbCArPSBkaXJlY3Rpb247XG4gICAgICBpZiAodGhhdC5mYWRlTGV2ZWwgPT09IDApIHtcbiAgICAgICAgdGhhdC5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhhdC51cGRhdGVTZWxlY3Rpb25fKHRoYXQuZmFkZUxldmVsIC8gdG90YWxTdGVwcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdGVwcywgbWlsbGlzLCBjbGVhbnVwSWZDbGVhcmluZyk7XG59O1xuXG4vKipcbiAqIERyYXcgZG90cyBvdmVyIHRoZSBzZWxlY3RpZWQgcG9pbnRzIGluIHRoZSBkYXRhIHNlcmllcy4gVGhpcyBmdW5jdGlvblxuICogdGFrZXMgY2FyZSBvZiBjbGVhbnVwIG9mIHByZXZpb3VzbHktZHJhd24gZG90cy5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnVwZGF0ZVNlbGVjdGlvbl8gPSBmdW5jdGlvbihvcHRfYW5pbUZyYWN0aW9uKSB7XG4gIC8qdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSAqL1xuICB0aGlzLmNhc2NhZGVFdmVudHNfKCdzZWxlY3QnLCB7XG4gICAgc2VsZWN0ZWRSb3c6IHRoaXMubGFzdFJvd18gPT09IC0xID8gdW5kZWZpbmVkIDogdGhpcy5sYXN0Um93XyxcbiAgICBzZWxlY3RlZFg6IHRoaXMubGFzdHhfID09PSAtMSA/IHVuZGVmaW5lZCA6IHRoaXMubGFzdHhfLFxuICAgIHNlbGVjdGVkUG9pbnRzOiB0aGlzLnNlbFBvaW50c19cbiAgfSk7XG4gIC8vIFRPRE8oZGFudmspOiB1c2UgZGVmYXVsdFByZXZlbnRlZCBoZXJlP1xuXG4gIC8vIENsZWFyIHRoZSBwcmV2aW91c2x5IGRyYXduIHZlcnRpY2FsLCBpZiB0aGVyZSBpcyBvbmVcbiAgdmFyIGk7XG4gIHZhciBjdHggPSB0aGlzLmNhbnZhc19jdHhfO1xuICBpZiAodGhpcy5nZXRPcHRpb24oJ2hpZ2hsaWdodFNlcmllc09wdHMnKSkge1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aF8sIHRoaXMuaGVpZ2h0Xyk7XG4gICAgdmFyIGFscGhhID0gMS4wIC0gdGhpcy5nZXROdW1lcmljT3B0aW9uKCdoaWdobGlnaHRTZXJpZXNCYWNrZ3JvdW5kQWxwaGEnKTtcbiAgICB2YXIgYmFja2dyb3VuZENvbG9yID0gdXRpbHMudG9SR0JfKHRoaXMuZ2V0T3B0aW9uKCdoaWdobGlnaHRTZXJpZXNCYWNrZ3JvdW5kQ29sb3InKSk7XG5cbiAgICBpZiAoYWxwaGEpIHtcbiAgICAgIC8vIEFjdGl2YXRpbmcgYmFja2dyb3VuZCBmYWRlIGluY2x1ZGVzIGFuIGFuaW1hdGlvbiBlZmZlY3QgZm9yIGEgZ3JhZHVhbFxuICAgICAgLy8gZmFkZS4gVE9ETyhrbGF1c3cpOiBtYWtlIHRoaXMgaW5kZXBlbmRlbnRseSBjb25maWd1cmFibGUgaWYgaXQgY2F1c2VzXG4gICAgICAvLyBpc3N1ZXM/IFVzZSBhIHNoYXJlZCBwcmVmZXJlbmNlIHRvIGNvbnRyb2wgYW5pbWF0aW9ucz9cbiAgICAgIHZhciBhbmltYXRlQmFja2dyb3VuZEZhZGUgPSB0cnVlO1xuICAgICAgaWYgKGFuaW1hdGVCYWNrZ3JvdW5kRmFkZSkge1xuICAgICAgICBpZiAob3B0X2FuaW1GcmFjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gc3RhcnQgYSBuZXcgYW5pbWF0aW9uXG4gICAgICAgICAgdGhpcy5hbmltYXRlU2VsZWN0aW9uXygxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWxwaGEgKj0gb3B0X2FuaW1GcmFjdGlvbjtcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgnICsgYmFja2dyb3VuZENvbG9yLnIgKyAnLCcgKyBiYWNrZ3JvdW5kQ29sb3IuZyArICcsJyArIGJhY2tncm91bmRDb2xvci5iICsgJywnICsgYWxwaGEgKyAnKSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aF8sIHRoaXMuaGVpZ2h0Xyk7XG4gICAgfVxuXG4gICAgLy8gUmVkcmF3IG9ubHkgdGhlIGhpZ2hsaWdodGVkIHNlcmllcyBpbiB0aGUgaW50ZXJhY3RpdmUgY2FudmFzIChub3QgdGhlXG4gICAgLy8gc3RhdGljIHBsb3QgY2FudmFzLCB3aGljaCBpcyB3aGVyZSBzZXJpZXMgYXJlIHVzdWFsbHkgZHJhd24pLlxuICAgIHRoaXMucGxvdHRlcl8uX3JlbmRlckxpbmVDaGFydCh0aGlzLmhpZ2hsaWdodFNldF8sIGN0eCk7XG4gIH0gZWxzZSBpZiAodGhpcy5wcmV2aW91c1ZlcnRpY2FsWF8gPj0gMCkge1xuICAgIC8vIERldGVybWluZSB0aGUgbWF4aW11bSBoaWdobGlnaHQgY2lyY2xlIHNpemUuXG4gICAgdmFyIG1heENpcmNsZVNpemUgPSAwO1xuICAgIHZhciBsYWJlbHMgPSB0aGlzLmF0dHJfKCdsYWJlbHMnKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgciA9IHRoaXMuZ2V0TnVtZXJpY09wdGlvbignaGlnaGxpZ2h0Q2lyY2xlU2l6ZScsIGxhYmVsc1tpXSk7XG4gICAgICBpZiAociA+IG1heENpcmNsZVNpemUpIG1heENpcmNsZVNpemUgPSByO1xuICAgIH1cbiAgICB2YXIgcHggPSB0aGlzLnByZXZpb3VzVmVydGljYWxYXztcbiAgICBjdHguY2xlYXJSZWN0KHB4IC0gbWF4Q2lyY2xlU2l6ZSAtIDEsIDAsXG4gICAgICAgICAgICAgICAgICAyICogbWF4Q2lyY2xlU2l6ZSArIDIsIHRoaXMuaGVpZ2h0Xyk7XG4gIH1cblxuICBpZiAodGhpcy5zZWxQb2ludHNfLmxlbmd0aCA+IDApIHtcbiAgICAvLyBEcmF3IGNvbG9yZWQgY2lyY2xlcyBvdmVyIHRoZSBjZW50ZXIgb2YgZWFjaCBzZWxlY3RlZCBwb2ludFxuICAgIHZhciBjYW52YXN4ID0gdGhpcy5zZWxQb2ludHNfWzBdLmNhbnZhc3g7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zZWxQb2ludHNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHQgPSB0aGlzLnNlbFBvaW50c19baV07XG4gICAgICBpZiAoaXNOYU4ocHQuY2FudmFzeSkpIGNvbnRpbnVlO1xuXG4gICAgICB2YXIgY2lyY2xlU2l6ZSA9IHRoaXMuZ2V0TnVtZXJpY09wdGlvbignaGlnaGxpZ2h0Q2lyY2xlU2l6ZScsIHB0Lm5hbWUpO1xuICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5nZXRGdW5jdGlvbk9wdGlvbihcImRyYXdIaWdobGlnaHRQb2ludENhbGxiYWNrXCIsIHB0Lm5hbWUpO1xuICAgICAgdmFyIGNvbG9yID0gdGhpcy5wbG90dGVyXy5jb2xvcnNbcHQubmFtZV07XG4gICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdXRpbHMuQ2lyY2xlcy5ERUZBVUxUO1xuICAgICAgfVxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuZ2V0TnVtZXJpY09wdGlvbignc3Ryb2tlV2lkdGgnLCBwdC5uYW1lKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLCBwdC5uYW1lLCBjdHgsIGNhbnZhc3gsIHB0LmNhbnZhc3ksXG4gICAgICAgICAgY29sb3IsIGNpcmNsZVNpemUsIHB0LmlkeCk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICB0aGlzLnByZXZpb3VzVmVydGljYWxYXyA9IGNhbnZhc3g7XG4gIH1cbn07XG5cbi8qKlxuICogTWFudWFsbHkgc2V0IHRoZSBzZWxlY3RlZCBwb2ludHMgYW5kIGRpc3BsYXkgaW5mb3JtYXRpb24gYWJvdXQgdGhlbSBpbiB0aGVcbiAqIGxlZ2VuZC4gVGhlIHNlbGVjdGlvbiBjYW4gYmUgY2xlYXJlZCB1c2luZyBjbGVhclNlbGVjdGlvbigpIGFuZCBxdWVyaWVkXG4gKiB1c2luZyBnZXRTZWxlY3Rpb24oKS5cbiAqXG4gKiBUbyBzZXQgYSBzZWxlY3RlZCBzZXJpZXMgYnV0IG5vdCBhIHNlbGVjdGVkIHBvaW50LCBjYWxsIHNldFNlbGVjdGlvbiB3aXRoXG4gKiByb3c9ZmFsc2UgYW5kIHRoZSBzZWxlY3RlZCBzZXJpZXMgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcm93IFJvdyBudW1iZXIgdGhhdCBzaG91bGQgYmUgaGlnaGxpZ2h0ZWQgKGkuZS4gYXBwZWFyIHdpdGhcbiAqIGhvdmVyIGRvdHMgb24gdGhlIGNoYXJ0KS5cbiAqIEBwYXJhbSB7c2VyaWVzTmFtZX0gb3B0aW9uYWwgc2VyaWVzIG5hbWUgdG8gaGlnaGxpZ2h0IHRoYXQgc2VyaWVzIHdpdGggdGhlXG4gKiB0aGUgaGlnaGxpZ2h0U2VyaWVzT3B0cyBzZXR0aW5nLlxuICogQHBhcmFtIHsgbG9ja2VkIH0gb3B0aW9uYWwgSWYgdHJ1ZSwga2VlcCBzZXJpZXNOYW1lIHNlbGVjdGVkIHdoZW4gbW91c2luZ1xuICogb3ZlciB0aGUgZ3JhcGgsIGRpc2FibGluZyBjbG9zZXN0LXNlcmllcyBoaWdobGlnaHRpbmcuIENhbGwgY2xlYXJTZWxlY3Rpb24oKVxuICogdG8gdW5sb2NrIGl0LlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbihyb3csIG9wdF9zZXJpZXNOYW1lLCBvcHRfbG9ja2VkKSB7XG4gIC8vIEV4dHJhY3QgdGhlIHBvaW50cyB3ZSd2ZSBzZWxlY3RlZFxuICB0aGlzLnNlbFBvaW50c18gPSBbXTtcblxuICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICBpZiAocm93ICE9PSBmYWxzZSAmJiByb3cgPj0gMCkge1xuICAgIGlmIChyb3cgIT0gdGhpcy5sYXN0Um93XykgY2hhbmdlZCA9IHRydWU7XG4gICAgdGhpcy5sYXN0Um93XyA9IHJvdztcbiAgICBmb3IgKHZhciBzZXRJZHggPSAwOyBzZXRJZHggPCB0aGlzLmxheW91dF8ucG9pbnRzLmxlbmd0aDsgKytzZXRJZHgpIHtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLmxheW91dF8ucG9pbnRzW3NldElkeF07XG4gICAgICAvLyBDaGVjayBpZiB0aGUgcG9pbnQgYXQgdGhlIGFwcHJvcHJpYXRlIGluZGV4IGlzIHRoZSBwb2ludCB3ZSdyZSBsb29raW5nXG4gICAgICAvLyBmb3IuICBJZiBpdCBpcywganVzdCB1c2UgaXQsIG90aGVyd2lzZSBzZWFyY2ggdGhlIGFycmF5IGZvciBhIHBvaW50XG4gICAgICAvLyBpbiB0aGUgcHJvcGVyIHBsYWNlLlxuICAgICAgdmFyIHNldFJvdyA9IHJvdyAtIHRoaXMuZ2V0TGVmdEJvdW5kYXJ5XyhzZXRJZHgpO1xuICAgICAgaWYgKHNldFJvdyA+PSAwICYmIHNldFJvdyA8IHBvaW50cy5sZW5ndGggJiYgcG9pbnRzW3NldFJvd10uaWR4ID09IHJvdykge1xuICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbc2V0Um93XTtcbiAgICAgICAgaWYgKHBvaW50Lnl2YWwgIT09IG51bGwpIHRoaXMuc2VsUG9pbnRzXy5wdXNoKHBvaW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIHBvaW50SWR4ID0gMDsgcG9pbnRJZHggPCBwb2ludHMubGVuZ3RoOyArK3BvaW50SWR4KSB7XG4gICAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW3BvaW50SWR4XTtcbiAgICAgICAgICBpZiAocG9pbnQuaWR4ID09IHJvdykge1xuICAgICAgICAgICAgaWYgKHBvaW50Lnl2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZWxQb2ludHNfLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLmxhc3RSb3dfID49IDApIGNoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMubGFzdFJvd18gPSAtMTtcbiAgfVxuXG4gIGlmICh0aGlzLnNlbFBvaW50c18ubGVuZ3RoKSB7XG4gICAgdGhpcy5sYXN0eF8gPSB0aGlzLnNlbFBvaW50c19bMF0ueHZhbDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3R4XyA9IC0xO1xuICB9XG5cbiAgaWYgKG9wdF9zZXJpZXNOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpcy5oaWdobGlnaHRTZXRfICE9PSBvcHRfc2VyaWVzTmFtZSkgY2hhbmdlZCA9IHRydWU7XG4gICAgdGhpcy5oaWdobGlnaHRTZXRfID0gb3B0X3Nlcmllc05hbWU7XG4gIH1cblxuICBpZiAob3B0X2xvY2tlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5sb2NrZWRTZXRfID0gb3B0X2xvY2tlZDtcbiAgfVxuXG4gIGlmIChjaGFuZ2VkKSB7XG4gICAgdGhpcy51cGRhdGVTZWxlY3Rpb25fKHVuZGVmaW5lZCk7XG4gIH1cbiAgcmV0dXJuIGNoYW5nZWQ7XG59O1xuXG4vKipcbiAqIFRoZSBtb3VzZSBoYXMgbGVmdCB0aGUgY2FudmFzLiBDbGVhciBvdXQgd2hhdGV2ZXIgYXJ0aWZhY3RzIHJlbWFpblxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBtb3VzZW91dCBldmVudCBmcm9tIHRoZSBicm93c2VyLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUubW91c2VPdXRfID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgaWYgKHRoaXMuZ2V0RnVuY3Rpb25PcHRpb24oXCJ1bmhpZ2hsaWdodENhbGxiYWNrXCIpKSB7XG4gICAgdGhpcy5nZXRGdW5jdGlvbk9wdGlvbihcInVuaGlnaGxpZ2h0Q2FsbGJhY2tcIikuY2FsbCh0aGlzLCBldmVudCk7XG4gIH1cblxuICBpZiAodGhpcy5nZXRCb29sZWFuT3B0aW9uKFwiaGlkZU92ZXJsYXlPbk1vdXNlT3V0XCIpICYmICF0aGlzLmxvY2tlZFNldF8pIHtcbiAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiAoaS5lLiBwb2ludHMgdGhhdCB3ZXJlIGhpZ2hsaWdodGVkIGJ5IG1vdmluZ1xuICogdGhlIG1vdXNlIG92ZXIgdGhlIGNoYXJ0KS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuY2xlYXJTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jYXNjYWRlRXZlbnRzXygnZGVzZWxlY3QnLCB7fSk7XG5cbiAgdGhpcy5sb2NrZWRTZXRfID0gZmFsc2U7XG4gIC8vIEdldCByaWQgb2YgdGhlIG92ZXJsYXkgZGF0YVxuICBpZiAodGhpcy5mYWRlTGV2ZWwpIHtcbiAgICB0aGlzLmFuaW1hdGVTZWxlY3Rpb25fKC0xKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5jYW52YXNfY3R4Xy5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aF8sIHRoaXMuaGVpZ2h0Xyk7XG4gIHRoaXMuZmFkZUxldmVsID0gMDtcbiAgdGhpcy5zZWxQb2ludHNfID0gW107XG4gIHRoaXMubGFzdHhfID0gLTE7XG4gIHRoaXMubGFzdFJvd18gPSAtMTtcbiAgdGhpcy5oaWdobGlnaHRTZXRfID0gbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcm93LiBUbyBnZXQgZGF0YSBmb3IgdGhpcyByb3csXG4gKiB5b3UgY2FuIHVzZSB0aGUgZ2V0VmFsdWUgbWV0aG9kLlxuICogQHJldHVybiB7bnVtYmVyfSByb3cgbnVtYmVyLCBvciAtMSBpZiBub3RoaW5nIGlzIHNlbGVjdGVkXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuc2VsUG9pbnRzXyB8fCB0aGlzLnNlbFBvaW50c18ubGVuZ3RoIDwgMSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZvciAodmFyIHNldElkeCA9IDA7IHNldElkeCA8IHRoaXMubGF5b3V0Xy5wb2ludHMubGVuZ3RoOyBzZXRJZHgrKykge1xuICAgIHZhciBwb2ludHMgPSB0aGlzLmxheW91dF8ucG9pbnRzW3NldElkeF07XG4gICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgcG9pbnRzLmxlbmd0aDsgcm93KyspIHtcbiAgICAgIGlmIChwb2ludHNbcm93XS54ID09IHRoaXMuc2VsUG9pbnRzX1swXS54KSB7XG4gICAgICAgIHJldHVybiBwb2ludHNbcm93XS5pZHg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5LWhpZ2hsaWdodGVkIHNlcmllcy5cbiAqIE9ubHkgYXZhaWxhYmxlIHdoZW4gdGhlIGhpZ2hsaWdodFNlcmllc09wdHMgb3B0aW9uIGlzIGluIHVzZS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0SGlnaGxpZ2h0U2VyaWVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmhpZ2hsaWdodFNldF87XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudGx5LWhpZ2hsaWdodGVkIHNlcmllcyB3YXMgbG9ja2VkXG4gKiB2aWEgc2V0U2VsZWN0aW9uKC4uLiwgc2VyaWVzTmFtZSwgdHJ1ZSkuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmlzU2VyaWVzTG9ja2VkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmxvY2tlZFNldF87XG59O1xuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlcmUncyBkYXRhIGF2YWlsYWJsZSB0byBiZSBncmFwaGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgUmF3IENTViBkYXRhIHRvIGJlIHBsb3R0ZWRcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmxvYWRlZEV2ZW50XyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdGhpcy5yYXdEYXRhXyA9IHRoaXMucGFyc2VDU1ZfKGRhdGEpO1xuICB0aGlzLmNhc2NhZGVEYXRhRGlkVXBkYXRlRXZlbnRfKCk7XG4gIHRoaXMucHJlZHJhd18oKTtcbn07XG5cbi8qKlxuICogQWRkIHRpY2tzIG9uIHRoZSB4LWF4aXMgcmVwcmVzZW50aW5nIHllYXJzLCBtb250aHMsIHF1YXJ0ZXJzLCB3ZWVrcywgb3IgZGF5c1xuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuYWRkWFRpY2tzXyA9IGZ1bmN0aW9uKCkge1xuICAvLyBEZXRlcm1pbmUgdGhlIGNvcnJlY3QgdGlja3Mgc2NhbGUgb24gdGhlIHgtYXhpczogcXVhcnRlcmx5LCBtb250aGx5LCAuLi5cbiAgdmFyIHJhbmdlO1xuICBpZiAodGhpcy5kYXRlV2luZG93Xykge1xuICAgIHJhbmdlID0gW3RoaXMuZGF0ZVdpbmRvd19bMF0sIHRoaXMuZGF0ZVdpbmRvd19bMV1dO1xuICB9IGVsc2Uge1xuICAgIHJhbmdlID0gdGhpcy54QXhpc0V4dHJlbWVzKCk7XG4gIH1cblxuICB2YXIgeEF4aXNPcHRpb25zVmlldyA9IHRoaXMub3B0aW9uc1ZpZXdGb3JBeGlzXygneCcpO1xuICB2YXIgeFRpY2tzID0geEF4aXNPcHRpb25zVmlldygndGlja2VyJykoXG4gICAgICByYW5nZVswXSxcbiAgICAgIHJhbmdlWzFdLFxuICAgICAgdGhpcy5wbG90dGVyXy5hcmVhLncsICAvLyBUT0RPKGRhbnZrKTogc2hvdWxkIGJlIGFyZWEud2lkdGhcbiAgICAgIHhBeGlzT3B0aW9uc1ZpZXcsXG4gICAgICB0aGlzKTtcbiAgLy8gdmFyIG1zZyA9ICd0aWNrZXIoJyArIHJhbmdlWzBdICsgJywgJyArIHJhbmdlWzFdICsgJywgJyArIHRoaXMud2lkdGhfICsgJywgJyArIHRoaXMuYXR0cl8oJ3BpeGVsc1BlclhMYWJlbCcpICsgJykgLT4gJyArIEpTT04uc3RyaW5naWZ5KHhUaWNrcyk7XG4gIC8vIGNvbnNvbGUubG9nKG1zZyk7XG4gIHRoaXMubGF5b3V0Xy5zZXRYVGlja3MoeFRpY2tzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29ycmVjdCBoYW5kbGVyIGNsYXNzIGZvciB0aGUgY3VycmVudGx5IHNldCBvcHRpb25zLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0SGFuZGxlckNsYXNzXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaGFuZGxlckNsYXNzO1xuICBpZiAodGhpcy5hdHRyXygnZGF0YUhhbmRsZXInKSkge1xuICAgIGhhbmRsZXJDbGFzcyA9ICB0aGlzLmF0dHJfKCdkYXRhSGFuZGxlcicpO1xuICB9IGVsc2UgaWYgKHRoaXMuZnJhY3Rpb25zXykge1xuICAgIGlmICh0aGlzLmdldEJvb2xlYW5PcHRpb24oJ2Vycm9yQmFycycpKSB7XG4gICAgICBoYW5kbGVyQ2xhc3MgPSBGcmFjdGlvbnNCYXJzSGFuZGxlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlckNsYXNzID0gRGVmYXVsdEZyYWN0aW9uSGFuZGxlcjtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5nZXRCb29sZWFuT3B0aW9uKCdjdXN0b21CYXJzJykpIHtcbiAgICBoYW5kbGVyQ2xhc3MgPSBDdXN0b21CYXJzSGFuZGxlcjtcbiAgfSBlbHNlIGlmICh0aGlzLmdldEJvb2xlYW5PcHRpb24oJ2Vycm9yQmFycycpKSB7XG4gICAgaGFuZGxlckNsYXNzID0gRXJyb3JCYXJzSGFuZGxlcjtcbiAgfSBlbHNlIHtcbiAgICBoYW5kbGVyQ2xhc3MgPSBEZWZhdWx0SGFuZGxlcjtcbiAgfVxuICByZXR1cm4gaGFuZGxlckNsYXNzO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSB3aGVuIHRoZSBjaGFydCdzIGRhdGEgaXMgY2hhbmdlZCBvciB0aGUgb3B0aW9uc1xuICogZGljdGlvbmFyeSBpcyB1cGRhdGVkLiBJdCBpcyBfbm90XyBjYWxsZWQgd2hlbiB0aGUgdXNlciBwYW5zIG9yIHpvb21zLiBUaGVcbiAqIGlkZWEgaXMgdGhhdCB2YWx1ZXMgZGVyaXZlZCBmcm9tIHRoZSBjaGFydCdzIGRhdGEgY2FuIGJlIGNvbXB1dGVkIGhlcmUsXG4gKiByYXRoZXIgdGhhbiBldmVyeSB0aW1lIHRoZSBjaGFydCBpcyBkcmF3bi4gVGhpcyBpbmNsdWRlcyB0aGluZ3MgbGlrZSB0aGVcbiAqIG51bWJlciBvZiBheGVzLCByb2xsaW5nIGF2ZXJhZ2VzLCBldGMuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnByZWRyYXdfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGFydCA9IG5ldyBEYXRlKCk7XG5cbiAgLy8gQ3JlYXRlIHRoZSBjb3JyZWN0IGRhdGFIYW5kbGVyXG4gIHRoaXMuZGF0YUhhbmRsZXJfID0gbmV3ICh0aGlzLmdldEhhbmRsZXJDbGFzc18oKSkoKTtcblxuICB0aGlzLmxheW91dF8uY29tcHV0ZVBsb3RBcmVhKCk7XG5cbiAgLy8gVE9ETyhkYW52ayk6IG1vdmUgbW9yZSBjb21wdXRhdGlvbnMgb3V0IG9mIGRyYXdHcmFwaF8gYW5kIGludG8gaGVyZS5cbiAgdGhpcy5jb21wdXRlWUF4ZXNfKCk7XG5cbiAgaWYgKCF0aGlzLmlzX2luaXRpYWxfZHJhd18pIHtcbiAgICB0aGlzLmNhbnZhc19jdHhfLnJlc3RvcmUoKTtcbiAgICB0aGlzLmhpZGRlbl9jdHhfLnJlc3RvcmUoKTtcbiAgfVxuXG4gIHRoaXMuY2FudmFzX2N0eF8uc2F2ZSgpO1xuICB0aGlzLmhpZGRlbl9jdHhfLnNhdmUoKTtcblxuICAvLyBDcmVhdGUgYSBuZXcgcGxvdHRlci5cbiAgdGhpcy5wbG90dGVyXyA9IG5ldyBEeWdyYXBoQ2FudmFzUmVuZGVyZXIodGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRkZW5fLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGRlbl9jdHhfLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxheW91dF8pO1xuXG4gIC8vIFRoZSByb2xsZXIgc2l0cyBpbiB0aGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSBjaGFydC4gV2UgZG9uJ3Qga25vdyB3aGVyZVxuICAvLyB0aGlzIHdpbGwgYmUgdW50aWwgdGhlIG9wdGlvbnMgYXJlIGF2YWlsYWJsZSwgc28gaXQncyBwb3NpdGlvbmVkIGhlcmUuXG4gIHRoaXMuY3JlYXRlUm9sbEludGVyZmFjZV8oKTtcblxuICB0aGlzLmNhc2NhZGVFdmVudHNfKCdwcmVkcmF3Jyk7XG5cbiAgLy8gQ29udmVydCB0aGUgcmF3IGRhdGEgKGEgMkQgYXJyYXkpIGludG8gdGhlIGludGVybmFsIGZvcm1hdCBhbmQgY29tcHV0ZVxuICAvLyByb2xsaW5nIGF2ZXJhZ2VzLlxuICB0aGlzLnJvbGxlZFNlcmllc18gPSBbbnVsbF07ICAvLyB4LWF4aXMgaXMgdGhlIGZpcnN0IHNlcmllcyBhbmQgaXQncyBzcGVjaWFsXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5udW1Db2x1bW5zKCk7IGkrKykge1xuICAgIC8vIHZhciBsb2dTY2FsZSA9IHRoaXMuYXR0cl8oJ2xvZ3NjYWxlJywgaSk7IC8vIFRPRE8oa2xhdXN3KTogdGhpcyBsb29rcyB3cm9uZyAvLyBrb25pZ3NiZXJnIHRoaW5rcyBzbyB0b28uXG4gICAgdmFyIHNlcmllcyA9IHRoaXMuZGF0YUhhbmRsZXJfLmV4dHJhY3RTZXJpZXModGhpcy5yYXdEYXRhXywgaSwgdGhpcy5hdHRyaWJ1dGVzXyk7XG4gICAgaWYgKHRoaXMucm9sbFBlcmlvZF8gPiAxKSB7XG4gICAgICBzZXJpZXMgPSB0aGlzLmRhdGFIYW5kbGVyXy5yb2xsaW5nQXZlcmFnZShzZXJpZXMsIHRoaXMucm9sbFBlcmlvZF8sIHRoaXMuYXR0cmlidXRlc18pO1xuICAgIH1cblxuICAgIHRoaXMucm9sbGVkU2VyaWVzXy5wdXNoKHNlcmllcyk7XG4gIH1cblxuICAvLyBJZiB0aGUgZGF0YSBvciBvcHRpb25zIGhhdmUgY2hhbmdlZCwgdGhlbiB3ZSdkIGJldHRlciByZWRyYXcuXG4gIHRoaXMuZHJhd0dyYXBoXygpO1xuXG4gIC8vIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0byBkbyB2YXJpb3VzIGFuaW1hdGlvbnMuXG4gIHZhciBlbmQgPSBuZXcgRGF0ZSgpO1xuICB0aGlzLmRyYXdpbmdUaW1lTXNfID0gKGVuZCAtIHN0YXJ0KTtcbn07XG5cbi8qKlxuICogUG9pbnQgc3RydWN0dXJlLlxuICpcbiAqIHh2YWxfKiBhbmQgeXZhbF8qIGFyZSB0aGUgb3JpZ2luYWwgdW5zY2FsZWQgZGF0YSB2YWx1ZXMsXG4gKiB3aGlsZSB4XyogYW5kIHlfKiBhcmUgc2NhbGVkIHRvIHRoZSByYW5nZSAoMC4wLTEuMCkgZm9yIHBsb3R0aW5nLlxuICogeXZhbF9zdGFja2VkIGlzIHRoZSBjdW11bGF0aXZlIFkgdmFsdWUgdXNlZCBmb3Igc3RhY2tpbmcgZ3JhcGhzLFxuICogYW5kIGJvdHRvbS90b3AvbWludXMvcGx1cyBhcmUgdXNlZCBmb3IgZXJyb3IgYmFyIGdyYXBocy5cbiAqXG4gKiBAdHlwZWRlZiB7e1xuICogICAgIGlkeDogbnVtYmVyLFxuICogICAgIG5hbWU6IHN0cmluZyxcbiAqICAgICB4OiA/bnVtYmVyLFxuICogICAgIHh2YWw6ID9udW1iZXIsXG4gKiAgICAgeV9ib3R0b206ID9udW1iZXIsXG4gKiAgICAgeTogP251bWJlcixcbiAqICAgICB5X3N0YWNrZWQ6ID9udW1iZXIsXG4gKiAgICAgeV90b3A6ID9udW1iZXIsXG4gKiAgICAgeXZhbF9taW51czogP251bWJlcixcbiAqICAgICB5dmFsOiA/bnVtYmVyLFxuICogICAgIHl2YWxfcGx1czogP251bWJlcixcbiAqICAgICB5dmFsX3N0YWNrZWRcbiAqIH19XG4gKi9cbkR5Z3JhcGguUG9pbnRUeXBlID0gdW5kZWZpbmVkO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgcG9pbnQgc3RhY2tpbmcgZm9yIHN0YWNrZWRHcmFwaD10cnVlLlxuICpcbiAqIEZvciBzdGFja2luZyBwdXJwb3NlcywgaW50ZXJwb2xhdGUgb3IgZXh0ZW5kIG5laWdoYm9yaW5nIGRhdGEgYWNyb3NzXG4gKiBOYU4gdmFsdWVzIGJhc2VkIG9uIHN0YWNrZWRHcmFwaE5hTkZpbGwgc2V0dGluZ3MuIFRoaXMgaXMgZm9yIGRpc3BsYXlcbiAqIG9ubHksIHRoZSB1bmRlcmx5aW5nIGRhdGEgdmFsdWUgYXMgc2hvd24gaW4gdGhlIGxlZ2VuZCByZW1haW5zIE5hTi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxEeWdyYXBoLlBvaW50VHlwZT59IHBvaW50cyBQb2ludCBhcnJheSBmb3IgYSBzaW5nbGUgc2VyaWVzLlxuICogICAgIFVwZGF0ZXMgZWFjaCBQb2ludCdzIHl2YWxfc3RhY2tlZCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGN1bXVsYXRpdmVZdmFsIEFjY3VtdWxhdGVkIHRvcC1vZi1ncmFwaCBzdGFja2VkIFlcbiAqICAgICB2YWx1ZXMgZm9yIHRoZSBzZXJpZXMgc2VlbiBzbyBmYXIuIEluZGV4IGlzIHRoZSByb3cgbnVtYmVyLiBVcGRhdGVkXG4gKiAgICAgYmFzZWQgb24gdGhlIGN1cnJlbnQgc2VyaWVzJ3MgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gc2VyaWVzRXh0cmVtZXMgTWluIGFuZCBtYXggdmFsdWVzLCB1cGRhdGVkXG4gKiAgICAgdG8gcmVmbGVjdCB0aGUgc3RhY2tlZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsbE1ldGhvZCBJbnRlcnBvbGF0aW9uIG1ldGhvZCwgb25lIG9mICdhbGwnLCAnaW5zaWRlJywgb3JcbiAqICAgICAnbm9uZScuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnN0YWNrUG9pbnRzXyA9IGZ1bmN0aW9uKFxuICAgIHBvaW50cywgY3VtdWxhdGl2ZVl2YWwsIHNlcmllc0V4dHJlbWVzLCBmaWxsTWV0aG9kKSB7XG4gIHZhciBsYXN0WHZhbCA9IG51bGw7XG4gIHZhciBwcmV2UG9pbnQgPSBudWxsO1xuICB2YXIgbmV4dFBvaW50ID0gbnVsbDtcbiAgdmFyIG5leHRQb2ludElkeCA9IC0xO1xuXG4gIC8vIEZpbmQgdGhlIG5leHQgc3RhY2thYmxlIHBvaW50IHN0YXJ0aW5nIGZyb20gdGhlIGdpdmVuIGluZGV4LlxuICB2YXIgdXBkYXRlTmV4dFBvaW50ID0gZnVuY3Rpb24oaWR4KSB7XG4gICAgLy8gSWYgd2UndmUgcHJldmlvdXNseSBmb3VuZCBhIG5vbi1OYU4gcG9pbnQgYW5kIGhhdmVuJ3QgZ29uZSBwYXN0IGl0IHlldCxcbiAgICAvLyBqdXN0IHVzZSB0aGF0LlxuICAgIGlmIChuZXh0UG9pbnRJZHggPj0gaWR4KSByZXR1cm47XG5cbiAgICAvLyBXZSBoYXZlbid0IGZvdW5kIGEgbm9uLU5hTiBwb2ludCB5ZXQgb3IgaGF2ZSBtb3ZlZCBwYXN0IGl0LFxuICAgIC8vIGxvb2sgdG93YXJkcyB0aGUgcmlnaHQgdG8gZmluZCBhIG5vbi1OYU4gcG9pbnQuXG4gICAgZm9yICh2YXIgaiA9IGlkeDsgaiA8IHBvaW50cy5sZW5ndGg7ICsraikge1xuICAgICAgLy8gQ2xlYXIgb3V0IGEgcHJldmlvdXNseS1mb3VuZCBwb2ludCAoaWYgYW55KSBzaW5jZSBpdCdzIG5vIGxvbmdlclxuICAgICAgLy8gdmFsaWQsIHdlIHNob3VsZG4ndCB1c2UgaXQgZm9yIGludGVycG9sYXRpb24gYW55bW9yZS5cbiAgICAgIG5leHRQb2ludCA9IG51bGw7XG4gICAgICBpZiAoIWlzTmFOKHBvaW50c1tqXS55dmFsKSAmJiBwb2ludHNbal0ueXZhbCAhPT0gbnVsbCkge1xuICAgICAgICBuZXh0UG9pbnRJZHggPSBqO1xuICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbal07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcbiAgICB2YXIgeHZhbCA9IHBvaW50Lnh2YWw7XG4gICAgaWYgKGN1bXVsYXRpdmVZdmFsW3h2YWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGN1bXVsYXRpdmVZdmFsW3h2YWxdID0gMDtcbiAgICB9XG5cbiAgICB2YXIgYWN0dWFsWXZhbCA9IHBvaW50Lnl2YWw7XG4gICAgaWYgKGlzTmFOKGFjdHVhbFl2YWwpIHx8IGFjdHVhbFl2YWwgPT09IG51bGwpIHtcbiAgICAgIGlmKGZpbGxNZXRob2QgPT0gJ25vbmUnKSB7XG4gICAgICAgIGFjdHVhbFl2YWwgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW50ZXJwb2xhdGUvZXh0ZW5kIGZvciBzdGFja2luZyBwdXJwb3NlcyBpZiBwb3NzaWJsZS5cbiAgICAgICAgdXBkYXRlTmV4dFBvaW50KGkpO1xuICAgICAgICBpZiAocHJldlBvaW50ICYmIG5leHRQb2ludCAmJiBmaWxsTWV0aG9kICE9ICdub25lJykge1xuICAgICAgICAgIC8vIFVzZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHByZXZQb2ludCBhbmQgbmV4dFBvaW50LlxuICAgICAgICAgIGFjdHVhbFl2YWwgPSBwcmV2UG9pbnQueXZhbCArIChuZXh0UG9pbnQueXZhbCAtIHByZXZQb2ludC55dmFsKSAqXG4gICAgICAgICAgICAgICgoeHZhbCAtIHByZXZQb2ludC54dmFsKSAvIChuZXh0UG9pbnQueHZhbCAtIHByZXZQb2ludC54dmFsKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldlBvaW50ICYmIGZpbGxNZXRob2QgPT0gJ2FsbCcpIHtcbiAgICAgICAgICBhY3R1YWxZdmFsID0gcHJldlBvaW50Lnl2YWw7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFBvaW50ICYmIGZpbGxNZXRob2QgPT0gJ2FsbCcpIHtcbiAgICAgICAgICBhY3R1YWxZdmFsID0gbmV4dFBvaW50Lnl2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWN0dWFsWXZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHJldlBvaW50ID0gcG9pbnQ7XG4gICAgfVxuXG4gICAgdmFyIHN0YWNrZWRZdmFsID0gY3VtdWxhdGl2ZVl2YWxbeHZhbF07XG4gICAgaWYgKGxhc3RYdmFsICE9IHh2YWwpIHtcbiAgICAgIC8vIElmIGFuIHgtdmFsdWUgaXMgcmVwZWF0ZWQsIHdlIGlnbm9yZSB0aGUgZHVwbGljYXRlcy5cbiAgICAgIHN0YWNrZWRZdmFsICs9IGFjdHVhbFl2YWw7XG4gICAgICBjdW11bGF0aXZlWXZhbFt4dmFsXSA9IHN0YWNrZWRZdmFsO1xuICAgIH1cbiAgICBsYXN0WHZhbCA9IHh2YWw7XG5cbiAgICBwb2ludC55dmFsX3N0YWNrZWQgPSBzdGFja2VkWXZhbDtcblxuICAgIGlmIChzdGFja2VkWXZhbCA+IHNlcmllc0V4dHJlbWVzWzFdKSB7XG4gICAgICBzZXJpZXNFeHRyZW1lc1sxXSA9IHN0YWNrZWRZdmFsO1xuICAgIH1cbiAgICBpZiAoc3RhY2tlZFl2YWwgPCBzZXJpZXNFeHRyZW1lc1swXSkge1xuICAgICAgc2VyaWVzRXh0cmVtZXNbMF0gPSBzdGFja2VkWXZhbDtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBMb29wIG92ZXIgYWxsIGZpZWxkcyBhbmQgY3JlYXRlIGRhdGFzZXRzLCBjYWxjdWxhdGluZyBleHRyZW1lIHktdmFsdWVzIGZvclxuICogZWFjaCBzZXJpZXMgYW5kIGV4dHJlbWUgeC1pbmRpY2VzIGFzIHdlIGdvLlxuICpcbiAqIGRhdGVXaW5kb3cgaXMgcGFzc2VkIGluIGFzIGFuIGV4cGxpY2l0IHBhcmFtZXRlciBzbyB0aGF0IHdlIGNhbiBjb21wdXRlXG4gKiBleHRyZW1lIHZhbHVlcyBcInNwZWN1bGF0aXZlbHlcIiwgaS5lLiB3aXRob3V0IGFjdHVhbGx5IHNldHRpbmcgc3RhdGUgb24gdGhlXG4gKiBkeWdyYXBoLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxBcnJheS48KG51bWJlcnxBcnJheTxudW1iZXI+KT4+fSByb2xsZWRTZXJpZXMsIHdoZXJlXG4gKiAgICAgcm9sbGVkU2VyaWVzW3Nlcmllc0luZGV4XVtyb3ddID0gcmF3IHBvaW50LCB3aGVyZVxuICogICAgIHNlcmllc0luZGV4IGlzIHRoZSBjb2x1bW4gbnVtYmVyIHN0YXJ0aW5nIHdpdGggMSwgYW5kXG4gKiAgICAgcmF3UG9pbnQgaXMgW3gseV0gb3IgW3gsIFt5LCBlcnJdXSBvciBbeCwgW3ksIHltaW51cywgeXBsdXNdXS5cbiAqIEBwYXJhbSB7P0FycmF5LjxudW1iZXI+fSBkYXRlV2luZG93IFt4bWluLCB4bWF4XSBwYWlyLCBvciBudWxsLlxuICogQHJldHVybiB7e1xuICogICAgIHBvaW50czogQXJyYXkuPEFycmF5LjxEeWdyYXBoLlBvaW50VHlwZT4+LFxuICogICAgIHNlcmllc0V4dHJlbWVzOiBBcnJheS48QXJyYXkuPG51bWJlcj4+LFxuICogICAgIGJvdW5kYXJ5SWRzOiBBcnJheS48bnVtYmVyPn19XG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nYXRoZXJEYXRhc2V0c18gPSBmdW5jdGlvbihyb2xsZWRTZXJpZXMsIGRhdGVXaW5kb3cpIHtcbiAgdmFyIGJvdW5kYXJ5SWRzID0gW107XG4gIHZhciBwb2ludHMgPSBbXTtcbiAgdmFyIGN1bXVsYXRpdmVZdmFsID0gW107ICAvLyBGb3Igc3RhY2tlZCBzZXJpZXMuXG4gIHZhciBleHRyZW1lcyA9IHt9OyAgLy8gc2VyaWVzIG5hbWUgLT4gW2xvdywgaGlnaF1cbiAgdmFyIHNlcmllc0lkeCwgc2FtcGxlSWR4O1xuICB2YXIgZmlyc3RJZHgsIGxhc3RJZHg7XG4gIHZhciBheGlzSWR4O1xuXG4gIC8vIExvb3Agb3ZlciB0aGUgZmllbGRzIChzZXJpZXMpLiAgR28gZnJvbSB0aGUgbGFzdCB0byB0aGUgZmlyc3QsXG4gIC8vIGJlY2F1c2UgaWYgdGhleSdyZSBzdGFja2VkIHRoYXQncyBob3cgd2UgYWNjdW11bGF0ZSB0aGUgdmFsdWVzLlxuICB2YXIgbnVtX3NlcmllcyA9IHJvbGxlZFNlcmllcy5sZW5ndGggLSAxO1xuICB2YXIgc2VyaWVzO1xuICBmb3IgKHNlcmllc0lkeCA9IG51bV9zZXJpZXM7IHNlcmllc0lkeCA+PSAxOyBzZXJpZXNJZHgtLSkge1xuICAgIGlmICghdGhpcy52aXNpYmlsaXR5KClbc2VyaWVzSWR4IC0gMV0pIGNvbnRpbnVlO1xuXG4gICAgLy8gUHJ1bmUgZG93biB0byB0aGUgZGVzaXJlZCByYW5nZSwgaWYgbmVjZXNzYXJ5IChmb3Igem9vbWluZylcbiAgICAvLyBCZWNhdXNlIHRoZXJlIGNhbiBiZSBsaW5lcyBnb2luZyB0byBwb2ludHMgb3V0c2lkZSBvZiB0aGUgdmlzaWJsZSBhcmVhLFxuICAgIC8vIHdlIGFjdHVhbGx5IHBydW5lIHRvIHZpc2libGUgcG9pbnRzLCBwbHVzIG9uZSBvbiBlaXRoZXIgc2lkZS5cbiAgICBpZiAoZGF0ZVdpbmRvdykge1xuICAgICAgc2VyaWVzID0gcm9sbGVkU2VyaWVzW3Nlcmllc0lkeF07XG4gICAgICB2YXIgbG93ID0gZGF0ZVdpbmRvd1swXTtcbiAgICAgIHZhciBoaWdoID0gZGF0ZVdpbmRvd1sxXTtcblxuICAgICAgLy8gVE9ETyhkYW52ayk6IGRvIGJpbmFyeSBzZWFyY2ggaW5zdGVhZCBvZiBsaW5lYXIgc2VhcmNoLlxuICAgICAgLy8gVE9ETyhkYW52ayk6IHBhc3MgZmlyc3RJZHggYW5kIGxhc3RJZHggZGlyZWN0bHkgdG8gdGhlIHJlbmRlcmVyLlxuICAgICAgZmlyc3RJZHggPSBudWxsO1xuICAgICAgbGFzdElkeCA9IG51bGw7XG4gICAgICBmb3IgKHNhbXBsZUlkeCA9IDA7IHNhbXBsZUlkeCA8IHNlcmllcy5sZW5ndGg7IHNhbXBsZUlkeCsrKSB7XG4gICAgICAgIGlmIChzZXJpZXNbc2FtcGxlSWR4XVswXSA+PSBsb3cgJiYgZmlyc3RJZHggPT09IG51bGwpIHtcbiAgICAgICAgICBmaXJzdElkeCA9IHNhbXBsZUlkeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VyaWVzW3NhbXBsZUlkeF1bMF0gPD0gaGlnaCkge1xuICAgICAgICAgIGxhc3RJZHggPSBzYW1wbGVJZHg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpcnN0SWR4ID09PSBudWxsKSBmaXJzdElkeCA9IDA7XG4gICAgICB2YXIgY29ycmVjdGVkRmlyc3RJZHggPSBmaXJzdElkeDtcbiAgICAgIHZhciBpc0ludmFsaWRWYWx1ZSA9IHRydWU7XG4gICAgICB3aGlsZSAoaXNJbnZhbGlkVmFsdWUgJiYgY29ycmVjdGVkRmlyc3RJZHggPiAwKSB7XG4gICAgICAgIGNvcnJlY3RlZEZpcnN0SWR4LS07XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSB5IHZhbHVlIGlzIG51bGwuXG4gICAgICAgIGlzSW52YWxpZFZhbHVlID0gc2VyaWVzW2NvcnJlY3RlZEZpcnN0SWR4XVsxXSA9PT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3RJZHggPT09IG51bGwpIGxhc3RJZHggPSBzZXJpZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjb3JyZWN0ZWRMYXN0SWR4ID0gbGFzdElkeDtcbiAgICAgIGlzSW52YWxpZFZhbHVlID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChpc0ludmFsaWRWYWx1ZSAmJiBjb3JyZWN0ZWRMYXN0SWR4IDwgc2VyaWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgY29ycmVjdGVkTGFzdElkeCsrO1xuICAgICAgICBpc0ludmFsaWRWYWx1ZSA9IHNlcmllc1tjb3JyZWN0ZWRMYXN0SWR4XVsxXSA9PT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvcnJlY3RlZEZpcnN0SWR4IT09Zmlyc3RJZHgpIHtcbiAgICAgICAgZmlyc3RJZHggPSBjb3JyZWN0ZWRGaXJzdElkeDtcbiAgICAgIH1cbiAgICAgIGlmIChjb3JyZWN0ZWRMYXN0SWR4ICE9PSBsYXN0SWR4KSB7XG4gICAgICAgIGxhc3RJZHggPSBjb3JyZWN0ZWRMYXN0SWR4O1xuICAgICAgfVxuXG4gICAgICBib3VuZGFyeUlkc1tzZXJpZXNJZHgtMV0gPSBbZmlyc3RJZHgsIGxhc3RJZHhdO1xuXG4gICAgICAvLyAuc2xpY2UncyBlbmQgaXMgZXhjbHVzaXZlLCB3ZSB3YW50IHRvIGluY2x1ZGUgbGFzdElkeC5cbiAgICAgIHNlcmllcyA9IHNlcmllcy5zbGljZShmaXJzdElkeCwgbGFzdElkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpZXMgPSByb2xsZWRTZXJpZXNbc2VyaWVzSWR4XTtcbiAgICAgIGJvdW5kYXJ5SWRzW3Nlcmllc0lkeC0xXSA9IFswLCBzZXJpZXMubGVuZ3RoLTFdO1xuICAgIH1cblxuICAgIHZhciBzZXJpZXNOYW1lID0gdGhpcy5hdHRyXyhcImxhYmVsc1wiKVtzZXJpZXNJZHhdO1xuICAgIHZhciBzZXJpZXNFeHRyZW1lcyA9IHRoaXMuZGF0YUhhbmRsZXJfLmdldEV4dHJlbWVZVmFsdWVzKHNlcmllcyxcbiAgICAgICAgZGF0ZVdpbmRvdywgdGhpcy5nZXRCb29sZWFuT3B0aW9uKFwic3RlcFBsb3RcIixzZXJpZXNOYW1lKSk7XG5cbiAgICB2YXIgc2VyaWVzUG9pbnRzID0gdGhpcy5kYXRhSGFuZGxlcl8uc2VyaWVzVG9Qb2ludHMoc2VyaWVzLFxuICAgICAgICBzZXJpZXNOYW1lLCBib3VuZGFyeUlkc1tzZXJpZXNJZHgtMV1bMF0pO1xuXG4gICAgaWYgKHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbihcInN0YWNrZWRHcmFwaFwiKSkge1xuICAgICAgYXhpc0lkeCA9IHRoaXMuYXR0cmlidXRlc18uYXhpc0ZvclNlcmllcyhzZXJpZXNOYW1lKTtcbiAgICAgIGlmIChjdW11bGF0aXZlWXZhbFtheGlzSWR4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN1bXVsYXRpdmVZdmFsW2F4aXNJZHhdID0gW107XG4gICAgICB9XG4gICAgICBEeWdyYXBoLnN0YWNrUG9pbnRzXyhzZXJpZXNQb2ludHMsIGN1bXVsYXRpdmVZdmFsW2F4aXNJZHhdLCBzZXJpZXNFeHRyZW1lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbihcInN0YWNrZWRHcmFwaE5hTkZpbGxcIikpO1xuICAgIH1cblxuICAgIGV4dHJlbWVzW3Nlcmllc05hbWVdID0gc2VyaWVzRXh0cmVtZXM7XG4gICAgcG9pbnRzW3Nlcmllc0lkeF0gPSBzZXJpZXNQb2ludHM7XG4gIH1cblxuICByZXR1cm4geyBwb2ludHM6IHBvaW50cywgZXh0cmVtZXM6IGV4dHJlbWVzLCBib3VuZGFyeUlkczogYm91bmRhcnlJZHMgfTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBncmFwaCB3aXRoIG5ldyBkYXRhLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgdmlld2luZyBhcmVhXG4gKiBoYXMgY2hhbmdlZC4gSWYgdGhlIHVuZGVybHlpbmcgZGF0YSBvciBvcHRpb25zIGhhdmUgY2hhbmdlZCwgcHJlZHJhd18gd2lsbFxuICogYmUgY2FsbGVkIGJlZm9yZSBkcmF3R3JhcGhfIGlzIGNhbGxlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5kcmF3R3JhcGhfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGFydCA9IG5ldyBEYXRlKCk7XG5cbiAgLy8gVGhpcyBpcyB1c2VkIHRvIHNldCB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBkcmF3Q2FsbGJhY2ssIGJlbG93LlxuICB2YXIgaXNfaW5pdGlhbF9kcmF3ID0gdGhpcy5pc19pbml0aWFsX2RyYXdfO1xuICB0aGlzLmlzX2luaXRpYWxfZHJhd18gPSBmYWxzZTtcblxuICB0aGlzLmxheW91dF8ucmVtb3ZlQWxsRGF0YXNldHMoKTtcbiAgdGhpcy5zZXRDb2xvcnNfKCk7XG4gIHRoaXMuYXR0cnNfLnBvaW50U2l6ZSA9IDAuNSAqIHRoaXMuZ2V0TnVtZXJpY09wdGlvbignaGlnaGxpZ2h0Q2lyY2xlU2l6ZScpO1xuXG4gIHZhciBwYWNrZWQgPSB0aGlzLmdhdGhlckRhdGFzZXRzXyh0aGlzLnJvbGxlZFNlcmllc18sIHRoaXMuZGF0ZVdpbmRvd18pO1xuICB2YXIgcG9pbnRzID0gcGFja2VkLnBvaW50cztcbiAgdmFyIGV4dHJlbWVzID0gcGFja2VkLmV4dHJlbWVzO1xuICB0aGlzLmJvdW5kYXJ5SWRzXyA9IHBhY2tlZC5ib3VuZGFyeUlkcztcblxuICB0aGlzLnNldEluZGV4QnlOYW1lXyA9IHt9O1xuICB2YXIgbGFiZWxzID0gdGhpcy5hdHRyXyhcImxhYmVsc1wiKTtcbiAgdmFyIGRhdGFJZHggPSAwO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghdGhpcy52aXNpYmlsaXR5KClbaSAtIDFdKSBjb250aW51ZTtcbiAgICB0aGlzLmxheW91dF8uYWRkRGF0YXNldChsYWJlbHNbaV0sIHBvaW50c1tpXSk7XG4gICAgdGhpcy5kYXRhc2V0SW5kZXhfW2ldID0gZGF0YUlkeCsrO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5zZXRJbmRleEJ5TmFtZV9bbGFiZWxzW2ldXSA9IGk7XG4gIH1cblxuICB0aGlzLmNvbXB1dGVZQXhpc1Jhbmdlc18oZXh0cmVtZXMpO1xuICB0aGlzLmxheW91dF8uc2V0WUF4ZXModGhpcy5heGVzXyk7XG5cbiAgdGhpcy5hZGRYVGlja3NfKCk7XG5cbiAgLy8gVGVsbCBQbG90S2l0IHRvIHVzZSB0aGlzIG5ldyBkYXRhIGFuZCByZW5kZXIgaXRzZWxmXG4gIHRoaXMubGF5b3V0Xy5ldmFsdWF0ZSgpO1xuICB0aGlzLnJlbmRlckdyYXBoXyhpc19pbml0aWFsX2RyYXcpO1xuXG4gIGlmICh0aGlzLmdldFN0cmluZ09wdGlvbihcInRpbWluZ05hbWVcIikpIHtcbiAgICB2YXIgZW5kID0gbmV3IERhdGUoKTtcbiAgICBjb25zb2xlLmxvZyh0aGlzLmdldFN0cmluZ09wdGlvbihcInRpbWluZ05hbWVcIikgKyBcIiAtIGRyYXdHcmFwaDogXCIgKyAoZW5kIC0gc3RhcnQpICsgXCJtc1wiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIGRvZXMgdGhlIHdvcmsgb2YgZHJhd2luZyB0aGUgY2hhcnQuIEl0IGFzc3VtZXMgdGhhdCB0aGUgbGF5b3V0IGFuZCBheGlzXG4gKiBzY2FsZXMgaGF2ZSBhbHJlYWR5IGJlZW4gc2V0IChlLmcuIGJ5IHByZWRyYXdfKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5yZW5kZXJHcmFwaF8gPSBmdW5jdGlvbihpc19pbml0aWFsX2RyYXcpIHtcbiAgdGhpcy5jYXNjYWRlRXZlbnRzXygnY2xlYXJDaGFydCcpO1xuICB0aGlzLnBsb3R0ZXJfLmNsZWFyKCk7XG5cbiAgY29uc3QgdW5kZXJsYXlDYWxsYmFjayA9IHRoaXMuZ2V0RnVuY3Rpb25PcHRpb24oJ3VuZGVybGF5Q2FsbGJhY2snKTtcbiAgaWYgKHVuZGVybGF5Q2FsbGJhY2spIHtcbiAgICAvLyBOT1RFOiB3ZSBwYXNzIHRoZSBkeWdyYXBoIG9iamVjdCB0byB0aGlzIGNhbGxiYWNrIHR3aWNlIHRvIGF2b2lkIGJyZWFraW5nXG4gICAgLy8gdXNlcnMgd2hvIGV4cGVjdCBhIGRlcHJlY2F0ZWQgZm9ybSBvZiB0aGlzIGNhbGxiYWNrLlxuICAgIHVuZGVybGF5Q2FsbGJhY2suY2FsbCh0aGlzLFxuICAgICAgICB0aGlzLmhpZGRlbl9jdHhfLCB0aGlzLmxheW91dF8uZ2V0UGxvdEFyZWEoKSwgdGhpcywgdGhpcyk7XG4gIH1cblxuICB2YXIgZSA9IHtcbiAgICBjYW52YXM6IHRoaXMuaGlkZGVuXyxcbiAgICBkcmF3aW5nQ29udGV4dDogdGhpcy5oaWRkZW5fY3R4X1xuICB9O1xuICB0aGlzLmNhc2NhZGVFdmVudHNfKCd3aWxsRHJhd0NoYXJ0JywgZSk7XG4gIHRoaXMucGxvdHRlcl8ucmVuZGVyKCk7XG4gIHRoaXMuY2FzY2FkZUV2ZW50c18oJ2RpZERyYXdDaGFydCcsIGUpO1xuICB0aGlzLmxhc3RSb3dfID0gLTE7ICAvLyBiZWNhdXNlIHBsdWdpbnMvbGVnZW5kLmpzIGNsZWFycyB0aGUgbGVnZW5kXG5cbiAgLy8gVE9ETyhkYW52ayk6IGlzIHRoaXMgYSBwZXJmb3JtYW5jZSBib3R0bGVuZWNrIHdoZW4gcGFubmluZz9cbiAgLy8gVGhlIGludGVyYWN0aW9uIGNhbnZhcyBzaG91bGQgYWxyZWFkeSBiZSBlbXB0eSBpbiB0aGF0IHNpdHVhdGlvbi5cbiAgdGhpcy5jYW52YXNfLmdldENvbnRleHQoJzJkJykuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGhfLCB0aGlzLmhlaWdodF8pO1xuXG4gIGNvbnN0IGRyYXdDYWxsYmFjayA9IHRoaXMuZ2V0RnVuY3Rpb25PcHRpb24oXCJkcmF3Q2FsbGJhY2tcIik7XG4gIGlmIChkcmF3Q2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICBkcmF3Q2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLCBpc19pbml0aWFsX2RyYXcpO1xuICB9XG4gIGlmIChpc19pbml0aWFsX2RyYXcpIHtcbiAgICB0aGlzLnJlYWR5RmlyZWRfID0gdHJ1ZTtcbiAgICB3aGlsZSAodGhpcy5yZWFkeUZuc18ubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGZuID0gdGhpcy5yZWFkeUZuc18ucG9wKCk7XG4gICAgICBmbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIERldGVybWluZSBwcm9wZXJ0aWVzIG9mIHRoZSB5LWF4ZXMgd2hpY2ggYXJlIGluZGVwZW5kZW50IG9mIHRoZSBkYXRhXG4gKiBjdXJyZW50bHkgYmVpbmcgZGlzcGxheWVkLiBUaGlzIGluY2x1ZGVzIHRoaW5ncyBsaWtlIHRoZSBudW1iZXIgb2YgYXhlcyBhbmRcbiAqIHRoZSBzdHlsZSBvZiB0aGUgYXhlcy4gSXQgZG9lcyBub3QgaW5jbHVkZSB0aGUgcmFuZ2Ugb2YgZWFjaCBheGlzIGFuZCBpdHNcbiAqIHRpY2sgbWFya3MuXG4gKiBUaGlzIGZpbGxzIGluIHRoaXMuYXhlc18uXG4gKiBheGVzXyA9IFsgeyBvcHRpb25zIH0gXVxuICogICBpbmRpY2VzIGFyZSBpbnRvIHRoZSBheGVzXyBhcnJheS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuY29tcHV0ZVlBeGVzXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXhpcywgaW5kZXgsIG9wdHMsIHY7XG5cbiAgLy8gdGhpcy5heGVzXyBkb2Vzbid0IG1hdGNoIHRoaXMuYXR0cmlidXRlc18uYXhlc18ub3B0aW9ucy4gSXQncyB1c2VkIGZvclxuICAvLyBkYXRhIGNvbXB1dGF0aW9uIGFzIHdlbGwgYXMgb3B0aW9ucyBzdG9yYWdlLlxuICAvLyBHbyB0aHJvdWdoIG9uY2UgYW5kIGFkZCBhbGwgdGhlIGF4ZXMuXG4gIHRoaXMuYXhlc18gPSBbXTtcblxuICBmb3IgKGF4aXMgPSAwOyBheGlzIDwgdGhpcy5hdHRyaWJ1dGVzXy5udW1BeGVzKCk7IGF4aXMrKykge1xuICAgIC8vIEFkZCBhIG5ldyBheGlzLCBtYWtpbmcgYSBjb3B5IG9mIGl0cyBwZXItYXhpcyBvcHRpb25zLlxuICAgIG9wdHMgPSB7IGcgOiB0aGlzIH07XG4gICAgdXRpbHMudXBkYXRlKG9wdHMsIHRoaXMuYXR0cmlidXRlc18uYXhpc09wdGlvbnMoYXhpcykpO1xuICAgIHRoaXMuYXhlc19bYXhpc10gPSBvcHRzO1xuICB9XG5cbiAgZm9yIChheGlzID0gMDsgYXhpcyA8IHRoaXMuYXhlc18ubGVuZ3RoOyBheGlzKyspIHtcbiAgICBpZiAoYXhpcyA9PT0gMCkge1xuICAgICAgb3B0cyA9IHRoaXMub3B0aW9uc1ZpZXdGb3JBeGlzXygneScgKyAoYXhpcyA/ICcyJyA6ICcnKSk7XG4gICAgICB2ID0gb3B0cyhcInZhbHVlUmFuZ2VcIik7XG4gICAgICBpZiAodikgdGhpcy5heGVzX1theGlzXS52YWx1ZVJhbmdlID0gdjtcbiAgICB9IGVsc2UgeyAgLy8gVG8ga2VlcCBvbGQgYmVoYXZpb3JcbiAgICAgIHZhciBheGVzID0gdGhpcy51c2VyX2F0dHJzXy5heGVzO1xuICAgICAgaWYgKGF4ZXMgJiYgYXhlcy55Mikge1xuICAgICAgICB2ID0gYXhlcy55Mi52YWx1ZVJhbmdlO1xuICAgICAgICBpZiAodikgdGhpcy5heGVzX1theGlzXS52YWx1ZVJhbmdlID0gdjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHktYXhlcyBvbiB0aGUgY2hhcnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBudW1iZXIgb2YgYXhlcy5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUubnVtQXhlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzXy5udW1BeGVzKCk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZXR1cm5zIGF4aXMgcHJvcGVydGllcyBmb3IgdGhlIGdpdmVuIHNlcmllcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZXROYW1lIFRoZSBuYW1lIG9mIHRoZSBzZXJpZXMgZm9yIHdoaWNoIHRvIGdldCBheGlzXG4gKiBwcm9wZXJ0aWVzLCBlLmcuICdZMScuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBheGlzIHByb3BlcnRpZXMuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmF4aXNQcm9wZXJ0aWVzRm9yU2VyaWVzID0gZnVuY3Rpb24oc2VyaWVzKSB7XG4gIC8vIFRPRE8oZGFudmspOiBoYW5kbGUgZXJyb3JzLlxuICByZXR1cm4gdGhpcy5heGVzX1t0aGlzLmF0dHJpYnV0ZXNfLmF4aXNGb3JTZXJpZXMoc2VyaWVzKV07XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBEZXRlcm1pbmUgdGhlIHZhbHVlIHJhbmdlIGFuZCB0aWNrIG1hcmtzIGZvciBlYWNoIGF4aXMuXG4gKiBAcGFyYW0ge09iamVjdH0gZXh0cmVtZXMgQSBtYXBwaW5nIGZyb20gc2VyaWVzTmFtZSAtPiBbbG93LCBoaWdoXVxuICogVGhpcyBmaWxscyBpbiB0aGUgdmFsdWVSYW5nZSBhbmQgdGlja3MgZmllbGRzIGluIGVhY2ggZW50cnkgb2YgdGhpcy5heGVzXy5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuY29tcHV0ZVlBeGlzUmFuZ2VzXyA9IGZ1bmN0aW9uKGV4dHJlbWVzKSB7XG4gIHZhciBpc051bGxVbmRlZmluZWRPck5hTiA9IGZ1bmN0aW9uKG51bSkge1xuICAgIHJldHVybiBpc05hTihwYXJzZUZsb2F0KG51bSkpO1xuICB9O1xuICB2YXIgbnVtQXhlcyA9IHRoaXMuYXR0cmlidXRlc18ubnVtQXhlcygpO1xuICB2YXIgeXBhZENvbXBhdCwgc3Bhbiwgc2VyaWVzLCB5cGFkO1xuXG4gIHZhciBwX2F4aXM7XG5cbiAgLy8gQ29tcHV0ZSBleHRyZW1lIHZhbHVlcywgYSBzcGFuIGFuZCB0aWNrIG1hcmtzIGZvciBlYWNoIGF4aXMuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQXhlczsgaSsrKSB7XG4gICAgdmFyIGF4aXMgPSB0aGlzLmF4ZXNfW2ldO1xuICAgIHZhciBsb2dzY2FsZSA9IHRoaXMuYXR0cmlidXRlc18uZ2V0Rm9yQXhpcyhcImxvZ3NjYWxlXCIsIGkpO1xuICAgIHZhciBpbmNsdWRlWmVybyA9IHRoaXMuYXR0cmlidXRlc18uZ2V0Rm9yQXhpcyhcImluY2x1ZGVaZXJvXCIsIGkpO1xuICAgIHZhciBpbmRlcGVuZGVudFRpY2tzID0gdGhpcy5hdHRyaWJ1dGVzXy5nZXRGb3JBeGlzKFwiaW5kZXBlbmRlbnRUaWNrc1wiLCBpKTtcbiAgICBzZXJpZXMgPSB0aGlzLmF0dHJpYnV0ZXNfLnNlcmllc0ZvckF4aXMoaSk7XG5cbiAgICAvLyBBZGQgc29tZSBwYWRkaW5nLiBUaGlzIHN1cHBvcnRzIHR3byBZIHBhZGRpbmcgb3BlcmF0aW9uIG1vZGVzOlxuICAgIC8vXG4gICAgLy8gLSBiYWNrd2FyZHMgY29tcGF0aWJsZSAoeVJhbmdlUGFkIG5vdCBzZXQpOlxuICAgIC8vICAgMTAlIHBhZGRpbmcgZm9yIGF1dG9tYXRpYyBZIHJhbmdlcywgYnV0IG5vdCBmb3IgdXNlci1zdXBwbGllZFxuICAgIC8vICAgcmFuZ2VzLCBhbmQgbW92ZSBhIGNsb3NlLXRvLXplcm8gZWRnZSB0byB6ZXJvLCBzaW5jZSBkcmF3aW5nIGF0IHRoZSBlZGdlXG4gICAgLy8gICByZXN1bHRzIGluIGludmlzaWJsZSBsaW5lcy4gVW5mb3J0dW5hdGVseSBsaW5lcyBkcmF3biBhdCB0aGUgZWRnZSBvZiBhXG4gICAgLy8gICB1c2VyLXN1cHBsaWVkIHJhbmdlIHdpbGwgc3RpbGwgYmUgaW52aXNpYmxlLiBJZiBsb2dzY2FsZSBpc1xuICAgIC8vICAgc2V0LCBhZGQgYSB2YXJpYWJsZSBhbW91bnQgb2YgcGFkZGluZyBhdCB0aGUgdG9wIGJ1dFxuICAgIC8vICAgbm9uZSBhdCB0aGUgYm90dG9tLlxuICAgIC8vXG4gICAgLy8gLSBuZXctc3R5bGUgKHlSYW5nZVBhZCBzZXQgYnkgdGhlIHVzZXIpOlxuICAgIC8vICAgYWx3YXlzIGFkZCB0aGUgc3BlY2lmaWVkIFkgcGFkZGluZy5cbiAgICAvL1xuICAgIHlwYWRDb21wYXQgPSB0cnVlO1xuICAgIHlwYWQgPSAwLjE7IC8vIGFkZCAxMCVcbiAgICBjb25zdCB5UmFuZ2VQYWQgPSB0aGlzLmdldE51bWVyaWNPcHRpb24oJ3lSYW5nZVBhZCcpO1xuICAgIGlmICh5UmFuZ2VQYWQgIT09IG51bGwpIHtcbiAgICAgIHlwYWRDb21wYXQgPSBmYWxzZTtcbiAgICAgIC8vIENvbnZlcnQgcGl4ZWwgcGFkZGluZyB0byByYXRpb1xuICAgICAgeXBhZCA9IHlSYW5nZVBhZCAvIHRoaXMucGxvdHRlcl8uYXJlYS5oO1xuICAgIH1cblxuICAgIGlmIChzZXJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBJZiBubyBzZXJpZXMgYXJlIGRlZmluZWQgb3IgdmlzaWJsZSB0aGVuIHVzZSBhIHJlYXNvbmFibGUgZGVmYXVsdFxuICAgICAgYXhpcy5leHRyZW1lUmFuZ2UgPSBbMCwgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZXh0cmVtZXMgb2YgZXh0cmVtZXMuXG4gICAgICB2YXIgbWluWSA9IEluZmluaXR5OyAgLy8gZXh0cmVtZXNbc2VyaWVzWzBdXVswXTtcbiAgICAgIHZhciBtYXhZID0gLUluZmluaXR5OyAgLy8gZXh0cmVtZXNbc2VyaWVzWzBdXVsxXTtcbiAgICAgIHZhciBleHRyZW1lTWluWSwgZXh0cmVtZU1heFk7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VyaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIC8vIHRoaXMgc2tpcHMgaW52aXNpYmxlIHNlcmllc1xuICAgICAgICBpZiAoIWV4dHJlbWVzLmhhc093blByb3BlcnR5KHNlcmllc1tqXSkpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIE9ubHkgdXNlIHZhbGlkIGV4dHJlbWVzIHRvIHN0b3AgbnVsbCBkYXRhIHNlcmllcycgZnJvbSBjb3JydXB0aW5nIHRoZSBzY2FsZS5cbiAgICAgICAgZXh0cmVtZU1pblkgPSBleHRyZW1lc1tzZXJpZXNbal1dWzBdO1xuICAgICAgICBpZiAoZXh0cmVtZU1pblkgIT09IG51bGwpIHtcbiAgICAgICAgICBtaW5ZID0gTWF0aC5taW4oZXh0cmVtZU1pblksIG1pblkpO1xuICAgICAgICB9XG4gICAgICAgIGV4dHJlbWVNYXhZID0gZXh0cmVtZXNbc2VyaWVzW2pdXVsxXTtcbiAgICAgICAgaWYgKGV4dHJlbWVNYXhZICE9PSBudWxsKSB7XG4gICAgICAgICAgbWF4WSA9IE1hdGgubWF4KGV4dHJlbWVNYXhZLCBtYXhZKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJbmNsdWRlIHplcm8gaWYgcmVxdWVzdGVkIGJ5IHRoZSB1c2VyLlxuICAgICAgaWYgKGluY2x1ZGVaZXJvICYmICFsb2dzY2FsZSkge1xuICAgICAgICBpZiAobWluWSA+IDApIG1pblkgPSAwO1xuICAgICAgICBpZiAobWF4WSA8IDApIG1heFkgPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBFbnN1cmUgd2UgaGF2ZSBhIHZhbGlkIHNjYWxlLCBvdGhlcndpc2UgZGVmYXVsdCB0byBbMCwgMV0gZm9yIHNhZmV0eS5cbiAgICAgIGlmIChtaW5ZID09IEluZmluaXR5KSBtaW5ZID0gMDtcbiAgICAgIGlmIChtYXhZID09IC1JbmZpbml0eSkgbWF4WSA9IDE7XG5cbiAgICAgIHNwYW4gPSBtYXhZIC0gbWluWTtcbiAgICAgIC8vIHNwZWNpYWwgY2FzZTogaWYgd2UgaGF2ZSBubyBzZW5zZSBvZiBzY2FsZSwgY2VudGVyIG9uIHRoZSBzb2xlIHZhbHVlLlxuICAgICAgaWYgKHNwYW4gPT09IDApIHtcbiAgICAgICAgaWYgKG1heFkgIT09IDApIHtcbiAgICAgICAgICBzcGFuID0gTWF0aC5hYnMobWF4WSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gLi4uIGFuZCBpZiB0aGUgc29sZSB2YWx1ZSBpcyB6ZXJvLCB1c2UgcmFuZ2UgMC0xLlxuICAgICAgICAgIG1heFkgPSAxO1xuICAgICAgICAgIHNwYW4gPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXhBeGlzWSA9IG1heFksIG1pbkF4aXNZID0gbWluWTtcbiAgICAgIGlmICh5cGFkQ29tcGF0KSB7XG4gICAgICAgIGlmIChsb2dzY2FsZSkge1xuICAgICAgICAgIG1heEF4aXNZID0gbWF4WSArIHlwYWQgKiBzcGFuO1xuICAgICAgICAgIG1pbkF4aXNZID0gbWluWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXhBeGlzWSA9IG1heFkgKyB5cGFkICogc3BhbjtcbiAgICAgICAgICBtaW5BeGlzWSA9IG1pblkgLSB5cGFkICogc3BhbjtcblxuICAgICAgICAgIC8vIEJhY2t3YXJkcy1jb21wYXRpYmxlIGJlaGF2aW9yOiBNb3ZlIHRoZSBzcGFuIHRvIHN0YXJ0IG9yIGVuZCBhdCB6ZXJvIGlmIGl0J3NcbiAgICAgICAgICAvLyBjbG9zZSB0byB6ZXJvLlxuICAgICAgICAgIGlmIChtaW5BeGlzWSA8IDAgJiYgbWluWSA+PSAwKSBtaW5BeGlzWSA9IDA7XG4gICAgICAgICAgaWYgKG1heEF4aXNZID4gMCAmJiBtYXhZIDw9IDApIG1heEF4aXNZID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXhpcy5leHRyZW1lUmFuZ2UgPSBbbWluQXhpc1ksIG1heEF4aXNZXTtcbiAgICB9XG4gICAgaWYgKGF4aXMudmFsdWVSYW5nZSkge1xuICAgICAgLy8gVGhpcyBpcyBhIHVzZXItc2V0IHZhbHVlIHJhbmdlIGZvciB0aGlzIGF4aXMuXG4gICAgICB2YXIgeTAgPSBpc051bGxVbmRlZmluZWRPck5hTihheGlzLnZhbHVlUmFuZ2VbMF0pID8gYXhpcy5leHRyZW1lUmFuZ2VbMF0gOiBheGlzLnZhbHVlUmFuZ2VbMF07XG4gICAgICB2YXIgeTEgPSBpc051bGxVbmRlZmluZWRPck5hTihheGlzLnZhbHVlUmFuZ2VbMV0pID8gYXhpcy5leHRyZW1lUmFuZ2VbMV0gOiBheGlzLnZhbHVlUmFuZ2VbMV07XG4gICAgICBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZSA9IFt5MCwgeTFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZSA9IGF4aXMuZXh0cmVtZVJhbmdlO1xuICAgIH1cbiAgICBpZiAoIXlwYWRDb21wYXQpIHtcbiAgICAgIC8vIFdoZW4gdXNpbmcgeVJhbmdlUGFkLCBhZGp1c3QgdGhlIHVwcGVyL2xvd2VyIGJvdW5kcyB0byBhZGRcbiAgICAgIC8vIHBhZGRpbmcgdW5sZXNzIHRoZSB1c2VyIGhhcyB6b29tZWQvcGFubmVkIHRoZSBZIGF4aXMgcmFuZ2UuXG4gICAgICBpZiAobG9nc2NhbGUpIHtcbiAgICAgICAgeTAgPSBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVswXTtcbiAgICAgICAgeTEgPSBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVsxXTtcbiAgICAgICAgdmFyIHkwcGN0ID0geXBhZCAvICgyICogeXBhZCAtIDEpO1xuICAgICAgICB2YXIgeTFwY3QgPSAoeXBhZCAtIDEpIC8gKDIgKiB5cGFkIC0gMSk7XG4gICAgICAgIGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdID0gdXRpbHMubG9nUmFuZ2VGcmFjdGlvbih5MCwgeTEsIHkwcGN0KTtcbiAgICAgICAgYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMV0gPSB1dGlscy5sb2dSYW5nZUZyYWN0aW9uKHkwLCB5MSwgeTFwY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeTAgPSBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVswXTtcbiAgICAgICAgeTEgPSBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVsxXTtcbiAgICAgICAgc3BhbiA9IHkxIC0geTA7XG4gICAgICAgIGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdID0geTAgLSBzcGFuICogeXBhZDtcbiAgICAgICAgYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMV0gPSB5MSArIHNwYW4gKiB5cGFkO1xuICAgICAgfVxuICAgIH1cblxuXG4gICAgaWYgKGluZGVwZW5kZW50VGlja3MpIHtcbiAgICAgIGF4aXMuaW5kZXBlbmRlbnRUaWNrcyA9IGluZGVwZW5kZW50VGlja3M7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9uc1ZpZXdGb3JBeGlzXygneScgKyAoaSA/ICcyJyA6ICcnKSk7XG4gICAgICB2YXIgdGlja2VyID0gb3B0cygndGlja2VyJyk7XG4gICAgICBheGlzLnRpY2tzID0gdGlja2VyKGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdLFxuICAgICAgICAgICAgICBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVsxXSxcbiAgICAgICAgICAgICAgdGhpcy5wbG90dGVyXy5hcmVhLmgsXG4gICAgICAgICAgICAgIG9wdHMsXG4gICAgICAgICAgICAgIHRoaXMpO1xuICAgICAgLy8gRGVmaW5lIHRoZSBmaXJzdCBpbmRlcGVuZGVudCBheGlzIGFzIHByaW1hcnkgYXhpcy5cbiAgICAgIGlmICghcF9heGlzKSBwX2F4aXMgPSBheGlzO1xuICAgIH1cbiAgfVxuICBpZiAocF9heGlzID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyAoXCJDb25maWd1cmF0aW9uIEVycm9yOiBBdCBsZWFzdCBvbmUgYXhpcyBoYXMgdG8gaGF2ZSB0aGUgXFxcImluZGVwZW5kZW50VGlja3NcXFwiIG9wdGlvbiBhY3RpdmF0ZWQuXCIpO1xuICB9XG4gIC8vIEFkZCB0aWNrcy4gQnkgZGVmYXVsdCwgYWxsIGF4ZXMgaW5oZXJpdCB0aGUgdGljayBwb3NpdGlvbnMgb2YgdGhlXG4gIC8vIHByaW1hcnkgYXhpcy4gSG93ZXZlciwgaWYgYW4gYXhpcyBpcyBzcGVjaWZpY2FsbHkgbWFya2VkIGFzIGhhdmluZ1xuICAvLyBpbmRlcGVuZGVudCB0aWNrcywgdGhlbiB0aGF0IGlzIHBlcm1pc3NpYmxlIGFzIHdlbGwuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQXhlczsgaSsrKSB7XG4gICAgdmFyIGF4aXMgPSB0aGlzLmF4ZXNfW2ldO1xuXG4gICAgaWYgKCFheGlzLmluZGVwZW5kZW50VGlja3MpIHtcbiAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zVmlld0ZvckF4aXNfKCd5JyArIChpID8gJzInIDogJycpKTtcbiAgICAgIHZhciB0aWNrZXIgPSBvcHRzKCd0aWNrZXInKTtcbiAgICAgIHZhciBwX3RpY2tzID0gcF9heGlzLnRpY2tzO1xuICAgICAgdmFyIHBfc2NhbGUgPSBwX2F4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzFdIC0gcF9heGlzLmNvbXB1dGVkVmFsdWVSYW5nZVswXTtcbiAgICAgIHZhciBzY2FsZSA9IGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzFdIC0gYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMF07XG4gICAgICB2YXIgdGlja192YWx1ZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcF90aWNrcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgeV9mcmFjID0gKHBfdGlja3Nba10udiAtIHBfYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMF0pIC8gcF9zY2FsZTtcbiAgICAgICAgdmFyIHlfdmFsID0gYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMF0gKyB5X2ZyYWMgKiBzY2FsZTtcbiAgICAgICAgdGlja192YWx1ZXMucHVzaCh5X3ZhbCk7XG4gICAgICB9XG5cbiAgICAgIGF4aXMudGlja3MgPSB0aWNrZXIoYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsb3R0ZXJfLmFyZWEuaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGlja192YWx1ZXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBEZXRlY3RzIHRoZSB0eXBlIG9mIHRoZSBzdHIgKGRhdGUgb3IgbnVtZXJpYykgYW5kIHNldHMgdGhlIHZhcmlvdXNcbiAqIGZvcm1hdHRpbmcgYXR0cmlidXRlcyBpbiB0aGlzLmF0dHJzXyBiYXNlZCBvbiB0aGlzIHR5cGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIEFuIHggdmFsdWUuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5kZXRlY3RUeXBlRnJvbVN0cmluZ18gPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIGlzRGF0ZSA9IGZhbHNlO1xuICB2YXIgZGFzaFBvcyA9IHN0ci5pbmRleE9mKCctJyk7ICAvLyBjb3VsZCBiZSAyMDA2LTAxLTAxIF9vcl8gMS4wZS0yXG4gIGlmICgoZGFzaFBvcyA+IDAgJiYgKHN0cltkYXNoUG9zLTFdICE9ICdlJyAmJiBzdHJbZGFzaFBvcy0xXSAhPSAnRScpKSB8fFxuICAgICAgc3RyLmluZGV4T2YoJy8nKSA+PSAwIHx8XG4gICAgICBpc05hTihwYXJzZUZsb2F0KHN0cikpKSB7XG4gICAgaXNEYXRlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzdHIubGVuZ3RoID09IDggJiYgc3RyID4gJzE5NzAwMTAxJyAmJiBzdHIgPCAnMjAzNzEyMzEnKSB7XG4gICAgLy8gVE9ETyhkYW52ayk6IHJlbW92ZSBzdXBwb3J0IGZvciB0aGlzIGZvcm1hdC5cbiAgICBpc0RhdGUgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5zZXRYQXhpc09wdGlvbnNfKGlzRGF0ZSk7XG59O1xuXG5EeWdyYXBoLnByb3RvdHlwZS5zZXRYQXhpc09wdGlvbnNfID0gZnVuY3Rpb24oaXNEYXRlKSB7XG4gIGlmIChpc0RhdGUpIHtcbiAgICB0aGlzLmF0dHJzXy54VmFsdWVQYXJzZXIgPSB1dGlscy5kYXRlUGFyc2VyO1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC52YWx1ZUZvcm1hdHRlciA9IHV0aWxzLmRhdGVWYWx1ZUZvcm1hdHRlcjtcbiAgICB0aGlzLmF0dHJzXy5heGVzLngudGlja2VyID0gRHlncmFwaFRpY2tlcnMuZGF0ZVRpY2tlcjtcbiAgICB0aGlzLmF0dHJzXy5heGVzLnguYXhpc0xhYmVsRm9ybWF0dGVyID0gdXRpbHMuZGF0ZUF4aXNMYWJlbEZvcm1hdHRlcjtcbiAgfSBlbHNlIHtcbiAgICAvKiogQHByaXZhdGUgKHNodXQgdXAsIGpzZG9jISkgKi9cbiAgICB0aGlzLmF0dHJzXy54VmFsdWVQYXJzZXIgPSBmdW5jdGlvbih4KSB7IHJldHVybiBwYXJzZUZsb2F0KHgpOyB9O1xuICAgIC8vIFRPRE8oZGFudmspOiB1c2UgRHlncmFwaC5udW1iZXJWYWx1ZUZvcm1hdHRlciBoZXJlP1xuICAgIC8qKiBAcHJpdmF0ZSAoc2h1dCB1cCwganNkb2MhKSAqL1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC52YWx1ZUZvcm1hdHRlciA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg7IH07XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LnRpY2tlciA9IER5Z3JhcGhUaWNrZXJzLm51bWVyaWNUaWNrcztcbiAgICB0aGlzLmF0dHJzXy5heGVzLnguYXhpc0xhYmVsRm9ybWF0dGVyID0gdGhpcy5hdHRyc18uYXhlcy54LnZhbHVlRm9ybWF0dGVyO1xuICB9XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBQYXJzZXMgYSBzdHJpbmcgaW4gYSBzcGVjaWFsIGNzdiBmb3JtYXQuICBXZSBleHBlY3QgYSBjc3YgZmlsZSB3aGVyZSBlYWNoXG4gKiBsaW5lIGlzIGEgZGF0ZSBwb2ludCwgYW5kIHRoZSBmaXJzdCBmaWVsZCBpbiBlYWNoIGxpbmUgaXMgdGhlIGRhdGUgc3RyaW5nLlxuICogV2UgYWxzbyBleHBlY3QgdGhhdCBhbGwgcmVtYWluaW5nIGZpZWxkcyByZXByZXNlbnQgc2VyaWVzLlxuICogaWYgdGhlIGVycm9yQmFycyBhdHRyaWJ1dGUgaXMgc2V0LCB0aGVuIGludGVycHJldCB0aGUgZmllbGRzIGFzOlxuICogZGF0ZSwgc2VyaWVzMSwgc3RkZGV2MSwgc2VyaWVzMiwgc3RkZGV2MiwgLi4uXG4gKiBAcGFyYW0ge1tPYmplY3RdfSBkYXRhIFNlZSBhYm92ZS5cbiAqXG4gKiBAcmV0dXJuIFtPYmplY3RdIEFuIGFycmF5IHdpdGggb25lIGVudHJ5IGZvciBlYWNoIHJvdy4gVGhlc2UgZW50cmllc1xuICogYXJlIGFuIGFycmF5IG9mIGNlbGxzIGluIHRoYXQgcm93LiBUaGUgZmlyc3QgZW50cnkgaXMgdGhlIHBhcnNlZCB4LXZhbHVlIGZvclxuICogdGhlIHJvdy4gVGhlIHNlY29uZCwgdGhpcmQsIGV0Yy4gYXJlIHRoZSB5LXZhbHVlcy4gVGhlc2UgY2FuIHRha2Ugb24gb25lIG9mXG4gKiB0aHJlZSBmb3JtcywgZGVwZW5kaW5nIG9uIHRoZSBDU1YgYW5kIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnM6XG4gKiAxLiBudW1lcmljIHZhbHVlXG4gKiAyLiBbIHZhbHVlLCBzdGRkZXYgXVxuICogMy4gWyBsb3cgdmFsdWUsIGNlbnRlciB2YWx1ZSwgaGlnaCB2YWx1ZSBdXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnBhcnNlQ1NWXyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIHJldCA9IFtdO1xuICB2YXIgbGluZV9kZWxpbWl0ZXIgPSB1dGlscy5kZXRlY3RMaW5lRGVsaW1pdGVyKGRhdGEpO1xuICB2YXIgbGluZXMgPSBkYXRhLnNwbGl0KGxpbmVfZGVsaW1pdGVyIHx8IFwiXFxuXCIpO1xuICB2YXIgdmFscywgajtcblxuICAvLyBVc2UgdGhlIGRlZmF1bHQgZGVsaW1pdGVyIG9yIGZhbGwgYmFjayB0byBhIHRhYiBpZiB0aGF0IG1ha2VzIHNlbnNlLlxuICB2YXIgZGVsaW0gPSB0aGlzLmdldFN0cmluZ09wdGlvbignZGVsaW1pdGVyJyk7XG4gIGlmIChsaW5lc1swXS5pbmRleE9mKGRlbGltKSA9PSAtMSAmJiBsaW5lc1swXS5pbmRleE9mKCdcXHQnKSA+PSAwKSB7XG4gICAgZGVsaW0gPSAnXFx0JztcbiAgfVxuXG4gIHZhciBzdGFydCA9IDA7XG4gIGlmICghKCdsYWJlbHMnIGluIHRoaXMudXNlcl9hdHRyc18pKSB7XG4gICAgLy8gVXNlciBoYXNuJ3QgZXhwbGljaXRseSBzZXQgbGFiZWxzLCBzbyB0aGV5J3JlIChwcmVzdW1hYmx5KSBpbiB0aGUgQ1NWLlxuICAgIHN0YXJ0ID0gMTtcbiAgICB0aGlzLmF0dHJzXy5sYWJlbHMgPSBsaW5lc1swXS5zcGxpdChkZWxpbSk7ICAvLyBOT1RFOiBfbm90XyB1c2VyX2F0dHJzXy5cbiAgICB0aGlzLmF0dHJpYnV0ZXNfLnJlcGFyc2VTZXJpZXMoKTtcbiAgfVxuICB2YXIgbGluZV9ubyA9IDA7XG5cbiAgdmFyIHhQYXJzZXI7XG4gIHZhciBkZWZhdWx0UGFyc2VyU2V0ID0gZmFsc2U7ICAvLyBhdHRlbXB0IHRvIGF1dG8tZGV0ZWN0IHggdmFsdWUgdHlwZVxuICB2YXIgZXhwZWN0ZWRDb2xzID0gdGhpcy5hdHRyXyhcImxhYmVsc1wiKS5sZW5ndGg7XG4gIHZhciBvdXRPZk9yZGVyID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBsaW5lX25vID0gaTtcbiAgICBpZiAobGluZS5sZW5ndGggPT09IDApIGNvbnRpbnVlOyAgLy8gc2tpcCBibGFuayBsaW5lc1xuICAgIGlmIChsaW5lWzBdID09ICcjJykgY29udGludWU7ICAgIC8vIHNraXAgY29tbWVudCBsaW5lc1xuICAgIHZhciBpbkZpZWxkcyA9IGxpbmUuc3BsaXQoZGVsaW0pO1xuICAgIGlmIChpbkZpZWxkcy5sZW5ndGggPCAyKSBjb250aW51ZTtcblxuICAgIHZhciBmaWVsZHMgPSBbXTtcbiAgICBpZiAoIWRlZmF1bHRQYXJzZXJTZXQpIHtcbiAgICAgIHRoaXMuZGV0ZWN0VHlwZUZyb21TdHJpbmdfKGluRmllbGRzWzBdKTtcbiAgICAgIHhQYXJzZXIgPSB0aGlzLmdldEZ1bmN0aW9uT3B0aW9uKFwieFZhbHVlUGFyc2VyXCIpO1xuICAgICAgZGVmYXVsdFBhcnNlclNldCA9IHRydWU7XG4gICAgfVxuICAgIGZpZWxkc1swXSA9IHhQYXJzZXIoaW5GaWVsZHNbMF0sIHRoaXMpO1xuXG4gICAgLy8gSWYgZnJhY3Rpb25zIGFyZSBleHBlY3RlZCwgcGFyc2UgdGhlIG51bWJlcnMgYXMgXCJBL0JcIlxuICAgIGlmICh0aGlzLmZyYWN0aW9uc18pIHtcbiAgICAgIGZvciAoaiA9IDE7IGogPCBpbkZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAvLyBUT0RPKGRhbnZrKTogZmlndXJlIG91dCBhbiBhcHByb3ByaWF0ZSB3YXkgdG8gZmxhZyBwYXJzZSBlcnJvcnMuXG4gICAgICAgIHZhbHMgPSBpbkZpZWxkc1tqXS5zcGxpdChcIi9cIik7XG4gICAgICAgIGlmICh2YWxzLmxlbmd0aCAhPSAyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXhwZWN0ZWQgZnJhY3Rpb25hbCBcIm51bS9kZW5cIiB2YWx1ZXMgaW4gQ1NWIGRhdGEgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBcImJ1dCBmb3VuZCBhIHZhbHVlICdcIiArIGluRmllbGRzW2pdICsgXCInIG9uIGxpbmUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKDEgKyBpKSArIFwiICgnXCIgKyBsaW5lICsgXCInKSB3aGljaCBpcyBub3Qgb2YgdGhpcyBmb3JtLlwiKTtcbiAgICAgICAgICBmaWVsZHNbal0gPSBbMCwgMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmllbGRzW2pdID0gW3V0aWxzLnBhcnNlRmxvYXRfKHZhbHNbMF0sIGksIGxpbmUpLFxuICAgICAgICAgICAgICAgICAgICAgICB1dGlscy5wYXJzZUZsb2F0Xyh2YWxzWzFdLCBpLCBsaW5lKV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbihcImVycm9yQmFyc1wiKSkge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIGVycm9yIGJhcnMsIHZhbHVlcyBhcmUgKHZhbHVlLCBzdGRkZXYpIHBhaXJzXG4gICAgICBpZiAoaW5GaWVsZHMubGVuZ3RoICUgMiAhPSAxKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0V4cGVjdGVkIGFsdGVybmF0aW5nICh2YWx1ZSwgc3RkZXYuKSBwYWlycyBpbiBDU1YgZGF0YSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnYnV0IGxpbmUgJyArICgxICsgaSkgKyAnIGhhcyBhbiBvZGQgbnVtYmVyIG9mIHZhbHVlcyAoJyArXG4gICAgICAgICAgICAgICAgICAgICAgKGluRmllbGRzLmxlbmd0aCAtIDEpICsgXCIpOiAnXCIgKyBsaW5lICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChqID0gMTsgaiA8IGluRmllbGRzLmxlbmd0aDsgaiArPSAyKSB7XG4gICAgICAgIGZpZWxkc1soaiArIDEpIC8gMl0gPSBbdXRpbHMucGFyc2VGbG9hdF8oaW5GaWVsZHNbal0sIGksIGxpbmUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLnBhcnNlRmxvYXRfKGluRmllbGRzW2ogKyAxXSwgaSwgbGluZSldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5nZXRCb29sZWFuT3B0aW9uKFwiY3VzdG9tQmFyc1wiKSkge1xuICAgICAgLy8gQmFycyBhcmUgYSBsb3c7Y2VudGVyO2hpZ2ggdHVwbGVcbiAgICAgIGZvciAoaiA9IDE7IGogPCBpbkZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgdmFsID0gaW5GaWVsZHNbal07XG4gICAgICAgIGlmICgvXiAqJC8udGVzdCh2YWwpKSB7XG4gICAgICAgICAgZmllbGRzW2pdID0gW251bGwsIG51bGwsIG51bGxdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHMgPSB2YWwuc3BsaXQoXCI7XCIpO1xuICAgICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICBmaWVsZHNbal0gPSBbIHV0aWxzLnBhcnNlRmxvYXRfKHZhbHNbMF0sIGksIGxpbmUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlscy5wYXJzZUZsb2F0Xyh2YWxzWzFdLCBpLCBsaW5lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMucGFyc2VGbG9hdF8odmFsc1syXSwgaSwgbGluZSkgXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXaGVuIHVzaW5nIGN1c3RvbUJhcnMsIHZhbHVlcyBtdXN0IGJlIGVpdGhlciBibGFuayAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnb3IgXCJsb3c7Y2VudGVyO2hpZ2hcIiB0dXBsZXMgKGdvdCBcIicgKyB2YWwgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdcIiBvbiBsaW5lICcgKyAoMStpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFZhbHVlcyBhcmUganVzdCBudW1iZXJzXG4gICAgICBmb3IgKGogPSAxOyBqIDwgaW5GaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZmllbGRzW2pdID0gdXRpbHMucGFyc2VGbG9hdF8oaW5GaWVsZHNbal0sIGksIGxpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmV0Lmxlbmd0aCA+IDAgJiYgZmllbGRzWzBdIDwgcmV0W3JldC5sZW5ndGggLSAxXVswXSkge1xuICAgICAgb3V0T2ZPcmRlciA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggIT0gZXhwZWN0ZWRDb2xzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiTnVtYmVyIG9mIGNvbHVtbnMgaW4gbGluZSBcIiArIGkgKyBcIiAoXCIgKyBmaWVsZHMubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAgICAgXCIpIGRvZXMgbm90IGFncmVlIHdpdGggbnVtYmVyIG9mIGxhYmVscyAoXCIgKyBleHBlY3RlZENvbHMgK1xuICAgICAgICAgICAgICAgICAgICBcIikgXCIgKyBsaW5lKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXNlciBzcGVjaWZpZWQgdGhlICdsYWJlbHMnIG9wdGlvbiBhbmQgbm9uZSBvZiB0aGUgY2VsbHMgb2YgdGhlXG4gICAgLy8gZmlyc3Qgcm93IHBhcnNlZCBjb3JyZWN0bHksIHRoZW4gdGhleSBwcm9iYWJseSBkb3VibGUtc3BlY2lmaWVkIHRoZVxuICAgIC8vIGxhYmVscy4gV2UgZ28gd2l0aCB0aGUgdmFsdWVzIHNldCBpbiB0aGUgb3B0aW9uLCBkaXNjYXJkIHRoaXMgcm93IGFuZFxuICAgIC8vIGxvZyBhIHdhcm5pbmcgdG8gdGhlIEpTIGNvbnNvbGUuXG4gICAgaWYgKGkgPT09IDAgJiYgdGhpcy5hdHRyXygnbGFiZWxzJykpIHtcbiAgICAgIHZhciBhbGxfbnVsbCA9IHRydWU7XG4gICAgICBmb3IgKGogPSAwOyBhbGxfbnVsbCAmJiBqIDwgZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChmaWVsZHNbal0pIGFsbF9udWxsID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoYWxsX251bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIGR5Z3JhcGhzICdsYWJlbHMnIG9wdGlvbiBpcyBzZXQsIGJ1dCB0aGUgZmlyc3Qgcm93IFwiICtcbiAgICAgICAgICAgICAgICAgICAgIFwib2YgQ1NWIGRhdGEgKCdcIiArIGxpbmUgKyBcIicpIGFwcGVhcnMgdG8gYWxzbyBjb250YWluIFwiICtcbiAgICAgICAgICAgICAgICAgICAgIFwibGFiZWxzLiBXaWxsIGRyb3AgdGhlIENTViBsYWJlbHMgYW5kIHVzZSB0aGUgb3B0aW9uIFwiICtcbiAgICAgICAgICAgICAgICAgICAgIFwibGFiZWxzLlwiKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldC5wdXNoKGZpZWxkcyk7XG4gIH1cblxuICBpZiAob3V0T2ZPcmRlcikge1xuICAgIGNvbnNvbGUud2FybihcIkNTViBpcyBvdXQgb2Ygb3JkZXI7IG9yZGVyIGl0IGNvcnJlY3RseSB0byBzcGVlZCBsb2FkaW5nLlwiKTtcbiAgICByZXQuc29ydChmdW5jdGlvbihhLGIpIHsgcmV0dXJuIGFbMF0gLSBiWzBdOyB9KTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vLyBJbiBuYXRpdmUgZm9ybWF0LCBhbGwgdmFsdWVzIG11c3QgYmUgZGF0ZXMgb3IgbnVtYmVycy5cbi8vIFRoaXMgY2hlY2sgaXNuJ3QgcGVyZmVjdCBidXQgd2lsbCBjYXRjaCBtb3N0IG1pc3Rha2VuIHVzZXMgb2Ygc3RyaW5ncy5cbmZ1bmN0aW9uIHZhbGlkYXRlTmF0aXZlRm9ybWF0KGRhdGEpIHtcbiAgY29uc3QgZmlyc3RSb3cgPSBkYXRhWzBdO1xuICBjb25zdCBmaXJzdFggPSBmaXJzdFJvd1swXTtcbiAgaWYgKHR5cGVvZiBmaXJzdFggIT09ICdudW1iZXInICYmICF1dGlscy5pc0RhdGVMaWtlKGZpcnN0WCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIG51bWJlciBvciBkYXRlIGJ1dCBnb3QgJHt0eXBlb2YgZmlyc3RYfTogJHtmaXJzdFh9LmApO1xuICB9XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgZmlyc3RSb3cubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB2YWwgPSBmaXJzdFJvd1tpXTtcbiAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIGNvbnRpbnVlO1xuICAgIGlmICh1dGlscy5pc0FycmF5TGlrZSh2YWwpKSBjb250aW51ZTsgIC8vIGUuZy4gZXJyb3IgYmFycyBvciBjdXN0b20gYmFycy5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIG51bWJlciBvciBhcnJheSBidXQgZ290ICR7dHlwZW9mIHZhbH06ICR7dmFsfS5gKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSB1c2VyIGhhcyBwcm92aWRlZCB0aGVpciBkYXRhIGFzIGEgcHJlLXBhY2thZ2VkIEpTIGFycmF5LiBJZiB0aGUgeCB2YWx1ZXNcbiAqIGFyZSBudW1lcmljLCB0aGlzIGlzIHRoZSBzYW1lIGFzIGR5Z3JhcGhzJyBpbnRlcm5hbCBmb3JtYXQuIElmIHRoZSB4IHZhbHVlc1xuICogYXJlIGRhdGVzLCB3ZSBuZWVkIHRvIGNvbnZlcnQgdGhlbSBmcm9tIERhdGUgb2JqZWN0cyB0byBtcyBzaW5jZSBlcG9jaC5cbiAqIEBwYXJhbSB7IUFycmF5fSBkYXRhXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRhdGEgd2l0aCBudW1lcmljIHggdmFsdWVzLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUucGFyc2VBcnJheV8gPSBmdW5jdGlvbihkYXRhKSB7XG4gIC8vIFBlZWsgYXQgdGhlIGZpcnN0IHggdmFsdWUgdG8gc2VlIGlmIGl0J3MgbnVtZXJpYy5cbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkNhbid0IHBsb3QgZW1wdHkgZGF0YSBzZXRcIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGRhdGFbMF0ubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkRhdGEgc2V0IGNhbm5vdCBjb250YWluIGFuIGVtcHR5IHJvd1wiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhbGlkYXRlTmF0aXZlRm9ybWF0KGRhdGEpO1xuXG4gIHZhciBpO1xuICBpZiAodGhpcy5hdHRyXyhcImxhYmVsc1wiKSA9PT0gbnVsbCkge1xuICAgIGNvbnNvbGUud2FybihcIlVzaW5nIGRlZmF1bHQgbGFiZWxzLiBTZXQgbGFiZWxzIGV4cGxpY2l0bHkgdmlhICdsYWJlbHMnIFwiICtcbiAgICAgICAgICAgICAgICAgXCJpbiB0aGUgb3B0aW9ucyBwYXJhbWV0ZXJcIik7XG4gICAgdGhpcy5hdHRyc18ubGFiZWxzID0gWyBcIlhcIiBdO1xuICAgIGZvciAoaSA9IDE7IGkgPCBkYXRhWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmF0dHJzXy5sYWJlbHMucHVzaChcIllcIiArIGkpOyAvLyBOb3QgdXNlcl9hdHRyc18uXG4gICAgfVxuICAgIHRoaXMuYXR0cmlidXRlc18ucmVwYXJzZVNlcmllcygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBudW1fbGFiZWxzID0gdGhpcy5hdHRyXyhcImxhYmVsc1wiKTtcbiAgICBpZiAobnVtX2xhYmVscy5sZW5ndGggIT0gZGF0YVswXS5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJNaXNtYXRjaCBiZXR3ZWVuIG51bWJlciBvZiBsYWJlbHMgKFwiICsgbnVtX2xhYmVscyArIFwiKVwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgYW5kIG51bWJlciBvZiBjb2x1bW5zIGluIGFycmF5IChcIiArIGRhdGFbMF0ubGVuZ3RoICsgXCIpXCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgaWYgKHV0aWxzLmlzRGF0ZUxpa2UoZGF0YVswXVswXSkpIHtcbiAgICAvLyBTb21lIGludGVsbGlnZW50IGRlZmF1bHRzIGZvciBhIGRhdGUgeC1heGlzLlxuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC52YWx1ZUZvcm1hdHRlciA9IHV0aWxzLmRhdGVWYWx1ZUZvcm1hdHRlcjtcbiAgICB0aGlzLmF0dHJzXy5heGVzLngudGlja2VyID0gRHlncmFwaFRpY2tlcnMuZGF0ZVRpY2tlcjtcbiAgICB0aGlzLmF0dHJzXy5heGVzLnguYXhpc0xhYmVsRm9ybWF0dGVyID0gdXRpbHMuZGF0ZUF4aXNMYWJlbEZvcm1hdHRlcjtcblxuICAgIC8vIEFzc3VtZSB0aGV5J3JlIGFsbCBkYXRlcy5cbiAgICB2YXIgcGFyc2VkRGF0YSA9IHV0aWxzLmNsb25lKGRhdGEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocGFyc2VkRGF0YVtpXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlJvdyBcIiArICgxICsgaSkgKyBcIiBvZiBkYXRhIGlzIGVtcHR5XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWREYXRhW2ldWzBdID09PSBudWxsIHx8XG4gICAgICAgICAgdHlwZW9mKHBhcnNlZERhdGFbaV1bMF0uZ2V0VGltZSkgIT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgIGlzTmFOKHBhcnNlZERhdGFbaV1bMF0uZ2V0VGltZSgpKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwieCB2YWx1ZSBpbiByb3cgXCIgKyAoMSArIGkpICsgXCIgaXMgbm90IGEgRGF0ZVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBwYXJzZWREYXRhW2ldWzBdID0gcGFyc2VkRGF0YVtpXVswXS5nZXRUaW1lKCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWREYXRhO1xuICB9IGVsc2Uge1xuICAgIC8vIFNvbWUgaW50ZWxsaWdlbnQgZGVmYXVsdHMgZm9yIGEgbnVtZXJpYyB4LWF4aXMuXG4gICAgLyoqIEBwcml2YXRlIChzaHV0IHVwLCBqc2RvYyEpICovXG4gICAgdGhpcy5hdHRyc18uYXhlcy54LnZhbHVlRm9ybWF0dGVyID0gZnVuY3Rpb24oeCkgeyByZXR1cm4geDsgfTtcbiAgICB0aGlzLmF0dHJzXy5heGVzLngudGlja2VyID0gRHlncmFwaFRpY2tlcnMubnVtZXJpY1RpY2tzO1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC5heGlzTGFiZWxGb3JtYXR0ZXIgPSB1dGlscy5udW1iZXJBeGlzTGFiZWxGb3JtYXR0ZXI7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogUGFyc2VzIGEgRGF0YVRhYmxlIG9iamVjdCBmcm9tIGd2aXouXG4gKiBUaGUgZGF0YSBpcyBleHBlY3RlZCB0byBoYXZlIGEgZmlyc3QgY29sdW1uIHRoYXQgaXMgZWl0aGVyIGEgZGF0ZSBvciBhXG4gKiBudW1iZXIuIEFsbCBzdWJzZXF1ZW50IGNvbHVtbnMgbXVzdCBiZSBudW1iZXJzLiBJZiB0aGVyZSBpcyBhIGNsZWFyIG1pc21hdGNoXG4gKiBiZXR3ZWVuIHRoaXMueFZhbHVlUGFyc2VyXyBhbmQgdGhlIHR5cGUgb2YgdGhlIGZpcnN0IGNvbHVtbiwgaXQgd2lsbCBiZVxuICogZml4ZWQuIEZpbGxzIG91dCByYXdEYXRhXy5cbiAqIEBwYXJhbSB7IWdvb2dsZS52aXN1YWxpemF0aW9uLkRhdGFUYWJsZX0gZGF0YSBTZWUgYWJvdmUuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5wYXJzZURhdGFUYWJsZV8gPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBzaG9ydFRleHRGb3JBbm5vdGF0aW9uTnVtID0gZnVuY3Rpb24obnVtKSB7XG4gICAgLy8gY29udmVydHMgWzAtOV0rIFtBLVpdW2Etel0qXG4gICAgLy8gZXhhbXBsZTogMD1BLCAxPUIsIDI1PVosIDI2PUFhLCAyNz1BYlxuICAgIC8vIGFuZCBjb250aW51ZXMgbGlrZS4uIEJhIEJiIC4uIFphIC4uIFp6Li5BYWEuLi5aenogQWFhYSBaenp6XG4gICAgdmFyIHNob3J0VGV4dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoNjUgLyogQSAqLyArIG51bSAlIDI2KTtcbiAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIDI2KTtcbiAgICB3aGlsZSAoIG51bSA+IDAgKSB7XG4gICAgICBzaG9ydFRleHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1IC8qIEEgKi8gKyAobnVtIC0gMSkgJSAyNiApICsgc2hvcnRUZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgICBudW0gPSBNYXRoLmZsb29yKChudW0gLSAxKSAvIDI2KTtcbiAgICB9XG4gICAgcmV0dXJuIHNob3J0VGV4dDtcbiAgfTtcblxuICB2YXIgY29scyA9IGRhdGEuZ2V0TnVtYmVyT2ZDb2x1bW5zKCk7XG4gIHZhciByb3dzID0gZGF0YS5nZXROdW1iZXJPZlJvd3MoKTtcblxuICB2YXIgaW5kZXBUeXBlID0gZGF0YS5nZXRDb2x1bW5UeXBlKDApO1xuICBpZiAoaW5kZXBUeXBlID09ICdkYXRlJyB8fCBpbmRlcFR5cGUgPT0gJ2RhdGV0aW1lJykge1xuICAgIHRoaXMuYXR0cnNfLnhWYWx1ZVBhcnNlciA9IHV0aWxzLmRhdGVQYXJzZXI7XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LnZhbHVlRm9ybWF0dGVyID0gdXRpbHMuZGF0ZVZhbHVlRm9ybWF0dGVyO1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC50aWNrZXIgPSBEeWdyYXBoVGlja2Vycy5kYXRlVGlja2VyO1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC5heGlzTGFiZWxGb3JtYXR0ZXIgPSB1dGlscy5kYXRlQXhpc0xhYmVsRm9ybWF0dGVyO1xuICB9IGVsc2UgaWYgKGluZGVwVHlwZSA9PSAnbnVtYmVyJykge1xuICAgIHRoaXMuYXR0cnNfLnhWYWx1ZVBhcnNlciA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHBhcnNlRmxvYXQoeCk7IH07XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LnZhbHVlRm9ybWF0dGVyID0gZnVuY3Rpb24oeCkgeyByZXR1cm4geDsgfTtcbiAgICB0aGlzLmF0dHJzXy5heGVzLngudGlja2VyID0gRHlncmFwaFRpY2tlcnMubnVtZXJpY1RpY2tzO1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC5heGlzTGFiZWxGb3JtYXR0ZXIgPSB0aGlzLmF0dHJzXy5heGVzLngudmFsdWVGb3JtYXR0ZXI7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwib25seSAnZGF0ZScsICdkYXRldGltZScgYW5kICdudW1iZXInIHR5cGVzIGFyZSBzdXBwb3J0ZWQgXCIgK1xuICAgICAgICAgIFwiZm9yIGNvbHVtbiAxIG9mIERhdGFUYWJsZSBpbnB1dCAoR290ICdcIiArIGluZGVwVHlwZSArIFwiJylcIik7XG4gIH1cblxuICAvLyBBcnJheSBvZiB0aGUgY29sdW1uIGluZGljZXMgd2hpY2ggY29udGFpbiBkYXRhIChhbmQgbm90IGFubm90YXRpb25zKS5cbiAgdmFyIGNvbElkeCA9IFtdO1xuICB2YXIgYW5ub3RhdGlvbkNvbHMgPSB7fTsgIC8vIGRhdGEgaW5kZXggLT4gW2Fubm90YXRpb24gY29sc11cbiAgdmFyIGhhc0Fubm90YXRpb25zID0gZmFsc2U7XG4gIHZhciBpLCBqO1xuICBmb3IgKGkgPSAxOyBpIDwgY29sczsgaSsrKSB7XG4gICAgdmFyIHR5cGUgPSBkYXRhLmdldENvbHVtblR5cGUoaSk7XG4gICAgaWYgKHR5cGUgPT0gJ251bWJlcicpIHtcbiAgICAgIGNvbElkeC5wdXNoKGkpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnc3RyaW5nJyAmJiB0aGlzLmdldEJvb2xlYW5PcHRpb24oJ2Rpc3BsYXlBbm5vdGF0aW9ucycpKSB7XG4gICAgICAvLyBUaGlzIGlzIE9LIC0tIGl0J3MgYW4gYW5ub3RhdGlvbiBjb2x1bW4uXG4gICAgICB2YXIgZGF0YUlkeCA9IGNvbElkeFtjb2xJZHgubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoIWFubm90YXRpb25Db2xzLmhhc093blByb3BlcnR5KGRhdGFJZHgpKSB7XG4gICAgICAgIGFubm90YXRpb25Db2xzW2RhdGFJZHhdID0gW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5ub3RhdGlvbkNvbHNbZGF0YUlkeF0ucHVzaChpKTtcbiAgICAgIH1cbiAgICAgIGhhc0Fubm90YXRpb25zID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiT25seSAnbnVtYmVyJyBpcyBzdXBwb3J0ZWQgYXMgYSBkZXBlbmRlbnQgdHlwZSB3aXRoIEd2aXouXCIgK1xuICAgICAgICAgIFwiICdzdHJpbmcnIGlzIG9ubHkgc3VwcG9ydGVkIGlmIGRpc3BsYXlBbm5vdGF0aW9ucyBpcyB0cnVlXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlYWQgY29sdW1uIGxhYmVsc1xuICAvLyBUT0RPKGRhbnZrKTogYWRkIHN1cHBvcnQgYmFjayBmb3IgZXJyb3JCYXJzXG4gIHZhciBsYWJlbHMgPSBbZGF0YS5nZXRDb2x1bW5MYWJlbCgwKV07XG4gIGZvciAoaSA9IDA7IGkgPCBjb2xJZHgubGVuZ3RoOyBpKyspIHtcbiAgICBsYWJlbHMucHVzaChkYXRhLmdldENvbHVtbkxhYmVsKGNvbElkeFtpXSkpO1xuICAgIGlmICh0aGlzLmdldEJvb2xlYW5PcHRpb24oXCJlcnJvckJhcnNcIikpIGkgKz0gMTtcbiAgfVxuICB0aGlzLmF0dHJzXy5sYWJlbHMgPSBsYWJlbHM7XG4gIGNvbHMgPSBsYWJlbHMubGVuZ3RoO1xuXG4gIHZhciByZXQgPSBbXTtcbiAgdmFyIG91dE9mT3JkZXIgPSBmYWxzZTtcbiAgdmFyIGFubm90YXRpb25zID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICB2YXIgcm93ID0gW107XG4gICAgaWYgKHR5cGVvZihkYXRhLmdldFZhbHVlKGksIDApKSA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgZGF0YS5nZXRWYWx1ZShpLCAwKSA9PT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKFwiSWdub3Jpbmcgcm93IFwiICsgaSArXG4gICAgICAgICAgICAgICAgICAgXCIgb2YgRGF0YVRhYmxlIGJlY2F1c2Ugb2YgdW5kZWZpbmVkIG9yIG51bGwgZmlyc3QgY29sdW1uLlwiKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChpbmRlcFR5cGUgPT0gJ2RhdGUnIHx8IGluZGVwVHlwZSA9PSAnZGF0ZXRpbWUnKSB7XG4gICAgICByb3cucHVzaChkYXRhLmdldFZhbHVlKGksIDApLmdldFRpbWUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdy5wdXNoKGRhdGEuZ2V0VmFsdWUoaSwgMCkpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZ2V0Qm9vbGVhbk9wdGlvbihcImVycm9yQmFyc1wiKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IGNvbElkeC5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgY29sID0gY29sSWR4W2pdO1xuICAgICAgICByb3cucHVzaChkYXRhLmdldFZhbHVlKGksIGNvbCkpO1xuICAgICAgICBpZiAoaGFzQW5ub3RhdGlvbnMgJiZcbiAgICAgICAgICAgIGFubm90YXRpb25Db2xzLmhhc093blByb3BlcnR5KGNvbCkgJiZcbiAgICAgICAgICAgIGRhdGEuZ2V0VmFsdWUoaSwgYW5ub3RhdGlvbkNvbHNbY29sXVswXSkgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgYW5uID0ge307XG4gICAgICAgICAgYW5uLnNlcmllcyA9IGRhdGEuZ2V0Q29sdW1uTGFiZWwoY29sKTtcbiAgICAgICAgICBhbm4ueHZhbCA9IHJvd1swXTtcbiAgICAgICAgICBhbm4uc2hvcnRUZXh0ID0gc2hvcnRUZXh0Rm9yQW5ub3RhdGlvbk51bShhbm5vdGF0aW9ucy5sZW5ndGgpO1xuICAgICAgICAgIGFubi50ZXh0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhbm5vdGF0aW9uQ29sc1tjb2xdLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBpZiAoaykgYW5uLnRleHQgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgIGFubi50ZXh0ICs9IGRhdGEuZ2V0VmFsdWUoaSwgYW5ub3RhdGlvbkNvbHNbY29sXVtrXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFubm90YXRpb25zLnB1c2goYW5uKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTdHJpcCBvdXQgaW5maW5pdGllcywgd2hpY2ggZ2l2ZSBkeWdyYXBocyBwcm9ibGVtcyBsYXRlciBvbi5cbiAgICAgIGZvciAoaiA9IDA7IGogPCByb3cubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShyb3dbal0pKSByb3dbal0gPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgY29scyAtIDE7IGorKykge1xuICAgICAgICByb3cucHVzaChbIGRhdGEuZ2V0VmFsdWUoaSwgMSArIDIgKiBqKSwgZGF0YS5nZXRWYWx1ZShpLCAyICsgMiAqIGopIF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmV0Lmxlbmd0aCA+IDAgJiYgcm93WzBdIDwgcmV0W3JldC5sZW5ndGggLSAxXVswXSkge1xuICAgICAgb3V0T2ZPcmRlciA9IHRydWU7XG4gICAgfVxuICAgIHJldC5wdXNoKHJvdyk7XG4gIH1cblxuICBpZiAob3V0T2ZPcmRlcikge1xuICAgIGNvbnNvbGUud2FybihcIkRhdGFUYWJsZSBpcyBvdXQgb2Ygb3JkZXI7IG9yZGVyIGl0IGNvcnJlY3RseSB0byBzcGVlZCBsb2FkaW5nLlwiKTtcbiAgICByZXQuc29ydChmdW5jdGlvbihhLGIpIHsgcmV0dXJuIGFbMF0gLSBiWzBdOyB9KTtcbiAgfVxuICB0aGlzLnJhd0RhdGFfID0gcmV0O1xuXG4gIGlmIChhbm5vdGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5zZXRBbm5vdGF0aW9ucyhhbm5vdGF0aW9ucywgdHJ1ZSk7XG4gIH1cbiAgdGhpcy5hdHRyaWJ1dGVzXy5yZXBhcnNlU2VyaWVzKCk7XG59O1xuXG4vKipcbiAqIFNpZ25hbHMgdG8gcGx1Z2lucyB0aGF0IHRoZSBjaGFydCBkYXRhIGhhcyB1cGRhdGVkLlxuICogVGhpcyBoYXBwZW5zIGFmdGVyIHRoZSBkYXRhIGhhcyB1cGRhdGVkIGJ1dCBiZWZvcmUgdGhlIGNoYXJ0IGhhcyByZWRyYXduLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuY2FzY2FkZURhdGFEaWRVcGRhdGVFdmVudF8gPSBmdW5jdGlvbigpIHtcbiAgLy8gVE9ETyhkYW52ayk6IHRoZXJlIGFyZSBzb21lIGlzc3VlcyBjaGVja2luZyB4QXhpc1JhbmdlKCkgYW5kIHVzaW5nXG4gIC8vIHRvRG9tQ29vcmRzIGZyb20gaGFuZGxlcnMgb2YgdGhpcyBldmVudC4gVGhlIHZpc2libGUgcmFuZ2Ugc2hvdWxkIGJlIHNldFxuICAvLyB3aGVuIHRoZSBjaGFydCBpcyBkcmF3biwgbm90IGRlcml2ZWQgZnJvbSB0aGUgZGF0YS5cbiAgdGhpcy5jYXNjYWRlRXZlbnRzXygnZGF0YURpZFVwZGF0ZScsIHt9KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBDU1YgZGF0YS4gSWYgaXQncyBpbiBhIGZ1bmN0aW9uLCBjYWxsIHRoYXQgZnVuY3Rpb24uIElmIGl0J3MgaW4gYVxuICogZmlsZSwgZG8gYW4gWE1MSHR0cFJlcXVlc3QgdG8gZ2V0IGl0LlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuc3RhcnRfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhID0gdGhpcy5maWxlXztcblxuICAvLyBGdW5jdGlvbnMgY2FuIHJldHVybiByZWZlcmVuY2VzIG9mIGFsbCBvdGhlciB0eXBlcy5cbiAgaWYgKHR5cGVvZiBkYXRhID09ICdmdW5jdGlvbicpIHtcbiAgICBkYXRhID0gZGF0YSgpO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzQXJyYXlMaWtlKGRhdGEpKSB7XG4gICAgdGhpcy5yYXdEYXRhXyA9IHRoaXMucGFyc2VBcnJheV8oZGF0YSk7XG4gICAgdGhpcy5jYXNjYWRlRGF0YURpZFVwZGF0ZUV2ZW50XygpO1xuICAgIHRoaXMucHJlZHJhd18oKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgIHR5cGVvZiBkYXRhLmdldENvbHVtblJhbmdlID09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBtdXN0IGJlIGEgRGF0YVRhYmxlIGZyb20gZ3Zpei5cbiAgICB0aGlzLnBhcnNlRGF0YVRhYmxlXyhkYXRhKTtcbiAgICB0aGlzLmNhc2NhZGVEYXRhRGlkVXBkYXRlRXZlbnRfKCk7XG4gICAgdGhpcy5wcmVkcmF3XygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgLy8gSGV1cmlzdGljOiBhIG5ld2xpbmUgbWVhbnMgaXQncyBDU1YgZGF0YS4gT3RoZXJ3aXNlIGl0J3MgYW4gVVJMLlxuICAgIHZhciBsaW5lX2RlbGltaXRlciA9IHV0aWxzLmRldGVjdExpbmVEZWxpbWl0ZXIoZGF0YSk7XG4gICAgaWYgKGxpbmVfZGVsaW1pdGVyKSB7XG4gICAgICB0aGlzLmxvYWRlZEV2ZW50XyhkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUkVNT1ZFX0ZPUl9JRVxuICAgICAgdmFyIHJlcTtcbiAgICAgIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgLy8gRmlyZWZveCwgT3BlcmEsIElFNywgYW5kIG90aGVyIGJyb3dzZXJzIHdpbGwgdXNlIHRoZSBuYXRpdmUgb2JqZWN0XG4gICAgICAgIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSUUgNSBhbmQgNiB3aWxsIHVzZSB0aGUgQWN0aXZlWCBjb250cm9sXG4gICAgICAgIHJlcSA9IG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYWxsZXIgPSB0aGlzO1xuICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICBpZiAocmVxLnN0YXR1cyA9PT0gMjAwIHx8ICAvLyBOb3JtYWwgaHR0cFxuICAgICAgICAgICAgICByZXEuc3RhdHVzID09PSAwKSB7ICAgIC8vIENocm9tZSB3LyAtLWFsbG93LWZpbGUtYWNjZXNzLWZyb20tZmlsZXNcbiAgICAgICAgICAgIGNhbGxlci5sb2FkZWRFdmVudF8ocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXEub3BlbihcIkdFVFwiLCBkYXRhLCB0cnVlKTtcbiAgICAgIHJlcS5zZW5kKG51bGwpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVW5rbm93biBkYXRhIGZvcm1hdDogXCIgKyAodHlwZW9mIGRhdGEpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGFuZ2VzIHZhcmlvdXMgcHJvcGVydGllcyBvZiB0aGUgZ3JhcGguIFRoZXNlIGNhbiBpbmNsdWRlOlxuICogPHVsPlxuICogPGxpPmZpbGU6IGNoYW5nZXMgdGhlIHNvdXJjZSBkYXRhIGZvciB0aGUgZ3JhcGg8L2xpPlxuICogPGxpPmVycm9yQmFyczogY2hhbmdlcyB3aGV0aGVyIHRoZSBkYXRhIGNvbnRhaW5zIHN0ZGRldjwvbGk+XG4gKiA8L3VsPlxuICpcbiAqIFRoZXJlJ3MgYSBodWdlIHZhcmlldHkgb2Ygb3B0aW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhpcyBtZXRob2QuIEZvciBhXG4gKiBmdWxsIGxpc3QsIHNlZSBodHRwOi8vZHlncmFwaHMuY29tL29wdGlvbnMuaHRtbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRfYXR0cnMgVGhlIG5ldyBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYmxvY2tfcmVkcmF3IFVzdWFsbHkgdGhlIGNoYXJ0IGlzIHJlZHJhd24gYWZ0ZXIgZXZlcnlcbiAqICAgICBjYWxsIHRvIHVwZGF0ZU9wdGlvbnMoKS4gSWYgeW91IGtub3cgYmV0dGVyLCB5b3UgY2FuIHBhc3MgdHJ1ZSB0b1xuICogICAgIGV4cGxpY2l0bHkgYmxvY2sgdGhlIHJlZHJhdy4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBjaGFpbmluZ1xuICogICAgIHVwZGF0ZU9wdGlvbnMoKSBjYWxscywgYXZvaWRpbmcgdGhlIG9jY2FzaW9uYWwgaW5maW5pdGUgbG9vcCBhbmRcbiAqICAgICBwcmV2ZW50aW5nIHJlZHJhd3Mgd2hlbiBpdCdzIG5vdCBuZWNlc3NhcnkgKGUuZy4gd2hlbiB1cGRhdGluZyBhXG4gKiAgICAgY2FsbGJhY2spLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS51cGRhdGVPcHRpb25zID0gZnVuY3Rpb24oaW5wdXRfYXR0cnMsIGJsb2NrX3JlZHJhdykge1xuICBpZiAodHlwZW9mKGJsb2NrX3JlZHJhdykgPT0gJ3VuZGVmaW5lZCcpIGJsb2NrX3JlZHJhdyA9IGZhbHNlO1xuXG4gIC8vIGNvcHlVc2VyQXR0cnNfIGRyb3BzIHRoZSBcImZpbGVcIiBwYXJhbWV0ZXIgYXMgYSBjb252ZW5pZW5jZSB0byB1cy5cbiAgdmFyIGZpbGUgPSBpbnB1dF9hdHRycy5maWxlO1xuICB2YXIgYXR0cnMgPSBEeWdyYXBoLmNvcHlVc2VyQXR0cnNfKGlucHV0X2F0dHJzKTtcblxuICAvLyBUT0RPKGRhbnZrKTogdGhpcyBpcyBhIG1lc3MuIE1vdmUgdGhlc2Ugb3B0aW9ucyBpbnRvIGF0dHJfLlxuICBpZiAoJ3JvbGxQZXJpb2QnIGluIGF0dHJzKSB7XG4gICAgdGhpcy5yb2xsUGVyaW9kXyA9IGF0dHJzLnJvbGxQZXJpb2Q7XG4gIH1cbiAgaWYgKCdkYXRlV2luZG93JyBpbiBhdHRycykge1xuICAgIHRoaXMuZGF0ZVdpbmRvd18gPSBhdHRycy5kYXRlV2luZG93O1xuICB9XG5cbiAgLy8gVE9ETyhkYW52ayk6IHZhbGlkYXRlIHBlci1zZXJpZXMgb3B0aW9ucy5cbiAgLy8gU3VwcG9ydGVkOlxuICAvLyBzdHJva2VXaWR0aFxuICAvLyBwb2ludFNpemVcbiAgLy8gZHJhd1BvaW50c1xuICAvLyBoaWdobGlnaHRDaXJjbGVTaXplXG5cbiAgLy8gQ2hlY2sgaWYgdGhpcyBzZXQgb3B0aW9ucyB3aWxsIHJlcXVpcmUgbmV3IHBvaW50cy5cbiAgdmFyIHJlcXVpcmVzTmV3UG9pbnRzID0gdXRpbHMuaXNQaXhlbENoYW5naW5nT3B0aW9uTGlzdCh0aGlzLmF0dHJfKFwibGFiZWxzXCIpLCBhdHRycyk7XG5cbiAgdXRpbHMudXBkYXRlRGVlcCh0aGlzLnVzZXJfYXR0cnNfLCBhdHRycyk7XG5cbiAgdGhpcy5hdHRyaWJ1dGVzXy5yZXBhcnNlU2VyaWVzKCk7XG5cbiAgaWYgKGZpbGUpIHtcbiAgICAvLyBUaGlzIGV2ZW50IGluZGljYXRlcyB0aGF0IHRoZSBkYXRhIGlzIGFib3V0IHRvIGNoYW5nZSwgYnV0IGhhc24ndCB5ZXQuXG4gICAgLy8gVE9ETyhkYW52ayk6IHN1cHBvcnQgY2FuY2VsbGF0aW9uIG9mIHRoZSB1cGRhdGUgdmlhIHRoaXMgZXZlbnQuXG4gICAgdGhpcy5jYXNjYWRlRXZlbnRzXygnZGF0YVdpbGxVcGRhdGUnLCB7fSk7XG5cbiAgICB0aGlzLmZpbGVfID0gZmlsZTtcbiAgICBpZiAoIWJsb2NrX3JlZHJhdykgdGhpcy5zdGFydF8oKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWJsb2NrX3JlZHJhdykge1xuICAgICAgaWYgKHJlcXVpcmVzTmV3UG9pbnRzKSB7XG4gICAgICAgIHRoaXMucHJlZHJhd18oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZGVyR3JhcGhfKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTWFrZSBhIGNvcHkgb2YgaW5wdXQgYXR0cmlidXRlcywgcmVtb3ZpbmcgZmlsZSBhcyBhIGNvbnZlbmllbmNlLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5jb3B5VXNlckF0dHJzXyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gIHZhciBteV9hdHRycyA9IHt9O1xuICBmb3IgKHZhciBrIGluIGF0dHJzKSB7XG4gICAgaWYgKCFhdHRycy5oYXNPd25Qcm9wZXJ0eShrKSkgY29udGludWU7XG4gICAgaWYgKGsgPT0gJ2ZpbGUnKSBjb250aW51ZTtcbiAgICBpZiAoYXR0cnMuaGFzT3duUHJvcGVydHkoaykpIG15X2F0dHJzW2tdID0gYXR0cnNba107XG4gIH1cbiAgcmV0dXJuIG15X2F0dHJzO1xufTtcblxuLyoqXG4gKiBSZXNpemVzIHRoZSBkeWdyYXBoLiBJZiBubyBwYXJhbWV0ZXJzIGFyZSBzcGVjaWZpZWQsIHJlc2l6ZXMgdG8gZmlsbCB0aGVcbiAqIGNvbnRhaW5pbmcgZGl2ICh3aGljaCBoYXMgcHJlc3VtYWJseSBjaGFuZ2VkIHNpemUgc2luY2UgdGhlIGR5Z3JhcGggd2FzXG4gKiBpbnN0YW50aWF0ZWQuIElmIHRoZSB3aWR0aC9oZWlnaHQgYXJlIHNwZWNpZmllZCwgdGhlIGRpdiB3aWxsIGJlIHJlc2l6ZWQuXG4gKlxuICogVGhpcyBpcyBmYXIgbW9yZSBlZmZpY2llbnQgdGhhbiBkZXN0cm95aW5nIGFuZCByZS1pbnN0YW50aWF0aW5nIGFcbiAqIER5Z3JhcGgsIHNpbmNlIGl0IGRvZXNuJ3QgaGF2ZSB0byByZXBhcnNlIHRoZSB1bmRlcmx5aW5nIGRhdGEuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIChpbiBwaXhlbHMpXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCAoaW4gcGl4ZWxzKVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gIGlmICh0aGlzLnJlc2l6ZV9sb2NrKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucmVzaXplX2xvY2sgPSB0cnVlO1xuXG4gIGlmICgod2lkdGggPT09IG51bGwpICE9IChoZWlnaHQgPT09IG51bGwpKSB7XG4gICAgY29uc29sZS53YXJuKFwiRHlncmFwaC5yZXNpemUoKSBzaG91bGQgYmUgY2FsbGVkIHdpdGggemVybyBwYXJhbWV0ZXJzIG9yIFwiICtcbiAgICAgICAgICAgICAgICAgXCJ0d28gbm9uLU5VTEwgcGFyYW1ldGVycy4gUHJldGVuZGluZyBpdCB3YXMgemVyby5cIik7XG4gICAgd2lkdGggPSBoZWlnaHQgPSBudWxsO1xuICB9XG5cbiAgdmFyIG9sZF93aWR0aCA9IHRoaXMud2lkdGhfO1xuICB2YXIgb2xkX2hlaWdodCA9IHRoaXMuaGVpZ2h0XztcblxuICBpZiAod2lkdGgpIHtcbiAgICB0aGlzLm1haW5kaXZfLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgdGhpcy5tYWluZGl2Xy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgdGhpcy53aWR0aF8gPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodF8gPSBoZWlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53aWR0aF8gPSB0aGlzLm1haW5kaXZfLmNsaWVudFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0XyA9IHRoaXMubWFpbmRpdl8uY2xpZW50SGVpZ2h0O1xuICB9XG5cbiAgaWYgKG9sZF93aWR0aCAhPSB0aGlzLndpZHRoXyB8fCBvbGRfaGVpZ2h0ICE9IHRoaXMuaGVpZ2h0Xykge1xuICAgIC8vIFJlc2l6aW5nIGEgY2FudmFzIGVyYXNlcyBpdCwgZXZlbiB3aGVuIHRoZSBzaXplIGRvZXNuJ3QgY2hhbmdlLCBzb1xuICAgIC8vIGFueSByZXNpemUgbmVlZHMgdG8gYmUgZm9sbG93ZWQgYnkgYSByZWRyYXcuXG4gICAgdGhpcy5yZXNpemVFbGVtZW50c18oKTtcbiAgICB0aGlzLnByZWRyYXdfKCk7XG4gIH1cblxuICB0aGlzLnJlc2l6ZV9sb2NrID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEFkanVzdHMgdGhlIG51bWJlciBvZiBwb2ludHMgaW4gdGhlIHJvbGxpbmcgYXZlcmFnZS4gVXBkYXRlcyB0aGUgZ3JhcGggdG9cbiAqIHJlZmxlY3QgdGhlIG5ldyBhdmVyYWdpbmcgcGVyaW9kLlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBOdW1iZXIgb2YgcG9pbnRzIG92ZXIgd2hpY2ggdG8gYXZlcmFnZSB0aGUgZGF0YS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuYWRqdXN0Um9sbCA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICB0aGlzLnJvbGxQZXJpb2RfID0gbGVuZ3RoO1xuICB0aGlzLnByZWRyYXdfKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBib29sZWFuIGFycmF5IG9mIHZpc2liaWxpdHkgc3RhdHVzZXMuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnZpc2liaWxpdHkgPSBmdW5jdGlvbigpIHtcbiAgLy8gRG8gbGF6eS1pbml0aWFsaXphdGlvbiwgc28gdGhhdCB0aGlzIGhhcHBlbnMgYWZ0ZXIgd2Uga25vdyB0aGUgbnVtYmVyIG9mXG4gIC8vIGRhdGEgc2VyaWVzLlxuICBpZiAoIXRoaXMuZ2V0T3B0aW9uKFwidmlzaWJpbGl0eVwiKSkge1xuICAgIHRoaXMuYXR0cnNfLnZpc2liaWxpdHkgPSBbXTtcbiAgfVxuICAvLyBUT0RPKGRhbnZrKTogaXQgbG9va3MgbGlrZSB0aGlzIGNvdWxkIGdvIGludG8gYW4gaW5maW5pdGUgbG9vcCB3LyB1c2VyX2F0dHJzLlxuICB3aGlsZSAodGhpcy5nZXRPcHRpb24oXCJ2aXNpYmlsaXR5XCIpLmxlbmd0aCA8IHRoaXMubnVtQ29sdW1ucygpIC0gMSkge1xuICAgIHRoaXMuYXR0cnNfLnZpc2liaWxpdHkucHVzaCh0cnVlKTtcbiAgfVxuICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXCJ2aXNpYmlsaXR5XCIpO1xufTtcblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSB2aXNpYmlsaXR5IG9mIG9uZSBvciBtb3JlIHNlcmllcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXXxvYmplY3R9IG51bSB0aGUgc2VyaWVzIGluZGV4IG9yIGFuIGFycmF5IG9mIHNlcmllcyBpbmRpY2VzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBhIGJvb2xlYW4gYXJyYXkgb2YgdmlzaWJpbGl0eSBzdGF0ZXMgYnkgaW5kZXhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGFuIG9iamVjdCBtYXBwaW5nIHNlcmllcyBudW1iZXJzLCBhcyBrZXlzLCB0b1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eSBzdGF0ZSAoYm9vbGVhbiB2YWx1ZXMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIHRoZSB2aXNpYmlsaXR5IHN0YXRlIGV4cHJlc3NlZCBhcyBhIGJvb2xlYW5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuc2V0VmlzaWJpbGl0eSA9IGZ1bmN0aW9uKG51bSwgdmFsdWUpIHtcbiAgdmFyIHggPSB0aGlzLnZpc2liaWxpdHkoKTtcbiAgdmFyIG51bUlzT2JqZWN0ID0gZmFsc2U7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KG51bSkpIHtcbiAgICBpZiAobnVtICE9PSBudWxsICYmIHR5cGVvZiBudW0gPT09ICdvYmplY3QnKSB7XG4gICAgICBudW1Jc09iamVjdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bSA9IFtudW1dO1xuICAgIH1cbiAgfVxuXG4gIGlmIChudW1Jc09iamVjdCkge1xuICAgIGZvciAodmFyIGkgaW4gbnVtKSB7XG4gICAgICBpZiAobnVtLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGlmIChpIDwgMCB8fCBpID49IHgubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCBzZXJpZXMgbnVtYmVyIGluIHNldFZpc2liaWxpdHk6IFwiICsgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeFtpXSA9IG51bVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiBudW1baV0gPT09ICdib29sZWFuJykge1xuICAgICAgICBpZiAoaSA+PSB4Lmxlbmd0aCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgc2VyaWVzIG51bWJlciBpbiBzZXRWaXNpYmlsaXR5OiBcIiArIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhbaV0gPSBudW1baV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChudW1baV0gPCAwIHx8IG51bVtpXSA+PSB4Lmxlbmd0aCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgc2VyaWVzIG51bWJlciBpbiBzZXRWaXNpYmlsaXR5OiBcIiArIG51bVtpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeFtudW1baV1dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLnByZWRyYXdfKCk7XG59O1xuXG4vKipcbiAqIEhvdyBsYXJnZSBvZiBhbiBhcmVhIHdpbGwgdGhlIGR5Z3JhcGggcmVuZGVyIGl0c2VsZiBpbj9cbiAqIFRoaXMgaXMgdXNlZCBmb3IgdGVzdGluZy5cbiAqIEByZXR1cm4gQSB7d2lkdGg6IHcsIGhlaWdodDogaH0gb2JqZWN0LlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4geyB3aWR0aDogdGhpcy53aWR0aF8sIGhlaWdodDogdGhpcy5oZWlnaHRfIH07XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgbGlzdCBvZiBhbm5vdGF0aW9ucyBhbmQgcmVkcmF3IHRoZSBjaGFydC5cbiAqIFNlZSBkeWdyYXBocy5jb20vYW5ub3RhdGlvbnMuaHRtbCBmb3IgbW9yZSBpbmZvIG9uIGhvdyB0byB1c2UgYW5ub3RhdGlvbnMuXG4gKiBAcGFyYW0gYW5uIHtBcnJheX0gQW4gYXJyYXkgb2YgYW5ub3RhdGlvbiBvYmplY3RzLlxuICogQHBhcmFtIHN1cHByZXNzRHJhdyB7Qm9vbGVhbn0gU2V0IHRvIFwidHJ1ZVwiIHRvIGJsb2NrIGNoYXJ0IHJlZHJhdyAob3B0aW9uYWwpLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5zZXRBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uKGFubiwgc3VwcHJlc3NEcmF3KSB7XG4gIC8vIE9ubHkgYWRkIHRoZSBhbm5vdGF0aW9uIENTUyBydWxlIG9uY2Ugd2Uga25vdyBpdCB3aWxsIGJlIHVzZWQuXG4gIHRoaXMuYW5ub3RhdGlvbnNfID0gYW5uO1xuICBpZiAoIXRoaXMubGF5b3V0Xykge1xuICAgIGNvbnNvbGUud2FybihcIlRyaWVkIHRvIHNldEFubm90YXRpb25zIGJlZm9yZSBkeWdyYXBoIHdhcyByZWFkeS4gXCIgK1xuICAgICAgICAgICAgICAgICBcIlRyeSBzZXR0aW5nIHRoZW0gaW4gYSByZWFkeSgpIGJsb2NrLiBTZWUgXCIgK1xuICAgICAgICAgICAgICAgICBcImR5Z3JhcGhzLmNvbS90ZXN0cy9hbm5vdGF0aW9uLmh0bWxcIik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5sYXlvdXRfLnNldEFubm90YXRpb25zKHRoaXMuYW5ub3RhdGlvbnNfKTtcbiAgaWYgKCFzdXBwcmVzc0RyYXcpIHtcbiAgICB0aGlzLnByZWRyYXdfKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0IG9mIGFubm90YXRpb25zLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5hbm5vdGF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5hbm5vdGF0aW9uc187XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGlzdCBvZiBsYWJlbCBuYW1lcyBmb3IgdGhpcyBncmFwaC4gVGhlIGZpcnN0IGNvbHVtbiBpcyB0aGVcbiAqIHgtYXhpcywgc28gdGhlIGRhdGEgc2VyaWVzIG5hbWVzIHN0YXJ0IGF0IGluZGV4IDEuXG4gKlxuICogUmV0dXJucyBudWxsIHdoZW4gbGFiZWxzIGhhdmUgbm90IHlldCBiZWVuIGRlZmluZWQuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldExhYmVscyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGFiZWxzID0gdGhpcy5hdHRyXyhcImxhYmVsc1wiKTtcbiAgcmV0dXJuIGxhYmVscyA/IGxhYmVscy5zbGljZSgpIDogbnVsbDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBpbmRleCBvZiBhIHNlcmllcyAoY29sdW1uKSBnaXZlbiBpdHMgbmFtZS4gVGhlIGZpcnN0IGNvbHVtbiBpcyB0aGVcbiAqIHgtYXhpcywgc28gdGhlIGRhdGEgc2VyaWVzIHN0YXJ0IHdpdGggaW5kZXggMS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuaW5kZXhGcm9tU2V0TmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuc2V0SW5kZXhCeU5hbWVfW25hbWVdO1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSByb3cgbnVtYmVyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIHgtdmFsdWUuXG4gKiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm8gc3VjaCB4LXZhbHVlIGluIHRoZSBkYXRhLlxuICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIHJvd3Mgd2l0aCB0aGUgc2FtZSB4LXZhbHVlLCB0aGlzIHdpbGwgcmV0dXJuIHRoZVxuICogZmlyc3Qgb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IHhWYWwgVGhlIHgtdmFsdWUgdG8gbG9vayBmb3IgKGUuZy4gbWlsbGlzIHNpbmNlIGVwb2NoKS5cbiAqIEByZXR1cm4gez9udW1iZXJ9IFRoZSByb3cgbnVtYmVyLCB3aGljaCB5b3UgY2FuIHBhc3MgdG8gZ2V0VmFsdWUoKSwgb3IgbnVsbC5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0Um93Rm9yWCA9IGZ1bmN0aW9uKHhWYWwpIHtcbiAgdmFyIGxvdyA9IDAsXG4gICAgICBoaWdoID0gdGhpcy5udW1Sb3dzKCkgLSAxO1xuXG4gIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgIHZhciBpZHggPSAoaGlnaCArIGxvdykgPj4gMTtcbiAgICB2YXIgeCA9IHRoaXMuZ2V0VmFsdWUoaWR4LCAwKTtcbiAgICBpZiAoeCA8IHhWYWwpIHtcbiAgICAgIGxvdyA9IGlkeCArIDE7XG4gICAgfSBlbHNlIGlmICh4ID4geFZhbCkge1xuICAgICAgaGlnaCA9IGlkeCAtIDE7XG4gICAgfSBlbHNlIGlmIChsb3cgIT0gaWR4KSB7ICAvLyBlcXVhbCwgYnV0IHRoZXJlIG1heSBiZSBhbiBlYXJsaWVyIG1hdGNoLlxuICAgICAgaGlnaCA9IGlkeDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogVHJpZ2dlciBhIGNhbGxiYWNrIHdoZW4gdGhlIGR5Z3JhcGggaGFzIGRyYXduIGl0c2VsZiBhbmQgaXMgcmVhZHkgdG8gYmVcbiAqIG1hbmlwdWxhdGVkLiBUaGlzIGlzIHByaW1hcmlseSB1c2VmdWwgd2hlbiBkeWdyYXBocyBoYXMgdG8gZG8gYW4gWEhSIGZvciB0aGVcbiAqIGRhdGEgKGkuZS4gYSBVUkwgaXMgcGFzc2VkIGFzIHRoZSBkYXRhIHNvdXJjZSkgYW5kIHRoZSBjaGFydCBpcyBkcmF3blxuICogYXN5bmNocm9ub3VzbHkuIElmIHRoZSBjaGFydCBoYXMgYWxyZWFkeSBkcmF3biwgdGhlIGNhbGxiYWNrIHdpbGwgZmlyZVxuICogaW1tZWRpYXRlbHkuXG4gKlxuICogVGhpcyBpcyBhIGdvb2QgcGxhY2UgdG8gY2FsbCBzZXRBbm5vdGF0aW9uKCkuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbighRHlncmFwaCl9IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byB0cmlnZ2VyIHdoZW4gdGhlIGNoYXJ0XG4gKiAgICAgaXMgcmVhZHkuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgaWYgKHRoaXMuaXNfaW5pdGlhbF9kcmF3Xykge1xuICAgIHRoaXMucmVhZHlGbnNfLnB1c2goY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGhhbmRsZXIuIFRoaXMgZXZlbnQgaGFuZGxlciBpcyBrZXB0IHVudGlsIHRoZSBncmFwaCBpc1xuICogZGVzdHJveWVkIHdpdGggYSBjYWxsIHRvIGdyYXBoLmRlc3Ryb3koKS5cbiAqXG4gKiBAcGFyYW0geyFOb2RlfSBlbGVtIFRoZSBlbGVtZW50IHRvIGFkZCB0aGUgZXZlbnQgdG8uXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2Vtb3ZlJy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnQpOihib29sZWFufHVuZGVmaW5lZCl9IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsXG4gKiAgICAgb24gdGhlIGV2ZW50LiBUaGUgZnVuY3Rpb24gdGFrZXMgb25lIHBhcmFtZXRlcjogdGhlIGV2ZW50IG9iamVjdC5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmFkZEFuZFRyYWNrRXZlbnQgPSBmdW5jdGlvbihlbGVtLCB0eXBlLCBmbikge1xuICB1dGlscy5hZGRFdmVudChlbGVtLCB0eXBlLCBmbik7XG4gIHRoaXMucmVnaXN0ZXJlZEV2ZW50c18ucHVzaCh7ZWxlbSwgdHlwZSwgZm59KTtcbn07XG5cbkR5Z3JhcGgucHJvdG90eXBlLnJlbW92ZVRyYWNrZWRFdmVudHNfID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnJlZ2lzdGVyZWRFdmVudHNfKSB7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy5yZWdpc3RlcmVkRXZlbnRzXy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICB2YXIgcmVnID0gdGhpcy5yZWdpc3RlcmVkRXZlbnRzX1tpZHhdO1xuICAgICAgdXRpbHMucmVtb3ZlRXZlbnQocmVnLmVsZW0sIHJlZy50eXBlLCByZWcuZm4pO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMucmVnaXN0ZXJlZEV2ZW50c18gPSBbXTtcbn07XG5cblxuLy8gSW5zdGFsbGVkIHBsdWdpbnMsIGluIG9yZGVyIG9mIHByZWNlZGVuY2UgKG1vc3QtZ2VuZXJhbCB0byBtb3N0LXNwZWNpZmljKS5cbkR5Z3JhcGguUExVR0lOUyA9IFtcbiAgTGVnZW5kUGx1Z2luLFxuICBBeGVzUGx1Z2luLFxuICBSYW5nZVNlbGVjdG9yUGx1Z2luLCAvLyBIYXMgdG8gYmUgYmVmb3JlIENoYXJ0TGFiZWxzIHNvIHRoYXQgaXRzIGNhbGxiYWNrcyBhcmUgY2FsbGVkIGFmdGVyIENoYXJ0TGFiZWxzJyBjYWxsYmFja3MuXG4gIENoYXJ0TGFiZWxzUGx1Z2luLFxuICBBbm5vdGF0aW9uc1BsdWdpbixcbiAgR3JpZFBsdWdpblxuXTtcblxuLy8gVGhlcmUgYXJlIG1hbnkgc3ltYm9scyB3aGljaCBoYXZlIGhpc3RvcmljYWxseSBiZWVuIGF2YWlsYWJsZSB0aHJvdWdoIHRoZVxuLy8gRHlncmFwaCBjbGFzcy4gVGhlc2UgYXJlIGV4cG9ydGVkIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuRHlncmFwaC5HVml6Q2hhcnQgPSBHVml6Q2hhcnQ7XG5EeWdyYXBoLkRBU0hFRF9MSU5FID0gdXRpbHMuREFTSEVEX0xJTkU7XG5EeWdyYXBoLkRPVF9EQVNIX0xJTkUgPSB1dGlscy5ET1RfREFTSF9MSU5FO1xuRHlncmFwaC5kYXRlQXhpc0xhYmVsRm9ybWF0dGVyID0gdXRpbHMuZGF0ZUF4aXNMYWJlbEZvcm1hdHRlcjtcbkR5Z3JhcGgudG9SR0JfID0gdXRpbHMudG9SR0JfO1xuRHlncmFwaC5maW5kUG9zID0gdXRpbHMuZmluZFBvcztcbkR5Z3JhcGgucGFnZVggPSB1dGlscy5wYWdlWDtcbkR5Z3JhcGgucGFnZVkgPSB1dGlscy5wYWdlWTtcbkR5Z3JhcGguZGF0ZVN0cmluZ18gPSB1dGlscy5kYXRlU3RyaW5nXztcbkR5Z3JhcGguZGVmYXVsdEludGVyYWN0aW9uTW9kZWwgPSBEeWdyYXBoSW50ZXJhY3Rpb24uZGVmYXVsdE1vZGVsO1xuRHlncmFwaC5ub25JbnRlcmFjdGl2ZU1vZGVsID0gRHlncmFwaC5ub25JbnRlcmFjdGl2ZU1vZGVsXyA9IER5Z3JhcGhJbnRlcmFjdGlvbi5ub25JbnRlcmFjdGl2ZU1vZGVsXztcbkR5Z3JhcGguQ2lyY2xlcyA9IHV0aWxzLkNpcmNsZXM7XG5cbkR5Z3JhcGguUGx1Z2lucyA9IHtcbiAgTGVnZW5kOiBMZWdlbmRQbHVnaW4sXG4gIEF4ZXM6IEF4ZXNQbHVnaW4sXG4gIEFubm90YXRpb25zOiBBbm5vdGF0aW9uc1BsdWdpbixcbiAgQ2hhcnRMYWJlbHM6IENoYXJ0TGFiZWxzUGx1Z2luLFxuICBHcmlkOiBHcmlkUGx1Z2luLFxuICBSYW5nZVNlbGVjdG9yOiBSYW5nZVNlbGVjdG9yUGx1Z2luXG59O1xuXG5EeWdyYXBoLkRhdGFIYW5kbGVycyA9IHtcbiAgRGVmYXVsdEhhbmRsZXIsXG4gIEJhcnNIYW5kbGVyLFxuICBDdXN0b21CYXJzSGFuZGxlcixcbiAgRGVmYXVsdEZyYWN0aW9uSGFuZGxlcixcbiAgRXJyb3JCYXJzSGFuZGxlcixcbiAgRnJhY3Rpb25zQmFyc0hhbmRsZXJcbn07XG5cbkR5Z3JhcGguc3RhcnRQYW4gPSBEeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRQYW47XG5EeWdyYXBoLnN0YXJ0Wm9vbSA9IER5Z3JhcGhJbnRlcmFjdGlvbi5zdGFydFpvb207XG5EeWdyYXBoLm1vdmVQYW4gPSBEeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVBhbjtcbkR5Z3JhcGgubW92ZVpvb20gPSBEeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVpvb207XG5EeWdyYXBoLmVuZFBhbiA9IER5Z3JhcGhJbnRlcmFjdGlvbi5lbmRQYW47XG5EeWdyYXBoLmVuZFpvb20gPSBEeWdyYXBoSW50ZXJhY3Rpb24uZW5kWm9vbTtcblxuRHlncmFwaC5udW1lcmljTGluZWFyVGlja3MgPSBEeWdyYXBoVGlja2Vycy5udW1lcmljTGluZWFyVGlja3M7XG5EeWdyYXBoLm51bWVyaWNUaWNrcyA9IER5Z3JhcGhUaWNrZXJzLm51bWVyaWNUaWNrcztcbkR5Z3JhcGguZGF0ZVRpY2tlciA9IER5Z3JhcGhUaWNrZXJzLmRhdGVUaWNrZXI7XG5EeWdyYXBoLkdyYW51bGFyaXR5ID0gRHlncmFwaFRpY2tlcnMuR3JhbnVsYXJpdHk7XG5EeWdyYXBoLmdldERhdGVBeGlzID0gRHlncmFwaFRpY2tlcnMuZ2V0RGF0ZUF4aXM7XG5EeWdyYXBoLmZsb2F0Rm9ybWF0ID0gdXRpbHMuZmxvYXRGb3JtYXQ7XG5cbmV4cG9ydCBkZWZhdWx0IER5Z3JhcGg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n    return [];\n};\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZSIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJjYWxsIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwiaSIsInB1c2giLCJJdGVtIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwibmFtZSIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUlBLFVBQVVDLE9BQU9DLE9BQVAsR0FBaUIsRUFBL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSUMsZ0JBQUo7QUFDQSxJQUFJQyxrQkFBSjs7QUFFQSxTQUFTQyxnQkFBVCxHQUE0QjtBQUN4QixVQUFNLElBQUlDLEtBQUosQ0FBVSxpQ0FBVixDQUFOO0FBQ0g7QUFDRCxT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QUFWLEVBQWU7QUFDM0IsVUFBTSxJQUFJcEQsS0FBSixDQUFVLGdDQUFWLENBQU47QUFDSCxDQUZEO0FBR0FOLFFBQVEyRCxLQUFSLEdBQWdCLFlBQVc7QUFBRSxXQUFPLENBQVA7QUFBVyxDQUF4QyIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__datahandler__ = __webpack_require__(10);\n/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler default implementation used for simple line charts.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * @constructor\n * @extends Dygraph.DataHandler\n */\nvar DefaultHandler = function DefaultHandler() {};\n\nDefaultHandler.prototype = new __WEBPACK_IMPORTED_MODULE_0__datahandler__[\"a\" /* default */]();\n\n/** @inheritDoc */\nDefaultHandler.prototype.extractSeries = function (rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var logScale = options.get('logscale');\n  for (var j = 0; j < rawData.length; j++) {\n    var x = rawData[j][0];\n    var point = rawData[j][i];\n    if (logScale) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point <= 0) {\n        point = null;\n      }\n    }\n    series.push([x, point]);\n  }\n  return series;\n};\n\n/** @inheritDoc */\nDefaultHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n\n  var i, j, y, sum, num_ok;\n  // Calculate the rolling average for the first rollPeriod - 1 points\n  // where\n  // there is not enough data to roll over the full number of points\n  if (rollPeriod == 1) {\n    return originalData;\n  }\n  for (i = 0; i < originalData.length; i++) {\n    sum = 0;\n    num_ok = 0;\n    for (j = Math.max(0, i - rollPeriod + 1); j < i + 1; j++) {\n      y = originalData[j][1];\n      if (y === null || isNaN(y)) continue;\n      num_ok++;\n      sum += originalData[j][1];\n    }\n    if (num_ok) {\n      rollingData[i] = [originalData[i][0], sum / num_ok];\n    } else {\n      rollingData[i] = [originalData[i][0], null];\n    }\n  }\n\n  return rollingData;\n};\n\n/** @inheritDoc */\nDefaultHandler.prototype.getExtremeYValues = function (series, dateWindow, options) {\n  var minY = null,\n      maxY = null,\n      y;\n  var firstIdx = 0,\n      lastIdx = series.length - 1;\n\n  for (var j = firstIdx; j <= lastIdx; j++) {\n    y = series[j][1];\n    if (y === null || isNaN(y)) continue;\n    if (maxY === null || y > maxY) {\n      maxY = y;\n    }\n    if (minY === null || y < minY) {\n      minY = y;\n    }\n  }\n  return [minY, maxY];\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DefaultHandler);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9kZWZhdWx0LmpzPzVhM2EiXSwibmFtZXMiOlsiRGVmYXVsdEhhbmRsZXIiLCJwcm90b3R5cGUiLCJleHRyYWN0U2VyaWVzIiwicmF3RGF0YSIsImkiLCJvcHRpb25zIiwic2VyaWVzIiwibG9nU2NhbGUiLCJnZXQiLCJqIiwibGVuZ3RoIiwieCIsInBvaW50IiwicHVzaCIsInJvbGxpbmdBdmVyYWdlIiwib3JpZ2luYWxEYXRhIiwicm9sbFBlcmlvZCIsIk1hdGgiLCJtaW4iLCJyb2xsaW5nRGF0YSIsInkiLCJzdW0iLCJudW1fb2siLCJtYXgiLCJpc05hTiIsImdldEV4dHJlbWVZVmFsdWVzIiwiZGF0ZVdpbmRvdyIsIm1pblkiLCJtYXhZIiwiZmlyc3RJZHgiLCJsYXN0SWR4Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOzs7Ozs7QUFNQTs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUEsSUFBSUEsaUJBQWlCLFNBQWpCQSxjQUFpQixHQUFXLENBQy9CLENBREQ7O0FBR0FBLGVBQWVDLFNBQWYsR0FBMkIsSUFBSSw2REFBSixFQUEzQjs7QUFFQTtBQUNBRCxlQUFlQyxTQUFmLENBQXlCQyxhQUF6QixHQUF5QyxVQUFTQyxPQUFULEVBQWtCQyxDQUFsQixFQUFxQkMsT0FBckIsRUFBOEI7QUFDckU7QUFDQSxNQUFJQyxTQUFTLEVBQWI7QUFDQSxNQUFJQyxXQUFXRixRQUFRRyxHQUFSLENBQVksVUFBWixDQUFmO0FBQ0EsT0FBTSxJQUFJQyxJQUFJLENBQWQsRUFBaUJBLElBQUlOLFFBQVFPLE1BQTdCLEVBQXFDRCxHQUFyQyxFQUEwQztBQUN4QyxRQUFJRSxJQUFJUixRQUFRTSxDQUFSLEVBQVcsQ0FBWCxDQUFSO0FBQ0EsUUFBSUcsUUFBUVQsUUFBUU0sQ0FBUixFQUFXTCxDQUFYLENBQVo7QUFDQSxRQUFJRyxRQUFKLEVBQWM7QUFDWjtBQUNBO0FBQ0EsVUFBSUssU0FBUyxDQUFiLEVBQWdCO0FBQ2RBLGdCQUFRLElBQVI7QUFDRDtBQUNGO0FBQ0ROLFdBQU9PLElBQVAsQ0FBWSxDQUFFRixDQUFGLEVBQUtDLEtBQUwsQ0FBWjtBQUNEO0FBQ0QsU0FBT04sTUFBUDtBQUNELENBakJEOztBQW1CQTtBQUNBTixlQUFlQyxTQUFmLENBQXlCYSxjQUF6QixHQUEwQyxVQUFTQyxZQUFULEVBQXVCQyxVQUF2QixFQUN0Q1gsT0FEc0MsRUFDN0I7QUFDWFcsZUFBYUMsS0FBS0MsR0FBTCxDQUFTRixVQUFULEVBQXFCRCxhQUFhTCxNQUFsQyxDQUFiO0FBQ0EsTUFBSVMsY0FBYyxFQUFsQjs7QUFFQSxNQUFJZixDQUFKLEVBQU9LLENBQVAsRUFBVVcsQ0FBVixFQUFhQyxHQUFiLEVBQWtCQyxNQUFsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUlOLGNBQWMsQ0FBbEIsRUFBcUI7QUFDbkIsV0FBT0QsWUFBUDtBQUNEO0FBQ0QsT0FBS1gsSUFBSSxDQUFULEVBQVlBLElBQUlXLGFBQWFMLE1BQTdCLEVBQXFDTixHQUFyQyxFQUEwQztBQUN4Q2lCLFVBQU0sQ0FBTjtBQUNBQyxhQUFTLENBQVQ7QUFDQSxTQUFLYixJQUFJUSxLQUFLTSxHQUFMLENBQVMsQ0FBVCxFQUFZbkIsSUFBSVksVUFBSixHQUFpQixDQUE3QixDQUFULEVBQTBDUCxJQUFJTCxJQUFJLENBQWxELEVBQXFESyxHQUFyRCxFQUEwRDtBQUN4RFcsVUFBSUwsYUFBYU4sQ0FBYixFQUFnQixDQUFoQixDQUFKO0FBQ0EsVUFBSVcsTUFBTSxJQUFOLElBQWNJLE1BQU1KLENBQU4sQ0FBbEIsRUFDRTtBQUNGRTtBQUNBRCxhQUFPTixhQUFhTixDQUFiLEVBQWdCLENBQWhCLENBQVA7QUFDRDtBQUNELFFBQUlhLE1BQUosRUFBWTtBQUNWSCxrQkFBWWYsQ0FBWixJQUFpQixDQUFFVyxhQUFhWCxDQUFiLEVBQWdCLENBQWhCLENBQUYsRUFBc0JpQixNQUFNQyxNQUE1QixDQUFqQjtBQUNELEtBRkQsTUFFTztBQUNMSCxrQkFBWWYsQ0FBWixJQUFpQixDQUFFVyxhQUFhWCxDQUFiLEVBQWdCLENBQWhCLENBQUYsRUFBc0IsSUFBdEIsQ0FBakI7QUFDRDtBQUNGOztBQUVELFNBQU9lLFdBQVA7QUFDRCxDQTlCRDs7QUFnQ0E7QUFDQW5CLGVBQWVDLFNBQWYsQ0FBeUJ3QixpQkFBekIsR0FBNkMsVUFBU25CLE1BQVQsRUFBaUJvQixVQUFqQixFQUN6Q3JCLE9BRHlDLEVBQ2hDO0FBQ1gsTUFBSXNCLE9BQU8sSUFBWDtBQUFBLE1BQWlCQyxPQUFPLElBQXhCO0FBQUEsTUFBOEJSLENBQTlCO0FBQ0EsTUFBSVMsV0FBVyxDQUFmO0FBQUEsTUFBa0JDLFVBQVV4QixPQUFPSSxNQUFQLEdBQWdCLENBQTVDOztBQUVBLE9BQU0sSUFBSUQsSUFBSW9CLFFBQWQsRUFBd0JwQixLQUFLcUIsT0FBN0IsRUFBc0NyQixHQUF0QyxFQUEyQztBQUN6Q1csUUFBSWQsT0FBT0csQ0FBUCxFQUFVLENBQVYsQ0FBSjtBQUNBLFFBQUlXLE1BQU0sSUFBTixJQUFjSSxNQUFNSixDQUFOLENBQWxCLEVBQ0U7QUFDRixRQUFJUSxTQUFTLElBQVQsSUFBaUJSLElBQUlRLElBQXpCLEVBQStCO0FBQzdCQSxhQUFPUixDQUFQO0FBQ0Q7QUFDRCxRQUFJTyxTQUFTLElBQVQsSUFBaUJQLElBQUlPLElBQXpCLEVBQStCO0FBQzdCQSxhQUFPUCxDQUFQO0FBQ0Q7QUFDRjtBQUNELFNBQU8sQ0FBRU8sSUFBRixFQUFRQyxJQUFSLENBQVA7QUFDRCxDQWpCRDs7QUFtQkEseURBQWU1QixjQUFmIiwiZmlsZSI6IjE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTMgRGF2aWQgRWJlcmxlaW4gKGRhdmlkLmViZXJsZWluQGNoLnNhdXRlci1iYy5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERhdGFIYW5kbGVyIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gdXNlZCBmb3Igc2ltcGxlIGxpbmUgY2hhcnRzLlxuICogQGF1dGhvciBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqL1xuXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IER5Z3JhcGhEYXRhSGFuZGxlciBmcm9tICcuL2RhdGFoYW5kbGVyJztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIER5Z3JhcGguRGF0YUhhbmRsZXJcbiAqL1xudmFyIERlZmF1bHRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG59O1xuXG5EZWZhdWx0SGFuZGxlci5wcm90b3R5cGUgPSBuZXcgRHlncmFwaERhdGFIYW5kbGVyKCk7XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuRGVmYXVsdEhhbmRsZXIucHJvdG90eXBlLmV4dHJhY3RTZXJpZXMgPSBmdW5jdGlvbihyYXdEYXRhLCBpLCBvcHRpb25zKSB7XG4gIC8vIFRPRE8oZGFudmspOiBwcmUtYWxsb2NhdGUgc2VyaWVzIGhlcmUuXG4gIHZhciBzZXJpZXMgPSBbXTtcbiAgdmFyIGxvZ1NjYWxlID0gb3B0aW9ucy5nZXQoJ2xvZ3NjYWxlJyk7XG4gIGZvciAoIHZhciBqID0gMDsgaiA8IHJhd0RhdGEubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgeCA9IHJhd0RhdGFbal1bMF07XG4gICAgdmFyIHBvaW50ID0gcmF3RGF0YVtqXVtpXTtcbiAgICBpZiAobG9nU2NhbGUpIHtcbiAgICAgIC8vIE9uIHRoZSBsb2cgc2NhbGUsIHBvaW50cyBsZXNzIHRoYW4gemVybyBkbyBub3QgZXhpc3QuXG4gICAgICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgZ2FwIGluIHRoZSBjaGFydC5cbiAgICAgIGlmIChwb2ludCA8PSAwKSB7XG4gICAgICAgIHBvaW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VyaWVzLnB1c2goWyB4LCBwb2ludCBdKTtcbiAgfVxuICByZXR1cm4gc2VyaWVzO1xufTtcblxuLyoqIEBpbmhlcml0RG9jICovXG5EZWZhdWx0SGFuZGxlci5wcm90b3R5cGUucm9sbGluZ0F2ZXJhZ2UgPSBmdW5jdGlvbihvcmlnaW5hbERhdGEsIHJvbGxQZXJpb2QsXG4gICAgb3B0aW9ucykge1xuICByb2xsUGVyaW9kID0gTWF0aC5taW4ocm9sbFBlcmlvZCwgb3JpZ2luYWxEYXRhLmxlbmd0aCk7XG4gIHZhciByb2xsaW5nRGF0YSA9IFtdO1xuXG4gIHZhciBpLCBqLCB5LCBzdW0sIG51bV9vaztcbiAgLy8gQ2FsY3VsYXRlIHRoZSByb2xsaW5nIGF2ZXJhZ2UgZm9yIHRoZSBmaXJzdCByb2xsUGVyaW9kIC0gMSBwb2ludHNcbiAgLy8gd2hlcmVcbiAgLy8gdGhlcmUgaXMgbm90IGVub3VnaCBkYXRhIHRvIHJvbGwgb3ZlciB0aGUgZnVsbCBudW1iZXIgb2YgcG9pbnRzXG4gIGlmIChyb2xsUGVyaW9kID09IDEpIHtcbiAgICByZXR1cm4gb3JpZ2luYWxEYXRhO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBvcmlnaW5hbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBzdW0gPSAwO1xuICAgIG51bV9vayA9IDA7XG4gICAgZm9yIChqID0gTWF0aC5tYXgoMCwgaSAtIHJvbGxQZXJpb2QgKyAxKTsgaiA8IGkgKyAxOyBqKyspIHtcbiAgICAgIHkgPSBvcmlnaW5hbERhdGFbal1bMV07XG4gICAgICBpZiAoeSA9PT0gbnVsbCB8fCBpc05hTih5KSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBudW1fb2srKztcbiAgICAgIHN1bSArPSBvcmlnaW5hbERhdGFbal1bMV07XG4gICAgfVxuICAgIGlmIChudW1fb2spIHtcbiAgICAgIHJvbGxpbmdEYXRhW2ldID0gWyBvcmlnaW5hbERhdGFbaV1bMF0sIHN1bSAvIG51bV9vayBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByb2xsaW5nRGF0YVtpXSA9IFsgb3JpZ2luYWxEYXRhW2ldWzBdLCBudWxsIF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJvbGxpbmdEYXRhO1xufTtcblxuLyoqIEBpbmhlcml0RG9jICovXG5EZWZhdWx0SGFuZGxlci5wcm90b3R5cGUuZ2V0RXh0cmVtZVlWYWx1ZXMgPSBmdW5jdGlvbihzZXJpZXMsIGRhdGVXaW5kb3csXG4gICAgb3B0aW9ucykge1xuICB2YXIgbWluWSA9IG51bGwsIG1heFkgPSBudWxsLCB5O1xuICB2YXIgZmlyc3RJZHggPSAwLCBsYXN0SWR4ID0gc2VyaWVzLmxlbmd0aCAtIDE7XG5cbiAgZm9yICggdmFyIGogPSBmaXJzdElkeDsgaiA8PSBsYXN0SWR4OyBqKyspIHtcbiAgICB5ID0gc2VyaWVzW2pdWzFdO1xuICAgIGlmICh5ID09PSBudWxsIHx8IGlzTmFOKHkpKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKG1heFkgPT09IG51bGwgfHwgeSA+IG1heFkpIHtcbiAgICAgIG1heFkgPSB5O1xuICAgIH1cbiAgICBpZiAobWluWSA9PT0gbnVsbCB8fCB5IDwgbWluWSkge1xuICAgICAgbWluWSA9IHk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbIG1pblksIG1heFkgXTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERlZmF1bHRIYW5kbGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9keWdyYXBocy9zcmMvZGF0YWhhbmRsZXIvZGVmYXVsdC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dygraph__ = __webpack_require__(13);\n/**\n * @license\n * Copyright 2006 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview Based on PlotKit.CanvasRenderer, but modified to meet the\n * needs of dygraphs.\n *\n * In particular, support for:\n * - grid overlays\n * - error bars\n * - dygraphs attribute system\n */\n\n/**\n * The DygraphCanvasRenderer class does the actual rendering of the chart onto\n * a canvas. It's based on PlotKit.CanvasRenderer.\n * @param {Object} element The canvas to attach to\n * @param {Object} elementContext The 2d context of the canvas (injected so it\n * can be mocked for testing.)\n * @param {Layout} layout The DygraphLayout object for this graph.\n * @constructor\n */\n\n/*global Dygraph:false */\n\n\n\n\n\n/**\n * @constructor\n *\n * This gets called when there are \"new points\" to chart. This is generally the\n * case when the underlying data being charted has changed. It is _not_ called\n * in the common case that the user has zoomed or is panning the view.\n *\n * The chart canvas has already been created by the Dygraph object. The\n * renderer simply gets a drawing context.\n *\n * @param {Dygraph} dygraph The chart to which this renderer belongs.\n * @param {HTMLCanvasElement} element The &lt;canvas&gt; DOM element on which to draw.\n * @param {CanvasRenderingContext2D} elementContext The drawing context.\n * @param {DygraphLayout} layout The chart's DygraphLayout object.\n *\n * TODO(danvk): remove the elementContext property.\n */\nvar DygraphCanvasRenderer = function DygraphCanvasRenderer(dygraph, element, elementContext, layout) {\n  this.dygraph_ = dygraph;\n\n  this.layout = layout;\n  this.element = element;\n  this.elementContext = elementContext;\n\n  this.height = dygraph.height_;\n  this.width = dygraph.width_;\n\n  // --- check whether everything is ok before we return\n  if (!__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"Q\" /* isCanvasSupported */](this.element)) {\n    throw \"Canvas is not supported.\";\n  }\n\n  // internal state\n  this.area = layout.getPlotArea();\n\n  // Set up a clipping area for the canvas (and the interaction canvas).\n  // This ensures that we don't overdraw.\n  var ctx = this.dygraph_.canvas_ctx_;\n  ctx.beginPath();\n  ctx.rect(this.area.x, this.area.y, this.area.w, this.area.h);\n  ctx.clip();\n\n  ctx = this.dygraph_.hidden_ctx_;\n  ctx.beginPath();\n  ctx.rect(this.area.x, this.area.y, this.area.w, this.area.h);\n  ctx.clip();\n};\n\n/**\n * Clears out all chart content and DOM elements.\n * This is called immediately before render() on every frame, including\n * during zooms and pans.\n * @private\n */\nDygraphCanvasRenderer.prototype.clear = function () {\n  this.elementContext.clearRect(0, 0, this.width, this.height);\n};\n\n/**\n * This method is responsible for drawing everything on the chart, including\n * lines, error bars, fills and axes.\n * It is called immediately after clear() on every frame, including during pans\n * and zooms.\n * @private\n */\nDygraphCanvasRenderer.prototype.render = function () {\n  // attaches point.canvas{x,y}\n  this._updatePoints();\n\n  // actually draws the chart.\n  this._renderLineChart();\n};\n\n/**\n * Returns a predicate to be used with an iterator, which will\n * iterate over points appropriately, depending on whether\n * connectSeparatedPoints is true. When it's false, the predicate will\n * skip over points with missing yVals.\n */\nDygraphCanvasRenderer._getIteratorPredicate = function (connectSeparatedPoints) {\n  return connectSeparatedPoints ? DygraphCanvasRenderer._predicateThatSkipsEmptyPoints : null;\n};\n\nDygraphCanvasRenderer._predicateThatSkipsEmptyPoints = function (array, idx) {\n  return array[idx].yval !== null;\n};\n\n/**\n * Draws a line with the styles passed in and calls all the drawPointCallbacks.\n * @param {Object} e The dictionary passed to the plotter function.\n * @private\n */\nDygraphCanvasRenderer._drawStyledLine = function (e, color, strokeWidth, strokePattern, drawPoints, drawPointCallback, pointSize) {\n  var g = e.dygraph;\n  // TODO(konigsberg): Compute attributes outside this method call.\n  var stepPlot = g.getBooleanOption(\"stepPlot\", e.setName);\n\n  if (!__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"B\" /* isArrayLike */](strokePattern)) {\n    strokePattern = null;\n  }\n\n  var drawGapPoints = g.getBooleanOption('drawGapEdgePoints', e.setName);\n\n  var points = e.points;\n  var setName = e.setName;\n  var iter = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"R\" /* createIterator */](points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n  var stroking = strokePattern && strokePattern.length >= 2;\n\n  var ctx = e.drawingContext;\n  ctx.save();\n  if (stroking) {\n    if (ctx.setLineDash) ctx.setLineDash(strokePattern);\n  }\n\n  var pointsOnLine = DygraphCanvasRenderer._drawSeries(e, iter, strokeWidth, pointSize, drawPoints, drawGapPoints, stepPlot, color);\n  DygraphCanvasRenderer._drawPointsOnLine(e, pointsOnLine, drawPointCallback, color, pointSize);\n\n  if (stroking) {\n    if (ctx.setLineDash) ctx.setLineDash([]);\n  }\n\n  ctx.restore();\n};\n\n/**\n * This does the actual drawing of lines on the canvas, for just one series.\n * Returns a list of [canvasx, canvasy] pairs for points for which a\n * drawPointCallback should be fired.  These include isolated points, or all\n * points if drawPoints=true.\n * @param {Object} e The dictionary passed to the plotter function.\n * @private\n */\nDygraphCanvasRenderer._drawSeries = function (e, iter, strokeWidth, pointSize, drawPoints, drawGapPoints, stepPlot, color) {\n\n  var prevCanvasX = null;\n  var prevCanvasY = null;\n  var nextCanvasY = null;\n  var isIsolated; // true if this point is isolated (no line segments)\n  var point; // the point being processed in the while loop\n  var pointsOnLine = []; // Array of [canvasx, canvasy] pairs.\n  var first = true; // the first cycle through the while loop\n\n  var ctx = e.drawingContext;\n  ctx.beginPath();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = strokeWidth;\n\n  // NOTE: we break the iterator's encapsulation here for about a 25% speedup.\n  var arr = iter.array_;\n  var limit = iter.end_;\n  var predicate = iter.predicate_;\n\n  for (var i = iter.start_; i < limit; i++) {\n    point = arr[i];\n    if (predicate) {\n      while (i < limit && !predicate(arr, i)) {\n        i++;\n      }\n      if (i == limit) break;\n      point = arr[i];\n    }\n\n    // FIXME: The 'canvasy != canvasy' test here catches NaN values but the test\n    // doesn't catch Infinity values. Could change this to\n    // !isFinite(point.canvasy), but I assume it avoids isNaN for performance?\n    if (point.canvasy === null || point.canvasy != point.canvasy) {\n      if (stepPlot && prevCanvasX !== null) {\n        // Draw a horizontal line to the start of the missing data\n        ctx.moveTo(prevCanvasX, prevCanvasY);\n        ctx.lineTo(point.canvasx, prevCanvasY);\n      }\n      prevCanvasX = prevCanvasY = null;\n    } else {\n      isIsolated = false;\n      if (drawGapPoints || prevCanvasX === null) {\n        iter.nextIdx_ = i;\n        iter.next();\n        nextCanvasY = iter.hasNext ? iter.peek.canvasy : null;\n\n        var isNextCanvasYNullOrNaN = nextCanvasY === null || nextCanvasY != nextCanvasY;\n        isIsolated = prevCanvasX === null && isNextCanvasYNullOrNaN;\n        if (drawGapPoints) {\n          // Also consider a point to be \"isolated\" if it's adjacent to a\n          // null point, excluding the graph edges.\n          if (!first && prevCanvasX === null || iter.hasNext && isNextCanvasYNullOrNaN) {\n            isIsolated = true;\n          }\n        }\n      }\n\n      if (prevCanvasX !== null) {\n        if (strokeWidth) {\n          if (stepPlot) {\n            ctx.moveTo(prevCanvasX, prevCanvasY);\n            ctx.lineTo(point.canvasx, prevCanvasY);\n          }\n\n          ctx.lineTo(point.canvasx, point.canvasy);\n        }\n      } else {\n        ctx.moveTo(point.canvasx, point.canvasy);\n      }\n      if (drawPoints || isIsolated) {\n        pointsOnLine.push([point.canvasx, point.canvasy, point.idx]);\n      }\n      prevCanvasX = point.canvasx;\n      prevCanvasY = point.canvasy;\n    }\n    first = false;\n  }\n  ctx.stroke();\n  return pointsOnLine;\n};\n\n/**\n * This fires the drawPointCallback functions, which draw dots on the points by\n * default. This gets used when the \"drawPoints\" option is set, or when there\n * are isolated points.\n * @param {Object} e The dictionary passed to the plotter function.\n * @private\n */\nDygraphCanvasRenderer._drawPointsOnLine = function (e, pointsOnLine, drawPointCallback, color, pointSize) {\n  var ctx = e.drawingContext;\n  for (var idx = 0; idx < pointsOnLine.length; idx++) {\n    var cb = pointsOnLine[idx];\n    ctx.save();\n    drawPointCallback.call(e.dygraph, e.dygraph, e.setName, ctx, cb[0], cb[1], color, pointSize, cb[2]);\n    ctx.restore();\n  }\n};\n\n/**\n * Attaches canvas coordinates to the points array.\n * @private\n */\nDygraphCanvasRenderer.prototype._updatePoints = function () {\n  // Update Points\n  // TODO(danvk): here\n  //\n  // TODO(bhs): this loop is a hot-spot for high-point-count charts. These\n  // transformations can be pushed into the canvas via linear transformation\n  // matrices.\n  // NOTE(danvk): this is trickier than it sounds at first. The transformation\n  // needs to be done before the .moveTo() and .lineTo() calls, but must be\n  // undone before the .stroke() call to ensure that the stroke width is\n  // unaffected.  An alternative is to reduce the stroke width in the\n  // transformed coordinate space, but you can't specify different values for\n  // each dimension (as you can with .scale()). The speedup here is ~12%.\n  var sets = this.layout.points;\n  for (var i = sets.length; i--;) {\n    var points = sets[i];\n    for (var j = points.length; j--;) {\n      var point = points[j];\n      point.canvasx = this.area.w * point.x + this.area.x;\n      point.canvasy = this.area.h * point.y + this.area.y;\n    }\n  }\n};\n\n/**\n * Add canvas Actually draw the lines chart, including error bars.\n *\n * This function can only be called if DygraphLayout's points array has been\n * updated with canvas{x,y} attributes, i.e. by\n * DygraphCanvasRenderer._updatePoints.\n *\n * @param {string=} opt_seriesName when specified, only that series will\n *     be drawn. (This is used for expedited redrawing with highlightSeriesOpts)\n * @param {CanvasRenderingContext2D} opt_ctx when specified, the drawing\n *     context.  However, lines are typically drawn on the object's\n *     elementContext.\n * @private\n */\nDygraphCanvasRenderer.prototype._renderLineChart = function (opt_seriesName, opt_ctx) {\n  var ctx = opt_ctx || this.elementContext;\n  var i;\n\n  var sets = this.layout.points;\n  var setNames = this.layout.setNames;\n  var setName;\n\n  this.colors = this.dygraph_.colorsMap_;\n\n  // Determine which series have specialized plotters.\n  var plotter_attr = this.dygraph_.getOption(\"plotter\");\n  var plotters = plotter_attr;\n  if (!__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"B\" /* isArrayLike */](plotters)) {\n    plotters = [plotters];\n  }\n\n  var setPlotters = {}; // series name -> plotter fn.\n  for (i = 0; i < setNames.length; i++) {\n    setName = setNames[i];\n    var setPlotter = this.dygraph_.getOption(\"plotter\", setName);\n    if (setPlotter == plotter_attr) continue; // not specialized.\n\n    setPlotters[setName] = setPlotter;\n  }\n\n  for (i = 0; i < plotters.length; i++) {\n    var plotter = plotters[i];\n    var is_last = i == plotters.length - 1;\n\n    for (var j = 0; j < sets.length; j++) {\n      setName = setNames[j];\n      if (opt_seriesName && setName != opt_seriesName) continue;\n\n      var points = sets[j];\n\n      // Only throw in the specialized plotters on the last iteration.\n      var p = plotter;\n      if (setName in setPlotters) {\n        if (is_last) {\n          p = setPlotters[setName];\n        } else {\n          // Don't use the standard plotters in this case.\n          continue;\n        }\n      }\n\n      var color = this.colors[setName];\n      var strokeWidth = this.dygraph_.getOption(\"strokeWidth\", setName);\n\n      ctx.save();\n      ctx.strokeStyle = color;\n      ctx.lineWidth = strokeWidth;\n      p({\n        points: points,\n        setName: setName,\n        drawingContext: ctx,\n        color: color,\n        strokeWidth: strokeWidth,\n        dygraph: this.dygraph_,\n        axis: this.dygraph_.axisPropertiesForSeries(setName),\n        plotArea: this.area,\n        seriesIndex: j,\n        seriesCount: sets.length,\n        singleSeriesName: opt_seriesName,\n        allSeriesPoints: sets\n      });\n      ctx.restore();\n    }\n  }\n};\n\n/**\n * Standard plotters. These may be used by clients via Dygraph.Plotters.\n * See comments there for more details.\n */\nDygraphCanvasRenderer._Plotters = {\n  linePlotter: function linePlotter(e) {\n    DygraphCanvasRenderer._linePlotter(e);\n  },\n\n  fillPlotter: function fillPlotter(e) {\n    DygraphCanvasRenderer._fillPlotter(e);\n  },\n\n  errorPlotter: function errorPlotter(e) {\n    DygraphCanvasRenderer._errorPlotter(e);\n  }\n};\n\n/**\n * Plotter which draws the central lines for a series.\n * @private\n */\nDygraphCanvasRenderer._linePlotter = function (e) {\n  var g = e.dygraph;\n  var setName = e.setName;\n  var strokeWidth = e.strokeWidth;\n\n  // TODO(danvk): Check if there's any performance impact of just calling\n  // getOption() inside of _drawStyledLine. Passing in so many parameters makes\n  // this code a bit nasty.\n  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) || __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"u\" /* Circles */].DEFAULT;\n  var strokePattern = g.getOption(\"strokePattern\", setName);\n  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\n  if (borderWidth && strokeWidth) {\n    DygraphCanvasRenderer._drawStyledLine(e, g.getOption(\"strokeBorderColor\", setName), strokeWidth + 2 * borderWidth, strokePattern, drawPoints, drawPointCallback, pointSize);\n  }\n\n  DygraphCanvasRenderer._drawStyledLine(e, e.color, strokeWidth, strokePattern, drawPoints, drawPointCallback, pointSize);\n};\n\n/**\n * Draws the shaded error bars/confidence intervals for each series.\n * This happens before the center lines are drawn, since the center lines\n * need to be drawn on top of the error bars for all series.\n * @private\n */\nDygraphCanvasRenderer._errorPlotter = function (e) {\n  var g = e.dygraph;\n  var setName = e.setName;\n  var errorBars = g.getBooleanOption(\"errorBars\") || g.getBooleanOption(\"customBars\");\n  if (!errorBars) return;\n\n  var fillGraph = g.getBooleanOption(\"fillGraph\", setName);\n  if (fillGraph) {\n    console.warn(\"Can't use fillGraph option with error bars\");\n  }\n\n  var ctx = e.drawingContext;\n  var color = e.color;\n  var fillAlpha = g.getNumericOption('fillAlpha', setName);\n  var stepPlot = g.getBooleanOption(\"stepPlot\", setName);\n  var points = e.points;\n\n  var iter = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"R\" /* createIterator */](points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n  var newYs;\n\n  // setup graphics context\n  var prevX = NaN;\n  var prevY = NaN;\n  var prevYs = [-1, -1];\n  // should be same color as the lines but only 15% opaque.\n  var rgb = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"t\" /* toRGB_ */](color);\n  var err_color = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n  ctx.fillStyle = err_color;\n  ctx.beginPath();\n\n  var isNullUndefinedOrNaN = function isNullUndefinedOrNaN(x) {\n    return x === null || x === undefined || isNaN(x);\n  };\n\n  while (iter.hasNext) {\n    var point = iter.next();\n    if (!stepPlot && isNullUndefinedOrNaN(point.y) || stepPlot && !isNaN(prevY) && isNullUndefinedOrNaN(prevY)) {\n      prevX = NaN;\n      continue;\n    }\n\n    newYs = [point.y_bottom, point.y_top];\n    if (stepPlot) {\n      prevY = point.y;\n    }\n\n    // The documentation specifically disallows nulls inside the point arrays,\n    // but in case it happens we should do something sensible.\n    if (isNaN(newYs[0])) newYs[0] = point.y;\n    if (isNaN(newYs[1])) newYs[1] = point.y;\n\n    newYs[0] = e.plotArea.h * newYs[0] + e.plotArea.y;\n    newYs[1] = e.plotArea.h * newYs[1] + e.plotArea.y;\n    if (!isNaN(prevX)) {\n      if (stepPlot) {\n        ctx.moveTo(prevX, prevYs[0]);\n        ctx.lineTo(point.canvasx, prevYs[0]);\n        ctx.lineTo(point.canvasx, prevYs[1]);\n      } else {\n        ctx.moveTo(prevX, prevYs[0]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n        ctx.lineTo(point.canvasx, newYs[1]);\n      }\n      ctx.lineTo(prevX, prevYs[1]);\n      ctx.closePath();\n    }\n    prevYs = newYs;\n    prevX = point.canvasx;\n  }\n  ctx.fill();\n};\n\n/**\n * Proxy for CanvasRenderingContext2D which drops moveTo/lineTo calls which are\n * superfluous. It accumulates all movements which haven't changed the x-value\n * and only applies the two with the most extreme y-values.\n *\n * Calls to lineTo/moveTo must have non-decreasing x-values.\n */\nDygraphCanvasRenderer._fastCanvasProxy = function (context) {\n  var pendingActions = []; // array of [type, x, y] tuples\n  var lastRoundedX = null;\n  var lastFlushedX = null;\n\n  var LINE_TO = 1,\n      MOVE_TO = 2;\n\n  var actionCount = 0; // number of moveTos and lineTos passed to context.\n\n  // Drop superfluous motions\n  // Assumes all pendingActions have the same (rounded) x-value.\n  var compressActions = function compressActions(opt_losslessOnly) {\n    if (pendingActions.length <= 1) return;\n\n    // Lossless compression: drop inconsequential moveTos.\n    for (var i = pendingActions.length - 1; i > 0; i--) {\n      var action = pendingActions[i];\n      if (action[0] == MOVE_TO) {\n        var prevAction = pendingActions[i - 1];\n        if (prevAction[1] == action[1] && prevAction[2] == action[2]) {\n          pendingActions.splice(i, 1);\n        }\n      }\n    }\n\n    // Lossless compression: ... drop consecutive moveTos ...\n    for (var i = 0; i < pendingActions.length - 1;) /* incremented internally */{\n      var action = pendingActions[i];\n      if (action[0] == MOVE_TO && pendingActions[i + 1][0] == MOVE_TO) {\n        pendingActions.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Lossy compression: ... drop all but the extreme y-values ...\n    if (pendingActions.length > 2 && !opt_losslessOnly) {\n      // keep an initial moveTo, but drop all others.\n      var startIdx = 0;\n      if (pendingActions[0][0] == MOVE_TO) startIdx++;\n      var minIdx = null,\n          maxIdx = null;\n      for (var i = startIdx; i < pendingActions.length; i++) {\n        var action = pendingActions[i];\n        if (action[0] != LINE_TO) continue;\n        if (minIdx === null && maxIdx === null) {\n          minIdx = i;\n          maxIdx = i;\n        } else {\n          var y = action[2];\n          if (y < pendingActions[minIdx][2]) {\n            minIdx = i;\n          } else if (y > pendingActions[maxIdx][2]) {\n            maxIdx = i;\n          }\n        }\n      }\n      var minAction = pendingActions[minIdx],\n          maxAction = pendingActions[maxIdx];\n      pendingActions.splice(startIdx, pendingActions.length - startIdx);\n      if (minIdx < maxIdx) {\n        pendingActions.push(minAction);\n        pendingActions.push(maxAction);\n      } else if (minIdx > maxIdx) {\n        pendingActions.push(maxAction);\n        pendingActions.push(minAction);\n      } else {\n        pendingActions.push(minAction);\n      }\n    }\n  };\n\n  var flushActions = function flushActions(opt_noLossyCompression) {\n    compressActions(opt_noLossyCompression);\n    for (var i = 0, len = pendingActions.length; i < len; i++) {\n      var action = pendingActions[i];\n      if (action[0] == LINE_TO) {\n        context.lineTo(action[1], action[2]);\n      } else if (action[0] == MOVE_TO) {\n        context.moveTo(action[1], action[2]);\n      }\n    }\n    if (pendingActions.length) {\n      lastFlushedX = pendingActions[pendingActions.length - 1][1];\n    }\n    actionCount += pendingActions.length;\n    pendingActions = [];\n  };\n\n  var addAction = function addAction(action, x, y) {\n    var rx = Math.round(x);\n    if (lastRoundedX === null || rx != lastRoundedX) {\n      // if there are large gaps on the x-axis, it's essential to keep the\n      // first and last point as well.\n      var hasGapOnLeft = lastRoundedX - lastFlushedX > 1,\n          hasGapOnRight = rx - lastRoundedX > 1,\n          hasGap = hasGapOnLeft || hasGapOnRight;\n      flushActions(hasGap);\n      lastRoundedX = rx;\n    }\n    pendingActions.push([action, x, y]);\n  };\n\n  return {\n    moveTo: function moveTo(x, y) {\n      addAction(MOVE_TO, x, y);\n    },\n    lineTo: function lineTo(x, y) {\n      addAction(LINE_TO, x, y);\n    },\n\n    // for major operations like stroke/fill, we skip compression to ensure\n    // that there are no artifacts at the right edge.\n    stroke: function stroke() {\n      flushActions(true);context.stroke();\n    },\n    fill: function fill() {\n      flushActions(true);context.fill();\n    },\n    beginPath: function beginPath() {\n      flushActions(true);context.beginPath();\n    },\n    closePath: function closePath() {\n      flushActions(true);context.closePath();\n    },\n\n    _count: function _count() {\n      return actionCount;\n    }\n  };\n};\n\n/**\n * Draws the shaded regions when \"fillGraph\" is set. Not to be confused with\n * error bars.\n *\n * For stacked charts, it's more convenient to handle all the series\n * simultaneously. So this plotter plots all the points on the first series\n * it's asked to draw, then ignores all the other series.\n *\n * @private\n */\nDygraphCanvasRenderer._fillPlotter = function (e) {\n  // Skip if we're drawing a single series for interactive highlight overlay.\n  if (e.singleSeriesName) return;\n\n  // We'll handle all the series at once, not one-by-one.\n  if (e.seriesIndex !== 0) return;\n\n  var g = e.dygraph;\n  var setNames = g.getLabels().slice(1); // remove x-axis\n\n  // getLabels() includes names for invisible series, which are not included in\n  // allSeriesPoints. We remove those to make the two match.\n  // TODO(danvk): provide a simpler way to get this information.\n  for (var i = setNames.length; i >= 0; i--) {\n    if (!g.visibility()[i]) setNames.splice(i, 1);\n  }\n\n  var anySeriesFilled = function () {\n    for (var i = 0; i < setNames.length; i++) {\n      if (g.getBooleanOption(\"fillGraph\", setNames[i])) return true;\n    }\n    return false;\n  }();\n\n  if (!anySeriesFilled) return;\n\n  var area = e.plotArea;\n  var sets = e.allSeriesPoints;\n  var setCount = sets.length;\n\n  var stackedGraph = g.getBooleanOption(\"stackedGraph\");\n  var colors = g.getColors();\n\n  // For stacked graphs, track the baseline for filling.\n  //\n  // The filled areas below graph lines are trapezoids with two\n  // vertical edges. The top edge is the line segment being drawn, and\n  // the baseline is the bottom edge. Each baseline corresponds to the\n  // top line segment from the previous stacked line. In the case of\n  // step plots, the trapezoids are rectangles.\n  var baseline = {};\n  var currBaseline;\n  var prevStepPlot; // for different line drawing modes (line/step) per series\n\n  // Helper function to trace a line back along the baseline.\n  var traceBackPath = function traceBackPath(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    if (stackedGraph) {\n      for (var i = pathBack.length - 1; i >= 0; i--) {\n        var pt = pathBack[i];\n        ctx.lineTo(pt[0], pt[1]);\n      }\n    }\n  };\n\n  // process sets in reverse order (needed for stacked graphs)\n  for (var setIdx = setCount - 1; setIdx >= 0; setIdx--) {\n    var ctx = e.drawingContext;\n    var setName = setNames[setIdx];\n    if (!g.getBooleanOption('fillGraph', setName)) continue;\n\n    var fillAlpha = g.getNumericOption('fillAlpha', setName);\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n    var color = colors[setIdx];\n    var axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n    var points = sets[setIdx];\n    var iter = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"R\" /* createIterator */](points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    // setup graphics context\n    var prevX = NaN;\n    var prevYs = [-1, -1];\n    var newYs;\n    // should be same color as the lines but only 15% opaque.\n    var rgb = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"t\" /* toRGB_ */](color);\n    var err_color = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x,\n        is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || __WEBPACK_IMPORTED_MODULE_1__dygraph__[\"a\" /* default */].FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // For filled charts, we draw points from left to right, then back along\n    // the x-axis to complete a shape for filling.\n    // For stacked plots, this \"back path\" is a more complex shape. This array\n    // stores the [x, y] values needed to trace that shape.\n    var pathBack = [];\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"S\" /* isOK */](point.y) && !stepPlot) {\n        traceBackPath(ctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (stackedGraph) {\n        if (!is_first && last_x == point.xval) {\n          continue;\n        } else {\n          is_first = false;\n          last_x = point.xval;\n        }\n\n        currBaseline = baseline[point.canvasx];\n        var lastY;\n        if (currBaseline === undefined) {\n          lastY = axisY;\n        } else {\n          if (prevStepPlot) {\n            lastY = currBaseline[0];\n          } else {\n            lastY = currBaseline;\n          }\n        }\n        newYs = [point.canvasy, lastY];\n\n        if (stepPlot) {\n          // Step plots must keep track of the top and bottom of\n          // the baseline at each point.\n          if (prevYs[0] === -1) {\n            baseline[point.canvasx] = [point.canvasy, axisY];\n          } else {\n            baseline[point.canvasx] = [point.canvasy, prevYs[0]];\n          }\n        } else {\n          baseline[point.canvasx] = point.canvasy;\n        }\n      } else {\n        if (isNaN(point.canvasy) && stepPlot) {\n          newYs = [area.y + area.h, axisY];\n        } else {\n          newYs = [point.canvasy, axisY];\n        }\n      }\n      if (!isNaN(prevX)) {\n        // Move to top fill point\n        if (stepPlot) {\n          ctx.lineTo(point.canvasx, prevYs[0]);\n          ctx.lineTo(point.canvasx, newYs[0]);\n        } else {\n          ctx.lineTo(point.canvasx, newYs[0]);\n        }\n\n        // Record the baseline for the reverse path.\n        if (stackedGraph) {\n          pathBack.push([prevX, prevYs[1]]);\n          if (prevStepPlot && currBaseline) {\n            // Draw to the bottom of the baseline\n            pathBack.push([point.canvasx, currBaseline[1]]);\n          } else {\n            pathBack.push([point.canvasx, newYs[1]]);\n          }\n        }\n      } else {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n    }\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      traceBackPath(ctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DygraphCanvasRenderer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLWNhbnZhcy5qcz9mMjg0Il0sIm5hbWVzIjpbIkR5Z3JhcGhDYW52YXNSZW5kZXJlciIsImR5Z3JhcGgiLCJlbGVtZW50IiwiZWxlbWVudENvbnRleHQiLCJsYXlvdXQiLCJkeWdyYXBoXyIsImhlaWdodCIsImhlaWdodF8iLCJ3aWR0aCIsIndpZHRoXyIsImFyZWEiLCJnZXRQbG90QXJlYSIsImN0eCIsImNhbnZhc19jdHhfIiwiYmVnaW5QYXRoIiwicmVjdCIsIngiLCJ5IiwidyIsImgiLCJjbGlwIiwiaGlkZGVuX2N0eF8iLCJwcm90b3R5cGUiLCJjbGVhciIsImNsZWFyUmVjdCIsInJlbmRlciIsIl91cGRhdGVQb2ludHMiLCJfcmVuZGVyTGluZUNoYXJ0IiwiX2dldEl0ZXJhdG9yUHJlZGljYXRlIiwiY29ubmVjdFNlcGFyYXRlZFBvaW50cyIsIl9wcmVkaWNhdGVUaGF0U2tpcHNFbXB0eVBvaW50cyIsImFycmF5IiwiaWR4IiwieXZhbCIsIl9kcmF3U3R5bGVkTGluZSIsImUiLCJjb2xvciIsInN0cm9rZVdpZHRoIiwic3Ryb2tlUGF0dGVybiIsImRyYXdQb2ludHMiLCJkcmF3UG9pbnRDYWxsYmFjayIsInBvaW50U2l6ZSIsImciLCJzdGVwUGxvdCIsImdldEJvb2xlYW5PcHRpb24iLCJzZXROYW1lIiwiZHJhd0dhcFBvaW50cyIsInBvaW50cyIsIml0ZXIiLCJsZW5ndGgiLCJzdHJva2luZyIsImRyYXdpbmdDb250ZXh0Iiwic2F2ZSIsInNldExpbmVEYXNoIiwicG9pbnRzT25MaW5lIiwiX2RyYXdTZXJpZXMiLCJfZHJhd1BvaW50c09uTGluZSIsInJlc3RvcmUiLCJwcmV2Q2FudmFzWCIsInByZXZDYW52YXNZIiwibmV4dENhbnZhc1kiLCJpc0lzb2xhdGVkIiwicG9pbnQiLCJmaXJzdCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwiYXJyIiwiYXJyYXlfIiwibGltaXQiLCJlbmRfIiwicHJlZGljYXRlIiwicHJlZGljYXRlXyIsImkiLCJzdGFydF8iLCJjYW52YXN5IiwibW92ZVRvIiwibGluZVRvIiwiY2FudmFzeCIsIm5leHRJZHhfIiwibmV4dCIsImhhc05leHQiLCJwZWVrIiwiaXNOZXh0Q2FudmFzWU51bGxPck5hTiIsInB1c2giLCJzdHJva2UiLCJjYiIsImNhbGwiLCJzZXRzIiwiaiIsIm9wdF9zZXJpZXNOYW1lIiwib3B0X2N0eCIsInNldE5hbWVzIiwiY29sb3JzIiwiY29sb3JzTWFwXyIsInBsb3R0ZXJfYXR0ciIsImdldE9wdGlvbiIsInBsb3R0ZXJzIiwic2V0UGxvdHRlcnMiLCJzZXRQbG90dGVyIiwicGxvdHRlciIsImlzX2xhc3QiLCJwIiwiYXhpcyIsImF4aXNQcm9wZXJ0aWVzRm9yU2VyaWVzIiwicGxvdEFyZWEiLCJzZXJpZXNJbmRleCIsInNlcmllc0NvdW50Iiwic2luZ2xlU2VyaWVzTmFtZSIsImFsbFNlcmllc1BvaW50cyIsIl9QbG90dGVycyIsImxpbmVQbG90dGVyIiwiX2xpbmVQbG90dGVyIiwiZmlsbFBsb3R0ZXIiLCJfZmlsbFBsb3R0ZXIiLCJlcnJvclBsb3R0ZXIiLCJfZXJyb3JQbG90dGVyIiwiYm9yZGVyV2lkdGgiLCJnZXROdW1lcmljT3B0aW9uIiwiREVGQVVMVCIsImVycm9yQmFycyIsImZpbGxHcmFwaCIsImNvbnNvbGUiLCJ3YXJuIiwiZmlsbEFscGhhIiwibmV3WXMiLCJwcmV2WCIsIk5hTiIsInByZXZZIiwicHJldllzIiwicmdiIiwiZXJyX2NvbG9yIiwiciIsImIiLCJmaWxsU3R5bGUiLCJpc051bGxVbmRlZmluZWRPck5hTiIsInVuZGVmaW5lZCIsImlzTmFOIiwieV9ib3R0b20iLCJ5X3RvcCIsImNsb3NlUGF0aCIsImZpbGwiLCJfZmFzdENhbnZhc1Byb3h5IiwiY29udGV4dCIsInBlbmRpbmdBY3Rpb25zIiwibGFzdFJvdW5kZWRYIiwibGFzdEZsdXNoZWRYIiwiTElORV9UTyIsIk1PVkVfVE8iLCJhY3Rpb25Db3VudCIsImNvbXByZXNzQWN0aW9ucyIsIm9wdF9sb3NzbGVzc09ubHkiLCJhY3Rpb24iLCJwcmV2QWN0aW9uIiwic3BsaWNlIiwic3RhcnRJZHgiLCJtaW5JZHgiLCJtYXhJZHgiLCJtaW5BY3Rpb24iLCJtYXhBY3Rpb24iLCJmbHVzaEFjdGlvbnMiLCJvcHRfbm9Mb3NzeUNvbXByZXNzaW9uIiwibGVuIiwiYWRkQWN0aW9uIiwicngiLCJNYXRoIiwicm91bmQiLCJoYXNHYXBPbkxlZnQiLCJoYXNHYXBPblJpZ2h0IiwiaGFzR2FwIiwiX2NvdW50IiwiZ2V0TGFiZWxzIiwic2xpY2UiLCJ2aXNpYmlsaXR5IiwiYW55U2VyaWVzRmlsbGVkIiwic2V0Q291bnQiLCJzdGFja2VkR3JhcGgiLCJnZXRDb2xvcnMiLCJiYXNlbGluZSIsImN1cnJCYXNlbGluZSIsInByZXZTdGVwUGxvdCIsInRyYWNlQmFja1BhdGgiLCJiYXNlbGluZVgiLCJiYXNlbGluZVkiLCJwYXRoQmFjayIsInB0Iiwic2V0SWR4IiwiYXhpc1kiLCJtaW55dmFsIiwieXNjYWxlIiwibGFzdF94IiwiaXNfZmlyc3QiLCJEeWdyYXBoIiwiRk9SQ0VfRkFTVF9QUk9YWSIsInlfc3RhY2tlZCIsInh2YWwiLCJsYXN0WSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQUE7Ozs7OztBQU1BOzs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLElBQUlBLHdCQUF3QixTQUF4QkEscUJBQXdCLENBQVNDLE9BQVQsRUFBa0JDLE9BQWxCLEVBQTJCQyxjQUEzQixFQUEyQ0MsTUFBM0MsRUFBbUQ7QUFDN0UsT0FBS0MsUUFBTCxHQUFnQkosT0FBaEI7O0FBRUEsT0FBS0csTUFBTCxHQUFjQSxNQUFkO0FBQ0EsT0FBS0YsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsT0FBS0MsY0FBTCxHQUFzQkEsY0FBdEI7O0FBRUEsT0FBS0csTUFBTCxHQUFjTCxRQUFRTSxPQUF0QjtBQUNBLE9BQUtDLEtB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QUFDQWhILFlBQUlnRSxNQUFKLENBQVdkLE1BQU1lLE9BQWpCLEVBQTBCK0MsTUFBTSxDQUFOLENBQTFCO0FBQ0Q7QUFDREksZUFBU0osS0FBVDtBQUNBQyxjQUFRL0QsTUFBTWUsT0FBZDtBQUNEO0FBQ0RzRyxtQkFBZXhJLFFBQWY7QUFDQSxRQUFJaUYsU0FBUzlELEtBQWIsRUFBb0I7QUFDbEJzSCxvQkFBY3hLLEdBQWQsRUFBbUJrRCxNQUFNZSxPQUF6QixFQUFrQytDLE1BQU0sQ0FBTixDQUFsQyxFQUE0QzJELFFBQTVDO0FBQ0FBLGlCQUFXLEVBQVg7QUFDRDtBQUNEM0ssUUFBSWdJLElBQUo7QUFDRDtBQUNGLENBM0xEOztBQTZMQSx5REFBZTVJLHFCQUFmIiwiZmlsZSI6IjE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMDYgRGFuIFZhbmRlcmthbSAoZGFudmRrQGdtYWlsLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQmFzZWQgb24gUGxvdEtpdC5DYW52YXNSZW5kZXJlciwgYnV0IG1vZGlmaWVkIHRvIG1lZXQgdGhlXG4gKiBuZWVkcyBvZiBkeWdyYXBocy5cbiAqXG4gKiBJbiBwYXJ0aWN1bGFyLCBzdXBwb3J0IGZvcjpcbiAqIC0gZ3JpZCBvdmVybGF5c1xuICogLSBlcnJvciBiYXJzXG4gKiAtIGR5Z3JhcGhzIGF0dHJpYnV0ZSBzeXN0ZW1cbiAqL1xuXG4vKipcbiAqIFRoZSBEeWdyYXBoQ2FudmFzUmVuZGVyZXIgY2xhc3MgZG9lcyB0aGUgYWN0dWFsIHJlbmRlcmluZyBvZiB0aGUgY2hhcnQgb250b1xuICogYSBjYW52YXMuIEl0J3MgYmFzZWQgb24gUGxvdEtpdC5DYW52YXNSZW5kZXJlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IFRoZSBjYW52YXMgdG8gYXR0YWNoIHRvXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudENvbnRleHQgVGhlIDJkIGNvbnRleHQgb2YgdGhlIGNhbnZhcyAoaW5qZWN0ZWQgc28gaXRcbiAqIGNhbiBiZSBtb2NrZWQgZm9yIHRlc3RpbmcuKVxuICogQHBhcmFtIHtMYXlvdXR9IGxheW91dCBUaGUgRHlncmFwaExheW91dCBvYmplY3QgZm9yIHRoaXMgZ3JhcGguXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi9keWdyYXBoLXV0aWxzJztcbmltcG9ydCBEeWdyYXBoIGZyb20gJy4vZHlncmFwaCc7XG5cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gdGhlcmUgYXJlIFwibmV3IHBvaW50c1wiIHRvIGNoYXJ0LiBUaGlzIGlzIGdlbmVyYWxseSB0aGVcbiAqIGNhc2Ugd2hlbiB0aGUgdW5kZXJseWluZyBkYXRhIGJlaW5nIGNoYXJ0ZWQgaGFzIGNoYW5nZWQuIEl0IGlzIF9ub3RfIGNhbGxlZFxuICogaW4gdGhlIGNvbW1vbiBjYXNlIHRoYXQgdGhlIHVzZXIgaGFzIHpvb21lZCBvciBpcyBwYW5uaW5nIHRoZSB2aWV3LlxuICpcbiAqIFRoZSBjaGFydCBjYW52YXMgaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkIGJ5IHRoZSBEeWdyYXBoIG9iamVjdC4gVGhlXG4gKiByZW5kZXJlciBzaW1wbHkgZ2V0cyBhIGRyYXdpbmcgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0ge0R5Z3JhcGh9IGR5Z3JhcGggVGhlIGNoYXJ0IHRvIHdoaWNoIHRoaXMgcmVuZGVyZXIgYmVsb25ncy5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGVsZW1lbnQgVGhlICZsdDtjYW52YXMmZ3Q7IERPTSBlbGVtZW50IG9uIHdoaWNoIHRvIGRyYXcuXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZWxlbWVudENvbnRleHQgVGhlIGRyYXdpbmcgY29udGV4dC5cbiAqIEBwYXJhbSB7RHlncmFwaExheW91dH0gbGF5b3V0IFRoZSBjaGFydCdzIER5Z3JhcGhMYXlvdXQgb2JqZWN0LlxuICpcbiAqIFRPRE8oZGFudmspOiByZW1vdmUgdGhlIGVsZW1lbnRDb250ZXh0IHByb3BlcnR5LlxuICovXG52YXIgRHlncmFwaENhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24oZHlncmFwaCwgZWxlbWVudCwgZWxlbWVudENvbnRleHQsIGxheW91dCkge1xuICB0aGlzLmR5Z3JhcGhfID0gZHlncmFwaDtcblxuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgdGhpcy5lbGVtZW50Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0O1xuXG4gIHRoaXMuaGVpZ2h0ID0gZHlncmFwaC5oZWlnaHRfO1xuICB0aGlzLndpZHRoID0gZHlncmFwaC53aWR0aF87XG5cbiAgLy8gLS0tIGNoZWNrIHdoZXRoZXIgZXZlcnl0aGluZyBpcyBvayBiZWZvcmUgd2UgcmV0dXJuXG4gIGlmICghdXRpbHMuaXNDYW52YXNTdXBwb3J0ZWQodGhpcy5lbGVtZW50KSkge1xuICAgIHRocm93IFwiQ2FudmFzIGlzIG5vdCBzdXBwb3J0ZWQuXCI7XG4gIH1cblxuICAvLyBpbnRlcm5hbCBzdGF0ZVxuICB0aGlzLmFyZWEgPSBsYXlvdXQuZ2V0UGxvdEFyZWEoKTtcblxuICAvLyBTZXQgdXAgYSBjbGlwcGluZyBhcmVhIGZvciB0aGUgY2FudmFzIChhbmQgdGhlIGludGVyYWN0aW9uIGNhbnZhcykuXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHdlIGRvbid0IG92ZXJkcmF3LlxuICB2YXIgY3R4ID0gdGhpcy5keWdyYXBoXy5jYW52YXNfY3R4XztcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgucmVjdCh0aGlzLmFyZWEueCwgdGhpcy5hcmVhLnksIHRoaXMuYXJlYS53LCB0aGlzLmFyZWEuaCk7XG4gIGN0eC5jbGlwKCk7XG5cbiAgY3R4ID0gdGhpcy5keWdyYXBoXy5oaWRkZW5fY3R4XztcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgucmVjdCh0aGlzLmFyZWEueCwgdGhpcy5hcmVhLnksIHRoaXMuYXJlYS53LCB0aGlzLmFyZWEuaCk7XG4gIGN0eC5jbGlwKCk7XG59O1xuXG4vKipcbiAqIENsZWFycyBvdXQgYWxsIGNoYXJ0IGNvbnRlbnQgYW5kIERPTSBlbGVtZW50cy5cbiAqIFRoaXMgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGJlZm9yZSByZW5kZXIoKSBvbiBldmVyeSBmcmFtZSwgaW5jbHVkaW5nXG4gKiBkdXJpbmcgem9vbXMgYW5kIHBhbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZWxlbWVudENvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgcmVzcG9uc2libGUgZm9yIGRyYXdpbmcgZXZlcnl0aGluZyBvbiB0aGUgY2hhcnQsIGluY2x1ZGluZ1xuICogbGluZXMsIGVycm9yIGJhcnMsIGZpbGxzIGFuZCBheGVzLlxuICogSXQgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIGNsZWFyKCkgb24gZXZlcnkgZnJhbWUsIGluY2x1ZGluZyBkdXJpbmcgcGFuc1xuICogYW5kIHpvb21zLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgLy8gYXR0YWNoZXMgcG9pbnQuY2FudmFze3gseX1cbiAgdGhpcy5fdXBkYXRlUG9pbnRzKCk7XG5cbiAgLy8gYWN0dWFsbHkgZHJhd3MgdGhlIGNoYXJ0LlxuICB0aGlzLl9yZW5kZXJMaW5lQ2hhcnQoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHByZWRpY2F0ZSB0byBiZSB1c2VkIHdpdGggYW4gaXRlcmF0b3IsIHdoaWNoIHdpbGxcbiAqIGl0ZXJhdGUgb3ZlciBwb2ludHMgYXBwcm9wcmlhdGVseSwgZGVwZW5kaW5nIG9uIHdoZXRoZXJcbiAqIGNvbm5lY3RTZXBhcmF0ZWRQb2ludHMgaXMgdHJ1ZS4gV2hlbiBpdCdzIGZhbHNlLCB0aGUgcHJlZGljYXRlIHdpbGxcbiAqIHNraXAgb3ZlciBwb2ludHMgd2l0aCBtaXNzaW5nIHlWYWxzLlxuICovXG5EeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2dldEl0ZXJhdG9yUHJlZGljYXRlID0gZnVuY3Rpb24oY29ubmVjdFNlcGFyYXRlZFBvaW50cykge1xuICByZXR1cm4gY29ubmVjdFNlcGFyYXRlZFBvaW50cyA/XG4gICAgICBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX3ByZWRpY2F0ZVRoYXRTa2lwc0VtcHR5UG9pbnRzIDpcbiAgICAgIG51bGw7XG59O1xuXG5EeWdyYXBoQ2FudmFzUmVuZGVyZXIuX3ByZWRpY2F0ZVRoYXRTa2lwc0VtcHR5UG9pbnRzID1cbiAgICBmdW5jdGlvbihhcnJheSwgaWR4KSB7XG4gIHJldHVybiBhcnJheVtpZHhdLnl2YWwgIT09IG51bGw7XG59O1xuXG4vKipcbiAqIERyYXdzIGEgbGluZSB3aXRoIHRoZSBzdHlsZXMgcGFzc2VkIGluIGFuZCBjYWxscyBhbGwgdGhlIGRyYXdQb2ludENhbGxiYWNrcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBkaWN0aW9uYXJ5IHBhc3NlZCB0byB0aGUgcGxvdHRlciBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5fZHJhd1N0eWxlZExpbmUgPSBmdW5jdGlvbihlLFxuICAgIGNvbG9yLCBzdHJva2VXaWR0aCwgc3Ryb2tlUGF0dGVybiwgZHJhd1BvaW50cyxcbiAgICBkcmF3UG9pbnRDYWxsYmFjaywgcG9pbnRTaXplKSB7XG4gIHZhciBnID0gZS5keWdyYXBoO1xuICAvLyBUT0RPKGtvbmlnc2JlcmcpOiBDb21wdXRlIGF0dHJpYnV0ZXMgb3V0c2lkZSB0aGlzIG1ldGhvZCBjYWxsLlxuICB2YXIgc3RlcFBsb3QgPSBnLmdldEJvb2xlYW5PcHRpb24oXCJzdGVwUGxvdFwiLCBlLnNldE5hbWUpO1xuXG4gIGlmICghdXRpbHMuaXNBcnJheUxpa2Uoc3Ryb2tlUGF0dGVybikpIHtcbiAgICBzdHJva2VQYXR0ZXJuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkcmF3R2FwUG9pbnRzID0gZy5nZXRCb29sZWFuT3B0aW9uKCdkcmF3R2FwRWRnZVBvaW50cycsIGUuc2V0TmFtZSk7XG5cbiAgdmFyIHBvaW50cyA9IGUucG9pbnRzO1xuICB2YXIgc2V0TmFtZSA9IGUuc2V0TmFtZTtcbiAgdmFyIGl0ZXIgPSB1dGlscy5jcmVhdGVJdGVyYXRvcihwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsXG4gICAgICBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2dldEl0ZXJhdG9yUHJlZGljYXRlKFxuICAgICAgICAgIGcuZ2V0Qm9vbGVhbk9wdGlvbihcImNvbm5lY3RTZXBhcmF0ZWRQb2ludHNcIiwgc2V0TmFtZSkpKTtcblxuICB2YXIgc3Ryb2tpbmcgPSBzdHJva2VQYXR0ZXJuICYmIChzdHJva2VQYXR0ZXJuLmxlbmd0aCA+PSAyKTtcblxuICB2YXIgY3R4ID0gZS5kcmF3aW5nQ29udGV4dDtcbiAgY3R4LnNhdmUoKTtcbiAgaWYgKHN0cm9raW5nKSB7XG4gICAgaWYgKGN0eC5zZXRMaW5lRGFzaCkgY3R4LnNldExpbmVEYXNoKHN0cm9rZVBhdHRlcm4pO1xuICB9XG5cbiAgdmFyIHBvaW50c09uTGluZSA9IER5Z3JhcGhDYW52YXNSZW5kZXJlci5fZHJhd1NlcmllcyhcbiAgICAgIGUsIGl0ZXIsIHN0cm9rZVdpZHRoLCBwb2ludFNpemUsIGRyYXdQb2ludHMsIGRyYXdHYXBQb2ludHMsIHN0ZXBQbG90LCBjb2xvcik7XG4gIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fZHJhd1BvaW50c09uTGluZShcbiAgICAgIGUsIHBvaW50c09uTGluZSwgZHJhd1BvaW50Q2FsbGJhY2ssIGNvbG9yLCBwb2ludFNpemUpO1xuXG4gIGlmIChzdHJva2luZykge1xuICAgIGlmIChjdHguc2V0TGluZURhc2gpIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gIH1cblxuICBjdHgucmVzdG9yZSgpO1xufTtcblxuLyoqXG4gKiBUaGlzIGRvZXMgdGhlIGFjdHVhbCBkcmF3aW5nIG9mIGxpbmVzIG9uIHRoZSBjYW52YXMsIGZvciBqdXN0IG9uZSBzZXJpZXMuXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBbY2FudmFzeCwgY2FudmFzeV0gcGFpcnMgZm9yIHBvaW50cyBmb3Igd2hpY2ggYVxuICogZHJhd1BvaW50Q2FsbGJhY2sgc2hvdWxkIGJlIGZpcmVkLiAgVGhlc2UgaW5jbHVkZSBpc29sYXRlZCBwb2ludHMsIG9yIGFsbFxuICogcG9pbnRzIGlmIGRyYXdQb2ludHM9dHJ1ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBkaWN0aW9uYXJ5IHBhc3NlZCB0byB0aGUgcGxvdHRlciBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5fZHJhd1NlcmllcyA9IGZ1bmN0aW9uKGUsXG4gICAgaXRlciwgc3Ryb2tlV2lkdGgsIHBvaW50U2l6ZSwgZHJhd1BvaW50cywgZHJhd0dhcFBvaW50cywgc3RlcFBsb3QsIGNvbG9yKSB7XG5cbiAgdmFyIHByZXZDYW52YXNYID0gbnVsbDtcbiAgdmFyIHByZXZDYW52YXNZID0gbnVsbDtcbiAgdmFyIG5leHRDYW52YXNZID0gbnVsbDtcbiAgdmFyIGlzSXNvbGF0ZWQ7IC8vIHRydWUgaWYgdGhpcyBwb2ludCBpcyBpc29sYXRlZCAobm8gbGluZSBzZWdtZW50cylcbiAgdmFyIHBvaW50OyAvLyB0aGUgcG9pbnQgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSB3aGlsZSBsb29wXG4gIHZhciBwb2ludHNPbkxpbmUgPSBbXTsgLy8gQXJyYXkgb2YgW2NhbnZhc3gsIGNhbnZhc3ldIHBhaXJzLlxuICB2YXIgZmlyc3QgPSB0cnVlOyAvLyB0aGUgZmlyc3QgY3ljbGUgdGhyb3VnaCB0aGUgd2hpbGUgbG9vcFxuXG4gIHZhciBjdHggPSBlLmRyYXdpbmdDb250ZXh0O1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICBjdHgubGluZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG5cbiAgLy8gTk9URTogd2UgYnJlYWsgdGhlIGl0ZXJhdG9yJ3MgZW5jYXBzdWxhdGlvbiBoZXJlIGZvciBhYm91dCBhIDI1JSBzcGVlZHVwLlxuICB2YXIgYXJyID0gaXRlci5hcnJheV87XG4gIHZhciBsaW1pdCA9IGl0ZXIuZW5kXztcbiAgdmFyIHByZWRpY2F0ZSA9IGl0ZXIucHJlZGljYXRlXztcblxuICBmb3IgKHZhciBpID0gaXRlci5zdGFydF87IGkgPCBsaW1pdDsgaSsrKSB7XG4gICAgcG9pbnQgPSBhcnJbaV07XG4gICAgaWYgKHByZWRpY2F0ZSkge1xuICAgICAgd2hpbGUgKGkgPCBsaW1pdCAmJiAhcHJlZGljYXRlKGFyciwgaSkpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgaWYgKGkgPT0gbGltaXQpIGJyZWFrO1xuICAgICAgcG9pbnQgPSBhcnJbaV07XG4gICAgfVxuXG4gICAgLy8gRklYTUU6IFRoZSAnY2FudmFzeSAhPSBjYW52YXN5JyB0ZXN0IGhlcmUgY2F0Y2hlcyBOYU4gdmFsdWVzIGJ1dCB0aGUgdGVzdFxuICAgIC8vIGRvZXNuJ3QgY2F0Y2ggSW5maW5pdHkgdmFsdWVzLiBDb3VsZCBjaGFuZ2UgdGhpcyB0b1xuICAgIC8vICFpc0Zpbml0ZShwb2ludC5jYW52YXN5KSwgYnV0IEkgYXNzdW1lIGl0IGF2b2lkcyBpc05hTiBmb3IgcGVyZm9ybWFuY2U/XG4gICAgaWYgKHBvaW50LmNhbnZhc3kgPT09IG51bGwgfHwgcG9pbnQuY2FudmFzeSAhPSBwb2ludC5jYW52YXN5KSB7XG4gICAgICBpZiAoc3RlcFBsb3QgJiYgcHJldkNhbnZhc1ggIT09IG51bGwpIHtcbiAgICAgICAgLy8gRHJhdyBhIGhvcml6b250YWwgbGluZSB0byB0aGUgc3RhcnQgb2YgdGhlIG1pc3NpbmcgZGF0YVxuICAgICAgICBjdHgubW92ZVRvKHByZXZDYW52YXNYLCBwcmV2Q2FudmFzWSk7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQuY2FudmFzeCwgcHJldkNhbnZhc1kpO1xuICAgICAgfVxuICAgICAgcHJldkNhbnZhc1ggPSBwcmV2Q2FudmFzWSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzSXNvbGF0ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChkcmF3R2FwUG9pbnRzIHx8IHByZXZDYW52YXNYID09PSBudWxsKSB7XG4gICAgICAgIGl0ZXIubmV4dElkeF8gPSBpO1xuICAgICAgICBpdGVyLm5leHQoKTtcbiAgICAgICAgbmV4dENhbnZhc1kgPSBpdGVyLmhhc05leHQgPyBpdGVyLnBlZWsuY2FudmFzeSA6IG51bGw7XG5cbiAgICAgICAgdmFyIGlzTmV4dENhbnZhc1lOdWxsT3JOYU4gPSBuZXh0Q2FudmFzWSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgbmV4dENhbnZhc1kgIT0gbmV4dENhbnZhc1k7XG4gICAgICAgIGlzSXNvbGF0ZWQgPSAocHJldkNhbnZhc1ggPT09IG51bGwgJiYgaXNOZXh0Q2FudmFzWU51bGxPck5hTik7XG4gICAgICAgIGlmIChkcmF3R2FwUG9pbnRzKSB7XG4gICAgICAgICAgLy8gQWxzbyBjb25zaWRlciBhIHBvaW50IHRvIGJlIFwiaXNvbGF0ZWRcIiBpZiBpdCdzIGFkamFjZW50IHRvIGFcbiAgICAgICAgICAvLyBudWxsIHBvaW50LCBleGNsdWRpbmcgdGhlIGdyYXBoIGVkZ2VzLlxuICAgICAgICAgIGlmICgoIWZpcnN0ICYmIHByZXZDYW52YXNYID09PSBudWxsKSB8fFxuICAgICAgICAgICAgICAoaXRlci5oYXNOZXh0ICYmIGlzTmV4dENhbnZhc1lOdWxsT3JOYU4pKSB7XG4gICAgICAgICAgICBpc0lzb2xhdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZDYW52YXNYICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzdHJva2VXaWR0aCkge1xuICAgICAgICAgIGlmIChzdGVwUGxvdCkge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhwcmV2Q2FudmFzWCwgcHJldkNhbnZhc1kpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludC5jYW52YXN4LCBwcmV2Q2FudmFzWSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3R4LmxpbmVUbyhwb2ludC5jYW52YXN4LCBwb2ludC5jYW52YXN5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhwb2ludC5jYW52YXN4LCBwb2ludC5jYW52YXN5KTtcbiAgICAgIH1cbiAgICAgIGlmIChkcmF3UG9pbnRzIHx8IGlzSXNvbGF0ZWQpIHtcbiAgICAgICAgcG9pbnRzT25MaW5lLnB1c2goW3BvaW50LmNhbnZhc3gsIHBvaW50LmNhbnZhc3ksIHBvaW50LmlkeF0pO1xuICAgICAgfVxuICAgICAgcHJldkNhbnZhc1ggPSBwb2ludC5jYW52YXN4O1xuICAgICAgcHJldkNhbnZhc1kgPSBwb2ludC5jYW52YXN5O1xuICAgIH1cbiAgICBmaXJzdCA9IGZhbHNlO1xuICB9XG4gIGN0eC5zdHJva2UoKTtcbiAgcmV0dXJuIHBvaW50c09uTGluZTtcbn07XG5cbi8qKlxuICogVGhpcyBmaXJlcyB0aGUgZHJhd1BvaW50Q2FsbGJhY2sgZnVuY3Rpb25zLCB3aGljaCBkcmF3IGRvdHMgb24gdGhlIHBvaW50cyBieVxuICogZGVmYXVsdC4gVGhpcyBnZXRzIHVzZWQgd2hlbiB0aGUgXCJkcmF3UG9pbnRzXCIgb3B0aW9uIGlzIHNldCwgb3Igd2hlbiB0aGVyZVxuICogYXJlIGlzb2xhdGVkIHBvaW50cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBkaWN0aW9uYXJ5IHBhc3NlZCB0byB0aGUgcGxvdHRlciBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5fZHJhd1BvaW50c09uTGluZSA9IGZ1bmN0aW9uKFxuICAgIGUsIHBvaW50c09uTGluZSwgZHJhd1BvaW50Q2FsbGJhY2ssIGNvbG9yLCBwb2ludFNpemUpIHtcbiAgdmFyIGN0eCA9IGUuZHJhd2luZ0NvbnRleHQ7XG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHBvaW50c09uTGluZS5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdmFyIGNiID0gcG9pbnRzT25MaW5lW2lkeF07XG4gICAgY3R4LnNhdmUoKTtcbiAgICBkcmF3UG9pbnRDYWxsYmFjay5jYWxsKGUuZHlncmFwaCxcbiAgICAgICAgZS5keWdyYXBoLCBlLnNldE5hbWUsIGN0eCwgY2JbMF0sIGNiWzFdLCBjb2xvciwgcG9pbnRTaXplLCBjYlsyXSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBdHRhY2hlcyBjYW52YXMgY29vcmRpbmF0ZXMgdG8gdGhlIHBvaW50cyBhcnJheS5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZVBvaW50cyA9IGZ1bmN0aW9uKCkge1xuICAvLyBVcGRhdGUgUG9pbnRzXG4gIC8vIFRPRE8oZGFudmspOiBoZXJlXG4gIC8vXG4gIC8vIFRPRE8oYmhzKTogdGhpcyBsb29wIGlzIGEgaG90LXNwb3QgZm9yIGhpZ2gtcG9pbnQtY291bnQgY2hhcnRzLiBUaGVzZVxuICAvLyB0cmFuc2Zvcm1hdGlvbnMgY2FuIGJlIHB1c2hlZCBpbnRvIHRoZSBjYW52YXMgdmlhIGxpbmVhciB0cmFuc2Zvcm1hdGlvblxuICAvLyBtYXRyaWNlcy5cbiAgLy8gTk9URShkYW52ayk6IHRoaXMgaXMgdHJpY2tpZXIgdGhhbiBpdCBzb3VuZHMgYXQgZmlyc3QuIFRoZSB0cmFuc2Zvcm1hdGlvblxuICAvLyBuZWVkcyB0byBiZSBkb25lIGJlZm9yZSB0aGUgLm1vdmVUbygpIGFuZCAubGluZVRvKCkgY2FsbHMsIGJ1dCBtdXN0IGJlXG4gIC8vIHVuZG9uZSBiZWZvcmUgdGhlIC5zdHJva2UoKSBjYWxsIHRvIGVuc3VyZSB0aGF0IHRoZSBzdHJva2Ugd2lkdGggaXNcbiAgLy8gdW5hZmZlY3RlZC4gIEFuIGFsdGVybmF0aXZlIGlzIHRvIHJlZHVjZSB0aGUgc3Ryb2tlIHdpZHRoIGluIHRoZVxuICAvLyB0cmFuc2Zvcm1lZCBjb29yZGluYXRlIHNwYWNlLCBidXQgeW91IGNhbid0IHNwZWNpZnkgZGlmZmVyZW50IHZhbHVlcyBmb3JcbiAgLy8gZWFjaCBkaW1lbnNpb24gKGFzIHlvdSBjYW4gd2l0aCAuc2NhbGUoKSkuIFRoZSBzcGVlZHVwIGhlcmUgaXMgfjEyJS5cbiAgdmFyIHNldHMgPSB0aGlzLmxheW91dC5wb2ludHM7XG4gIGZvciAodmFyIGkgPSBzZXRzLmxlbmd0aDsgaS0tOykge1xuICAgIHZhciBwb2ludHMgPSBzZXRzW2ldO1xuICAgIGZvciAodmFyIGogPSBwb2ludHMubGVuZ3RoOyBqLS07KSB7XG4gICAgICB2YXIgcG9pbnQgPSBwb2ludHNbal07XG4gICAgICBwb2ludC5jYW52YXN4ID0gdGhpcy5hcmVhLncgKiBwb2ludC54ICsgdGhpcy5hcmVhLng7XG4gICAgICBwb2ludC5jYW52YXN5ID0gdGhpcy5hcmVhLmggKiBwb2ludC55ICsgdGhpcy5hcmVhLnk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEFkZCBjYW52YXMgQWN0dWFsbHkgZHJhdyB0aGUgbGluZXMgY2hhcnQsIGluY2x1ZGluZyBlcnJvciBiYXJzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIG9ubHkgYmUgY2FsbGVkIGlmIER5Z3JhcGhMYXlvdXQncyBwb2ludHMgYXJyYXkgaGFzIGJlZW5cbiAqIHVwZGF0ZWQgd2l0aCBjYW52YXN7eCx5fSBhdHRyaWJ1dGVzLCBpLmUuIGJ5XG4gKiBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX3VwZGF0ZVBvaW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zZXJpZXNOYW1lIHdoZW4gc3BlY2lmaWVkLCBvbmx5IHRoYXQgc2VyaWVzIHdpbGxcbiAqICAgICBiZSBkcmF3bi4gKFRoaXMgaXMgdXNlZCBmb3IgZXhwZWRpdGVkIHJlZHJhd2luZyB3aXRoIGhpZ2hsaWdodFNlcmllc09wdHMpXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gb3B0X2N0eCB3aGVuIHNwZWNpZmllZCwgdGhlIGRyYXdpbmdcbiAqICAgICBjb250ZXh0LiAgSG93ZXZlciwgbGluZXMgYXJlIHR5cGljYWxseSBkcmF3biBvbiB0aGUgb2JqZWN0J3NcbiAqICAgICBlbGVtZW50Q29udGV4dC5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuX3JlbmRlckxpbmVDaGFydCA9IGZ1bmN0aW9uKG9wdF9zZXJpZXNOYW1lLCBvcHRfY3R4KSB7XG4gIHZhciBjdHggPSBvcHRfY3R4IHx8IHRoaXMuZWxlbWVudENvbnRleHQ7XG4gIHZhciBpO1xuXG4gIHZhciBzZXRzID0gdGhpcy5sYXlvdXQucG9pbnRzO1xuICB2YXIgc2V0TmFtZXMgPSB0aGlzLmxheW91dC5zZXROYW1lcztcbiAgdmFyIHNldE5hbWU7XG5cbiAgdGhpcy5jb2xvcnMgPSB0aGlzLmR5Z3JhcGhfLmNvbG9yc01hcF87XG5cbiAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNlcmllcyBoYXZlIHNwZWNpYWxpemVkIHBsb3R0ZXJzLlxuICB2YXIgcGxvdHRlcl9hdHRyID0gdGhpcy5keWdyYXBoXy5nZXRPcHRpb24oXCJwbG90dGVyXCIpO1xuICB2YXIgcGxvdHRlcnMgPSBwbG90dGVyX2F0dHI7XG4gIGlmICghdXRpbHMuaXNBcnJheUxpa2UocGxvdHRlcnMpKSB7XG4gICAgcGxvdHRlcnMgPSBbcGxvdHRlcnNdO1xuICB9XG5cbiAgdmFyIHNldFBsb3R0ZXJzID0ge307ICAvLyBzZXJpZXMgbmFtZSAtPiBwbG90dGVyIGZuLlxuICBmb3IgKGkgPSAwOyBpIDwgc2V0TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBzZXROYW1lID0gc2V0TmFtZXNbaV07XG4gICAgdmFyIHNldFBsb3R0ZXIgPSB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbihcInBsb3R0ZXJcIiwgc2V0TmFtZSk7XG4gICAgaWYgKHNldFBsb3R0ZXIgPT0gcGxvdHRlcl9hdHRyKSBjb250aW51ZTsgIC8vIG5vdCBzcGVjaWFsaXplZC5cblxuICAgIHNldFBsb3R0ZXJzW3NldE5hbWVdID0gc2V0UGxvdHRlcjtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBwbG90dGVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwbG90dGVyID0gcGxvdHRlcnNbaV07XG4gICAgdmFyIGlzX2xhc3QgPSAoaSA9PSBwbG90dGVycy5sZW5ndGggLSAxKTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2V0cy5sZW5ndGg7IGorKykge1xuICAgICAgc2V0TmFtZSA9IHNldE5hbWVzW2pdO1xuICAgICAgaWYgKG9wdF9zZXJpZXNOYW1lICYmIHNldE5hbWUgIT0gb3B0X3Nlcmllc05hbWUpIGNvbnRpbnVlO1xuXG4gICAgICB2YXIgcG9pbnRzID0gc2V0c1tqXTtcblxuICAgICAgLy8gT25seSB0aHJvdyBpbiB0aGUgc3BlY2lhbGl6ZWQgcGxvdHRlcnMgb24gdGhlIGxhc3QgaXRlcmF0aW9uLlxuICAgICAgdmFyIHAgPSBwbG90dGVyO1xuICAgICAgaWYgKHNldE5hbWUgaW4gc2V0UGxvdHRlcnMpIHtcbiAgICAgICAgaWYgKGlzX2xhc3QpIHtcbiAgICAgICAgICBwID0gc2V0UGxvdHRlcnNbc2V0TmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRG9uJ3QgdXNlIHRoZSBzdGFuZGFyZCBwbG90dGVycyBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNvbG9yID0gdGhpcy5jb2xvcnNbc2V0TmFtZV07XG4gICAgICB2YXIgc3Ryb2tlV2lkdGggPSB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbihcInN0cm9rZVdpZHRoXCIsIHNldE5hbWUpO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICBjdHgubGluZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgICBwKHtcbiAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgIHNldE5hbWU6IHNldE5hbWUsXG4gICAgICAgIGRyYXdpbmdDb250ZXh0OiBjdHgsXG4gICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICBkeWdyYXBoOiB0aGlzLmR5Z3JhcGhfLFxuICAgICAgICBheGlzOiB0aGlzLmR5Z3JhcGhfLmF4aXNQcm9wZXJ0aWVzRm9yU2VyaWVzKHNldE5hbWUpLFxuICAgICAgICBwbG90QXJlYTogdGhpcy5hcmVhLFxuICAgICAgICBzZXJpZXNJbmRleDogaixcbiAgICAgICAgc2VyaWVzQ291bnQ6IHNldHMubGVuZ3RoLFxuICAgICAgICBzaW5nbGVTZXJpZXNOYW1lOiBvcHRfc2VyaWVzTmFtZSxcbiAgICAgICAgYWxsU2VyaWVzUG9pbnRzOiBzZXRzXG4gICAgICB9KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFN0YW5kYXJkIHBsb3R0ZXJzLiBUaGVzZSBtYXkgYmUgdXNlZCBieSBjbGllbnRzIHZpYSBEeWdyYXBoLlBsb3R0ZXJzLlxuICogU2VlIGNvbW1lbnRzIHRoZXJlIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5fUGxvdHRlcnMgPSB7XG4gIGxpbmVQbG90dGVyOiBmdW5jdGlvbihlKSB7XG4gICAgRHlncmFwaENhbnZhc1JlbmRlcmVyLl9saW5lUGxvdHRlcihlKTtcbiAgfSxcblxuICBmaWxsUGxvdHRlcjogZnVuY3Rpb24oZSkge1xuICAgIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fZmlsbFBsb3R0ZXIoZSk7XG4gIH0sXG5cbiAgZXJyb3JQbG90dGVyOiBmdW5jdGlvbihlKSB7XG4gICAgRHlncmFwaENhbnZhc1JlbmRlcmVyLl9lcnJvclBsb3R0ZXIoZSk7XG4gIH1cbn07XG5cbi8qKlxuICogUGxvdHRlciB3aGljaCBkcmF3cyB0aGUgY2VudHJhbCBsaW5lcyBmb3IgYSBzZXJpZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2xpbmVQbG90dGVyID0gZnVuY3Rpb24oZSkge1xuICB2YXIgZyA9IGUuZHlncmFwaDtcbiAgdmFyIHNldE5hbWUgPSBlLnNldE5hbWU7XG4gIHZhciBzdHJva2VXaWR0aCA9IGUuc3Ryb2tlV2lkdGg7XG5cbiAgLy8gVE9ETyhkYW52ayk6IENoZWNrIGlmIHRoZXJlJ3MgYW55IHBlcmZvcm1hbmNlIGltcGFjdCBvZiBqdXN0IGNhbGxpbmdcbiAgLy8gZ2V0T3B0aW9uKCkgaW5zaWRlIG9mIF9kcmF3U3R5bGVkTGluZS4gUGFzc2luZyBpbiBzbyBtYW55IHBhcmFtZXRlcnMgbWFrZXNcbiAgLy8gdGhpcyBjb2RlIGEgYml0IG5hc3R5LlxuICB2YXIgYm9yZGVyV2lkdGggPSBnLmdldE51bWVyaWNPcHRpb24oXCJzdHJva2VCb3JkZXJXaWR0aFwiLCBzZXROYW1lKTtcbiAgdmFyIGRyYXdQb2ludENhbGxiYWNrID0gZy5nZXRPcHRpb24oXCJkcmF3UG9pbnRDYWxsYmFja1wiLCBzZXROYW1lKSB8fFxuICAgICAgdXRpbHMuQ2lyY2xlcy5ERUZBVUxUO1xuICB2YXIgc3Ryb2tlUGF0dGVybiA9IGcuZ2V0T3B0aW9uKFwic3Ryb2tlUGF0dGVyblwiLCBzZXROYW1lKTtcbiAgdmFyIGRyYXdQb2ludHMgPSBnLmdldEJvb2xlYW5PcHRpb24oXCJkcmF3UG9pbnRzXCIsIHNldE5hbWUpO1xuICB2YXIgcG9pbnRTaXplID0gZy5nZXROdW1lcmljT3B0aW9uKFwicG9pbnRTaXplXCIsIHNldE5hbWUpO1xuXG4gIGlmIChib3JkZXJXaWR0aCAmJiBzdHJva2VXaWR0aCkge1xuICAgIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fZHJhd1N0eWxlZExpbmUoZSxcbiAgICAgICAgZy5nZXRPcHRpb24oXCJzdHJva2VCb3JkZXJDb2xvclwiLCBzZXROYW1lKSxcbiAgICAgICAgc3Ryb2tlV2lkdGggKyAyICogYm9yZGVyV2lkdGgsXG4gICAgICAgIHN0cm9rZVBhdHRlcm4sXG4gICAgICAgIGRyYXdQb2ludHMsXG4gICAgICAgIGRyYXdQb2ludENhbGxiYWNrLFxuICAgICAgICBwb2ludFNpemVcbiAgICAgICAgKTtcbiAgfVxuXG4gIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fZHJhd1N0eWxlZExpbmUoZSxcbiAgICAgIGUuY29sb3IsXG4gICAgICBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZVBhdHRlcm4sXG4gICAgICBkcmF3UG9pbnRzLFxuICAgICAgZHJhd1BvaW50Q2FsbGJhY2ssXG4gICAgICBwb2ludFNpemVcbiAgKTtcbn07XG5cbi8qKlxuICogRHJhd3MgdGhlIHNoYWRlZCBlcnJvciBiYXJzL2NvbmZpZGVuY2UgaW50ZXJ2YWxzIGZvciBlYWNoIHNlcmllcy5cbiAqIFRoaXMgaGFwcGVucyBiZWZvcmUgdGhlIGNlbnRlciBsaW5lcyBhcmUgZHJhd24sIHNpbmNlIHRoZSBjZW50ZXIgbGluZXNcbiAqIG5lZWQgdG8gYmUgZHJhd24gb24gdG9wIG9mIHRoZSBlcnJvciBiYXJzIGZvciBhbGwgc2VyaWVzLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLl9lcnJvclBsb3R0ZXIgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBnID0gZS5keWdyYXBoO1xuICB2YXIgc2V0TmFtZSA9IGUuc2V0TmFtZTtcbiAgdmFyIGVycm9yQmFycyA9IGcuZ2V0Qm9vbGVhbk9wdGlvbihcImVycm9yQmFyc1wiKSB8fFxuICAgICAgZy5nZXRCb29sZWFuT3B0aW9uKFwiY3VzdG9tQmFyc1wiKTtcbiAgaWYgKCFlcnJvckJhcnMpIHJldHVybjtcblxuICB2YXIgZmlsbEdyYXBoID0gZy5nZXRCb29sZWFuT3B0aW9uKFwiZmlsbEdyYXBoXCIsIHNldE5hbWUpO1xuICBpZiAoZmlsbEdyYXBoKSB7XG4gICAgY29uc29sZS53YXJuKFwiQ2FuJ3QgdXNlIGZpbGxHcmFwaCBvcHRpb24gd2l0aCBlcnJvciBiYXJzXCIpO1xuICB9XG5cbiAgdmFyIGN0eCA9IGUuZHJhd2luZ0NvbnRleHQ7XG4gIHZhciBjb2xvciA9IGUuY29sb3I7XG4gIHZhciBmaWxsQWxwaGEgPSBnLmdldE51bWVyaWNPcHRpb24oJ2ZpbGxBbHBoYScsIHNldE5hbWUpO1xuICB2YXIgc3RlcFBsb3QgPSBnLmdldEJvb2xlYW5PcHRpb24oXCJzdGVwUGxvdFwiLCBzZXROYW1lKTtcbiAgdmFyIHBvaW50cyA9IGUucG9pbnRzO1xuXG4gIHZhciBpdGVyID0gdXRpbHMuY3JlYXRlSXRlcmF0b3IocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLFxuICAgICAgRHlncmFwaENhbnZhc1JlbmRlcmVyLl9nZXRJdGVyYXRvclByZWRpY2F0ZShcbiAgICAgICAgICBnLmdldEJvb2xlYW5PcHRpb24oXCJjb25uZWN0U2VwYXJhdGVkUG9pbnRzXCIsIHNldE5hbWUpKSk7XG5cbiAgdmFyIG5ld1lzO1xuXG4gIC8vIHNldHVwIGdyYXBoaWNzIGNvbnRleHRcbiAgdmFyIHByZXZYID0gTmFOO1xuICB2YXIgcHJldlkgPSBOYU47XG4gIHZhciBwcmV2WXMgPSBbLTEsIC0xXTtcbiAgLy8gc2hvdWxkIGJlIHNhbWUgY29sb3IgYXMgdGhlIGxpbmVzIGJ1dCBvbmx5IDE1JSBvcGFxdWUuXG4gIHZhciByZ2IgPSB1dGlscy50b1JHQl8oY29sb3IpO1xuICB2YXIgZXJyX2NvbG9yID1cbiAgICAgICdyZ2JhKCcgKyByZ2IuciArICcsJyArIHJnYi5nICsgJywnICsgcmdiLmIgKyAnLCcgKyBmaWxsQWxwaGEgKyAnKSc7XG4gIGN0eC5maWxsU3R5bGUgPSBlcnJfY29sb3I7XG4gIGN0eC5iZWdpblBhdGgoKTtcblxuICB2YXIgaXNOdWxsVW5kZWZpbmVkT3JOYU4gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuICh4ID09PSBudWxsIHx8XG4gICAgICAgICAgICB4ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGlzTmFOKHgpKTtcbiAgfTtcblxuICB3aGlsZSAoaXRlci5oYXNOZXh0KSB7XG4gICAgdmFyIHBvaW50ID0gaXRlci5uZXh0KCk7XG4gICAgaWYgKCghc3RlcFBsb3QgJiYgaXNOdWxsVW5kZWZpbmVkT3JOYU4ocG9pbnQueSkpIHx8XG4gICAgICAgIChzdGVwUGxvdCAmJiAhaXNOYU4ocHJldlkpICYmIGlzTnVsbFVuZGVmaW5lZE9yTmFOKHByZXZZKSkpIHtcbiAgICAgIHByZXZYID0gTmFOO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbmV3WXMgPSBbIHBvaW50LnlfYm90dG9tLCBwb2ludC55X3RvcCBdO1xuICAgIGlmIChzdGVwUGxvdCkge1xuICAgICAgcHJldlkgPSBwb2ludC55O1xuICAgIH1cblxuICAgIC8vIFRoZSBkb2N1bWVudGF0aW9uIHNwZWNpZmljYWxseSBkaXNhbGxvd3MgbnVsbHMgaW5zaWRlIHRoZSBwb2ludCBhcnJheXMsXG4gICAgLy8gYnV0IGluIGNhc2UgaXQgaGFwcGVucyB3ZSBzaG91bGQgZG8gc29tZXRoaW5nIHNlbnNpYmxlLlxuICAgIGlmIChpc05hTihuZXdZc1swXSkpIG5ld1lzWzBdID0gcG9pbnQueTtcbiAgICBpZiAoaXNOYU4obmV3WXNbMV0pKSBuZXdZc1sxXSA9IHBvaW50Lnk7XG5cbiAgICBuZXdZc1swXSA9IGUucGxvdEFyZWEuaCAqIG5ld1lzWzBdICsgZS5wbG90QXJlYS55O1xuICAgIG5ld1lzWzFdID0gZS5wbG90QXJlYS5oICogbmV3WXNbMV0gKyBlLnBsb3RBcmVhLnk7XG4gICAgaWYgKCFpc05hTihwcmV2WCkpIHtcbiAgICAgIGlmIChzdGVwUGxvdCkge1xuICAgICAgICBjdHgubW92ZVRvKHByZXZYLCBwcmV2WXNbMF0pO1xuICAgICAgICBjdHgubGluZVRvKHBvaW50LmNhbnZhc3gsIHByZXZZc1swXSk7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQuY2FudmFzeCwgcHJldllzWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5tb3ZlVG8ocHJldlgsIHByZXZZc1swXSk7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQuY2FudmFzeCwgbmV3WXNbMF0pO1xuICAgICAgICBjdHgubGluZVRvKHBvaW50LmNhbnZhc3gsIG5ld1lzWzFdKTtcbiAgICAgIH1cbiAgICAgIGN0eC5saW5lVG8ocHJldlgsIHByZXZZc1sxXSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIHByZXZZcyA9IG5ld1lzO1xuICAgIHByZXZYID0gcG9pbnQuY2FudmFzeDtcbiAgfVxuICBjdHguZmlsbCgpO1xufTtcblxuXG4vKipcbiAqIFByb3h5IGZvciBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgd2hpY2ggZHJvcHMgbW92ZVRvL2xpbmVUbyBjYWxscyB3aGljaCBhcmVcbiAqIHN1cGVyZmx1b3VzLiBJdCBhY2N1bXVsYXRlcyBhbGwgbW92ZW1lbnRzIHdoaWNoIGhhdmVuJ3QgY2hhbmdlZCB0aGUgeC12YWx1ZVxuICogYW5kIG9ubHkgYXBwbGllcyB0aGUgdHdvIHdpdGggdGhlIG1vc3QgZXh0cmVtZSB5LXZhbHVlcy5cbiAqXG4gKiBDYWxscyB0byBsaW5lVG8vbW92ZVRvIG11c3QgaGF2ZSBub24tZGVjcmVhc2luZyB4LXZhbHVlcy5cbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLl9mYXN0Q2FudmFzUHJveHkgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBwZW5kaW5nQWN0aW9ucyA9IFtdOyAgLy8gYXJyYXkgb2YgW3R5cGUsIHgsIHldIHR1cGxlc1xuICB2YXIgbGFzdFJvdW5kZWRYID0gbnVsbDtcbiAgdmFyIGxhc3RGbHVzaGVkWCA9IG51bGw7XG5cbiAgdmFyIExJTkVfVE8gPSAxLFxuICAgICAgTU9WRV9UTyA9IDI7XG5cbiAgdmFyIGFjdGlvbkNvdW50ID0gMDsgIC8vIG51bWJlciBvZiBtb3ZlVG9zIGFuZCBsaW5lVG9zIHBhc3NlZCB0byBjb250ZXh0LlxuXG4gIC8vIERyb3Agc3VwZXJmbHVvdXMgbW90aW9uc1xuICAvLyBBc3N1bWVzIGFsbCBwZW5kaW5nQWN0aW9ucyBoYXZlIHRoZSBzYW1lIChyb3VuZGVkKSB4LXZhbHVlLlxuICB2YXIgY29tcHJlc3NBY3Rpb25zID0gZnVuY3Rpb24ob3B0X2xvc3NsZXNzT25seSkge1xuICAgIGlmIChwZW5kaW5nQWN0aW9ucy5sZW5ndGggPD0gMSkgcmV0dXJuO1xuXG4gICAgLy8gTG9zc2xlc3MgY29tcHJlc3Npb246IGRyb3AgaW5jb25zZXF1ZW50aWFsIG1vdmVUb3MuXG4gICAgZm9yICh2YXIgaSA9IHBlbmRpbmdBY3Rpb25zLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgIHZhciBhY3Rpb24gPSBwZW5kaW5nQWN0aW9uc1tpXTtcbiAgICAgIGlmIChhY3Rpb25bMF0gPT0gTU9WRV9UTykge1xuICAgICAgICB2YXIgcHJldkFjdGlvbiA9IHBlbmRpbmdBY3Rpb25zW2kgLSAxXTtcbiAgICAgICAgaWYgKHByZXZBY3Rpb25bMV0gPT0gYWN0aW9uWzFdICYmIHByZXZBY3Rpb25bMl0gPT0gYWN0aW9uWzJdKSB7XG4gICAgICAgICAgcGVuZGluZ0FjdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTG9zc2xlc3MgY29tcHJlc3Npb246IC4uLiBkcm9wIGNvbnNlY3V0aXZlIG1vdmVUb3MgLi4uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwZW5kaW5nQWN0aW9ucy5sZW5ndGggLSAxOyAvKiBpbmNyZW1lbnRlZCBpbnRlcm5hbGx5ICovKSB7XG4gICAgICB2YXIgYWN0aW9uID0gcGVuZGluZ0FjdGlvbnNbaV07XG4gICAgICBpZiAoYWN0aW9uWzBdID09IE1PVkVfVE8gJiYgcGVuZGluZ0FjdGlvbnNbaSArIDFdWzBdID09IE1PVkVfVE8pIHtcbiAgICAgICAgcGVuZGluZ0FjdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIExvc3N5IGNvbXByZXNzaW9uOiAuLi4gZHJvcCBhbGwgYnV0IHRoZSBleHRyZW1lIHktdmFsdWVzIC4uLlxuICAgIGlmIChwZW5kaW5nQWN0aW9ucy5sZW5ndGggPiAyICYmICFvcHRfbG9zc2xlc3NPbmx5KSB7XG4gICAgICAvLyBrZWVwIGFuIGluaXRpYWwgbW92ZVRvLCBidXQgZHJvcCBhbGwgb3RoZXJzLlxuICAgICAgdmFyIHN0YXJ0SWR4ID0gMDtcbiAgICAgIGlmIChwZW5kaW5nQWN0aW9uc1swXVswXSA9PSBNT1ZFX1RPKSBzdGFydElkeCsrO1xuICAgICAgdmFyIG1pbklkeCA9IG51bGwsIG1heElkeCA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRJZHg7IGkgPCBwZW5kaW5nQWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYWN0aW9uID0gcGVuZGluZ0FjdGlvbnNbaV07XG4gICAgICAgIGlmIChhY3Rpb25bMF0gIT0gTElORV9UTykgY29udGludWU7XG4gICAgICAgIGlmIChtaW5JZHggPT09IG51bGwgJiYgbWF4SWR4ID09PSBudWxsKSB7XG4gICAgICAgICAgbWluSWR4ID0gaTtcbiAgICAgICAgICBtYXhJZHggPSBpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB5ID0gYWN0aW9uWzJdO1xuICAgICAgICAgIGlmICh5IDwgcGVuZGluZ0FjdGlvbnNbbWluSWR4XVsyXSkge1xuICAgICAgICAgICAgbWluSWR4ID0gaTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHkgPiBwZW5kaW5nQWN0aW9uc1ttYXhJZHhdWzJdKSB7XG4gICAgICAgICAgICBtYXhJZHggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG1pbkFjdGlvbiA9IHBlbmRpbmdBY3Rpb25zW21pbklkeF0sXG4gICAgICAgICAgbWF4QWN0aW9uID0gcGVuZGluZ0FjdGlvbnNbbWF4SWR4XTtcbiAgICAgIHBlbmRpbmdBY3Rpb25zLnNwbGljZShzdGFydElkeCwgcGVuZGluZ0FjdGlvbnMubGVuZ3RoIC0gc3RhcnRJZHgpO1xuICAgICAgaWYgKG1pbklkeCA8IG1heElkeCkge1xuICAgICAgICBwZW5kaW5nQWN0aW9ucy5wdXNoKG1pbkFjdGlvbik7XG4gICAgICAgIHBlbmRpbmdBY3Rpb25zLnB1c2gobWF4QWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAobWluSWR4ID4gbWF4SWR4KSB7XG4gICAgICAgIHBlbmRpbmdBY3Rpb25zLnB1c2gobWF4QWN0aW9uKTtcbiAgICAgICAgcGVuZGluZ0FjdGlvbnMucHVzaChtaW5BY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVuZGluZ0FjdGlvbnMucHVzaChtaW5BY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgZmx1c2hBY3Rpb25zID0gZnVuY3Rpb24ob3B0X25vTG9zc3lDb21wcmVzc2lvbikge1xuICAgIGNvbXByZXNzQWN0aW9ucyhvcHRfbm9Mb3NzeUNvbXByZXNzaW9uKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGVuZGluZ0FjdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBhY3Rpb24gPSBwZW5kaW5nQWN0aW9uc1tpXTtcbiAgICAgIGlmIChhY3Rpb25bMF0gPT0gTElORV9UTykge1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhhY3Rpb25bMV0sIGFjdGlvblsyXSk7XG4gICAgICB9IGVsc2UgaWYgKGFjdGlvblswXSA9PSBNT1ZFX1RPKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKGFjdGlvblsxXSwgYWN0aW9uWzJdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBlbmRpbmdBY3Rpb25zLmxlbmd0aCkge1xuICAgICAgbGFzdEZsdXNoZWRYID0gcGVuZGluZ0FjdGlvbnNbcGVuZGluZ0FjdGlvbnMubGVuZ3RoIC0gMV1bMV07XG4gICAgfVxuICAgIGFjdGlvbkNvdW50ICs9IHBlbmRpbmdBY3Rpb25zLmxlbmd0aDtcbiAgICBwZW5kaW5nQWN0aW9ucyA9IFtdO1xuICB9O1xuXG4gIHZhciBhZGRBY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHgsIHkpIHtcbiAgICB2YXIgcnggPSBNYXRoLnJvdW5kKHgpO1xuICAgIGlmIChsYXN0Um91bmRlZFggPT09IG51bGwgfHwgcnggIT0gbGFzdFJvdW5kZWRYKSB7XG4gICAgICAvLyBpZiB0aGVyZSBhcmUgbGFyZ2UgZ2FwcyBvbiB0aGUgeC1heGlzLCBpdCdzIGVzc2VudGlhbCB0byBrZWVwIHRoZVxuICAgICAgLy8gZmlyc3QgYW5kIGxhc3QgcG9pbnQgYXMgd2VsbC5cbiAgICAgIHZhciBoYXNHYXBPbkxlZnQgPSAobGFzdFJvdW5kZWRYIC0gbGFzdEZsdXNoZWRYID4gMSksXG4gICAgICAgICAgaGFzR2FwT25SaWdodCA9IChyeCAtIGxhc3RSb3VuZGVkWCA+IDEpLFxuICAgICAgICAgIGhhc0dhcCA9IGhhc0dhcE9uTGVmdCB8fCBoYXNHYXBPblJpZ2h0O1xuICAgICAgZmx1c2hBY3Rpb25zKGhhc0dhcCk7XG4gICAgICBsYXN0Um91bmRlZFggPSByeDtcbiAgICB9XG4gICAgcGVuZGluZ0FjdGlvbnMucHVzaChbYWN0aW9uLCB4LCB5XSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBtb3ZlVG86IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGFkZEFjdGlvbihNT1ZFX1RPLCB4LCB5KTtcbiAgICB9LFxuICAgIGxpbmVUbzogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgYWRkQWN0aW9uKExJTkVfVE8sIHgsIHkpO1xuICAgIH0sXG5cbiAgICAvLyBmb3IgbWFqb3Igb3BlcmF0aW9ucyBsaWtlIHN0cm9rZS9maWxsLCB3ZSBza2lwIGNvbXByZXNzaW9uIHRvIGVuc3VyZVxuICAgIC8vIHRoYXQgdGhlcmUgYXJlIG5vIGFydGlmYWN0cyBhdCB0aGUgcmlnaHQgZWRnZS5cbiAgICBzdHJva2U6ICAgIGZ1bmN0aW9uKCkgeyBmbHVzaEFjdGlvbnModHJ1ZSk7IGNvbnRleHQuc3Ryb2tlKCk7IH0sXG4gICAgZmlsbDogICAgICBmdW5jdGlvbigpIHsgZmx1c2hBY3Rpb25zKHRydWUpOyBjb250ZXh0LmZpbGwoKTsgfSxcbiAgICBiZWdpblBhdGg6IGZ1bmN0aW9uKCkgeyBmbHVzaEFjdGlvbnModHJ1ZSk7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH0sXG4gICAgY2xvc2VQYXRoOiBmdW5jdGlvbigpIHsgZmx1c2hBY3Rpb25zKHRydWUpOyBjb250ZXh0LmNsb3NlUGF0aCgpOyB9LFxuXG4gICAgX2NvdW50OiBmdW5jdGlvbigpIHsgcmV0dXJuIGFjdGlvbkNvdW50OyB9XG4gIH07XG59O1xuXG4vKipcbiAqIERyYXdzIHRoZSBzaGFkZWQgcmVnaW9ucyB3aGVuIFwiZmlsbEdyYXBoXCIgaXMgc2V0LiBOb3QgdG8gYmUgY29uZnVzZWQgd2l0aFxuICogZXJyb3IgYmFycy5cbiAqXG4gKiBGb3Igc3RhY2tlZCBjaGFydHMsIGl0J3MgbW9yZSBjb252ZW5pZW50IHRvIGhhbmRsZSBhbGwgdGhlIHNlcmllc1xuICogc2ltdWx0YW5lb3VzbHkuIFNvIHRoaXMgcGxvdHRlciBwbG90cyBhbGwgdGhlIHBvaW50cyBvbiB0aGUgZmlyc3Qgc2VyaWVzXG4gKiBpdCdzIGFza2VkIHRvIGRyYXcsIHRoZW4gaWdub3JlcyBhbGwgdGhlIG90aGVyIHNlcmllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2ZpbGxQbG90dGVyID0gZnVuY3Rpb24oZSkge1xuICAvLyBTa2lwIGlmIHdlJ3JlIGRyYXdpbmcgYSBzaW5nbGUgc2VyaWVzIGZvciBpbnRlcmFjdGl2ZSBoaWdobGlnaHQgb3ZlcmxheS5cbiAgaWYgKGUuc2luZ2xlU2VyaWVzTmFtZSkgcmV0dXJuO1xuXG4gIC8vIFdlJ2xsIGhhbmRsZSBhbGwgdGhlIHNlcmllcyBhdCBvbmNlLCBub3Qgb25lLWJ5LW9uZS5cbiAgaWYgKGUuc2VyaWVzSW5kZXggIT09IDApIHJldHVybjtcblxuICB2YXIgZyA9IGUuZHlncmFwaDtcbiAgdmFyIHNldE5hbWVzID0gZy5nZXRMYWJlbHMoKS5zbGljZSgxKTsgIC8vIHJlbW92ZSB4LWF4aXNcblxuICAvLyBnZXRMYWJlbHMoKSBpbmNsdWRlcyBuYW1lcyBmb3IgaW52aXNpYmxlIHNlcmllcywgd2hpY2ggYXJlIG5vdCBpbmNsdWRlZCBpblxuICAvLyBhbGxTZXJpZXNQb2ludHMuIFdlIHJlbW92ZSB0aG9zZSB0byBtYWtlIHRoZSB0d28gbWF0Y2guXG4gIC8vIFRPRE8oZGFudmspOiBwcm92aWRlIGEgc2ltcGxlciB3YXkgdG8gZ2V0IHRoaXMgaW5mb3JtYXRpb24uXG4gIGZvciAodmFyIGkgPSBzZXROYW1lcy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKCFnLnZpc2liaWxpdHkoKVtpXSkgc2V0TmFtZXMuc3BsaWNlKGksIDEpO1xuICB9XG5cbiAgdmFyIGFueVNlcmllc0ZpbGxlZCA9IChmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZy5nZXRCb29sZWFuT3B0aW9uKFwiZmlsbEdyYXBoXCIsIHNldE5hbWVzW2ldKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSkoKTtcblxuICBpZiAoIWFueVNlcmllc0ZpbGxlZCkgcmV0dXJuO1xuXG4gIHZhciBhcmVhID0gZS5wbG90QXJlYTtcbiAgdmFyIHNldHMgPSBlLmFsbFNlcmllc1BvaW50cztcbiAgdmFyIHNldENvdW50ID0gc2V0cy5sZW5ndGg7XG5cbiAgdmFyIHN0YWNrZWRHcmFwaCA9IGcuZ2V0Qm9vbGVhbk9wdGlvbihcInN0YWNrZWRHcmFwaFwiKTtcbiAgdmFyIGNvbG9ycyA9IGcuZ2V0Q29sb3JzKCk7XG5cbiAgLy8gRm9yIHN0YWNrZWQgZ3JhcGhzLCB0cmFjayB0aGUgYmFzZWxpbmUgZm9yIGZpbGxpbmcuXG4gIC8vXG4gIC8vIFRoZSBmaWxsZWQgYXJlYXMgYmVsb3cgZ3JhcGggbGluZXMgYXJlIHRyYXBlem9pZHMgd2l0aCB0d29cbiAgLy8gdmVydGljYWwgZWRnZXMuIFRoZSB0b3AgZWRnZSBpcyB0aGUgbGluZSBzZWdtZW50IGJlaW5nIGRyYXduLCBhbmRcbiAgLy8gdGhlIGJhc2VsaW5lIGlzIHRoZSBib3R0b20gZWRnZS4gRWFjaCBiYXNlbGluZSBjb3JyZXNwb25kcyB0byB0aGVcbiAgLy8gdG9wIGxpbmUgc2VnbWVudCBmcm9tIHRoZSBwcmV2aW91cyBzdGFja2VkIGxpbmUuIEluIHRoZSBjYXNlIG9mXG4gIC8vIHN0ZXAgcGxvdHMsIHRoZSB0cmFwZXpvaWRzIGFyZSByZWN0YW5nbGVzLlxuICB2YXIgYmFzZWxpbmUgPSB7fTtcbiAgdmFyIGN1cnJCYXNlbGluZTtcbiAgdmFyIHByZXZTdGVwUGxvdDsgIC8vIGZvciBkaWZmZXJlbnQgbGluZSBkcmF3aW5nIG1vZGVzIChsaW5lL3N0ZXApIHBlciBzZXJpZXNcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gdHJhY2UgYSBsaW5lIGJhY2sgYWxvbmcgdGhlIGJhc2VsaW5lLlxuICB2YXIgdHJhY2VCYWNrUGF0aCA9IGZ1bmN0aW9uKGN0eCwgYmFzZWxpbmVYLCBiYXNlbGluZVksIHBhdGhCYWNrKSB7XG4gICAgY3R4LmxpbmVUbyhiYXNlbGluZVgsIGJhc2VsaW5lWSk7XG4gICAgaWYgKHN0YWNrZWRHcmFwaCkge1xuICAgICAgZm9yICh2YXIgaSA9IHBhdGhCYWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBwdCA9IHBhdGhCYWNrW2ldO1xuICAgICAgICBjdHgubGluZVRvKHB0WzBdLCBwdFsxXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIHByb2Nlc3Mgc2V0cyBpbiByZXZlcnNlIG9yZGVyIChuZWVkZWQgZm9yIHN0YWNrZWQgZ3JhcGhzKVxuICBmb3IgKHZhciBzZXRJZHggPSBzZXRDb3VudCAtIDE7IHNldElkeCA+PSAwOyBzZXRJZHgtLSkge1xuICAgIHZhciBjdHggPSBlLmRyYXdpbmdDb250ZXh0O1xuICAgIHZhciBzZXROYW1lID0gc2V0TmFtZXNbc2V0SWR4XTtcbiAgICBpZiAoIWcuZ2V0Qm9vbGVhbk9wdGlvbignZmlsbEdyYXBoJywgc2V0TmFtZSkpIGNvbnRpbnVlO1xuXG4gICAgdmFyIGZpbGxBbHBoYSA9IGcuZ2V0TnVtZXJpY09wdGlvbignZmlsbEFscGhhJywgc2V0TmFtZSk7XG4gICAgdmFyIHN0ZXBQbG90ID0gZy5nZXRCb29sZWFuT3B0aW9uKCdzdGVwUGxvdCcsIHNldE5hbWUpO1xuICAgIHZhciBjb2xvciA9IGNvbG9yc1tzZXRJZHhdO1xuICAgIHZhciBheGlzID0gZy5heGlzUHJvcGVydGllc0ZvclNlcmllcyhzZXROYW1lKTtcbiAgICB2YXIgYXhpc1kgPSAxLjAgKyBheGlzLm1pbnl2YWwgKiBheGlzLnlzY2FsZTtcbiAgICBpZiAoYXhpc1kgPCAwLjApIGF4aXNZID0gMC4wO1xuICAgIGVsc2UgaWYgKGF4aXNZID4gMS4wKSBheGlzWSA9IDEuMDtcbiAgICBheGlzWSA9IGFyZWEuaCAqIGF4aXNZICsgYXJlYS55O1xuXG4gICAgdmFyIHBvaW50cyA9IHNldHNbc2V0SWR4XTtcbiAgICB2YXIgaXRlciA9IHV0aWxzLmNyZWF0ZUl0ZXJhdG9yKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgRHlncmFwaENhbnZhc1JlbmRlcmVyLl9nZXRJdGVyYXRvclByZWRpY2F0ZShcbiAgICAgICAgICAgIGcuZ2V0Qm9vbGVhbk9wdGlvbihcImNvbm5lY3RTZXBhcmF0ZWRQb2ludHNcIiwgc2V0TmFtZSkpKTtcblxuICAgIC8vIHNldHVwIGdyYXBoaWNzIGNvbnRleHRcbiAgICB2YXIgcHJldlggPSBOYU47XG4gICAgdmFyIHByZXZZcyA9IFstMSwgLTFdO1xuICAgIHZhciBuZXdZcztcbiAgICAvLyBzaG91bGQgYmUgc2FtZSBjb2xvciBhcyB0aGUgbGluZXMgYnV0IG9ubHkgMTUlIG9wYXF1ZS5cbiAgICB2YXIgcmdiID0gdXRpbHMudG9SR0JfKGNvbG9yKTtcbiAgICB2YXIgZXJyX2NvbG9yID1cbiAgICAgICAgJ3JnYmEoJyArIHJnYi5yICsgJywnICsgcmdiLmcgKyAnLCcgKyByZ2IuYiArICcsJyArIGZpbGxBbHBoYSArICcpJztcbiAgICBjdHguZmlsbFN0eWxlID0gZXJyX2NvbG9yO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICB2YXIgbGFzdF94LCBpc19maXJzdCA9IHRydWU7XG5cbiAgICAvLyBJZiB0aGUgcG9pbnQgZGVuc2l0eSBpcyBoaWdoIGVub3VnaCwgZHJvcHBpbmcgc2VnbWVudHMgb24gdGhlaXIgd2F5IHRvXG4gICAgLy8gdGhlIGNhbnZhcyBqdXN0aWZpZXMgdGhlIG92ZXJoZWFkIG9mIGRvaW5nIHNvLlxuICAgIGlmIChwb2ludHMubGVuZ3RoID4gMiAqIGcud2lkdGhfIHx8IER5Z3JhcGguRk9SQ0VfRkFTVF9QUk9YWSkge1xuICAgICAgY3R4ID0gRHlncmFwaENhbnZhc1JlbmRlcmVyLl9mYXN0Q2FudmFzUHJveHkoY3R4KTtcbiAgICB9XG5cbiAgICAvLyBGb3IgZmlsbGVkIGNoYXJ0cywgd2UgZHJhdyBwb2ludHMgZnJvbSBsZWZ0IHRvIHJpZ2h0LCB0aGVuIGJhY2sgYWxvbmdcbiAgICAvLyB0aGUgeC1heGlzIHRvIGNvbXBsZXRlIGEgc2hhcGUgZm9yIGZpbGxpbmcuXG4gICAgLy8gRm9yIHN0YWNrZWQgcGxvdHMsIHRoaXMgXCJiYWNrIHBhdGhcIiBpcyBhIG1vcmUgY29tcGxleCBzaGFwZS4gVGhpcyBhcnJheVxuICAgIC8vIHN0b3JlcyB0aGUgW3gsIHldIHZhbHVlcyBuZWVkZWQgdG8gdHJhY2UgdGhhdCBzaGFwZS5cbiAgICB2YXIgcGF0aEJhY2sgPSBbXTtcblxuICAgIC8vIFRPRE8oZGFudmspOiB0aGVyZSBhcmUgYSBsb3Qgb2Ygb3B0aW9ucyBhdCBwbGF5IGluIHRoaXMgbG9vcC5cbiAgICAvLyAgICAgVGhlIGxvZ2ljIHdvdWxkIGJlIG11Y2ggY2xlYXJlciBpZiBzb21lIChlLmcuIHN0YWNrR3JhcGggYW5kXG4gICAgLy8gICAgIHN0ZXBQbG90KSB3ZXJlIHNwbGl0IG9mZiBpbnRvIHNlcGFyYXRlIHN1Yi1wbG90dGVycy5cbiAgICB2YXIgcG9pbnQ7XG4gICAgd2hpbGUgKGl0ZXIuaGFzTmV4dCkge1xuICAgICAgcG9pbnQgPSBpdGVyLm5leHQoKTtcbiAgICAgIGlmICghdXRpbHMuaXNPSyhwb2ludC55KSAmJiAhc3RlcFBsb3QpIHtcbiAgICAgICAgdHJhY2VCYWNrUGF0aChjdHgsIHByZXZYLCBwcmV2WXNbMV0sIHBhdGhCYWNrKTtcbiAgICAgICAgcGF0aEJhY2sgPSBbXTtcbiAgICAgICAgcHJldlggPSBOYU47XG4gICAgICAgIGlmIChwb2ludC55X3N0YWNrZWQgIT09IG51bGwgJiYgIWlzTmFOKHBvaW50Lnlfc3RhY2tlZCkpIHtcbiAgICAgICAgICBiYXNlbGluZVtwb2ludC5jYW52YXN4XSA9IGFyZWEuaCAqIHBvaW50Lnlfc3RhY2tlZCArIGFyZWEueTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFja2VkR3JhcGgpIHtcbiAgICAgICAgaWYgKCFpc19maXJzdCAmJiBsYXN0X3ggPT0gcG9pbnQueHZhbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzX2ZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgbGFzdF94ID0gcG9pbnQueHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJCYXNlbGluZSA9IGJhc2VsaW5lW3BvaW50LmNhbnZhc3hdO1xuICAgICAgICB2YXIgbGFzdFk7XG4gICAgICAgIGlmIChjdXJyQmFzZWxpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxhc3RZID0gYXhpc1k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYocHJldlN0ZXBQbG90KSB7XG4gICAgICAgICAgICBsYXN0WSA9IGN1cnJCYXNlbGluZVswXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdFkgPSBjdXJyQmFzZWxpbmU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1lzID0gWyBwb2ludC5jYW52YXN5LCBsYXN0WSBdO1xuXG4gICAgICAgIGlmIChzdGVwUGxvdCkge1xuICAgICAgICAgIC8vIFN0ZXAgcGxvdHMgbXVzdCBrZWVwIHRyYWNrIG9mIHRoZSB0b3AgYW5kIGJvdHRvbSBvZlxuICAgICAgICAgIC8vIHRoZSBiYXNlbGluZSBhdCBlYWNoIHBvaW50LlxuICAgICAgICAgIGlmIChwcmV2WXNbMF0gPT09IC0xKSB7XG4gICAgICAgICAgICBiYXNlbGluZVtwb2ludC5jYW52YXN4XSA9IFsgcG9pbnQuY2FudmFzeSwgYXhpc1kgXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZWxpbmVbcG9pbnQuY2FudmFzeF0gPSBbIHBvaW50LmNhbnZhc3ksIHByZXZZc1swXSBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXNlbGluZVtwb2ludC5jYW52YXN4XSA9IHBvaW50LmNhbnZhc3k7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmFOKHBvaW50LmNhbnZhc3kpICYmIHN0ZXBQbG90KSB7XG4gICAgICAgICAgbmV3WXMgPSBbIGFyZWEueSArIGFyZWEuaCwgYXhpc1kgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdZcyA9IFsgcG9pbnQuY2FudmFzeSwgYXhpc1kgXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc05hTihwcmV2WCkpIHtcbiAgICAgICAgLy8gTW92ZSB0byB0b3AgZmlsbCBwb2ludFxuICAgICAgICBpZiAoc3RlcFBsb3QpIHtcbiAgICAgICAgICBjdHgubGluZVRvKHBvaW50LmNhbnZhc3gsIHByZXZZc1swXSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhwb2ludC5jYW52YXN4LCBuZXdZc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmxpbmVUbyhwb2ludC5jYW52YXN4LCBuZXdZc1swXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWNvcmQgdGhlIGJhc2VsaW5lIGZvciB0aGUgcmV2ZXJzZSBwYXRoLlxuICAgICAgICBpZiAoc3RhY2tlZEdyYXBoKSB7XG4gICAgICAgICAgcGF0aEJhY2sucHVzaChbcHJldlgsIHByZXZZc1sxXV0pO1xuICAgICAgICAgIGlmIChwcmV2U3RlcFBsb3QgJiYgY3VyckJhc2VsaW5lKSB7XG4gICAgICAgICAgICAvLyBEcmF3IHRvIHRoZSBib3R0b20gb2YgdGhlIGJhc2VsaW5lXG4gICAgICAgICAgICBwYXRoQmFjay5wdXNoKFtwb2ludC5jYW52YXN4LCBjdXJyQmFzZWxpbmVbMV1dKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aEJhY2sucHVzaChbcG9pbnQuY2FudmFzeCwgbmV3WXNbMV1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5tb3ZlVG8ocG9pbnQuY2FudmFzeCwgbmV3WXNbMV0pO1xuICAgICAgICBjdHgubGluZVRvKHBvaW50LmNhbnZhc3gsIG5ld1lzWzBdKTtcbiAgICAgIH1cbiAgICAgIHByZXZZcyA9IG5ld1lzO1xuICAgICAgcHJldlggPSBwb2ludC5jYW52YXN4O1xuICAgIH1cbiAgICBwcmV2U3RlcFBsb3QgPSBzdGVwUGxvdDtcbiAgICBpZiAobmV3WXMgJiYgcG9pbnQpIHtcbiAgICAgIHRyYWNlQmFja1BhdGgoY3R4LCBwb2ludC5jYW52YXN4LCBuZXdZc1sxXSwgcGF0aEJhY2spO1xuICAgICAgcGF0aEJhY2sgPSBbXTtcbiAgICB9XG4gICAgY3R4LmZpbGwoKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgRHlncmFwaENhbnZhc1JlbmRlcmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9keWdyYXBocy9zcmMvZHlncmFwaC1jYW52YXMuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dygraph_interaction_model__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__dygraph_canvas__ = __webpack_require__(16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__dygraph_utils__ = __webpack_require__(8);\n\n\n\n\n\n\n\n// Default attribute values.\nvar DEFAULT_ATTRS = {\n  highlightCircleSize: 3,\n  highlightSeriesOpts: null,\n  highlightSeriesBackgroundAlpha: 0.5,\n  highlightSeriesBackgroundColor: 'rgb(255, 255, 255)',\n\n  labelsSeparateLines: false,\n  labelsShowZeroValues: true,\n  labelsKMB: false,\n  labelsKMG2: false,\n  showLabelsOnHighlight: true,\n\n  digitsAfterDecimal: 2,\n  maxNumberWidth: 6,\n  sigFigs: null,\n\n  strokeWidth: 1.0,\n  strokeBorderWidth: 0,\n  strokeBorderColor: \"white\",\n\n  axisTickSize: 3,\n  axisLabelFontSize: 14,\n  rightGap: 5,\n\n  showRoller: false,\n  xValueParser: undefined,\n\n  delimiter: ',',\n\n  sigma: 2.0,\n  errorBars: false,\n  fractions: false,\n  wilsonInterval: true, // only relevant if fractions is true\n  customBars: false,\n  fillGraph: false,\n  fillAlpha: 0.15,\n  connectSeparatedPoints: false,\n\n  stackedGraph: false,\n  stackedGraphNaNFill: 'all',\n  hideOverlayOnMouseOut: true,\n\n  legend: 'onmouseover',\n  stepPlot: false,\n  xRangePad: 0,\n  yRangePad: null,\n  drawAxesAtZero: false,\n\n  // Sizes of the various chart labels.\n  titleHeight: 28,\n  xLabelHeight: 18,\n  yLabelWidth: 18,\n\n  axisLineColor: \"black\",\n  axisLineWidth: 0.3,\n  gridLineWidth: 0.3,\n  axisLabelWidth: 50,\n  gridLineColor: \"rgb(128,128,128)\",\n\n  interactionModel: __WEBPACK_IMPORTED_MODULE_1__dygraph_interaction_model__[\"a\" /* default */].defaultModel,\n  animatedZooms: false, // (for now)\n\n  // Range selector options\n  showRangeSelector: false,\n  rangeSelectorHeight: 40,\n  rangeSelectorPlotStrokeColor: \"#808FAB\",\n  rangeSelectorPlotFillGradientColor: \"white\",\n  rangeSelectorPlotFillColor: \"#A7B1C4\",\n  rangeSelectorBackgroundStrokeColor: \"gray\",\n  rangeSelectorBackgroundLineWidth: 1,\n  rangeSelectorPlotLineWidth: 1.5,\n  rangeSelectorForegroundStrokeColor: \"black\",\n  rangeSelectorForegroundLineWidth: 1,\n  rangeSelectorAlpha: 0.6,\n  showInRangeSelector: null,\n\n  // The ordering here ensures that central lines always appear above any\n  // fill bars/error bars.\n  plotter: [__WEBPACK_IMPORTED_MODULE_2__dygraph_canvas__[\"a\" /* default */]._fillPlotter, __WEBPACK_IMPORTED_MODULE_2__dygraph_canvas__[\"a\" /* default */]._errorPlotter, __WEBPACK_IMPORTED_MODULE_2__dygraph_canvas__[\"a\" /* default */]._linePlotter],\n\n  plugins: [],\n\n  // per-axis options\n  axes: {\n    x: {\n      pixelsPerLabel: 70,\n      axisLabelWidth: 60,\n      axisLabelFormatter: __WEBPACK_IMPORTED_MODULE_3__dygraph_utils__[\"x\" /* dateAxisLabelFormatter */],\n      valueFormatter: __WEBPACK_IMPORTED_MODULE_3__dygraph_utils__[\"w\" /* dateValueFormatter */],\n      drawGrid: true,\n      drawAxis: true,\n      independentTicks: true,\n      ticker: __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__[\"a\" /* dateTicker */]\n    },\n    y: {\n      axisLabelWidth: 50,\n      pixelsPerLabel: 30,\n      valueFormatter: __WEBPACK_IMPORTED_MODULE_3__dygraph_utils__[\"P\" /* numberValueFormatter */],\n      axisLabelFormatter: __WEBPACK_IMPORTED_MODULE_3__dygraph_utils__[\"D\" /* numberAxisLabelFormatter */],\n      drawGrid: true,\n      drawAxis: true,\n      independentTicks: true,\n      ticker: __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__[\"b\" /* numericTicks */]\n    },\n    y2: {\n      axisLabelWidth: 50,\n      pixelsPerLabel: 30,\n      valueFormatter: __WEBPACK_IMPORTED_MODULE_3__dygraph_utils__[\"P\" /* numberValueFormatter */],\n      axisLabelFormatter: __WEBPACK_IMPORTED_MODULE_3__dygraph_utils__[\"D\" /* numberAxisLabelFormatter */],\n      drawAxis: true, // only applies when there are two axes of data.\n      drawGrid: false,\n      independentTicks: false,\n      ticker: __WEBPACK_IMPORTED_MODULE_0__dygraph_tickers__[\"b\" /* numericTicks */]\n    }\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DEFAULT_ATTRS);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLWRlZmF1bHQtYXR0cnMuanM/ZmIxYiJdLCJuYW1lcyI6WyJERUZBVUxUX0FUVFJTIiwiaGlnaGxpZ2h0Q2lyY2xlU2l6ZSIsImhpZ2hsaWdodFNlcmllc09wdHMiLCJoaWdobGlnaHRTZXJpZXNCYWNrZ3JvdW5kQWxwaGEiLCJoaWdobGlnaHRTZXJpZXNCYWNrZ3JvdW5kQ29sb3IiLCJsYWJlbHNTZXBhcmF0ZUxpbmVzIiwibGFiZWxzU2hvd1plcm9WYWx1ZXMiLCJsYWJlbHNLTUIiLCJsYWJlbHNLTUcyIiwic2hvd0xhYmVsc09uSGlnaGxpZ2h0IiwiZGlnaXRzQWZ0ZXJEZWNpbWFsIiwibWF4TnVtYmVyV2lkdGgiLCJzaWdGaWdzIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VCb3JkZXJXaWR0aCIsInN0cm9rZUJvcmRlckNvbG9yIiwiYXhpc1RpY2tTaXplIiwiYXhpc0xhYmVsRm9udFNpemUiLCJyaWdodEdhcCIsInNob3dSb2xsZXIiLCJ4VmFsdWVQYXJzZXIiLCJ1bmRlZmluZWQiLCJkZWxpbWl0ZXIiLCJzaWdtYSIsImVycm9yQmFycyIsImZyYWN0aW9ucyIsIndpbHNvbkludGVydmFsIiwiY3VzdG9tQmFycyIsImZpbGxHcmFwaCIsImZpbGxBbHBoYSIsImNvbm5lY3RTZXBhcmF0ZWRQb2ludHMiLCJzdGFja2VkR3JhcGgiLCJzdGFja2VkR3JhcGhOYU5GaWxsIiwiaGlkZU92ZXJsYXlPbk1vdXNlT3V0IiwibGVnZW5kIiwic3RlcFBsb3QiLCJ4UmFuZ2VQYWQiLCJ5UmFuZ2VQYWQiLCJkcmF3QXhlc0F0WmVybyIsInRpdGxlSGVpZ2h0IiwieExhYmVsSGVpZ2h0IiwieUxhYmVsV2lkdGgiLCJheGlzTGluZUNvbG9yIiwiYXhpc0xpbmVXaWR0aCIsImdyaWRMaW5lV2lkdGgiLCJheGlzTGFiZWxXaWR0aCIsImdyaWRMaW5lQ29sb3IiLCJpbnRlcmFjdGlvbk1vZGVsIiwiRHlncmFwaEludGVyYWN0aW9uIiwiZGVmYXVsdE1vZGVsIiwiYW5pbWF0ZWRab29tcyIsInNob3dSYW5nZVNlbGVjdG9yIiwicmFuZ2VTZWxlY3RvckhlaWdodCIsInJhbmdlU2VsZWN0b3JQbG90U3Ryb2tlQ29sb3IiLCJyYW5nZVNlbGVjdG9yUGxvdEZpbGxHcmFkaWVudENvbG9yIiwicmFuZ2VTZWxlY3RvclBsb3RGaWxsQ29sb3IiLCJyYW5nZVNlbGVjdG9yQmFja2dyb3VuZFN0cm9rZUNvbG9yIiwicmFuZ2VTZWxlY3RvckJhY2tncm91bmRMaW5lV2lkdGgiLCJyYW5nZVNlbGVjdG9yUGxvdExpbmVXaWR0aCIsInJhbmdlU2VsZWN0b3JGb3JlZ3JvdW5kU3Ryb2tlQ29sb3IiLCJyYW5nZVNlbGVjdG9yRm9yZWdyb3VuZExpbmVXaWR0aCIsInJhbmdlU2VsZWN0b3JBbHBoYSIsInNob3dJblJhbmdlU2VsZWN0b3IiLCJwbG90dGVyIiwiRHlncmFwaENhbnZhc1JlbmRlcmVyIiwiX2ZpbGxQbG90dGVyIiwiX2Vycm9yUGxvdHRlciIsIl9saW5lUGxvdHRlciIsInBsdWdpbnMiLCJheGVzIiwieCIsInBpeGVsc1BlckxhYmVsIiwiYXhpc0xhYmVsRm9ybWF0dGVyIiwidmFsdWVGb3JtYXR0ZXIiLCJkcmF3R3JpZCIsImRyYXdBeGlzIiwiaW5kZXBlbmRlbnRUaWNrcyIsInRpY2tlciIsImRhdGVUaWNrZXIiLCJ5IiwibnVtZXJpY1RpY2tzIiwieTIiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUlBLGdCQUFnQjtBQUNsQkMsdUJBQXFCLENBREg7QUFFbEJDLHVCQUFxQixJQUZIO0FBR2xCQyxrQ0FBZ0MsR0FIZDtBQUlsQkMsa0NBQWdDLG9CQUpkOztBQU1sQkMsdUJBQXFCLEtBTkg7QUFPbEJDLHdCQUFzQixJQVBKO0FBUWxCQyxhQUFXLEtBUk87QUFTbEJDLGNBQVksS0FUTTtBQVVsQkMseUJBQXVCLElBVkw7O0FBWWxCQyxzQkFBb0IsQ0FaRjtBQWFsQkMsa0JBQWdCLENBYkU7QUFjbEJDLFdBQVMsSUFkUzs7QUFnQmxCQyxlQUFhLEdBaEJLO0FBaUJsQkMscUJBQW1CLENBakJEO0FBa0JsQkMscUJBQW1CLE9BbEJEOztBQW9CbEJDLGdCQUFjLENBcEJJO0FBcUJsQkMscUJBQW1CLEVBckJEO0FBc0JsQkMsWUFBVSxDQXRCUTs7QUF3QmxCQyxjQUFZLEtBeEJNO0FBeUJsQkMsZ0JBQWNDLFNBekJJOztBQTJCbEJDLGFBQVcsR0EzQk87O0FBNkJsQkMsU0FBTyxHQTdCVztBQThCbEJDLGFBQVcsS0E5Qk87QUErQmxCQyxhQUFXLEtBL0JPO0FBZ0NsQkMsa0JBQWdCLElBaENFLEVBZ0NLO0FBQ3ZCQyxjQUFZLEtBakNNO0FBa0NsQkMsYUFBVyxLQWxDTztBQW1DbEJDLGFBQVcsSUFuQ087QUFvQ2xCQywwQkFBd0IsS0FwQ047O0FBc0NsQkMsZ0JBQWMsS0F0Q0k7QUF1Q2xCQyx1QkFBcUIsS0F2Q0g7QUF3Q2xCQyx5QkFBdUIsSUF4Q0w7O0FBMENsQkMsVUFBUSxhQTFDVTtBQTJDbEJDLFlBQVUsS0EzQ1E7QUE0Q2xCQyxhQUFXLENBNUNPO0FBNkNsQkMsYUFBVyxJQTdDTztBQThDbEJDLGtCQUFnQixLQTlDRTs7QUFnRGxCO0FBQ0FDLGVBQWEsRUFqREs7QUFrRGxCQyxnQkFBYyxFQWxESTtBQW1EbEJDLGVBQWEsRUFuREs7O0FBcURsQkMsaUJBQWUsT0FyREc7QUFzRGxCQyxpQkFBZSxHQXRERztBQXVEbEJDLGlCQUFlLEdBdkRHO0FBd0RsQkMsa0JBQWdCLEVBeERFO0FBeURsQkMsaUJBQWUsa0JBekRHOztBQTJEbEJDLG9CQUFrQiwyRUFBQUMsQ0FBbUJDLFlBM0RuQjtBQTREbEJDLGlCQUFlLEtBNURHLEVBNERLOztBQUV2QjtBQUNBQyxxQkFBbUIsS0EvREQ7QUFnRWxCQyx1QkFBcUIsRUFoRUg7QUFpRWxCQyxnQ0FBOEIsU0FqRVo7QUFrRWxCQyxzQ0FBb0MsT0FsRWxCO0FBbUVsQkMsOEJBQTRCLFNBbkVWO0FBb0VsQkMsc0NBQW9DLE1BcEVsQjtBQXFFbEJDLG9DQUFrQyxDQXJFaEI7QUFzRWxCQyw4QkFBMkIsR0F0RVQ7QUF1RWxCQyxzQ0FBb0MsT0F2RWxCO0FBd0VsQkMsb0NBQWtDLENBeEVoQjtBQXlFbEJDLHNCQUFvQixHQXpFRjtBQTBFbEJDLHVCQUFxQixJQTFFSDs7QUE0RWxCO0FBQ0E7QUFDQUMsV0FBUyxDQUNQLGdFQUFBQyxDQUFzQkMsWUFEZixFQUVQLGdFQUFBRCxDQUFzQkUsYUFGZixFQUdQLGdFQUFBRixDQUFzQkcsWUFIZixDQTlFUzs7QUFvRmxCQyxXQUFTLEVBcEZTOztBQXNGbEI7QUFDQUMsUUFBTTtBQUNKQyxPQUFHO0FBQ0RDLHNCQUFnQixFQURmO0FBRUQxQixzQkFBZ0IsRUFGZjtBQUdEMkIsMEJBQW9CLDhFQUhuQjtBQUlEQyxzQkFBZ0IsMEVBSmY7QUFLREMsZ0JBQVUsSUFMVDtBQU1EQyxnQkFBVSxJQU5UO0FBT0RDLHdCQUFrQixJQVBqQjtBQVFEQyxjQUFRLG9FQUFlQztBQVJ0QixLQURDO0FBV0pDLE9BQUc7QUFDRGxDLHNCQUFnQixFQURmO0FBRUQwQixzQkFBZ0IsRUFGZjtBQUdERSxzQkFBZ0IsNEVBSGY7QUFJREQsMEJBQW9CLGdGQUpuQjtBQUtERSxnQkFBVSxJQUxUO0FBTURDLGdCQUFVLElBTlQ7QUFPREMsd0JBQWtCLElBUGpCO0FBUURDLGNBQVEsc0VBQWVHO0FBUnRCLEtBWEM7QUFxQkpDLFFBQUk7QUFDRnBDLHNCQUFnQixFQURkO0FBRUYwQixzQkFBZ0IsRUFGZDtBQUdGRSxzQkFBZ0IsNEVBSGQ7QUFJRkQsMEJBQW9CLGdGQUpsQjtBQUtGRyxnQkFBVSxJQUxSLEVBS2U7QUFDakJELGdCQUFVLEtBTlI7QUFPRkUsd0JBQWtCLEtBUGhCO0FBUUZDLGNBQVEsc0VBQWVHO0FBUnJCO0FBckJBO0FBdkZZLENBQXBCOztBQXlIQSx5REFBZWhGLGFBQWYiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuaW1wb3J0ICogYXMgRHlncmFwaFRpY2tlcnMgZnJvbSAnLi9keWdyYXBoLXRpY2tlcnMnO1xuaW1wb3J0IER5Z3JhcGhJbnRlcmFjdGlvbiBmcm9tICcuL2R5Z3JhcGgtaW50ZXJhY3Rpb24tbW9kZWwnO1xuaW1wb3J0IER5Z3JhcGhDYW52YXNSZW5kZXJlciBmcm9tICcuL2R5Z3JhcGgtY2FudmFzJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vZHlncmFwaC11dGlscyc7XG5cbi8vIERlZmF1bHQgYXR0cmlidXRlIHZhbHVlcy5cbnZhciBERUZBVUxUX0FUVFJTID0ge1xuICBoaWdobGlnaHRDaXJjbGVTaXplOiAzLFxuICBoaWdobGlnaHRTZXJpZXNPcHRzOiBudWxsLFxuICBoaWdobGlnaHRTZXJpZXNCYWNrZ3JvdW5kQWxwaGE6IDAuNSxcbiAgaGlnaGxpZ2h0U2VyaWVzQmFja2dyb3VuZENvbG9yOiAncmdiKDI1NSwgMjU1LCAyNTUpJyxcblxuICBsYWJlbHNTZXBhcmF0ZUxpbmVzOiBmYWxzZSxcbiAgbGFiZWxzU2hvd1plcm9WYWx1ZXM6IHRydWUsXG4gIGxhYmVsc0tNQjogZmFsc2UsXG4gIGxhYmVsc0tNRzI6IGZhbHNlLFxuICBzaG93TGFiZWxzT25IaWdobGlnaHQ6IHRydWUsXG5cbiAgZGlnaXRzQWZ0ZXJEZWNpbWFsOiAyLFxuICBtYXhOdW1iZXJXaWR0aDogNixcbiAgc2lnRmlnczogbnVsbCxcblxuICBzdHJva2VXaWR0aDogMS4wLFxuICBzdHJva2VCb3JkZXJXaWR0aDogMCxcbiAgc3Ryb2tlQm9yZGVyQ29sb3I6IFwid2hpdGVcIixcblxuICBheGlzVGlja1NpemU6IDMsXG4gIGF4aXNMYWJlbEZvbnRTaXplOiAxNCxcbiAgcmlnaHRHYXA6IDUsXG5cbiAgc2hvd1JvbGxlcjogZmFsc2UsXG4gIHhWYWx1ZVBhcnNlcjogdW5kZWZpbmVkLFxuXG4gIGRlbGltaXRlcjogJywnLFxuXG4gIHNpZ21hOiAyLjAsXG4gIGVycm9yQmFyczogZmFsc2UsXG4gIGZyYWN0aW9uczogZmFsc2UsXG4gIHdpbHNvbkludGVydmFsOiB0cnVlLCAgLy8gb25seSByZWxldmFudCBpZiBmcmFjdGlvbnMgaXMgdHJ1ZVxuICBjdXN0b21CYXJzOiBmYWxzZSxcbiAgZmlsbEdyYXBoOiBmYWxzZSxcbiAgZmlsbEFscGhhOiAwLjE1LFxuICBjb25uZWN0U2VwYXJhdGVkUG9pbnRzOiBmYWxzZSxcblxuICBzdGFja2VkR3JhcGg6IGZhbHNlLFxuICBzdGFja2VkR3JhcGhOYU5GaWxsOiAnYWxsJyxcbiAgaGlkZU92ZXJsYXlPbk1vdXNlT3V0OiB0cnVlLFxuXG4gIGxlZ2VuZDogJ29ubW91c2VvdmVyJyxcbiAgc3RlcFBsb3Q6IGZhbHNlLFxuICB4UmFuZ2VQYWQ6IDAsXG4gIHlSYW5nZVBhZDogbnVsbCxcbiAgZHJhd0F4ZXNBdFplcm86IGZhbHNlLFxuXG4gIC8vIFNpemVzIG9mIHRoZSB2YXJpb3VzIGNoYXJ0IGxhYmVscy5cbiAgdGl0bGVIZWlnaHQ6IDI4LFxuICB4TGFiZWxIZWlnaHQ6IDE4LFxuICB5TGFiZWxXaWR0aDogMTgsXG5cbiAgYXhpc0xpbmVDb2xvcjogXCJibGFja1wiLFxuICBheGlzTGluZVdpZHRoOiAwLjMsXG4gIGdyaWRMaW5lV2lkdGg6IDAuMyxcbiAgYXhpc0xhYmVsV2lkdGg6IDUwLFxuICBncmlkTGluZUNvbG9yOiBcInJnYigxMjgsMTI4LDEyOClcIixcblxuICBpbnRlcmFjdGlvbk1vZGVsOiBEeWdyYXBoSW50ZXJhY3Rpb24uZGVmYXVsdE1vZGVsLFxuICBhbmltYXRlZFpvb21zOiBmYWxzZSwgIC8vIChmb3Igbm93KVxuXG4gIC8vIFJhbmdlIHNlbGVjdG9yIG9wdGlvbnNcbiAgc2hvd1JhbmdlU2VsZWN0b3I6IGZhbHNlLFxuICByYW5nZVNlbGVjdG9ySGVpZ2h0OiA0MCxcbiAgcmFuZ2VTZWxlY3RvclBsb3RTdHJva2VDb2xvcjogXCIjODA4RkFCXCIsXG4gIHJhbmdlU2VsZWN0b3JQbG90RmlsbEdyYWRpZW50Q29sb3I6IFwid2hpdGVcIixcbiAgcmFuZ2VTZWxlY3RvclBsb3RGaWxsQ29sb3I6IFwiI0E3QjFDNFwiLFxuICByYW5nZVNlbGVjdG9yQmFja2dyb3VuZFN0cm9rZUNvbG9yOiBcImdyYXlcIixcbiAgcmFuZ2VTZWxlY3RvckJhY2tncm91bmRMaW5lV2lkdGg6IDEsXG4gIHJhbmdlU2VsZWN0b3JQbG90TGluZVdpZHRoOjEuNSxcbiAgcmFuZ2VTZWxlY3RvckZvcmVncm91bmRTdHJva2VDb2xvcjogXCJibGFja1wiLFxuICByYW5nZVNlbGVjdG9yRm9yZWdyb3VuZExpbmVXaWR0aDogMSxcbiAgcmFuZ2VTZWxlY3RvckFscGhhOiAwLjYsXG4gIHNob3dJblJhbmdlU2VsZWN0b3I6IG51bGwsXG5cbiAgLy8gVGhlIG9yZGVyaW5nIGhlcmUgZW5zdXJlcyB0aGF0IGNlbnRyYWwgbGluZXMgYWx3YXlzIGFwcGVhciBhYm92ZSBhbnlcbiAgLy8gZmlsbCBiYXJzL2Vycm9yIGJhcnMuXG4gIHBsb3R0ZXI6IFtcbiAgICBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2ZpbGxQbG90dGVyLFxuICAgIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fZXJyb3JQbG90dGVyLFxuICAgIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fbGluZVBsb3R0ZXJcbiAgXSxcblxuICBwbHVnaW5zOiBbIF0sXG5cbiAgLy8gcGVyLWF4aXMgb3B0aW9uc1xuICBheGVzOiB7XG4gICAgeDoge1xuICAgICAgcGl4ZWxzUGVyTGFiZWw6IDcwLFxuICAgICAgYXhpc0xhYmVsV2lkdGg6IDYwLFxuICAgICAgYXhpc0xhYmVsRm9ybWF0dGVyOiB1dGlscy5kYXRlQXhpc0xhYmVsRm9ybWF0dGVyLFxuICAgICAgdmFsdWVGb3JtYXR0ZXI6IHV0aWxzLmRhdGVWYWx1ZUZvcm1hdHRlcixcbiAgICAgIGRyYXdHcmlkOiB0cnVlLFxuICAgICAgZHJhd0F4aXM6IHRydWUsXG4gICAgICBpbmRlcGVuZGVudFRpY2tzOiB0cnVlLFxuICAgICAgdGlja2VyOiBEeWdyYXBoVGlja2Vycy5kYXRlVGlja2VyXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICBheGlzTGFiZWxXaWR0aDogNTAsXG4gICAgICBwaXhlbHNQZXJMYWJlbDogMzAsXG4gICAgICB2YWx1ZUZvcm1hdHRlcjogdXRpbHMubnVtYmVyVmFsdWVGb3JtYXR0ZXIsXG4gICAgICBheGlzTGFiZWxGb3JtYXR0ZXI6IHV0aWxzLm51bWJlckF4aXNMYWJlbEZvcm1hdHRlcixcbiAgICAgIGRyYXdHcmlkOiB0cnVlLFxuICAgICAgZHJhd0F4aXM6IHRydWUsXG4gICAgICBpbmRlcGVuZGVudFRpY2tzOiB0cnVlLFxuICAgICAgdGlja2VyOiBEeWdyYXBoVGlja2Vycy5udW1lcmljVGlja3NcbiAgICB9LFxuICAgIHkyOiB7XG4gICAgICBheGlzTGFiZWxXaWR0aDogNTAsXG4gICAgICBwaXhlbHNQZXJMYWJlbDogMzAsXG4gICAgICB2YWx1ZUZvcm1hdHRlcjogdXRpbHMubnVtYmVyVmFsdWVGb3JtYXR0ZXIsXG4gICAgICBheGlzTGFiZWxGb3JtYXR0ZXI6IHV0aWxzLm51bWJlckF4aXNMYWJlbEZvcm1hdHRlcixcbiAgICAgIGRyYXdBeGlzOiB0cnVlLCAgLy8gb25seSBhcHBsaWVzIHdoZW4gdGhlcmUgYXJlIHR3byBheGVzIG9mIGRhdGEuXG4gICAgICBkcmF3R3JpZDogZmFsc2UsXG4gICAgICBpbmRlcGVuZGVudFRpY2tzOiBmYWxzZSxcbiAgICAgIHRpY2tlcjogRHlncmFwaFRpY2tlcnMubnVtZXJpY1RpY2tzXG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBERUZBVUxUX0FUVFJTO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9keWdyYXBocy9zcmMvZHlncmFwaC1kZWZhdWx0LWF0dHJzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__ = __webpack_require__(8);\n/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview Based on PlotKitLayout, but modified to meet the needs of\n * dygraphs.\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * Creates a new DygraphLayout object.\n *\n * This class contains all the data to be charted.\n * It uses data coordinates, but also records the chart range (in data\n * coordinates) and hence is able to calculate percentage positions ('In this\n * view, Point A lies 25% down the x-axis.')\n *\n * Two things that it does not do are:\n * 1. Record pixel coordinates for anything.\n * 2. (oddly) determine anything about the layout of chart elements.\n *\n * The naming is a vestige of Dygraph's original PlotKit roots.\n *\n * @constructor\n */\nvar DygraphLayout = function DygraphLayout(dygraph) {\n  this.dygraph_ = dygraph;\n  /**\n   * Array of points for each series.\n   *\n   * [series index][row index in series] = |Point| structure,\n   * where series index refers to visible series only, and the\n   * point index is for the reduced set of points for the current\n   * zoom region (including one point just outside the window).\n   * All points in the same row index share the same X value.\n   *\n   * @type {Array.<Array.<Dygraph.PointType>>}\n   */\n  this.points = [];\n  this.setNames = [];\n  this.annotations = [];\n  this.yAxes_ = null;\n\n  // TODO(danvk): it's odd that xTicks_ and yTicks_ are inputs, but xticks and\n  // yticks are outputs. Clean this up.\n  this.xTicks_ = null;\n  this.yTicks_ = null;\n};\n\n/**\n * Add points for a single series.\n *\n * @param {string} setname Name of the series.\n * @param {Array.<Dygraph.PointType>} set_xy Points for the series.\n */\nDygraphLayout.prototype.addDataset = function (setname, set_xy) {\n  this.points.push(set_xy);\n  this.setNames.push(setname);\n};\n\n/**\n * Returns the box which the chart should be drawn in. This is the canvas's\n * box, less space needed for the axis and chart labels.\n *\n * @return {{x: number, y: number, w: number, h: number}}\n */\nDygraphLayout.prototype.getPlotArea = function () {\n  return this.area_;\n};\n\n// Compute the box which the chart should be drawn in. This is the canvas's\n// box, less space needed for axis, chart labels, and other plug-ins.\n// NOTE: This should only be called by Dygraph.predraw_().\nDygraphLayout.prototype.computePlotArea = function () {\n  var area = {\n    // TODO(danvk): per-axis setting.\n    x: 0,\n    y: 0\n  };\n\n  area.w = this.dygraph_.width_ - area.x - this.dygraph_.getOption('rightGap');\n  area.h = this.dygraph_.height_;\n\n  // Let plugins reserve space.\n  var e = {\n    chart_div: this.dygraph_.graphDiv,\n    reserveSpaceLeft: function reserveSpaceLeft(px) {\n      var r = {\n        x: area.x,\n        y: area.y,\n        w: px,\n        h: area.h\n      };\n      area.x += px;\n      area.w -= px;\n      return r;\n    },\n    reserveSpaceRight: function reserveSpaceRight(px) {\n      var r = {\n        x: area.x + area.w - px,\n        y: area.y,\n        w: px,\n        h: area.h\n      };\n      area.w -= px;\n      return r;\n    },\n    reserveSpaceTop: function reserveSpaceTop(px) {\n      var r = {\n        x: area.x,\n        y: area.y,\n        w: area.w,\n        h: px\n      };\n      area.y += px;\n      area.h -= px;\n      return r;\n    },\n    reserveSpaceBottom: function reserveSpaceBottom(px) {\n      var r = {\n        x: area.x,\n        y: area.y + area.h - px,\n        w: area.w,\n        h: px\n      };\n      area.h -= px;\n      return r;\n    },\n    chartRect: function chartRect() {\n      return { x: area.x, y: area.y, w: area.w, h: area.h };\n    }\n  };\n  this.dygraph_.cascadeEvents_('layout', e);\n\n  this.area_ = area;\n};\n\nDygraphLayout.prototype.setAnnotations = function (ann) {\n  // The Dygraph object's annotations aren't parsed. We parse them here and\n  // save a copy. If there is no parser, then the user must be using raw format.\n  this.annotations = [];\n  var parse = this.dygraph_.getOption('xValueParser') || function (x) {\n    return x;\n  };\n  for (var i = 0; i < ann.length; i++) {\n    var a = {};\n    if (!ann[i].xval && ann[i].x === undefined) {\n      console.error(\"Annotations must have an 'x' property\");\n      return;\n    }\n    if (ann[i].icon && !(ann[i].hasOwnProperty('width') && ann[i].hasOwnProperty('height'))) {\n      console.error(\"Must set width and height when setting \" + \"annotation.icon property\");\n      return;\n    }\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"a\" /* update */](a, ann[i]);\n    if (!a.xval) a.xval = parse(a.x);\n    this.annotations.push(a);\n  }\n};\n\nDygraphLayout.prototype.setXTicks = function (xTicks) {\n  this.xTicks_ = xTicks;\n};\n\n// TODO(danvk): add this to the Dygraph object's API or move it into Layout.\nDygraphLayout.prototype.setYAxes = function (yAxes) {\n  this.yAxes_ = yAxes;\n};\n\nDygraphLayout.prototype.evaluate = function () {\n  this._xAxis = {};\n  this._evaluateLimits();\n  this._evaluateLineCharts();\n  this._evaluateLineTicks();\n  this._evaluateAnnotations();\n};\n\nDygraphLayout.prototype._evaluateLimits = function () {\n  var xlimits = this.dygraph_.xAxisRange();\n  this._xAxis.minval = xlimits[0];\n  this._xAxis.maxval = xlimits[1];\n  var xrange = xlimits[1] - xlimits[0];\n  this._xAxis.scale = xrange !== 0 ? 1 / xrange : 1.0;\n\n  if (this.dygraph_.getOptionForAxis(\"logscale\", 'x')) {\n    this._xAxis.xlogrange = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](this._xAxis.maxval) - __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](this._xAxis.minval);\n    this._xAxis.xlogscale = this._xAxis.xlogrange !== 0 ? 1.0 / this._xAxis.xlogrange : 1.0;\n  }\n  for (var i = 0; i < this.yAxes_.length; i++) {\n    var axis = this.yAxes_[i];\n    axis.minyval = axis.computedValueRange[0];\n    axis.maxyval = axis.computedValueRange[1];\n    axis.yrange = axis.maxyval - axis.minyval;\n    axis.yscale = axis.yrange !== 0 ? 1.0 / axis.yrange : 1.0;\n\n    if (this.dygraph_.getOption(\"logscale\")) {\n      axis.ylogrange = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](axis.maxyval) - __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](axis.minyval);\n      axis.ylogscale = axis.ylogrange !== 0 ? 1.0 / axis.ylogrange : 1.0;\n      if (!isFinite(axis.ylogrange) || isNaN(axis.ylogrange)) {\n        console.error('axis ' + i + ' of graph at ' + axis.g + ' can\\'t be displayed in log scale for range [' + axis.minyval + ' - ' + axis.maxyval + ']');\n      }\n    }\n  }\n};\n\nDygraphLayout.calcXNormal_ = function (value, xAxis, logscale) {\n  if (logscale) {\n    return (__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](value) - __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](xAxis.minval)) * xAxis.xlogscale;\n  } else {\n    return (value - xAxis.minval) * xAxis.scale;\n  }\n};\n\n/**\n * @param {DygraphAxisType} axis\n * @param {number} value\n * @param {boolean} logscale\n * @return {number}\n */\nDygraphLayout.calcYNormal_ = function (axis, value, logscale) {\n  if (logscale) {\n    var x = 1.0 - (__WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](value) - __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](axis.minyval)) * axis.ylogscale;\n    return isFinite(x) ? x : NaN; // shim for v8 issue; see pull request 276\n  } else {\n    return 1.0 - (value - axis.minyval) * axis.yscale;\n  }\n};\n\nDygraphLayout.prototype._evaluateLineCharts = function () {\n  var isStacked = this.dygraph_.getOption(\"stackedGraph\");\n  var isLogscaleForX = this.dygraph_.getOptionForAxis(\"logscale\", 'x');\n\n  for (var setIdx = 0; setIdx < this.points.length; setIdx++) {\n    var points = this.points[setIdx];\n    var setName = this.setNames[setIdx];\n    var connectSeparated = this.dygraph_.getOption('connectSeparatedPoints', setName);\n    var axis = this.dygraph_.axisPropertiesForSeries(setName);\n    // TODO (konigsberg): use optionsForAxis instead.\n    var logscale = this.dygraph_.attributes_.getForSeries(\"logscale\", setName);\n\n    for (var j = 0; j < points.length; j++) {\n      var point = points[j];\n\n      // Range from 0-1 where 0 represents left and 1 represents right.\n      point.x = DygraphLayout.calcXNormal_(point.xval, this._xAxis, isLogscaleForX);\n      // Range from 0-1 where 0 represents top and 1 represents bottom\n      var yval = point.yval;\n      if (isStacked) {\n        point.y_stacked = DygraphLayout.calcYNormal_(axis, point.yval_stacked, logscale);\n        if (yval !== null && !isNaN(yval)) {\n          yval = point.yval_stacked;\n        }\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    }\n\n    this.dygraph_.dataHandler_.onLineEvaluated(points, axis, logscale);\n  }\n};\n\nDygraphLayout.prototype._evaluateLineTicks = function () {\n  var i, tick, label, pos, v, has_tick;\n  this.xticks = [];\n  for (i = 0; i < this.xTicks_.length; i++) {\n    tick = this.xTicks_[i];\n    label = tick.label;\n    has_tick = !('label_v' in tick);\n    v = has_tick ? tick.v : tick.label_v;\n    pos = this.dygraph_.toPercentXCoord(v);\n    if (pos >= 0.0 && pos < 1.0) {\n      this.xticks.push({ pos: pos, label: label, has_tick: has_tick });\n    }\n  }\n\n  this.yticks = [];\n  for (i = 0; i < this.yAxes_.length; i++) {\n    var axis = this.yAxes_[i];\n    for (var j = 0; j < axis.ticks.length; j++) {\n      tick = axis.ticks[j];\n      label = tick.label;\n      has_tick = !('label_v' in tick);\n      v = has_tick ? tick.v : tick.label_v;\n      pos = this.dygraph_.toPercentYCoord(v, i);\n      if (pos > 0.0 && pos <= 1.0) {\n        this.yticks.push({ axis: i, pos: pos, label: label, has_tick: has_tick });\n      }\n    }\n  }\n};\n\nDygraphLayout.prototype._evaluateAnnotations = function () {\n  // Add the annotations to the point to which they belong.\n  // Make a map from (setName, xval) to annotation for quick lookups.\n  var i;\n  var annotations = {};\n  for (i = 0; i < this.annotations.length; i++) {\n    var a = this.annotations[i];\n    annotations[a.xval + \",\" + a.series] = a;\n  }\n\n  this.annotated_points = [];\n\n  // Exit the function early if there are no annotations.\n  if (!this.annotations || !this.annotations.length) {\n    return;\n  }\n\n  // TODO(antrob): loop through annotations not points.\n  for (var setIdx = 0; setIdx < this.points.length; setIdx++) {\n    var points = this.points[setIdx];\n    for (i = 0; i < points.length; i++) {\n      var p = points[i];\n      var k = p.xval + \",\" + p.name;\n      if (k in annotations) {\n        p.annotation = annotations[k];\n        this.annotated_points.push(p);\n      }\n    }\n  }\n};\n\n/**\n * Convenience function to remove all the data sets from a graph\n */\nDygraphLayout.prototype.removeAllDatasets = function () {\n  delete this.points;\n  delete this.setNames;\n  delete this.setPointsLengths;\n  delete this.setPointsOffsets;\n  this.points = [];\n  this.setNames = [];\n  this.setPointsLengths = [];\n  this.setPointsOffsets = [];\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DygraphLayout);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLWxheW91dC5qcz9mODlkIl0sIm5hbWVzIjpbIkR5Z3JhcGhMYXlvdXQiLCJkeWdyYXBoIiwiZHlncmFwaF8iLCJwb2ludHMiLCJzZXROYW1lcyIsImFubm90YXRpb25zIiwieUF4ZXNfIiwieFRpY2tzXyIsInlUaWNrc18iLCJwcm90b3R5cGUiLCJhZGREYXRhc2V0Iiwic2V0bmFtZSIsInNldF94eSIsInB1c2giLCJnZXRQbG90QXJlYSIsImFyZWFfIiwiY29tcHV0ZVBsb3RBcmVhIiwiYXJlYSIsIngiLCJ5IiwidyIsIndpZHRoXyIsImdldE9wdGlvbiIsImgiLCJoZWlnaHRfIiwiZSIsImNoYXJ0X2RpdiIsImdyYXBoRGl2IiwicmVzZXJ2ZVNwYWNlTGVmdCIsInB4IiwiciIsInJlc2VydmVTcGFjZVJpZ2h0IiwicmVzZXJ2ZVNwYWNlVG9wIiwicmVzZXJ2ZVNwYWNlQm90dG9tIiwiY2hhcnRSZWN0IiwiY2FzY2FkZUV2ZW50c18iLCJzZXRBbm5vdGF0aW9ucyIsImFubiIsInBhcnNlIiwiaSIsImxlbmd0aCIsImEiLCJ4dmFsIiwidW5kZWZpbmVkIiwiY29uc29sZSIsImVycm9yIiwiaWNvbiIsImhhc093blByb3BlcnR5IiwidXRpbHMiLCJzZXRYVGlja3MiLCJ4VGlja3MiLCJzZXRZQXhlcyIsInlBeGVzIiwiZXZhbHVhdGUiLCJfeEF4aXMiLCJfZXZhbHVhdGVMaW1pdHMiLCJfZXZhbHVhdGVMaW5lQ2hhcnRzIiwiX2V2YWx1YXRlTGluZVRpY2tzIiwiX2V2YWx1YXRlQW5ub3RhdGlvbnMiLCJ4bGltaXRzIiwieEF4aXNSYW5nZSIsIm1pbnZhbCIsIm1heHZhbCIsInhyYW5nZSIsInNjYWxlIiwiZ2V0T3B0aW9uRm9yQXhpcyIsInhsb2dyYW5nZSIsInhsb2dzY2FsZSIsImF4aXMiLCJtaW55dmFsIiwiY29tcHV0ZWRWYWx1ZVJhbmdlIiwibWF4eXZhbCIsInlyYW5nZSIsInlzY2FsZSIsInlsb2dyYW5nZSIsInlsb2dzY2FsZSIsImlzRmluaXRlIiwiaXNOYU4iLCJnIiwiY2FsY1hOb3JtYWxfIiwidmFsdWUiLCJ4QXhpcyIsImxvZ3NjYWxlIiwiY2FsY1lOb3JtYWxfIiwiTmFOIiwiaXNTdGFja2VkIiwiaXNMb2dzY2FsZUZvclgiLCJzZXRJZHgiLCJzZXROYW1lIiwiY29ubmVjdFNlcGFyYXRlZCIsImF4aXNQcm9wZXJ0aWVzRm9yU2VyaWVzIiwiYXR0cmlidXRlc18iLCJnZXRGb3JTZXJpZXMiLCJqIiwicG9pbnQiLCJ5dmFsIiwieV9zdGFja2VkIiwieXZhbF9zdGFja2VkIiwiZGF0YUhhbmRsZXJfIiwib25MaW5lRXZhbHVhdGVkIiwidGljayIsImxhYmVsIiwicG9zIiwidiIsImhhc190aWNrIiwieHRpY2tzIiwibGFiZWxfdiIsInRvUGVyY2VudFhDb29yZCIsInl0aWNrcyIsInRpY2tzIiwidG9QZXJjZW50WUNvb3JkIiwic2VyaWVzIiwiYW5ub3RhdGVkX3BvaW50cyIsInAiLCJrIiwibmFtZSIsImFubm90YXRpb24iLCJyZW1vdmVBbGxEYXRhc2V0cyIsInNldFBvaW50c0xlbmd0aHMiLCJzZXRQb2ludHNPZmZzZXRzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOzs7Ozs7QUFNQTs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLElBQUlBLGdCQUFnQixTQUFoQkEsYUFBZ0IsQ0FBU0MsT0FBVCxFQUFrQjtBQUNwQyxPQUFLQyxRQUFMLEdBQWdCRCxPQUFoQjtBQUNBOzs7Ozs7Ozs7OztBQVdBLE9BQUtFLE1BQUwsR0FBYyxFQUFkO0FBQ0EsT0FBS0MsUUFBTCxHQUFnQixFQUFoQjtBQUNBLE9BQUtDLFdBQUwsR0FBbUIsRUFBbkI7QUFDQSxPQUFLQyxNQUFMLEdBQWMsSUFBZDs7QUFFQTtBQUNBO0FBQ0EsT0FBS0MsT0FBTCxHQUFlLElBQWY7QUFDQSxPQUFLQyxPQUFMLEdBQWUsSUFBZjtBQUNELENBdEJEOztBQXdCQTs7Ozs7O0FB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QUFGLEdBQWUvRyxZQUFZNkcsQ0FBWixDQUFmO0FBQ0EsYUFBS0YsZ0JBQUwsQ0FBc0JuRyxJQUF0QixDQUEyQm9HLENBQTNCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsQ0E3QkQ7O0FBK0JBOzs7QUFHQWpILGNBQWNTLFNBQWQsQ0FBd0I0RyxpQkFBeEIsR0FBNEMsWUFBVztBQUNyRCxTQUFPLEtBQUtsSCxNQUFaO0FBQ0EsU0FBTyxLQUFLQyxRQUFaO0FBQ0EsU0FBTyxLQUFLa0gsZ0JBQVo7QUFDQSxTQUFPLEtBQUtDLGdCQUFaO0FBQ0EsT0FBS3BILE1BQUwsR0FBYyxFQUFkO0FBQ0EsT0FBS0MsUUFBTCxHQUFnQixFQUFoQjtBQUNBLE9BQUtrSCxnQkFBTCxHQUF3QixFQUF4QjtBQUNBLE9BQUtDLGdCQUFMLEdBQXdCLEVBQXhCO0FBQ0QsQ0FURDs7QUFXQSx5REFBZXZILGFBQWYiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMSBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBCYXNlZCBvbiBQbG90S2l0TGF5b3V0LCBidXQgbW9kaWZpZWQgdG8gbWVldCB0aGUgbmVlZHMgb2ZcbiAqIGR5Z3JhcGhzLlxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2R5Z3JhcGgtdXRpbHMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgRHlncmFwaExheW91dCBvYmplY3QuXG4gKlxuICogVGhpcyBjbGFzcyBjb250YWlucyBhbGwgdGhlIGRhdGEgdG8gYmUgY2hhcnRlZC5cbiAqIEl0IHVzZXMgZGF0YSBjb29yZGluYXRlcywgYnV0IGFsc28gcmVjb3JkcyB0aGUgY2hhcnQgcmFuZ2UgKGluIGRhdGFcbiAqIGNvb3JkaW5hdGVzKSBhbmQgaGVuY2UgaXMgYWJsZSB0byBjYWxjdWxhdGUgcGVyY2VudGFnZSBwb3NpdGlvbnMgKCdJbiB0aGlzXG4gKiB2aWV3LCBQb2ludCBBIGxpZXMgMjUlIGRvd24gdGhlIHgtYXhpcy4nKVxuICpcbiAqIFR3byB0aGluZ3MgdGhhdCBpdCBkb2VzIG5vdCBkbyBhcmU6XG4gKiAxLiBSZWNvcmQgcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGFueXRoaW5nLlxuICogMi4gKG9kZGx5KSBkZXRlcm1pbmUgYW55dGhpbmcgYWJvdXQgdGhlIGxheW91dCBvZiBjaGFydCBlbGVtZW50cy5cbiAqXG4gKiBUaGUgbmFtaW5nIGlzIGEgdmVzdGlnZSBvZiBEeWdyYXBoJ3Mgb3JpZ2luYWwgUGxvdEtpdCByb290cy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIER5Z3JhcGhMYXlvdXQgPSBmdW5jdGlvbihkeWdyYXBoKSB7XG4gIHRoaXMuZHlncmFwaF8gPSBkeWdyYXBoO1xuICAvKipcbiAgICogQXJyYXkgb2YgcG9pbnRzIGZvciBlYWNoIHNlcmllcy5cbiAgICpcbiAgICogW3NlcmllcyBpbmRleF1bcm93IGluZGV4IGluIHNlcmllc10gPSB8UG9pbnR8IHN0cnVjdHVyZSxcbiAgICogd2hlcmUgc2VyaWVzIGluZGV4IHJlZmVycyB0byB2aXNpYmxlIHNlcmllcyBvbmx5LCBhbmQgdGhlXG4gICAqIHBvaW50IGluZGV4IGlzIGZvciB0aGUgcmVkdWNlZCBzZXQgb2YgcG9pbnRzIGZvciB0aGUgY3VycmVudFxuICAgKiB6b29tIHJlZ2lvbiAoaW5jbHVkaW5nIG9uZSBwb2ludCBqdXN0IG91dHNpZGUgdGhlIHdpbmRvdykuXG4gICAqIEFsbCBwb2ludHMgaW4gdGhlIHNhbWUgcm93IGluZGV4IHNoYXJlIHRoZSBzYW1lIFggdmFsdWUuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheS48QXJyYXkuPER5Z3JhcGguUG9pbnRUeXBlPj59XG4gICAqL1xuICB0aGlzLnBvaW50cyA9IFtdO1xuICB0aGlzLnNldE5hbWVzID0gW107XG4gIHRoaXMuYW5ub3RhdGlvbnMgPSBbXTtcbiAgdGhpcy55QXhlc18gPSBudWxsO1xuXG4gIC8vIFRPRE8oZGFudmspOiBpdCdzIG9kZCB0aGF0IHhUaWNrc18gYW5kIHlUaWNrc18gYXJlIGlucHV0cywgYnV0IHh0aWNrcyBhbmRcbiAgLy8geXRpY2tzIGFyZSBvdXRwdXRzLiBDbGVhbiB0aGlzIHVwLlxuICB0aGlzLnhUaWNrc18gPSBudWxsO1xuICB0aGlzLnlUaWNrc18gPSBudWxsO1xufTtcblxuLyoqXG4gKiBBZGQgcG9pbnRzIGZvciBhIHNpbmdsZSBzZXJpZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNldG5hbWUgTmFtZSBvZiB0aGUgc2VyaWVzLlxuICogQHBhcmFtIHtBcnJheS48RHlncmFwaC5Qb2ludFR5cGU+fSBzZXRfeHkgUG9pbnRzIGZvciB0aGUgc2VyaWVzLlxuICovXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5hZGREYXRhc2V0ID0gZnVuY3Rpb24oc2V0bmFtZSwgc2V0X3h5KSB7XG4gIHRoaXMucG9pbnRzLnB1c2goc2V0X3h5KTtcbiAgdGhpcy5zZXROYW1lcy5wdXNoKHNldG5hbWUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBib3ggd2hpY2ggdGhlIGNoYXJ0IHNob3VsZCBiZSBkcmF3biBpbi4gVGhpcyBpcyB0aGUgY2FudmFzJ3NcbiAqIGJveCwgbGVzcyBzcGFjZSBuZWVkZWQgZm9yIHRoZSBheGlzIGFuZCBjaGFydCBsYWJlbHMuXG4gKlxuICogQHJldHVybiB7e3g6IG51bWJlciwgeTogbnVtYmVyLCB3OiBudW1iZXIsIGg6IG51bWJlcn19XG4gKi9cbkR5Z3JhcGhMYXlvdXQucHJvdG90eXBlLmdldFBsb3RBcmVhID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmFyZWFfO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgYm94IHdoaWNoIHRoZSBjaGFydCBzaG91bGQgYmUgZHJhd24gaW4uIFRoaXMgaXMgdGhlIGNhbnZhcydzXG4vLyBib3gsIGxlc3Mgc3BhY2UgbmVlZGVkIGZvciBheGlzLCBjaGFydCBsYWJlbHMsIGFuZCBvdGhlciBwbHVnLWlucy5cbi8vIE5PVEU6IFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJ5IER5Z3JhcGgucHJlZHJhd18oKS5cbkR5Z3JhcGhMYXlvdXQucHJvdG90eXBlLmNvbXB1dGVQbG90QXJlYSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXJlYSA9IHtcbiAgICAvLyBUT0RPKGRhbnZrKTogcGVyLWF4aXMgc2V0dGluZy5cbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBhcmVhLncgPSB0aGlzLmR5Z3JhcGhfLndpZHRoXyAtIGFyZWEueCAtIHRoaXMuZHlncmFwaF8uZ2V0T3B0aW9uKCdyaWdodEdhcCcpO1xuICBhcmVhLmggPSB0aGlzLmR5Z3JhcGhfLmhlaWdodF87XG5cbiAgLy8gTGV0IHBsdWdpbnMgcmVzZXJ2ZSBzcGFjZS5cbiAgdmFyIGUgPSB7XG4gICAgY2hhcnRfZGl2OiB0aGlzLmR5Z3JhcGhfLmdyYXBoRGl2LFxuICAgIHJlc2VydmVTcGFjZUxlZnQ6IGZ1bmN0aW9uKHB4KSB7XG4gICAgICB2YXIgciA9IHtcbiAgICAgICAgeDogYXJlYS54LFxuICAgICAgICB5OiBhcmVhLnksXG4gICAgICAgIHc6IHB4LFxuICAgICAgICBoOiBhcmVhLmhcbiAgICAgIH07XG4gICAgICBhcmVhLnggKz0gcHg7XG4gICAgICBhcmVhLncgLT0gcHg7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIHJlc2VydmVTcGFjZVJpZ2h0OiBmdW5jdGlvbihweCkge1xuICAgICAgdmFyIHIgPSB7XG4gICAgICAgIHg6IGFyZWEueCArIGFyZWEudyAtIHB4LFxuICAgICAgICB5OiBhcmVhLnksXG4gICAgICAgIHc6IHB4LFxuICAgICAgICBoOiBhcmVhLmhcbiAgICAgIH07XG4gICAgICBhcmVhLncgLT0gcHg7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIHJlc2VydmVTcGFjZVRvcDogZnVuY3Rpb24ocHgpIHtcbiAgICAgIHZhciByID0ge1xuICAgICAgICB4OiBhcmVhLngsXG4gICAgICAgIHk6IGFyZWEueSxcbiAgICAgICAgdzogYXJlYS53LFxuICAgICAgICBoOiBweFxuICAgICAgfTtcbiAgICAgIGFyZWEueSArPSBweDtcbiAgICAgIGFyZWEuaCAtPSBweDtcbiAgICAgIHJldHVybiByO1xuICAgIH0sXG4gICAgcmVzZXJ2ZVNwYWNlQm90dG9tOiBmdW5jdGlvbihweCkge1xuICAgICAgdmFyIHIgPSB7XG4gICAgICAgIHg6IGFyZWEueCxcbiAgICAgICAgeTogYXJlYS55ICsgYXJlYS5oIC0gcHgsXG4gICAgICAgIHc6IGFyZWEudyxcbiAgICAgICAgaDogcHhcbiAgICAgIH07XG4gICAgICBhcmVhLmggLT0gcHg7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIGNoYXJ0UmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge3g6YXJlYS54LCB5OmFyZWEueSwgdzphcmVhLncsIGg6YXJlYS5ofTtcbiAgICB9XG4gIH07XG4gIHRoaXMuZHlncmFwaF8uY2FzY2FkZUV2ZW50c18oJ2xheW91dCcsIGUpO1xuXG4gIHRoaXMuYXJlYV8gPSBhcmVhO1xufTtcblxuRHlncmFwaExheW91dC5wcm90b3R5cGUuc2V0QW5ub3RhdGlvbnMgPSBmdW5jdGlvbihhbm4pIHtcbiAgLy8gVGhlIER5Z3JhcGggb2JqZWN0J3MgYW5ub3RhdGlvbnMgYXJlbid0IHBhcnNlZC4gV2UgcGFyc2UgdGhlbSBoZXJlIGFuZFxuICAvLyBzYXZlIGEgY29weS4gSWYgdGhlcmUgaXMgbm8gcGFyc2VyLCB0aGVuIHRoZSB1c2VyIG11c3QgYmUgdXNpbmcgcmF3IGZvcm1hdC5cbiAgdGhpcy5hbm5vdGF0aW9ucyA9IFtdO1xuICB2YXIgcGFyc2UgPSB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbigneFZhbHVlUGFyc2VyJykgfHwgZnVuY3Rpb24oeCkgeyByZXR1cm4geDsgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbm4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYSA9IHt9O1xuICAgIGlmICghYW5uW2ldLnh2YWwgJiYgYW5uW2ldLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkFubm90YXRpb25zIG11c3QgaGF2ZSBhbiAneCcgcHJvcGVydHlcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhbm5baV0uaWNvbiAmJlxuICAgICAgICAhKGFubltpXS5oYXNPd25Qcm9wZXJ0eSgnd2lkdGgnKSAmJlxuICAgICAgICAgIGFubltpXS5oYXNPd25Qcm9wZXJ0eSgnaGVpZ2h0JykpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiTXVzdCBzZXQgd2lkdGggYW5kIGhlaWdodCB3aGVuIHNldHRpbmcgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImFubm90YXRpb24uaWNvbiBwcm9wZXJ0eVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXRpbHMudXBkYXRlKGEsIGFubltpXSk7XG4gICAgaWYgKCFhLnh2YWwpIGEueHZhbCA9IHBhcnNlKGEueCk7XG4gICAgdGhpcy5hbm5vdGF0aW9ucy5wdXNoKGEpO1xuICB9XG59O1xuXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5zZXRYVGlja3MgPSBmdW5jdGlvbih4VGlja3MpIHtcbiAgdGhpcy54VGlja3NfID0geFRpY2tzO1xufTtcblxuLy8gVE9ETyhkYW52ayk6IGFkZCB0aGlzIHRvIHRoZSBEeWdyYXBoIG9iamVjdCdzIEFQSSBvciBtb3ZlIGl0IGludG8gTGF5b3V0LlxuRHlncmFwaExheW91dC5wcm90b3R5cGUuc2V0WUF4ZXMgPSBmdW5jdGlvbiAoeUF4ZXMpIHtcbiAgdGhpcy55QXhlc18gPSB5QXhlcztcbn07XG5cbkR5Z3JhcGhMYXlvdXQucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3hBeGlzID0ge307XG4gIHRoaXMuX2V2YWx1YXRlTGltaXRzKCk7XG4gIHRoaXMuX2V2YWx1YXRlTGluZUNoYXJ0cygpO1xuICB0aGlzLl9ldmFsdWF0ZUxpbmVUaWNrcygpO1xuICB0aGlzLl9ldmFsdWF0ZUFubm90YXRpb25zKCk7XG59O1xuXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5fZXZhbHVhdGVMaW1pdHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHhsaW1pdHMgPSB0aGlzLmR5Z3JhcGhfLnhBeGlzUmFuZ2UoKTtcbiAgdGhpcy5feEF4aXMubWludmFsID0geGxpbWl0c1swXTtcbiAgdGhpcy5feEF4aXMubWF4dmFsID0geGxpbWl0c1sxXTtcbiAgdmFyIHhyYW5nZSA9IHhsaW1pdHNbMV0gLSB4bGltaXRzWzBdO1xuICB0aGlzLl94QXhpcy5zY2FsZSA9ICh4cmFuZ2UgIT09IDAgPyAxIC8geHJhbmdlIDogMS4wKTtcblxuICBpZiAodGhpcy5keWdyYXBoXy5nZXRPcHRpb25Gb3JBeGlzKFwibG9nc2NhbGVcIiwgJ3gnKSkge1xuICAgIHRoaXMuX3hBeGlzLnhsb2dyYW5nZSA9IHV0aWxzLmxvZzEwKHRoaXMuX3hBeGlzLm1heHZhbCkgLSB1dGlscy5sb2cxMCh0aGlzLl94QXhpcy5taW52YWwpO1xuICAgIHRoaXMuX3hBeGlzLnhsb2dzY2FsZSA9ICh0aGlzLl94QXhpcy54bG9ncmFuZ2UgIT09IDAgPyAxLjAgLyB0aGlzLl94QXhpcy54bG9ncmFuZ2UgOiAxLjApO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy55QXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXhpcyA9IHRoaXMueUF4ZXNfW2ldO1xuICAgIGF4aXMubWlueXZhbCA9IGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdO1xuICAgIGF4aXMubWF4eXZhbCA9IGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzFdO1xuICAgIGF4aXMueXJhbmdlID0gYXhpcy5tYXh5dmFsIC0gYXhpcy5taW55dmFsO1xuICAgIGF4aXMueXNjYWxlID0gKGF4aXMueXJhbmdlICE9PSAwID8gMS4wIC8gYXhpcy55cmFuZ2UgOiAxLjApO1xuXG4gICAgaWYgKHRoaXMuZHlncmFwaF8uZ2V0T3B0aW9uKFwibG9nc2NhbGVcIikpIHtcbiAgICAgIGF4aXMueWxvZ3JhbmdlID0gdXRpbHMubG9nMTAoYXhpcy5tYXh5dmFsKSAtIHV0aWxzLmxvZzEwKGF4aXMubWlueXZhbCk7XG4gICAgICBheGlzLnlsb2dzY2FsZSA9IChheGlzLnlsb2dyYW5nZSAhPT0gMCA/IDEuMCAvIGF4aXMueWxvZ3JhbmdlIDogMS4wKTtcbiAgICAgIGlmICghaXNGaW5pdGUoYXhpcy55bG9ncmFuZ2UpIHx8IGlzTmFOKGF4aXMueWxvZ3JhbmdlKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdheGlzICcgKyBpICsgJyBvZiBncmFwaCBhdCAnICsgYXhpcy5nICtcbiAgICAgICAgICAgICAgICAgICAgICAnIGNhblxcJ3QgYmUgZGlzcGxheWVkIGluIGxvZyBzY2FsZSBmb3IgcmFuZ2UgWycgK1xuICAgICAgICAgICAgICAgICAgICAgIGF4aXMubWlueXZhbCArICcgLSAnICsgYXhpcy5tYXh5dmFsICsgJ10nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkR5Z3JhcGhMYXlvdXQuY2FsY1hOb3JtYWxfID0gZnVuY3Rpb24odmFsdWUsIHhBeGlzLCBsb2dzY2FsZSkge1xuICBpZiAobG9nc2NhbGUpIHtcbiAgICByZXR1cm4gKCh1dGlscy5sb2cxMCh2YWx1ZSkgLSB1dGlscy5sb2cxMCh4QXhpcy5taW52YWwpKSAqIHhBeGlzLnhsb2dzY2FsZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh2YWx1ZSAtIHhBeGlzLm1pbnZhbCkgKiB4QXhpcy5zY2FsZTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0R5Z3JhcGhBeGlzVHlwZX0gYXhpc1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvZ3NjYWxlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkR5Z3JhcGhMYXlvdXQuY2FsY1lOb3JtYWxfID0gZnVuY3Rpb24oYXhpcywgdmFsdWUsIGxvZ3NjYWxlKSB7XG4gIGlmIChsb2dzY2FsZSkge1xuICAgIHZhciB4ID0gMS4wIC0gKCh1dGlscy5sb2cxMCh2YWx1ZSkgLSB1dGlscy5sb2cxMChheGlzLm1pbnl2YWwpKSAqIGF4aXMueWxvZ3NjYWxlKTtcbiAgICByZXR1cm4gaXNGaW5pdGUoeCkgPyB4IDogTmFOOyAgLy8gc2hpbSBmb3IgdjggaXNzdWU7IHNlZSBwdWxsIHJlcXVlc3QgMjc2XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDEuMCAtICgodmFsdWUgLSBheGlzLm1pbnl2YWwpICogYXhpcy55c2NhbGUpO1xuICB9XG59O1xuXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5fZXZhbHVhdGVMaW5lQ2hhcnRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpc1N0YWNrZWQgPSB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbihcInN0YWNrZWRHcmFwaFwiKTtcbiAgdmFyIGlzTG9nc2NhbGVGb3JYID0gdGhpcy5keWdyYXBoXy5nZXRPcHRpb25Gb3JBeGlzKFwibG9nc2NhbGVcIiwgJ3gnKTtcblxuICBmb3IgKHZhciBzZXRJZHggPSAwOyBzZXRJZHggPCB0aGlzLnBvaW50cy5sZW5ndGg7IHNldElkeCsrKSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzW3NldElkeF07XG4gICAgdmFyIHNldE5hbWUgPSB0aGlzLnNldE5hbWVzW3NldElkeF07XG4gICAgdmFyIGNvbm5lY3RTZXBhcmF0ZWQgPSB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbignY29ubmVjdFNlcGFyYXRlZFBvaW50cycsIHNldE5hbWUpO1xuICAgIHZhciBheGlzID0gdGhpcy5keWdyYXBoXy5heGlzUHJvcGVydGllc0ZvclNlcmllcyhzZXROYW1lKTtcbiAgICAvLyBUT0RPIChrb25pZ3NiZXJnKTogdXNlIG9wdGlvbnNGb3JBeGlzIGluc3RlYWQuXG4gICAgdmFyIGxvZ3NjYWxlID0gdGhpcy5keWdyYXBoXy5hdHRyaWJ1dGVzXy5nZXRGb3JTZXJpZXMoXCJsb2dzY2FsZVwiLCBzZXROYW1lKTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcG9pbnQgPSBwb2ludHNbal07XG5cbiAgICAgIC8vIFJhbmdlIGZyb20gMC0xIHdoZXJlIDAgcmVwcmVzZW50cyBsZWZ0IGFuZCAxIHJlcHJlc2VudHMgcmlnaHQuXG4gICAgICBwb2ludC54ID0gRHlncmFwaExheW91dC5jYWxjWE5vcm1hbF8ocG9pbnQueHZhbCwgdGhpcy5feEF4aXMsIGlzTG9nc2NhbGVGb3JYKTtcbiAgICAgIC8vIFJhbmdlIGZyb20gMC0xIHdoZXJlIDAgcmVwcmVzZW50cyB0b3AgYW5kIDEgcmVwcmVzZW50cyBib3R0b21cbiAgICAgIHZhciB5dmFsID0gcG9pbnQueXZhbDtcbiAgICAgIGlmIChpc1N0YWNrZWQpIHtcbiAgICAgICAgcG9pbnQueV9zdGFja2VkID0gRHlncmFwaExheW91dC5jYWxjWU5vcm1hbF8oXG4gICAgICAgICAgICBheGlzLCBwb2ludC55dmFsX3N0YWNrZWQsIGxvZ3NjYWxlKTtcbiAgICAgICAgaWYgKHl2YWwgIT09IG51bGwgJiYgIWlzTmFOKHl2YWwpKSB7XG4gICAgICAgICAgeXZhbCA9IHBvaW50Lnl2YWxfc3RhY2tlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHl2YWwgPT09IG51bGwpIHtcbiAgICAgICAgeXZhbCA9IE5hTjtcbiAgICAgICAgaWYgKCFjb25uZWN0U2VwYXJhdGVkKSB7XG4gICAgICAgICAgcG9pbnQueXZhbCA9IE5hTjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcG9pbnQueSA9IER5Z3JhcGhMYXlvdXQuY2FsY1lOb3JtYWxfKGF4aXMsIHl2YWwsIGxvZ3NjYWxlKTtcbiAgICB9XG5cbiAgICB0aGlzLmR5Z3JhcGhfLmRhdGFIYW5kbGVyXy5vbkxpbmVFdmFsdWF0ZWQocG9pbnRzLCBheGlzLCBsb2dzY2FsZSk7XG4gIH1cbn07XG5cbkR5Z3JhcGhMYXlvdXQucHJvdG90eXBlLl9ldmFsdWF0ZUxpbmVUaWNrcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaSwgdGljaywgbGFiZWwsIHBvcywgdiwgaGFzX3RpY2s7XG4gIHRoaXMueHRpY2tzID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnhUaWNrc18ubGVuZ3RoOyBpKyspIHtcbiAgICB0aWNrID0gdGhpcy54VGlja3NfW2ldO1xuICAgIGxhYmVsID0gdGljay5sYWJlbDtcbiAgICBoYXNfdGljayA9ICEoJ2xhYmVsX3YnIGluIHRpY2spO1xuICAgIHYgPSBoYXNfdGljayA/IHRpY2sudiA6IHRpY2subGFiZWxfdjtcbiAgICBwb3MgPSB0aGlzLmR5Z3JhcGhfLnRvUGVyY2VudFhDb29yZCh2KTtcbiAgICBpZiAoKHBvcyA+PSAwLjApICYmIChwb3MgPCAxLjApKSB7XG4gICAgICB0aGlzLnh0aWNrcy5wdXNoKHtwb3MsIGxhYmVsLCBoYXNfdGlja30pO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMueXRpY2tzID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnlBeGVzXy5sZW5ndGg7IGkrKyApIHtcbiAgICB2YXIgYXhpcyA9IHRoaXMueUF4ZXNfW2ldO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXhpcy50aWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgdGljayA9IGF4aXMudGlja3Nbal07XG4gICAgICBsYWJlbCA9IHRpY2subGFiZWw7XG4gICAgICBoYXNfdGljayA9ICEoJ2xhYmVsX3YnIGluIHRpY2spO1xuICAgICAgdiA9IGhhc190aWNrID8gdGljay52IDogdGljay5sYWJlbF92O1xuICAgICAgcG9zID0gdGhpcy5keWdyYXBoXy50b1BlcmNlbnRZQ29vcmQodiwgaSk7XG4gICAgICBpZiAoKHBvcyA+IDAuMCkgJiYgKHBvcyA8PSAxLjApKSB7XG4gICAgICAgIHRoaXMueXRpY2tzLnB1c2goe2F4aXM6IGksIHBvcywgbGFiZWwsIGhhc190aWNrfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5fZXZhbHVhdGVBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAvLyBBZGQgdGhlIGFubm90YXRpb25zIHRvIHRoZSBwb2ludCB0byB3aGljaCB0aGV5IGJlbG9uZy5cbiAgLy8gTWFrZSBhIG1hcCBmcm9tIChzZXROYW1lLCB4dmFsKSB0byBhbm5vdGF0aW9uIGZvciBxdWljayBsb29rdXBzLlxuICB2YXIgaTtcbiAgdmFyIGFubm90YXRpb25zID0ge307XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLmFubm90YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGEgPSB0aGlzLmFubm90YXRpb25zW2ldO1xuICAgIGFubm90YXRpb25zW2EueHZhbCArIFwiLFwiICsgYS5zZXJpZXNdID0gYTtcbiAgfVxuXG4gIHRoaXMuYW5ub3RhdGVkX3BvaW50cyA9IFtdO1xuXG4gIC8vIEV4aXQgdGhlIGZ1bmN0aW9uIGVhcmx5IGlmIHRoZXJlIGFyZSBubyBhbm5vdGF0aW9ucy5cbiAgaWYgKCF0aGlzLmFubm90YXRpb25zIHx8ICF0aGlzLmFubm90YXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE8oYW50cm9iKTogbG9vcCB0aHJvdWdoIGFubm90YXRpb25zIG5vdCBwb2ludHMuXG4gIGZvciAodmFyIHNldElkeCA9IDA7IHNldElkeCA8IHRoaXMucG9pbnRzLmxlbmd0aDsgc2V0SWR4KyspIHtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHNbc2V0SWR4XTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICAgIHZhciBrID0gcC54dmFsICsgXCIsXCIgKyBwLm5hbWU7XG4gICAgICBpZiAoayBpbiBhbm5vdGF0aW9ucykge1xuICAgICAgICBwLmFubm90YXRpb24gPSBhbm5vdGF0aW9uc1trXTtcbiAgICAgICAgdGhpcy5hbm5vdGF0ZWRfcG9pbnRzLnB1c2gocCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHJlbW92ZSBhbGwgdGhlIGRhdGEgc2V0cyBmcm9tIGEgZ3JhcGhcbiAqL1xuRHlncmFwaExheW91dC5wcm90b3R5cGUucmVtb3ZlQWxsRGF0YXNldHMgPSBmdW5jdGlvbigpIHtcbiAgZGVsZXRlIHRoaXMucG9pbnRzO1xuICBkZWxldGUgdGhpcy5zZXROYW1lcztcbiAgZGVsZXRlIHRoaXMuc2V0UG9pbnRzTGVuZ3RocztcbiAgZGVsZXRlIHRoaXMuc2V0UG9pbnRzT2Zmc2V0cztcbiAgdGhpcy5wb2ludHMgPSBbXTtcbiAgdGhpcy5zZXROYW1lcyA9IFtdO1xuICB0aGlzLnNldFBvaW50c0xlbmd0aHMgPSBbXTtcbiAgdGhpcy5zZXRQb2ludHNPZmZzZXRzID0gW107XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEeWdyYXBoTGF5b3V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9keWdyYXBocy9zcmMvZHlncmFwaC1sYXlvdXQuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar OPTIONS_REFERENCE = null;\n\n// For \"production\" code, this gets removed by uglifyjs.\nif (typeof process !== 'undefined') {\n  if (process.env.NODE_ENV != 'production') {\n\n    // NOTE: in addition to parsing as JS, this snippet is expected to be valid\n    // JSON. This assumption cannot be checked in JS, but it will be checked when\n    // documentation is generated by the generate-documentation.py script. For the\n    // most part, this just means that you should always use double quotes.\n    OPTIONS_REFERENCE = // <JSON>\n    {\n      \"xValueParser\": {\n        \"default\": \"parseFloat() or Date.parse()*\",\n        \"labels\": [\"CSV parsing\"],\n        \"type\": \"function(str) -> number\",\n        \"description\": \"A function which parses x-values (i.e. the dependent series). Must return a number, even when the values are dates. In this case, millis since epoch are used. This is used primarily for parsing CSV data. *=Dygraphs is slightly more accepting in the dates which it will parse. See code for details.\"\n      },\n      \"stackedGraph\": {\n        \"default\": \"false\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"boolean\",\n        \"description\": \"If set, stack series on top of one another rather than drawing them independently. The first series specified in the input data will wind up on top of the chart and the last will be on bottom. NaN values are drawn as white areas without a line on top, see stackedGraphNaNFill for details.\"\n      },\n      \"stackedGraphNaNFill\": {\n        \"default\": \"all\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"string\",\n        \"description\": \"Controls handling of NaN values inside a stacked graph. NaN values are interpolated/extended for stacking purposes, but the actual point value remains NaN in the legend display. Valid option values are \\\"all\\\" (interpolate internally, repeat leftmost and rightmost value as needed), \\\"inside\\\" (interpolate internally only, use zero outside leftmost and rightmost value), and \\\"none\\\" (treat NaN as zero everywhere).\"\n      },\n      \"pointSize\": {\n        \"default\": \"1\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"integer\",\n        \"description\": \"The size of the dot to draw on each point in pixels (see drawPoints). A dot is always drawn when a point is \\\"isolated\\\", i.e. there is a missing point on either side of it. This also controls the size of those dots.\"\n      },\n      \"drawPoints\": {\n        \"default\": \"false\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"boolean\",\n        \"description\": \"Draw a small dot at each point, in addition to a line going through the point. This makes the individual data points easier to see, but can increase visual clutter in the chart. The small dot can be replaced with a custom rendering by supplying a <a href='#drawPointCallback'>drawPointCallback</a>.\"\n      },\n      \"drawGapEdgePoints\": {\n        \"default\": \"false\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"boolean\",\n        \"description\": \"Draw points at the edges of gaps in the data. This improves visibility of small data segments or other data irregularities.\"\n      },\n      \"drawPointCallback\": {\n        \"default\": \"null\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"function(g, seriesName, canvasContext, cx, cy, color, pointSize)\",\n        \"parameters\": [[\"g\", \"the reference graph\"], [\"seriesName\", \"the name of the series\"], [\"canvasContext\", \"the canvas to draw on\"], [\"cx\", \"center x coordinate\"], [\"cy\", \"center y coordinate\"], [\"color\", \"series color\"], [\"pointSize\", \"the radius of the image.\"], [\"idx\", \"the row-index of the point in the data.\"]],\n        \"description\": \"Draw a custom item when drawPoints is enabled. Default is a small dot matching the series color. This method should constrain drawing to within pointSize pixels from (cx, cy).  Also see <a href='#drawHighlightPointCallback'>drawHighlightPointCallback</a>\"\n      },\n      \"height\": {\n        \"default\": \"320\",\n        \"labels\": [\"Overall display\"],\n        \"type\": \"integer\",\n        \"description\": \"Height, in pixels, of the chart. If the container div has been explicitly sized, this will be ignored.\"\n      },\n      \"zoomCallback\": {\n        \"default\": \"null\",\n        \"labels\": [\"Callbacks\"],\n        \"type\": \"function(minDate, maxDate, yRanges)\",\n        \"parameters\": [[\"minDate\", \"milliseconds since epoch\"], [\"maxDate\", \"milliseconds since epoch.\"], [\"yRanges\", \"is an array of [bottom, top] pairs, one for each y-axis.\"]],\n        \"description\": \"A function to call when the zoom window is changed (either by zooming in or out). When animatedZooms is set, zoomCallback is called once at the end of the transition (it will not be called for intermediate frames).\"\n      },\n      \"pointClickCallback\": {\n        \"snippet\": \"function(e, point){<br>&nbsp;&nbsp;alert(point);<br>}\",\n        \"default\": \"null\",\n        \"labels\": [\"Callbacks\", \"Interactive Elements\"],\n        \"type\": \"function(e, point)\",\n        \"parameters\": [[\"e\", \"the event object for the click\"], [\"point\", \"the point that was clicked See <a href='#point_properties'>Point properties</a> for details\"]],\n        \"description\": \"A function to call when a data point is clicked. and the point that was clicked.\"\n      },\n      \"color\": {\n        \"default\": \"(see description)\",\n        \"labels\": [\"Data Series Colors\"],\n        \"type\": \"string\",\n        \"example\": \"red\",\n        \"description\": \"A per-series color definition. Used in conjunction with, and overrides, the colors option.\"\n      },\n      \"colors\": {\n        \"default\": \"(see description)\",\n        \"labels\": [\"Data Series Colors\"],\n        \"type\": \"array<string>\",\n        \"example\": \"['red', '#00FF00']\",\n        \"description\": \"List of colors for the data series. These can be of the form \\\"#AABBCC\\\" or \\\"rgb(255,100,200)\\\" or \\\"yellow\\\", etc. If not specified, equally-spaced points around a color wheel are used. Overridden by the 'color' option.\"\n      },\n      \"connectSeparatedPoints\": {\n        \"default\": \"false\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"boolean\",\n        \"description\": \"Usually, when Dygraphs encounters a missing value in a data series, it interprets this as a gap and draws it as such. If, instead, the missing values represents an x-value for which only a different series has data, then you'll want to connect the dots by setting this to true. To explicitly include a gap with this option set, use a value of NaN.\"\n      },\n      \"highlightCallback\": {\n        \"default\": \"null\",\n        \"labels\": [\"Callbacks\"],\n        \"type\": \"function(event, x, points, row, seriesName)\",\n        \"description\": \"When set, this callback gets called every time a new point is highlighted.\",\n        \"parameters\": [[\"event\", \"the JavaScript mousemove event\"], [\"x\", \"the x-coordinate of the highlighted points\"], [\"points\", \"an array of highlighted points: <code>[ {name: 'series', yval: y-value}, &hellip; ]</code>\"], [\"row\", \"integer index of the highlighted row in the data table, starting from 0\"], [\"seriesName\", \"name of the highlighted series, only present if highlightSeriesOpts is set.\"]]\n      },\n      \"drawHighlightPointCallback\": {\n        \"default\": \"null\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"function(g, seriesName, canvasContext, cx, cy, color, pointSize)\",\n        \"parameters\": [[\"g\", \"the reference graph\"], [\"seriesName\", \"the name of the series\"], [\"canvasContext\", \"the canvas to draw on\"], [\"cx\", \"center x coordinate\"], [\"cy\", \"center y coordinate\"], [\"color\", \"series color\"], [\"pointSize\", \"the radius of the image.\"], [\"idx\", \"the row-index of the point in the data.\"]],\n        \"description\": \"Draw a custom item when a point is highlighted.  Default is a small dot matching the series color. This method should constrain drawing to within pointSize pixels from (cx, cy) Also see <a href='#drawPointCallback'>drawPointCallback</a>\"\n      },\n      \"highlightSeriesOpts\": {\n        \"default\": \"null\",\n        \"labels\": [\"Interactive Elements\"],\n        \"type\": \"Object\",\n        \"description\": \"When set, the options from this object are applied to the timeseries closest to the mouse pointer for interactive highlighting. See also 'highlightCallback'. Example: highlightSeriesOpts: { strokeWidth: 3 }.\"\n      },\n      \"highlightSeriesBackgroundAlpha\": {\n        \"default\": \"0.5\",\n        \"labels\": [\"Interactive Elements\"],\n        \"type\": \"float\",\n        \"description\": \"Fade the background while highlighting series. 1=fully visible background (disable fading), 0=hiddden background (show highlighted series only).\"\n      },\n      \"highlightSeriesBackgroundColor\": {\n        \"default\": \"rgb(255, 255, 255)\",\n        \"labels\": [\"Interactive Elements\"],\n        \"type\": \"string\",\n        \"description\": \"Sets the background color used to fade out the series in conjunction with 'highlightSeriesBackgroundAlpha'.\"\n      },\n      \"includeZero\": {\n        \"default\": \"false\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"boolean\",\n        \"description\": \"Usually, dygraphs will use the range of the data plus some padding to set the range of the y-axis. If this option is set, the y-axis will always include zero, typically as the lowest value. This can be used to avoid exaggerating the variance in the data\"\n      },\n      \"rollPeriod\": {\n        \"default\": \"1\",\n        \"labels\": [\"Error Bars\", \"Rolling Averages\"],\n        \"type\": \"integer &gt;= 1\",\n        \"description\": \"Number of days over which to average data. Discussed extensively above.\"\n      },\n      \"unhighlightCallback\": {\n        \"default\": \"null\",\n        \"labels\": [\"Callbacks\"],\n        \"type\": \"function(event)\",\n        \"parameters\": [[\"event\", \"the mouse event\"]],\n        \"description\": \"When set, this callback gets called every time the user stops highlighting any point by mousing out of the graph.\"\n      },\n      \"axisTickSize\": {\n        \"default\": \"3.0\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"number\",\n        \"description\": \"The size of the line to display next to each tick mark on x- or y-axes.\"\n      },\n      \"labelsSeparateLines\": {\n        \"default\": \"false\",\n        \"labels\": [\"Legend\"],\n        \"type\": \"boolean\",\n        \"description\": \"Put <code>&lt;br/&gt;</code> between lines in the label string. Often used in conjunction with <strong>labelsDiv</strong>.\"\n      },\n      \"valueFormatter\": {\n        \"default\": \"Depends on the type of your data.\",\n        \"labels\": [\"Legend\", \"Value display/formatting\"],\n        \"type\": \"function(num or millis, opts, seriesName, dygraph, row, col)\",\n        \"description\": \"Function to provide a custom display format for the values displayed on mouseover. This does not affect the values that appear on tick marks next to the axes. To format those, see axisLabelFormatter. This is usually set on a <a href='per-axis.html'>per-axis</a> basis. .\",\n        \"parameters\": [[\"num_or_millis\", \"The value to be formatted. This is always a number. For date axes, it's millis since epoch. You can call new Date(millis) to get a Date object.\"], [\"opts\", \"This is a function you can call to access various options (e.g. opts('labelsKMB')). It returns per-axis values for the option when available.\"], [\"seriesName\", \"The name of the series from which the point came, e.g. 'X', 'Y', 'A', etc.\"], [\"dygraph\", \"The dygraph object for which the formatting is being done\"], [\"row\", \"The row of the data from which this point comes. g.getValue(row, 0) will return the x-value for this point.\"], [\"col\", \"The column of the data from which this point comes. g.getValue(row, col) will return the original y-value for this point. This can be used to get the full confidence interval for the point, or access un-rolled values for the point.\"]]\n      },\n      \"annotationMouseOverHandler\": {\n        \"default\": \"null\",\n        \"labels\": [\"Annotations\"],\n        \"type\": \"function(annotation, point, dygraph, event)\",\n        \"description\": \"If provided, this function is called whenever the user mouses over an annotation.\"\n      },\n      \"annotationMouseOutHandler\": {\n        \"default\": \"null\",\n        \"labels\": [\"Annotations\"],\n        \"type\": \"function(annotation, point, dygraph, event)\",\n        \"parameters\": [[\"annotation\", \"the annotation left\"], [\"point\", \"the point associated with the annotation\"], [\"dygraph\", \"the reference graph\"], [\"event\", \"the mouse event\"]],\n        \"description\": \"If provided, this function is called whenever the user mouses out of an annotation.\"\n      },\n      \"annotationClickHandler\": {\n        \"default\": \"null\",\n        \"labels\": [\"Annotations\"],\n        \"type\": \"function(annotation, point, dygraph, event)\",\n        \"parameters\": [[\"annotation\", \"the annotation left\"], [\"point\", \"the point associated with the annotation\"], [\"dygraph\", \"the reference graph\"], [\"event\", \"the mouse event\"]],\n        \"description\": \"If provided, this function is called whenever the user clicks on an annotation.\"\n      },\n      \"annotationDblClickHandler\": {\n        \"default\": \"null\",\n        \"labels\": [\"Annotations\"],\n        \"type\": \"function(annotation, point, dygraph, event)\",\n        \"parameters\": [[\"annotation\", \"the annotation left\"], [\"point\", \"the point associated with the annotation\"], [\"dygraph\", \"the reference graph\"], [\"event\", \"the mouse event\"]],\n        \"description\": \"If provided, this function is called whenever the user double-clicks on an annotation.\"\n      },\n      \"drawCallback\": {\n        \"default\": \"null\",\n        \"labels\": [\"Callbacks\"],\n        \"type\": \"function(dygraph, is_initial)\",\n        \"parameters\": [[\"dygraph\", \"The graph being drawn\"], [\"is_initial\", \"True if this is the initial draw, false for subsequent draws.\"]],\n        \"description\": \"When set, this callback gets called every time the dygraph is drawn. This includes the initial draw, after zooming and repeatedly while panning.\"\n      },\n      \"labelsKMG2\": {\n        \"default\": \"false\",\n        \"labels\": [\"Value display/formatting\"],\n        \"type\": \"boolean\",\n        \"description\": \"Show k/M/G for kilo/Mega/Giga on y-axis. This is different than <code>labelsKMB</code> in that it uses base 2, not 10.\"\n      },\n      \"delimiter\": {\n        \"default\": \",\",\n        \"labels\": [\"CSV parsing\"],\n        \"type\": \"string\",\n        \"description\": \"The delimiter to look for when separating fields of a CSV file. Setting this to a tab is not usually necessary, since tab-delimited data is auto-detected.\"\n      },\n      \"axisLabelFontSize\": {\n        \"default\": \"14\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"integer\",\n        \"description\": \"Size of the font (in pixels) to use in the axis labels, both x- and y-axis.\"\n      },\n      \"underlayCallback\": {\n        \"default\": \"null\",\n        \"labels\": [\"Callbacks\"],\n        \"type\": \"function(context, area, dygraph)\",\n        \"parameters\": [[\"context\", \"the canvas drawing context on which to draw\"], [\"area\", \"An object with {x,y,w,h} properties describing the drawing area.\"], [\"dygraph\", \"the reference graph\"]],\n        \"description\": \"When set, this callback gets called before the chart is drawn. It details on how to use this.\"\n      },\n      \"width\": {\n        \"default\": \"480\",\n        \"labels\": [\"Overall display\"],\n        \"type\": \"integer\",\n        \"description\": \"Width, in pixels, of the chart. If the container div has been explicitly sized, this will be ignored.\"\n      },\n      \"pixelRatio\": {\n        \"default\": \"(devicePixelRatio / context.backingStoreRatio)\",\n        \"labels\": [\"Overall display\"],\n        \"type\": \"float\",\n        \"description\": \"Overrides the pixel ratio scaling factor for the canvas's 2d context. Ordinarily, this is set to the devicePixelRatio / (context.backingStoreRatio || 1), so on mobile devices, where the devicePixelRatio can be somewhere around 3, performance can be improved by overriding this value to something less precise, like 1, at the expense of resolution.\"\n      },\n      \"interactionModel\": {\n        \"default\": \"...\",\n        \"labels\": [\"Interactive Elements\"],\n        \"type\": \"Object\",\n        \"description\": \"TODO(konigsberg): document this\"\n      },\n      \"ticker\": {\n        \"default\": \"Dygraph.dateTicker or Dygraph.numericTicks\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"function(min, max, pixels, opts, dygraph, vals) -> [{v: ..., label: ...}, ...]\",\n        \"parameters\": [[\"min\", \"\"], [\"max\", \"\"], [\"pixels\", \"\"], [\"opts\", \"\"], [\"dygraph\", \"the reference graph\"], [\"vals\", \"\"]],\n        \"description\": \"This lets you specify an arbitrary function to generate tick marks on an axis. The tick marks are an array of (value, label) pairs. The built-in functions go to great lengths to choose good tick marks so, if you set this option, you'll most likely want to call one of them and modify the result. See dygraph-tickers.js for an extensive discussion. This is set on a <a href='per-axis.html'>per-axis</a> basis.\"\n      },\n      \"xAxisHeight\": {\n        \"default\": \"(null)\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"integer\",\n        \"description\": \"Height, in pixels, of the x-axis. If not set explicitly, this is computed based on axisLabelFontSize and axisTickSize.\"\n      },\n      \"showLabelsOnHighlight\": {\n        \"default\": \"true\",\n        \"labels\": [\"Interactive Elements\", \"Legend\"],\n        \"type\": \"boolean\",\n        \"description\": \"Whether to show the legend upon mouseover.\"\n      },\n      \"axis\": {\n        \"default\": \"(none)\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"string\",\n        \"description\": \"Set to either 'y1' or 'y2' to assign a series to a y-axis (primary or secondary). Must be set per-series.\"\n      },\n      \"pixelsPerLabel\": {\n        \"default\": \"70 (x-axis) or 30 (y-axes)\",\n        \"labels\": [\"Axis display\", \"Grid\"],\n        \"type\": \"integer\",\n        \"description\": \"Number of pixels to require between each x- and y-label. Larger values will yield a sparser axis with fewer ticks. This is set on a <a href='per-axis.html'>per-axis</a> basis.\"\n      },\n      \"labelsDiv\": {\n        \"default\": \"null\",\n        \"labels\": [\"Legend\"],\n        \"type\": \"DOM element or string\",\n        \"example\": \"<code style='font-size: small'>document.getElementById('foo')</code>or<code>'foo'\",\n        \"description\": \"Show data labels in an external div, rather than on the graph.  This value can either be a div element or a div id.\"\n      },\n      \"fractions\": {\n        \"default\": \"false\",\n        \"labels\": [\"CSV parsing\", \"Error Bars\"],\n        \"type\": \"boolean\",\n        \"description\": \"When set, attempt to parse each cell in the CSV file as \\\"a/b\\\", where a and b are integers. The ratio will be plotted. This allows computation of Wilson confidence intervals (see below).\"\n      },\n      \"logscale\": {\n        \"default\": \"false\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"boolean\",\n        \"description\": \"When set for the y-axis or x-axis, the graph shows that axis in log scale. Any values less than or equal to zero are not displayed. Showing log scale with ranges that go below zero will result in an unviewable graph.\\n\\n Not compatible with showZero. connectSeparatedPoints is ignored. This is ignored for date-based x-axes.\"\n      },\n      \"strokeWidth\": {\n        \"default\": \"1.0\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"float\",\n        \"example\": \"0.5, 2.0\",\n        \"description\": \"The width of the lines connecting data points. This can be used to increase the contrast or some graphs.\"\n      },\n      \"strokePattern\": {\n        \"default\": \"null\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"array<integer>\",\n        \"example\": \"[10, 2, 5, 2]\",\n        \"description\": \"A custom pattern array where the even index is a draw and odd is a space in pixels. If null then it draws a solid line. The array should have a even length as any odd lengthed array could be expressed as a smaller even length array. This is used to create dashed lines.\"\n      },\n      \"strokeBorderWidth\": {\n        \"default\": \"null\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"float\",\n        \"example\": \"1.0\",\n        \"description\": \"Draw a border around graph lines to make crossing lines more easily distinguishable. Useful for graphs with many lines.\"\n      },\n      \"strokeBorderColor\": {\n        \"default\": \"white\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"string\",\n        \"example\": \"red, #ccffdd\",\n        \"description\": \"Color for the line border used if strokeBorderWidth is set.\"\n      },\n      \"wilsonInterval\": {\n        \"default\": \"true\",\n        \"labels\": [\"Error Bars\"],\n        \"type\": \"boolean\",\n        \"description\": \"Use in conjunction with the \\\"fractions\\\" option. Instead of plotting +/- N standard deviations, dygraphs will compute a Wilson confidence interval and plot that. This has more reasonable behavior for ratios close to 0 or 1.\"\n      },\n      \"fillGraph\": {\n        \"default\": \"false\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"boolean\",\n        \"description\": \"Should the area underneath the graph be filled? This option is not compatible with error bars. This may be set on a <a href='per-axis.html'>per-series</a> basis.\"\n      },\n      \"highlightCircleSize\": {\n        \"default\": \"3\",\n        \"labels\": [\"Interactive Elements\"],\n        \"type\": \"integer\",\n        \"description\": \"The size in pixels of the dot drawn over highlighted points.\"\n      },\n      \"gridLineColor\": {\n        \"default\": \"rgb(128,128,128)\",\n        \"labels\": [\"Grid\"],\n        \"type\": \"red, blue\",\n        \"description\": \"The color of the gridlines. This may be set on a per-axis basis to define each axis' grid separately.\"\n      },\n      \"gridLinePattern\": {\n        \"default\": \"null\",\n        \"labels\": [\"Grid\"],\n        \"type\": \"array<integer>\",\n        \"example\": \"[10, 2, 5, 2]\",\n        \"description\": \"A custom pattern array where the even index is a draw and odd is a space in pixels. If null then it draws a solid line. The array should have a even length as any odd lengthed array could be expressed as a smaller even length array. This is used to create dashed gridlines.\"\n      },\n      \"visibility\": {\n        \"default\": \"[true, true, ...]\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"Array of booleans\",\n        \"description\": \"Which series should initially be visible? Once the Dygraph has been constructed, you can access and modify the visibility of each series using the <code>visibility</code> and <code>setVisibility</code> methods.\"\n      },\n      \"valueRange\": {\n        \"default\": \"Full range of the input is shown\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"Array of two numbers\",\n        \"example\": \"[10, 110]\",\n        \"description\": \"Explicitly set the vertical range of the graph to [low, high]. This may be set on a per-axis basis to define each y-axis separately. If either limit is unspecified, it will be calculated automatically (e.g. [null, 30] to automatically calculate just the lower bound)\"\n      },\n      \"colorSaturation\": {\n        \"default\": \"1.0\",\n        \"labels\": [\"Data Series Colors\"],\n        \"type\": \"float (0.0 - 1.0)\",\n        \"description\": \"If <strong>colors</strong> is not specified, saturation of the automatically-generated data series colors.\"\n      },\n      \"hideOverlayOnMouseOut\": {\n        \"default\": \"true\",\n        \"labels\": [\"Interactive Elements\", \"Legend\"],\n        \"type\": \"boolean\",\n        \"description\": \"Whether to hide the legend when the mouse leaves the chart area.\"\n      },\n      \"legend\": {\n        \"default\": \"onmouseover\",\n        \"labels\": [\"Legend\"],\n        \"type\": \"string\",\n        \"description\": \"When to display the legend. By default, it only appears when a user mouses over the chart. Set it to \\\"always\\\" to always display a legend of some sort. When set to \\\"follow\\\", legend follows highlighted points.\"\n      },\n      \"legendFormatter\": {\n        \"default\": \"null\",\n        \"labels\": [\"Legend\"],\n        \"type\": \"function(data): string\",\n        \"params\": [[\"data\", \"An object containing information about the selection (or lack of a selection). This includes formatted values and series information. See <a href=\\\"https://github.com/danvk/dygraphs/pull/683\\\">here</a> for sample values.\"]],\n        \"description\": \"Set this to supply a custom formatter for the legend. See <a href=\\\"https://github.com/danvk/dygraphs/pull/683\\\">this comment</a> and the <a href=\\\"tests/legend-formatter.html\\\">legendFormatter demo</a> for usage.\"\n      },\n      \"labelsShowZeroValues\": {\n        \"default\": \"true\",\n        \"labels\": [\"Legend\"],\n        \"type\": \"boolean\",\n        \"description\": \"Show zero value labels in the labelsDiv.\"\n      },\n      \"stepPlot\": {\n        \"default\": \"false\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"boolean\",\n        \"description\": \"When set, display the graph as a step plot instead of a line plot. This option may either be set for the whole graph or for single series.\"\n      },\n      \"labelsUTC\": {\n        \"default\": \"false\",\n        \"labels\": [\"Value display/formatting\", \"Axis display\"],\n        \"type\": \"boolean\",\n        \"description\": \"Show date/time labels according to UTC (instead of local time).\"\n      },\n      \"labelsKMB\": {\n        \"default\": \"false\",\n        \"labels\": [\"Value display/formatting\"],\n        \"type\": \"boolean\",\n        \"description\": \"Show K/M/B for thousands/millions/billions on y-axis.\"\n      },\n      \"rightGap\": {\n        \"default\": \"5\",\n        \"labels\": [\"Overall display\"],\n        \"type\": \"integer\",\n        \"description\": \"Number of pixels to leave blank at the right edge of the Dygraph. This makes it easier to highlight the right-most data point.\"\n      },\n      \"drawAxesAtZero\": {\n        \"default\": \"false\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"boolean\",\n        \"description\": \"When set, draw the X axis at the Y=0 position and the Y axis at the X=0 position if those positions are inside the graph's visible area. Otherwise, draw the axes at the bottom or left graph edge as usual.\"\n      },\n      \"xRangePad\": {\n        \"default\": \"0\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"float\",\n        \"description\": \"Add the specified amount of extra space (in pixels) around the X-axis value range to ensure points at the edges remain visible.\"\n      },\n      \"yRangePad\": {\n        \"default\": \"null\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"float\",\n        \"description\": \"If set, add the specified amount of extra space (in pixels) around the Y-axis value range to ensure points at the edges remain visible. If unset, use the traditional Y padding algorithm.\"\n      },\n      \"axisLabelFormatter\": {\n        \"default\": \"Depends on the data type\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"function(number or Date, granularity, opts, dygraph)\",\n        \"parameters\": [[\"number or date\", \"Either a number (for a numeric axis) or a Date object (for a date axis)\"], [\"granularity\", \"specifies how fine-grained the axis is. For date axes, this is a reference to the time granularity enumeration, defined in dygraph-tickers.js, e.g. Dygraph.WEEKLY.\"], [\"opts\", \"a function which provides access to various options on the dygraph, e.g. opts('labelsKMB').\"], [\"dygraph\", \"the referenced graph\"]],\n        \"description\": \"Function to call to format the tick values that appear along an axis. This is usually set on a <a href='per-axis.html'>per-axis</a> basis.\"\n      },\n      \"clickCallback\": {\n        \"snippet\": \"function(e, date_millis){<br>&nbsp;&nbsp;alert(new Date(date_millis));<br>}\",\n        \"default\": \"null\",\n        \"labels\": [\"Callbacks\"],\n        \"type\": \"function(e, x, points)\",\n        \"parameters\": [[\"e\", \"The event object for the click\"], [\"x\", \"The x value that was clicked (for dates, this is milliseconds since epoch)\"], [\"points\", \"The closest points along that date. See <a href='#point_properties'>Point properties</a> for details.\"]],\n        \"description\": \"A function to call when the canvas is clicked.\"\n      },\n      \"labels\": {\n        \"default\": \"[\\\"X\\\", \\\"Y1\\\", \\\"Y2\\\", ...]*\",\n        \"labels\": [\"Legend\"],\n        \"type\": \"array<string>\",\n        \"description\": \"A name for each data series, including the independent (X) series. For CSV files and DataTable objections, this is determined by context. For raw data, this must be specified. If it is not, default values are supplied and a warning is logged.\"\n      },\n      \"dateWindow\": {\n        \"default\": \"Full range of the input is shown\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"Array of two numbers\",\n        \"example\": \"[<br>&nbsp;&nbsp;Date.parse('2006-01-01'),<br>&nbsp;&nbsp;(new Date()).valueOf()<br>]\",\n        \"description\": \"Initially zoom in on a section of the graph. Is of the form [earliest, latest], where earliest/latest are milliseconds since epoch. If the data for the x-axis is numeric, the values in dateWindow must also be numbers.\"\n      },\n      \"showRoller\": {\n        \"default\": \"false\",\n        \"labels\": [\"Interactive Elements\", \"Rolling Averages\"],\n        \"type\": \"boolean\",\n        \"description\": \"If the rolling average period text box should be shown.\"\n      },\n      \"sigma\": {\n        \"default\": \"2.0\",\n        \"labels\": [\"Error Bars\"],\n        \"type\": \"float\",\n        \"description\": \"When errorBars is set, shade this many standard deviations above/below each point.\"\n      },\n      \"customBars\": {\n        \"default\": \"false\",\n        \"labels\": [\"CSV parsing\", \"Error Bars\"],\n        \"type\": \"boolean\",\n        \"description\": \"When set, parse each CSV cell as \\\"low;middle;high\\\". Error bars will be drawn for each point between low and high, with the series itself going through middle.\"\n      },\n      \"colorValue\": {\n        \"default\": \"1.0\",\n        \"labels\": [\"Data Series Colors\"],\n        \"type\": \"float (0.0 - 1.0)\",\n        \"description\": \"If colors is not specified, value of the data series colors, as in hue/saturation/value. (0.0-1.0, default 0.5)\"\n      },\n      \"errorBars\": {\n        \"default\": \"false\",\n        \"labels\": [\"CSV parsing\", \"Error Bars\"],\n        \"type\": \"boolean\",\n        \"description\": \"Does the data contain standard deviations? Setting this to true alters the input format (see above).\"\n      },\n      \"displayAnnotations\": {\n        \"default\": \"false\",\n        \"labels\": [\"Annotations\"],\n        \"type\": \"boolean\",\n        \"description\": \"Only applies when Dygraphs is used as a GViz chart. Causes string columns following a data series to be interpreted as annotations on points in that series. This is the same format used by Google's AnnotatedTimeLine chart.\"\n      },\n      \"panEdgeFraction\": {\n        \"default\": \"null\",\n        \"labels\": [\"Axis display\", \"Interactive Elements\"],\n        \"type\": \"float\",\n        \"description\": \"A value representing the farthest a graph may be panned, in percent of the display. For example, a value of 0.1 means that the graph can only be panned 10% passed the edges of the displayed values. null means no bounds.\"\n      },\n      \"title\": {\n        \"labels\": [\"Chart labels\"],\n        \"type\": \"string\",\n        \"default\": \"null\",\n        \"description\": \"Text to display above the chart. You can supply any HTML for this value, not just text. If you wish to style it using CSS, use the 'dygraph-label' or 'dygraph-title' classes.\"\n      },\n      \"titleHeight\": {\n        \"default\": \"18\",\n        \"labels\": [\"Chart labels\"],\n        \"type\": \"integer\",\n        \"description\": \"Height of the chart title, in pixels. This also controls the default font size of the title. If you style the title on your own, this controls how much space is set aside above the chart for the title's div.\"\n      },\n      \"xlabel\": {\n        \"labels\": [\"Chart labels\"],\n        \"type\": \"string\",\n        \"default\": \"null\",\n        \"description\": \"Text to display below the chart's x-axis. You can supply any HTML for this value, not just text. If you wish to style it using CSS, use the 'dygraph-label' or 'dygraph-xlabel' classes.\"\n      },\n      \"xLabelHeight\": {\n        \"labels\": [\"Chart labels\"],\n        \"type\": \"integer\",\n        \"default\": \"18\",\n        \"description\": \"Height of the x-axis label, in pixels. This also controls the default font size of the x-axis label. If you style the label on your own, this controls how much space is set aside below the chart for the x-axis label's div.\"\n      },\n      \"ylabel\": {\n        \"labels\": [\"Chart labels\"],\n        \"type\": \"string\",\n        \"default\": \"null\",\n        \"description\": \"Text to display to the left of the chart's y-axis. You can supply any HTML for this value, not just text. If you wish to style it using CSS, use the 'dygraph-label' or 'dygraph-ylabel' classes. The text will be rotated 90 degrees by default, so CSS rules may behave in unintuitive ways. No additional space is set aside for a y-axis label. If you need more space, increase the width of the y-axis tick labels using the yAxisLabelWidth option. If you need a wider div for the y-axis label, either style it that way with CSS (but remember that it's rotated, so width is controlled by the 'height' property) or set the yLabelWidth option.\"\n      },\n      \"y2label\": {\n        \"labels\": [\"Chart labels\"],\n        \"type\": \"string\",\n        \"default\": \"null\",\n        \"description\": \"Text to display to the right of the chart's secondary y-axis. This label is only displayed if a secondary y-axis is present. See <a href='http://dygraphs.com/tests/two-axes.html'>this test</a> for an example of how to do this. The comments for the 'ylabel' option generally apply here as well. This label gets a 'dygraph-y2label' instead of a 'dygraph-ylabel' class.\"\n      },\n      \"yLabelWidth\": {\n        \"labels\": [\"Chart labels\"],\n        \"type\": \"integer\",\n        \"default\": \"18\",\n        \"description\": \"Width of the div which contains the y-axis label. Since the y-axis label appears rotated 90 degrees, this actually affects the height of its div.\"\n      },\n      \"drawGrid\": {\n        \"default\": \"true for x and y, false for y2\",\n        \"labels\": [\"Grid\"],\n        \"type\": \"boolean\",\n        \"description\": \"Whether to display gridlines in the chart. This may be set on a per-axis basis to define the visibility of each axis' grid separately.\"\n      },\n      \"independentTicks\": {\n        \"default\": \"true for y, false for y2\",\n        \"labels\": [\"Axis display\", \"Grid\"],\n        \"type\": \"boolean\",\n        \"description\": \"Only valid for y and y2, has no effect on x: This option defines whether the y axes should align their ticks or if they should be independent. Possible combinations: 1.) y=true, y2=false (default): y is the primary axis and the y2 ticks are aligned to the the ones of y. (only 1 grid) 2.) y=false, y2=true: y2 is the primary axis and the y ticks are aligned to the the ones of y2. (only 1 grid) 3.) y=true, y2=true: Both axis are independent and have their own ticks. (2 grids) 4.) y=false, y2=false: Invalid configuration causes an error.\"\n      },\n      \"drawAxis\": {\n        \"default\": \"true for x and y, false for y2\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"boolean\",\n        \"description\": \"Whether to draw the specified axis. This may be set on a per-axis basis to define the visibility of each axis separately. Setting this to false also prevents axis ticks from being drawn and reclaims the space for the chart grid/lines.\"\n      },\n      \"gridLineWidth\": {\n        \"default\": \"0.3\",\n        \"labels\": [\"Grid\"],\n        \"type\": \"float\",\n        \"description\": \"Thickness (in pixels) of the gridlines drawn under the chart. The vertical/horizontal gridlines can be turned off entirely by using the drawGrid option. This may be set on a per-axis basis to define each axis' grid separately.\"\n      },\n      \"axisLineWidth\": {\n        \"default\": \"0.3\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"float\",\n        \"description\": \"Thickness (in pixels) of the x- and y-axis lines.\"\n      },\n      \"axisLineColor\": {\n        \"default\": \"black\",\n        \"labels\": [\"Axis display\"],\n        \"type\": \"string\",\n        \"description\": \"Color of the x- and y-axis lines. Accepts any value which the HTML canvas strokeStyle attribute understands, e.g. 'black' or 'rgb(0, 100, 255)'.\"\n      },\n      \"fillAlpha\": {\n        \"default\": \"0.15\",\n        \"labels\": [\"Error Bars\", \"Data Series Colors\"],\n        \"type\": \"float (0.0 - 1.0)\",\n        \"description\": \"Error bars (or custom bars) for each series are drawn in the same color as the series, but with partial transparency. This sets the transparency. A value of 0.0 means that the error bars will not be drawn, whereas a value of 1.0 means that the error bars will be as dark as the line for the series itself. This can be used to produce chart lines whose thickness varies at each point.\"\n      },\n      \"axisLabelWidth\": {\n        \"default\": \"50 (y-axis), 60 (x-axis)\",\n        \"labels\": [\"Axis display\", \"Chart labels\"],\n        \"type\": \"integer\",\n        \"description\": \"Width (in pixels) of the containing divs for x- and y-axis labels. For the y-axis, this also controls the width of the y-axis. Note that for the x-axis, this is independent from pixelsPerLabel, which controls the spacing between labels.\"\n      },\n      \"sigFigs\": {\n        \"default\": \"null\",\n        \"labels\": [\"Value display/formatting\"],\n        \"type\": \"integer\",\n        \"description\": \"By default, dygraphs displays numbers with a fixed number of digits after the decimal point. If you'd prefer to have a fixed number of significant figures, set this option to that number of sig figs. A value of 2, for instance, would cause 1 to be display as 1.0 and 1234 to be displayed as 1.23e+3.\"\n      },\n      \"digitsAfterDecimal\": {\n        \"default\": \"2\",\n        \"labels\": [\"Value display/formatting\"],\n        \"type\": \"integer\",\n        \"description\": \"Unless it's run in scientific mode (see the <code>sigFigs</code> option), dygraphs displays numbers with <code>digitsAfterDecimal</code> digits after the decimal point. Trailing zeros are not displayed, so with a value of 2 you'll get '0', '0.1', '0.12', '123.45' but not '123.456' (it will be rounded to '123.46'). Numbers with absolute value less than 0.1^digitsAfterDecimal (i.e. those which would show up as '0.00') will be displayed in scientific notation.\"\n      },\n      \"maxNumberWidth\": {\n        \"default\": \"6\",\n        \"labels\": [\"Value display/formatting\"],\n        \"type\": \"integer\",\n        \"description\": \"When displaying numbers in normal (not scientific) mode, large numbers will be displayed with many trailing zeros (e.g. 100000000 instead of 1e9). This can lead to unwieldy y-axis labels. If there are more than <code>maxNumberWidth</code> digits to the left of the decimal in a number, dygraphs will switch to scientific notation, even when not operating in scientific mode. If you'd like to see all those digits, set this to something large, like 20 or 30.\"\n      },\n      \"file\": {\n        \"default\": \"(set when constructed)\",\n        \"labels\": [\"Data\"],\n        \"type\": \"string (URL of CSV or CSV), GViz DataTable or 2D Array\",\n        \"description\": \"Sets the data being displayed in the chart. This can only be set when calling updateOptions; it cannot be set from the constructor. For a full description of valid data formats, see the <a href='http://dygraphs.com/data.html'>Data Formats</a> page.\"\n      },\n      \"timingName\": {\n        \"default\": \"null\",\n        \"labels\": [\"Debugging\", \"Deprecated\"],\n        \"type\": \"string\",\n        \"description\": \"Set this option to log timing information. The value of the option will be logged along with the timimg, so that you can distinguish multiple dygraphs on the same page.\"\n      },\n      \"showRangeSelector\": {\n        \"default\": \"false\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"boolean\",\n        \"description\": \"Show or hide the range selector widget.\"\n      },\n      \"rangeSelectorHeight\": {\n        \"default\": \"40\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"integer\",\n        \"description\": \"Height, in pixels, of the range selector widget. This option can only be specified at Dygraph creation time.\"\n      },\n      \"rangeSelectorPlotStrokeColor\": {\n        \"default\": \"#808FAB\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"string\",\n        \"description\": \"The range selector mini plot stroke color. This can be of the form \\\"#AABBCC\\\" or \\\"rgb(255,100,200)\\\" or \\\"yellow\\\". You can also specify null or \\\"\\\" to turn off stroke.\"\n      },\n      \"rangeSelectorPlotFillColor\": {\n        \"default\": \"#A7B1C4\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"string\",\n        \"description\": \"The range selector mini plot fill color. This can be of the form \\\"#AABBCC\\\" or \\\"rgb(255,100,200)\\\" or \\\"yellow\\\". You can also specify null or \\\"\\\" to turn off fill.\"\n      },\n      \"rangeSelectorPlotFillGradientColor\": {\n        \"default\": \"white\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"string\",\n        \"description\": \"The top color for the range selector mini plot fill color gradient. This can be of the form \\\"#AABBCC\\\" or \\\"rgb(255,100,200)\\\" or \\\"rgba(255,100,200,42)\\\" or \\\"yellow\\\". You can also specify null or \\\"\\\" to disable the gradient and fill with one single color.\"\n      },\n      \"rangeSelectorBackgroundStrokeColor\": {\n        \"default\": \"gray\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"string\",\n        \"description\": \"The color of the lines below and on both sides of the range selector mini plot. This can be of the form \\\"#AABBCC\\\" or \\\"rgb(255,100,200)\\\" or \\\"yellow\\\".\"\n      },\n      \"rangeSelectorBackgroundLineWidth\": {\n        \"default\": \"1\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"float\",\n        \"description\": \"The width of the lines below and on both sides of the range selector mini plot.\"\n      },\n      \"rangeSelectorPlotLineWidth\": {\n        \"default\": \"1.5\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"float\",\n        \"description\": \"The width of the range selector mini plot line.\"\n      },\n      \"rangeSelectorForegroundStrokeColor\": {\n        \"default\": \"black\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"string\",\n        \"description\": \"The color of the lines in the interactive layer of the range selector. This can be of the form \\\"#AABBCC\\\" or \\\"rgb(255,100,200)\\\" or \\\"yellow\\\".\"\n      },\n      \"rangeSelectorForegroundLineWidth\": {\n        \"default\": \"1\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"float\",\n        \"description\": \"The width the lines in the interactive layer of the range selector.\"\n      },\n      \"rangeSelectorAlpha\": {\n        \"default\": \"0.6\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"float (0.0 - 1.0)\",\n        \"description\": \"The transparency of the veil that is drawn over the unselected portions of the range selector mini plot. A value of 0 represents full transparency and the unselected portions of the mini plot will appear as normal. A value of 1 represents full opacity and the unselected portions of the mini plot will be hidden.\"\n      },\n      \"showInRangeSelector\": {\n        \"default\": \"null\",\n        \"labels\": [\"Range Selector\"],\n        \"type\": \"boolean\",\n        \"description\": \"Mark this series for inclusion in the range selector. The mini plot curve will be an average of all such series. If this is not specified for any series, the default behavior is to average all the visible series. Setting it for one series will result in that series being charted alone in the range selector. Once it's set for a single series, it needs to be set for all series which should be included (regardless of visibility).\"\n      },\n      \"animatedZooms\": {\n        \"default\": \"false\",\n        \"labels\": [\"Interactive Elements\"],\n        \"type\": \"boolean\",\n        \"description\": \"Set this option to animate the transition between zoom windows. Applies to programmatic and interactive zooms. Note that if you also set a drawCallback, it will be called several times on each zoom. If you set a zoomCallback, it will only be called after the animation is complete.\"\n      },\n      \"plotter\": {\n        \"default\": \"[DygraphCanvasRenderer.Plotters.fillPlotter, DygraphCanvasRenderer.Plotters.errorPlotter, DygraphCanvasRenderer.Plotters.linePlotter]\",\n        \"labels\": [\"Data Line display\"],\n        \"type\": \"array or function\",\n        \"description\": \"A function (or array of functions) which plot each data series on the chart. TODO(danvk): more details! May be set per-series.\"\n      },\n      \"axes\": {\n        \"default\": \"null\",\n        \"labels\": [\"Configuration\"],\n        \"type\": \"Object\",\n        \"description\": \"Defines per-axis options. Valid keys are 'x', 'y' and 'y2'. Only some options may be set on a per-axis basis. If an option may be set in this way, it will be noted on this page. See also documentation on <a href='http://dygraphs.com/per-axis.html'>per-series and per-axis options</a>.\"\n      },\n      \"series\": {\n        \"default\": \"null\",\n        \"labels\": [\"Series\"],\n        \"type\": \"Object\",\n        \"description\": \"Defines per-series options. Its keys match the y-axis label names, and the values are dictionaries themselves that contain options specific to that series.\"\n      },\n      \"plugins\": {\n        \"default\": \"[]\",\n        \"labels\": [\"Configuration\"],\n        \"type\": \"Array<plugin>\",\n        \"description\": \"Defines per-graph plugins. Useful for per-graph customization\"\n      },\n      \"dataHandler\": {\n        \"default\": \"(depends on data)\",\n        \"labels\": [\"Data\"],\n        \"type\": \"Dygraph.DataHandler\",\n        \"description\": \"Custom DataHandler. This is an advanced customization. See http://bit.ly/151E7Aq.\"\n      }\n    }; // </JSON>\n    // NOTE: in addition to parsing as JS, this snippet is expected to be valid\n    // JSON. This assumption cannot be checked in JS, but it will be checked when\n    // documentation is generated by the generate-documentation.py script. For the\n    // most part, this just means that you should always use double quotes.\n\n    // Do a quick sanity check on the options reference.\n    var warn = function warn(msg) {\n      if (window.console) window.console.warn(msg);\n    };\n    var flds = ['type', 'default', 'description'];\n    var valid_cats = ['Annotations', 'Axis display', 'Chart labels', 'CSV parsing', 'Callbacks', 'Data', 'Data Line display', 'Data Series Colors', 'Error Bars', 'Grid', 'Interactive Elements', 'Range Selector', 'Legend', 'Overall display', 'Rolling Averages', 'Series', 'Value display/formatting', 'Zooming', 'Debugging', 'Configuration', 'Deprecated'];\n    var i;\n    var cats = {};\n    for (i = 0; i < valid_cats.length; i++) {\n      cats[valid_cats[i]] = true;\n    }for (var k in OPTIONS_REFERENCE) {\n      if (!OPTIONS_REFERENCE.hasOwnProperty(k)) continue;\n      var op = OPTIONS_REFERENCE[k];\n      for (i = 0; i < flds.length; i++) {\n        if (!op.hasOwnProperty(flds[i])) {\n          warn('Option ' + k + ' missing \"' + flds[i] + '\" property');\n        } else if (typeof op[flds[i]] != 'string') {\n          warn(k + '.' + flds[i] + ' must be of type string');\n        }\n      }\n      var labels = op.labels;\n      if ((typeof labels === 'undefined' ? 'undefined' : _typeof(labels)) !== 'object') {\n        warn('Option \"' + k + '\" is missing a \"labels\": [...] option');\n      } else {\n        for (i = 0; i < labels.length; i++) {\n          if (!cats.hasOwnProperty(labels[i])) {\n            warn('Option \"' + k + '\" has label \"' + labels[i] + '\", which is invalid.');\n          }\n        }\n      }\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (OPTIONS_REFERENCE);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(14)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLW9wdGlvbnMtcmVmZXJlbmNlLmpzP2M0ZTEiXSwibmFtZXMiOlsiT1BUSU9OU19SRUZFUkVOQ0UiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJ3YXJuIiwibXNnIiwid2luZG93IiwiY29uc29sZSIsImZsZHMiLCJ2YWxpZF9jYXRzIiwiaSIsImNhdHMiLCJsZW5ndGgiLCJrIiwiaGFzT3duUHJvcGVydHkiLCJvcCIsImxhYmVscyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQU1BOzs7O0FBRUEsSUFBSUEsb0JBQW9CLElBQXhCOztBQUVBO0FBQ0EsSUFBSSxPQUFPQyxPQUFQLEtBQW9CLFdBQXhCLEVBQXFDO0FBQ3JDLE1BQUlBLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixJQUF3QixZQUE1QixFQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQUgsd0JBQXFCO0FBQ3JCO0FBQ0Usc0JBQWdCO0FBQ2QsbUJBQVcsK0JBREc7QUFFZCxrQkFBVSxDQUFDLGFBQUQsQ0FGSTtBQUdkLGdCQUFRLHlCQUhNO0FBSWQsdUJBQWU7QUFKRCxPQURsQjtBQU9FLHNCQUFnQjtBQUNkLG1CQUFXLE9BREc7QUFFZCxrQkFBVSxDQUFDLG1CQUFELENBRkk7QUFHZCxnQkFBUSxTQUhNO0FBSWQsdUJBQWU7QUFKRCxPQVBsQjtBQWFFLDZCQUF1QjtBQUNyQixtQkFBVyxLQURVO0FBRXJCLGtCQUFVLENBQUMsbUJBQUQsQ0FGVztBQUdyQixnQkFBUSxRQUhhO0FBSXJCLHVCQUFlO0FBSk0sT0FiekI7QUFtQkUsbUJBQWE7QUFDWCxtQkFBVyxHQURBO0FBRVgsa0JBQVUsQ0FBQyxtQkFBRCxDQUZDO0FBR1gsZ0JBQVEsU0FIRztBQUlYLHVCQUFlO0FBSkosT0FuQmY7QUF5QkUsb0JBQWM7QUFDWixtQkFBVyxPQURDO0FBRVosa0JBQVUsQ0FBQyxtQkFBRCxDQUZFO0FBR1osZ0JBQVEsU0FISTtBQUlaLHVC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UyxDQUFaLEdBQWdCLFlBQWhCLEdBQStCTCxLQUFLRSxDQUFMLENBQS9CLEdBQXlDLFlBQTlDO0FBQ0QsU0FGRCxNQUVPLElBQUksT0FBT0ssR0FBR1AsS0FBS0UsQ0FBTCxDQUFILENBQVAsSUFBdUIsUUFBM0IsRUFBcUM7QUFDMUNOLGVBQUtTLElBQUksR0FBSixHQUFVTCxLQUFLRSxDQUFMLENBQVYsR0FBb0IseUJBQXpCO0FBQ0Q7QUFDRjtBQUNELFVBQUlNLFNBQVNELEdBQUdDLE1BQWhCO0FBQ0EsVUFBSSxRQUFPQSxNQUFQLHlDQUFPQSxNQUFQLE9BQW1CLFFBQXZCLEVBQWlDO0FBQy9CWixhQUFLLGFBQWFTLENBQWIsR0FBaUIsdUNBQXRCO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsYUFBS0gsSUFBSSxDQUFULEVBQVlBLElBQUlNLE9BQU9KLE1BQXZCLEVBQStCRixHQUEvQixFQUFvQztBQUNsQyxjQUFJLENBQUNDLEtBQUtHLGNBQUwsQ0FBb0JFLE9BQU9OLENBQVAsQ0FBcEIsQ0FBTCxFQUFxQztBQUNuQ04saUJBQUssYUFBYVMsQ0FBYixHQUFpQixlQUFqQixHQUFtQ0csT0FBT04sQ0FBUCxDQUFuQyxHQUNBLHNCQURMO0FBRUQ7QUFDRjtBQUNGO0FBQ0Y7QUFFQTtBQUNBOztBQUVELHlEQUFlVixpQkFBZixFIiwiZmlsZSI6IjE5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTEgRGFuIFZhbmRlcmthbSAoZGFudmRrQGdtYWlsLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIE9QVElPTlNfUkVGRVJFTkNFID0gbnVsbDtcblxuLy8gRm9yIFwicHJvZHVjdGlvblwiIGNvZGUsIHRoaXMgZ2V0cyByZW1vdmVkIGJ5IHVnbGlmeWpzLlxuaWYgKHR5cGVvZihwcm9jZXNzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPSAncHJvZHVjdGlvbicpIHtcblxuLy8gTk9URTogaW4gYWRkaXRpb24gdG8gcGFyc2luZyBhcyBKUywgdGhpcyBzbmlwcGV0IGlzIGV4cGVjdGVkIHRvIGJlIHZhbGlkXG4vLyBKU09OLiBUaGlzIGFzc3VtcHRpb24gY2Fubm90IGJlIGNoZWNrZWQgaW4gSlMsIGJ1dCBpdCB3aWxsIGJlIGNoZWNrZWQgd2hlblxuLy8gZG9jdW1lbnRhdGlvbiBpcyBnZW5lcmF0ZWQgYnkgdGhlIGdlbmVyYXRlLWRvY3VtZW50YXRpb24ucHkgc2NyaXB0LiBGb3IgdGhlXG4vLyBtb3N0IHBhcnQsIHRoaXMganVzdCBtZWFucyB0aGF0IHlvdSBzaG91bGQgYWx3YXlzIHVzZSBkb3VibGUgcXVvdGVzLlxuT1BUSU9OU19SRUZFUkVOQ0UgPSAgLy8gPEpTT04+XG57XG4gIFwieFZhbHVlUGFyc2VyXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJwYXJzZUZsb2F0KCkgb3IgRGF0ZS5wYXJzZSgpKlwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNTViBwYXJzaW5nXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKHN0cikgLT4gbnVtYmVyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgZnVuY3Rpb24gd2hpY2ggcGFyc2VzIHgtdmFsdWVzIChpLmUuIHRoZSBkZXBlbmRlbnQgc2VyaWVzKS4gTXVzdCByZXR1cm4gYSBudW1iZXIsIGV2ZW4gd2hlbiB0aGUgdmFsdWVzIGFyZSBkYXRlcy4gSW4gdGhpcyBjYXNlLCBtaWxsaXMgc2luY2UgZXBvY2ggYXJlIHVzZWQuIFRoaXMgaXMgdXNlZCBwcmltYXJpbHkgZm9yIHBhcnNpbmcgQ1NWIGRhdGEuICo9RHlncmFwaHMgaXMgc2xpZ2h0bHkgbW9yZSBhY2NlcHRpbmcgaW4gdGhlIGRhdGVzIHdoaWNoIGl0IHdpbGwgcGFyc2UuIFNlZSBjb2RlIGZvciBkZXRhaWxzLlwiXG4gIH0sXG4gIFwic3RhY2tlZEdyYXBoXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgc2V0LCBzdGFjayBzZXJpZXMgb24gdG9wIG9mIG9uZSBhbm90aGVyIHJhdGhlciB0aGFuIGRyYXdpbmcgdGhlbSBpbmRlcGVuZGVudGx5LiBUaGUgZmlyc3Qgc2VyaWVzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgZGF0YSB3aWxsIHdpbmQgdXAgb24gdG9wIG9mIHRoZSBjaGFydCBhbmQgdGhlIGxhc3Qgd2lsbCBiZSBvbiBib3R0b20uIE5hTiB2YWx1ZXMgYXJlIGRyYXduIGFzIHdoaXRlIGFyZWFzIHdpdGhvdXQgYSBsaW5lIG9uIHRvcCwgc2VlIHN0YWNrZWRHcmFwaE5hTkZpbGwgZm9yIGRldGFpbHMuXCJcbiAgfSxcbiAgXCJzdGFja2VkR3JhcGhOYU5GaWxsXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJhbGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIExpbmUgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQ29udHJvbHMgaGFuZGxpbmcgb2YgTmFOIHZhbHVlcyBpbnNpZGUgYSBzdGFja2VkIGdyYXBoLiBOYU4gdmFsdWVzIGFyZSBpbnRlcnBvbGF0ZWQvZXh0ZW5kZWQgZm9yIHN0YWNraW5nIHB1cnBvc2VzLCBidXQgdGhlIGFjdHVhbCBwb2ludCB2YWx1ZSByZW1haW5zIE5hTiBpbiB0aGUgbGVnZW5kIGRpc3BsYXkuIFZhbGlkIG9wdGlvbiB2YWx1ZXMgYXJlIFxcXCJhbGxcXFwiIChpbnRlcnBvbGF0ZSBpbnRlcm5hbGx5LCByZXBlYXQgbGVmdG1vc3QgYW5kIHJpZ2h0bW9zdCB2YWx1ZSBhcyBuZWVkZWQpLCBcXFwiaW5zaWRlXFxcIiAoaW50ZXJwb2xhdGUgaW50ZXJuYWxseSBvbmx5LCB1c2UgemVybyBvdXRzaWRlIGxlZnRtb3N0IGFuZCByaWdodG1vc3QgdmFsdWUpLCBhbmQgXFxcIm5vbmVcXFwiICh0cmVhdCBOYU4gYXMgemVybyBldmVyeXdoZXJlKS5cIlxuICB9LFxuICBcInBvaW50U2l6ZVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHNpemUgb2YgdGhlIGRvdCB0byBkcmF3IG9uIGVhY2ggcG9pbnQgaW4gcGl4ZWxzIChzZWUgZHJhd1BvaW50cykuIEEgZG90IGlzIGFsd2F5cyBkcmF3biB3aGVuIGEgcG9pbnQgaXMgXFxcImlzb2xhdGVkXFxcIiwgaS5lLiB0aGVyZSBpcyBhIG1pc3NpbmcgcG9pbnQgb24gZWl0aGVyIHNpZGUgb2YgaXQuIFRoaXMgYWxzbyBjb250cm9scyB0aGUgc2l6ZSBvZiB0aG9zZSBkb3RzLlwiXG4gIH0sXG4gIFwiZHJhd1BvaW50c1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIExpbmUgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkRyYXcgYSBzbWFsbCBkb3QgYXQgZWFjaCBwb2ludCwgaW4gYWRkaXRpb24gdG8gYSBsaW5lIGdvaW5nIHRocm91Z2ggdGhlIHBvaW50LiBUaGlzIG1ha2VzIHRoZSBpbmRpdmlkdWFsIGRhdGEgcG9pbnRzIGVhc2llciB0byBzZWUsIGJ1dCBjYW4gaW5jcmVhc2UgdmlzdWFsIGNsdXR0ZXIgaW4gdGhlIGNoYXJ0LiBUaGUgc21hbGwgZG90IGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgY3VzdG9tIHJlbmRlcmluZyBieSBzdXBwbHlpbmcgYSA8YSBocmVmPScjZHJhd1BvaW50Q2FsbGJhY2snPmRyYXdQb2ludENhbGxiYWNrPC9hPi5cIlxuICB9LFxuICBcImRyYXdHYXBFZGdlUG9pbnRzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRHJhdyBwb2ludHMgYXQgdGhlIGVkZ2VzIG9mIGdhcHMgaW4gdGhlIGRhdGEuIFRoaXMgaW1wcm92ZXMgdmlzaWJpbGl0eSBvZiBzbWFsbCBkYXRhIHNlZ21lbnRzIG9yIG90aGVyIGRhdGEgaXJyZWd1bGFyaXRpZXMuXCJcbiAgfSxcbiAgXCJkcmF3UG9pbnRDYWxsYmFja1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGcsIHNlcmllc05hbWUsIGNhbnZhc0NvbnRleHQsIGN4LCBjeSwgY29sb3IsIHBvaW50U2l6ZSlcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcImdcIiAsIFwidGhlIHJlZmVyZW5jZSBncmFwaFwiIF0sXG4gICAgICBbIFwic2VyaWVzTmFtZVwiICwgXCJ0aGUgbmFtZSBvZiB0aGUgc2VyaWVzXCIgXSxcbiAgICAgIFsgXCJjYW52YXNDb250ZXh0XCIgLCBcInRoZSBjYW52YXMgdG8gZHJhdyBvblwiIF0sXG4gICAgICBbIFwiY3hcIiAsIFwiY2VudGVyIHggY29vcmRpbmF0ZVwiIF0sXG4gICAgICBbIFwiY3lcIiAsIFwiY2VudGVyIHkgY29vcmRpbmF0ZVwiIF0sXG4gICAgICBbIFwiY29sb3JcIiAsIFwic2VyaWVzIGNvbG9yXCIgXSxcbiAgICAgIFsgXCJwb2ludFNpemVcIiAsIFwidGhlIHJhZGl1cyBvZiB0aGUgaW1hZ2UuXCIgXSxcbiAgICAgIFsgXCJpZHhcIiAsIFwidGhlIHJvdy1pbmRleCBvZiB0aGUgcG9pbnQgaW4gdGhlIGRhdGEuXCJdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRHJhdyBhIGN1c3RvbSBpdGVtIHdoZW4gZHJhd1BvaW50cyBpcyBlbmFibGVkLiBEZWZhdWx0IGlzIGEgc21hbGwgZG90IG1hdGNoaW5nIHRoZSBzZXJpZXMgY29sb3IuIFRoaXMgbWV0aG9kIHNob3VsZCBjb25zdHJhaW4gZHJhd2luZyB0byB3aXRoaW4gcG9pbnRTaXplIHBpeGVscyBmcm9tIChjeCwgY3kpLiAgQWxzbyBzZWUgPGEgaHJlZj0nI2RyYXdIaWdobGlnaHRQb2ludENhbGxiYWNrJz5kcmF3SGlnaGxpZ2h0UG9pbnRDYWxsYmFjazwvYT5cIlxuICB9LFxuICBcImhlaWdodFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMzIwXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiT3ZlcmFsbCBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSGVpZ2h0LCBpbiBwaXhlbHMsIG9mIHRoZSBjaGFydC4gSWYgdGhlIGNvbnRhaW5lciBkaXYgaGFzIGJlZW4gZXhwbGljaXRseSBzaXplZCwgdGhpcyB3aWxsIGJlIGlnbm9yZWQuXCJcbiAgfSxcbiAgXCJ6b29tQ2FsbGJhY2tcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJDYWxsYmFja3NcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24obWluRGF0ZSwgbWF4RGF0ZSwgeVJhbmdlcylcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcIm1pbkRhdGVcIiAsIFwibWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoXCIgXSxcbiAgICAgIFsgXCJtYXhEYXRlXCIgLCBcIm1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaC5cIiBdLFxuICAgICAgWyBcInlSYW5nZXNcIiAsIFwiaXMgYW4gYXJyYXkgb2YgW2JvdHRvbSwgdG9wXSBwYWlycywgb25lIGZvciBlYWNoIHktYXhpcy5cIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHpvb20gd2luZG93IGlzIGNoYW5nZWQgKGVpdGhlciBieSB6b29taW5nIGluIG9yIG91dCkuIFdoZW4gYW5pbWF0ZWRab29tcyBpcyBzZXQsIHpvb21DYWxsYmFjayBpcyBjYWxsZWQgb25jZSBhdCB0aGUgZW5kIG9mIHRoZSB0cmFuc2l0aW9uIChpdCB3aWxsIG5vdCBiZSBjYWxsZWQgZm9yIGludGVybWVkaWF0ZSBmcmFtZXMpLlwiXG4gIH0sXG4gIFwicG9pbnRDbGlja0NhbGxiYWNrXCI6IHtcbiAgICBcInNuaXBwZXRcIjogXCJmdW5jdGlvbihlLCBwb2ludCl7PGJyPiZuYnNwOyZuYnNwO2FsZXJ0KHBvaW50KTs8YnI+fVwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJDYWxsYmFja3NcIiwgXCJJbnRlcmFjdGl2ZSBFbGVtZW50c1wiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihlLCBwb2ludClcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcImVcIiAsIFwidGhlIGV2ZW50IG9iamVjdCBmb3IgdGhlIGNsaWNrXCIgXSxcbiAgICAgIFsgXCJwb2ludFwiICwgXCJ0aGUgcG9pbnQgdGhhdCB3YXMgY2xpY2tlZCBTZWUgPGEgaHJlZj0nI3BvaW50X3Byb3BlcnRpZXMnPlBvaW50IHByb3BlcnRpZXM8L2E+IGZvciBkZXRhaWxzXCIgXVxuICAgIF0sXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgZGF0YSBwb2ludCBpcyBjbGlja2VkLiBhbmQgdGhlIHBvaW50IHRoYXQgd2FzIGNsaWNrZWQuXCJcbiAgfSxcbiAgXCJjb2xvclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiKHNlZSBkZXNjcmlwdGlvbilcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIFNlcmllcyBDb2xvcnNcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJleGFtcGxlXCI6IFwicmVkXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgcGVyLXNlcmllcyBjb2xvciBkZWZpbml0aW9uLiBVc2VkIGluIGNvbmp1bmN0aW9uIHdpdGgsIGFuZCBvdmVycmlkZXMsIHRoZSBjb2xvcnMgb3B0aW9uLlwiXG4gIH0sXG4gIFwiY29sb3JzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIoc2VlIGRlc2NyaXB0aW9uKVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgU2VyaWVzIENvbG9yc1wiXSxcbiAgICBcInR5cGVcIjogXCJhcnJheTxzdHJpbmc+XCIsXG4gICAgXCJleGFtcGxlXCI6IFwiWydyZWQnLCAnIzAwRkYwMCddXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkxpc3Qgb2YgY29sb3JzIGZvciB0aGUgZGF0YSBzZXJpZXMuIFRoZXNlIGNhbiBiZSBvZiB0aGUgZm9ybSBcXFwiI0FBQkJDQ1xcXCIgb3IgXFxcInJnYigyNTUsMTAwLDIwMClcXFwiIG9yIFxcXCJ5ZWxsb3dcXFwiLCBldGMuIElmIG5vdCBzcGVjaWZpZWQsIGVxdWFsbHktc3BhY2VkIHBvaW50cyBhcm91bmQgYSBjb2xvciB3aGVlbCBhcmUgdXNlZC4gT3ZlcnJpZGRlbiBieSB0aGUgJ2NvbG9yJyBvcHRpb24uXCJcbiAgfSxcbiAgXCJjb25uZWN0U2VwYXJhdGVkUG9pbnRzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVXN1YWxseSwgd2hlbiBEeWdyYXBocyBlbmNvdW50ZXJzIGEgbWlzc2luZyB2YWx1ZSBpbiBhIGRhdGEgc2VyaWVzLCBpdCBpbnRlcnByZXRzIHRoaXMgYXMgYSBnYXAgYW5kIGRyYXdzIGl0IGFzIHN1Y2guIElmLCBpbnN0ZWFkLCB0aGUgbWlzc2luZyB2YWx1ZXMgcmVwcmVzZW50cyBhbiB4LXZhbHVlIGZvciB3aGljaCBvbmx5IGEgZGlmZmVyZW50IHNlcmllcyBoYXMgZGF0YSwgdGhlbiB5b3UnbGwgd2FudCB0byBjb25uZWN0IHRoZSBkb3RzIGJ5IHNldHRpbmcgdGhpcyB0byB0cnVlLiBUbyBleHBsaWNpdGx5IGluY2x1ZGUgYSBnYXAgd2l0aCB0aGlzIG9wdGlvbiBzZXQsIHVzZSBhIHZhbHVlIG9mIE5hTi5cIlxuICB9LFxuICBcImhpZ2hsaWdodENhbGxiYWNrXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ2FsbGJhY2tzXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGV2ZW50LCB4LCBwb2ludHMsIHJvdywgc2VyaWVzTmFtZSlcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hlbiBzZXQsIHRoaXMgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSBhIG5ldyBwb2ludCBpcyBoaWdobGlnaHRlZC5cIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgW1wiZXZlbnRcIiwgXCJ0aGUgSmF2YVNjcmlwdCBtb3VzZW1vdmUgZXZlbnRcIl0sXG4gICAgICBbXCJ4XCIsIFwidGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgaGlnaGxpZ2h0ZWQgcG9pbnRzXCJdLFxuICAgICAgW1wicG9pbnRzXCIsIFwiYW4gYXJyYXkgb2YgaGlnaGxpZ2h0ZWQgcG9pbnRzOiA8Y29kZT5bIHtuYW1lOiAnc2VyaWVzJywgeXZhbDogeS12YWx1ZX0sICZoZWxsaXA7IF08L2NvZGU+XCJdLFxuICAgICAgW1wicm93XCIsIFwiaW50ZWdlciBpbmRleCBvZiB0aGUgaGlnaGxpZ2h0ZWQgcm93IGluIHRoZSBkYXRhIHRhYmxlLCBzdGFydGluZyBmcm9tIDBcIl0sXG4gICAgICBbXCJzZXJpZXNOYW1lXCIsIFwibmFtZSBvZiB0aGUgaGlnaGxpZ2h0ZWQgc2VyaWVzLCBvbmx5IHByZXNlbnQgaWYgaGlnaGxpZ2h0U2VyaWVzT3B0cyBpcyBzZXQuXCJdXG4gICAgXVxuICB9LFxuICBcImRyYXdIaWdobGlnaHRQb2ludENhbGxiYWNrXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oZywgc2VyaWVzTmFtZSwgY2FudmFzQ29udGV4dCwgY3gsIGN5LCBjb2xvciwgcG9pbnRTaXplKVwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbIFwiZ1wiICwgXCJ0aGUgcmVmZXJlbmNlIGdyYXBoXCIgXSxcbiAgICAgIFsgXCJzZXJpZXNOYW1lXCIgLCBcInRoZSBuYW1lIG9mIHRoZSBzZXJpZXNcIiBdLFxuICAgICAgWyBcImNhbnZhc0NvbnRleHRcIiAsIFwidGhlIGNhbnZhcyB0byBkcmF3IG9uXCIgXSxcbiAgICAgIFsgXCJjeFwiICwgXCJjZW50ZXIgeCBjb29yZGluYXRlXCIgXSxcbiAgICAgIFsgXCJjeVwiICwgXCJjZW50ZXIgeSBjb29yZGluYXRlXCIgXSxcbiAgICAgIFsgXCJjb2xvclwiICwgXCJzZXJpZXMgY29sb3JcIiBdLFxuICAgICAgWyBcInBvaW50U2l6ZVwiICwgXCJ0aGUgcmFkaXVzIG9mIHRoZSBpbWFnZS5cIiBdLFxuICAgICAgWyBcImlkeFwiICwgXCJ0aGUgcm93LWluZGV4IG9mIHRoZSBwb2ludCBpbiB0aGUgZGF0YS5cIl1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJEcmF3IGEgY3VzdG9tIGl0ZW0gd2hlbiBhIHBvaW50IGlzIGhpZ2hsaWdodGVkLiAgRGVmYXVsdCBpcyBhIHNtYWxsIGRvdCBtYXRjaGluZyB0aGUgc2VyaWVzIGNvbG9yLiBUaGlzIG1ldGhvZCBzaG91bGQgY29uc3RyYWluIGRyYXdpbmcgdG8gd2l0aGluIHBvaW50U2l6ZSBwaXhlbHMgZnJvbSAoY3gsIGN5KSBBbHNvIHNlZSA8YSBocmVmPScjZHJhd1BvaW50Q2FsbGJhY2snPmRyYXdQb2ludENhbGxiYWNrPC9hPlwiXG4gIH0sXG4gIFwiaGlnaGxpZ2h0U2VyaWVzT3B0c1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkludGVyYWN0aXZlIEVsZW1lbnRzXCJdLFxuICAgIFwidHlwZVwiOiBcIk9iamVjdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIHNldCwgdGhlIG9wdGlvbnMgZnJvbSB0aGlzIG9iamVjdCBhcmUgYXBwbGllZCB0byB0aGUgdGltZXNlcmllcyBjbG9zZXN0IHRvIHRoZSBtb3VzZSBwb2ludGVyIGZvciBpbnRlcmFjdGl2ZSBoaWdobGlnaHRpbmcuIFNlZSBhbHNvICdoaWdobGlnaHRDYWxsYmFjaycuIEV4YW1wbGU6IGhpZ2hsaWdodFNlcmllc09wdHM6IHsgc3Ryb2tlV2lkdGg6IDMgfS5cIlxuICB9LFxuICBcImhpZ2hsaWdodFNlcmllc0JhY2tncm91bmRBbHBoYVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMC41XCIsXG4gICAgXCJsYWJlbHNcIjogW1wiSW50ZXJhY3RpdmUgRWxlbWVudHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRmFkZSB0aGUgYmFja2dyb3VuZCB3aGlsZSBoaWdobGlnaHRpbmcgc2VyaWVzLiAxPWZ1bGx5IHZpc2libGUgYmFja2dyb3VuZCAoZGlzYWJsZSBmYWRpbmcpLCAwPWhpZGRkZW4gYmFja2dyb3VuZCAoc2hvdyBoaWdobGlnaHRlZCBzZXJpZXMgb25seSkuXCJcbiAgfSxcbiAgXCJoaWdobGlnaHRTZXJpZXNCYWNrZ3JvdW5kQ29sb3JcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcInJnYigyNTUsIDI1NSwgMjU1KVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkludGVyYWN0aXZlIEVsZW1lbnRzXCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTZXRzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIHVzZWQgdG8gZmFkZSBvdXQgdGhlIHNlcmllcyBpbiBjb25qdW5jdGlvbiB3aXRoICdoaWdobGlnaHRTZXJpZXNCYWNrZ3JvdW5kQWxwaGEnLlwiXG4gIH0sXG4gIFwiaW5jbHVkZVplcm9cIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVXN1YWxseSwgZHlncmFwaHMgd2lsbCB1c2UgdGhlIHJhbmdlIG9mIHRoZSBkYXRhIHBsdXMgc29tZSBwYWRkaW5nIHRvIHNldCB0aGUgcmFuZ2Ugb2YgdGhlIHktYXhpcy4gSWYgdGhpcyBvcHRpb24gaXMgc2V0LCB0aGUgeS1heGlzIHdpbGwgYWx3YXlzIGluY2x1ZGUgemVybywgdHlwaWNhbGx5IGFzIHRoZSBsb3dlc3QgdmFsdWUuIFRoaXMgY2FuIGJlIHVzZWQgdG8gYXZvaWQgZXhhZ2dlcmF0aW5nIHRoZSB2YXJpYW5jZSBpbiB0aGUgZGF0YVwiXG4gIH0sXG4gIFwicm9sbFBlcmlvZFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkVycm9yIEJhcnNcIiwgXCJSb2xsaW5nIEF2ZXJhZ2VzXCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXIgJmd0Oz0gMVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJOdW1iZXIgb2YgZGF5cyBvdmVyIHdoaWNoIHRvIGF2ZXJhZ2UgZGF0YS4gRGlzY3Vzc2VkIGV4dGVuc2l2ZWx5IGFib3ZlLlwiXG4gIH0sXG4gIFwidW5oaWdobGlnaHRDYWxsYmFja1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNhbGxiYWNrc1wiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihldmVudClcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcImV2ZW50XCIgLCBcInRoZSBtb3VzZSBldmVudFwiIF1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIHNldCwgdGhpcyBjYWxsYmFjayBnZXRzIGNhbGxlZCBldmVyeSB0aW1lIHRoZSB1c2VyIHN0b3BzIGhpZ2hsaWdodGluZyBhbnkgcG9pbnQgYnkgbW91c2luZyBvdXQgb2YgdGhlIGdyYXBoLlwiXG4gIH0sXG4gIFwiYXhpc1RpY2tTaXplXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIzLjBcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBzaXplIG9mIHRoZSBsaW5lIHRvIGRpc3BsYXkgbmV4dCB0byBlYWNoIHRpY2sgbWFyayBvbiB4LSBvciB5LWF4ZXMuXCJcbiAgfSxcbiAgXCJsYWJlbHNTZXBhcmF0ZUxpbmVzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkxlZ2VuZFwiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlB1dCA8Y29kZT4mbHQ7YnIvJmd0OzwvY29kZT4gYmV0d2VlbiBsaW5lcyBpbiB0aGUgbGFiZWwgc3RyaW5nLiBPZnRlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggPHN0cm9uZz5sYWJlbHNEaXY8L3N0cm9uZz4uXCJcbiAgfSxcbiAgXCJ2YWx1ZUZvcm1hdHRlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiRGVwZW5kcyBvbiB0aGUgdHlwZSBvZiB5b3VyIGRhdGEuXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiTGVnZW5kXCIsIFwiVmFsdWUgZGlzcGxheS9mb3JtYXR0aW5nXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKG51bSBvciBtaWxsaXMsIG9wdHMsIHNlcmllc05hbWUsIGR5Z3JhcGgsIHJvdywgY29sKVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJGdW5jdGlvbiB0byBwcm92aWRlIGEgY3VzdG9tIGRpc3BsYXkgZm9ybWF0IGZvciB0aGUgdmFsdWVzIGRpc3BsYXllZCBvbiBtb3VzZW92ZXIuIFRoaXMgZG9lcyBub3QgYWZmZWN0IHRoZSB2YWx1ZXMgdGhhdCBhcHBlYXIgb24gdGljayBtYXJrcyBuZXh0IHRvIHRoZSBheGVzLiBUbyBmb3JtYXQgdGhvc2UsIHNlZSBheGlzTGFiZWxGb3JtYXR0ZXIuIFRoaXMgaXMgdXN1YWxseSBzZXQgb24gYSA8YSBocmVmPSdwZXItYXhpcy5odG1sJz5wZXItYXhpczwvYT4gYmFzaXMuIC5cIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgW1wibnVtX29yX21pbGxpc1wiLCBcIlRoZSB2YWx1ZSB0byBiZSBmb3JtYXR0ZWQuIFRoaXMgaXMgYWx3YXlzIGEgbnVtYmVyLiBGb3IgZGF0ZSBheGVzLCBpdCdzIG1pbGxpcyBzaW5jZSBlcG9jaC4gWW91IGNhbiBjYWxsIG5ldyBEYXRlKG1pbGxpcykgdG8gZ2V0IGEgRGF0ZSBvYmplY3QuXCJdLFxuICAgICAgW1wib3B0c1wiLCBcIlRoaXMgaXMgYSBmdW5jdGlvbiB5b3UgY2FuIGNhbGwgdG8gYWNjZXNzIHZhcmlvdXMgb3B0aW9ucyAoZS5nLiBvcHRzKCdsYWJlbHNLTUInKSkuIEl0IHJldHVybnMgcGVyLWF4aXMgdmFsdWVzIGZvciB0aGUgb3B0aW9uIHdoZW4gYXZhaWxhYmxlLlwiXSxcbiAgICAgIFtcInNlcmllc05hbWVcIiwgXCJUaGUgbmFtZSBvZiB0aGUgc2VyaWVzIGZyb20gd2hpY2ggdGhlIHBvaW50IGNhbWUsIGUuZy4gJ1gnLCAnWScsICdBJywgZXRjLlwiXSxcbiAgICAgIFtcImR5Z3JhcGhcIiwgXCJUaGUgZHlncmFwaCBvYmplY3QgZm9yIHdoaWNoIHRoZSBmb3JtYXR0aW5nIGlzIGJlaW5nIGRvbmVcIl0sXG4gICAgICBbXCJyb3dcIiwgXCJUaGUgcm93IG9mIHRoZSBkYXRhIGZyb20gd2hpY2ggdGhpcyBwb2ludCBjb21lcy4gZy5nZXRWYWx1ZShyb3csIDApIHdpbGwgcmV0dXJuIHRoZSB4LXZhbHVlIGZvciB0aGlzIHBvaW50LlwiXSxcbiAgICAgIFtcImNvbFwiLCBcIlRoZSBjb2x1bW4gb2YgdGhlIGRhdGEgZnJvbSB3aGljaCB0aGlzIHBvaW50IGNvbWVzLiBnLmdldFZhbHVlKHJvdywgY29sKSB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgeS12YWx1ZSBmb3IgdGhpcyBwb2ludC4gVGhpcyBjYW4gYmUgdXNlZCB0byBnZXQgdGhlIGZ1bGwgY29uZmlkZW5jZSBpbnRlcnZhbCBmb3IgdGhlIHBvaW50LCBvciBhY2Nlc3MgdW4tcm9sbGVkIHZhbHVlcyBmb3IgdGhlIHBvaW50LlwiXVxuICAgIF1cbiAgfSxcbiAgXCJhbm5vdGF0aW9uTW91c2VPdmVySGFuZGxlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkFubm90YXRpb25zXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGFubm90YXRpb24sIHBvaW50LCBkeWdyYXBoLCBldmVudClcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgcHJvdmlkZWQsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSB1c2VyIG1vdXNlcyBvdmVyIGFuIGFubm90YXRpb24uXCJcbiAgfSxcbiAgXCJhbm5vdGF0aW9uTW91c2VPdXRIYW5kbGVyXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQW5ub3RhdGlvbnNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oYW5ub3RhdGlvbiwgcG9pbnQsIGR5Z3JhcGgsIGV2ZW50KVwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbIFwiYW5ub3RhdGlvblwiICwgXCJ0aGUgYW5ub3RhdGlvbiBsZWZ0XCIgXSxcbiAgICAgIFsgXCJwb2ludFwiICwgXCJ0aGUgcG9pbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBhbm5vdGF0aW9uXCIgXSxcbiAgICAgIFsgXCJkeWdyYXBoXCIgLCBcInRoZSByZWZlcmVuY2UgZ3JhcGhcIiBdLFxuICAgICAgWyBcImV2ZW50XCIgLCBcInRoZSBtb3VzZSBldmVudFwiIF1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiBwcm92aWRlZCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHVzZXIgbW91c2VzIG91dCBvZiBhbiBhbm5vdGF0aW9uLlwiXG4gIH0sXG4gIFwiYW5ub3RhdGlvbkNsaWNrSGFuZGxlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkFubm90YXRpb25zXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGFubm90YXRpb24sIHBvaW50LCBkeWdyYXBoLCBldmVudClcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcImFubm90YXRpb25cIiAsIFwidGhlIGFubm90YXRpb24gbGVmdFwiIF0sXG4gICAgICBbIFwicG9pbnRcIiAsIFwidGhlIHBvaW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgYW5ub3RhdGlvblwiIF0sXG4gICAgICBbIFwiZHlncmFwaFwiICwgXCJ0aGUgcmVmZXJlbmNlIGdyYXBoXCIgXSxcbiAgICAgIFsgXCJldmVudFwiICwgXCJ0aGUgbW91c2UgZXZlbnRcIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgcHJvdmlkZWQsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSB1c2VyIGNsaWNrcyBvbiBhbiBhbm5vdGF0aW9uLlwiXG4gIH0sXG4gIFwiYW5ub3RhdGlvbkRibENsaWNrSGFuZGxlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkFubm90YXRpb25zXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGFubm90YXRpb24sIHBvaW50LCBkeWdyYXBoLCBldmVudClcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcImFubm90YXRpb25cIiAsIFwidGhlIGFubm90YXRpb24gbGVmdFwiIF0sXG4gICAgICBbIFwicG9pbnRcIiAsIFwidGhlIHBvaW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgYW5ub3RhdGlvblwiIF0sXG4gICAgICBbIFwiZHlncmFwaFwiICwgXCJ0aGUgcmVmZXJlbmNlIGdyYXBoXCIgXSxcbiAgICAgIFsgXCJldmVudFwiICwgXCJ0aGUgbW91c2UgZXZlbnRcIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgcHJvdmlkZWQsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSB1c2VyIGRvdWJsZS1jbGlja3Mgb24gYW4gYW5ub3RhdGlvbi5cIlxuICB9LFxuICBcImRyYXdDYWxsYmFja1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNhbGxiYWNrc1wiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihkeWdyYXBoLCBpc19pbml0aWFsKVwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbIFwiZHlncmFwaFwiICwgXCJUaGUgZ3JhcGggYmVpbmcgZHJhd25cIiBdLFxuICAgICAgWyBcImlzX2luaXRpYWxcIiAsIFwiVHJ1ZSBpZiB0aGlzIGlzIHRoZSBpbml0aWFsIGRyYXcsIGZhbHNlIGZvciBzdWJzZXF1ZW50IGRyYXdzLlwiIF1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIHNldCwgdGhpcyBjYWxsYmFjayBnZXRzIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBkeWdyYXBoIGlzIGRyYXduLiBUaGlzIGluY2x1ZGVzIHRoZSBpbml0aWFsIGRyYXcsIGFmdGVyIHpvb21pbmcgYW5kIHJlcGVhdGVkbHkgd2hpbGUgcGFubmluZy5cIlxuICB9LFxuICBcImxhYmVsc0tNRzJcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiVmFsdWUgZGlzcGxheS9mb3JtYXR0aW5nXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2hvdyBrL00vRyBmb3Iga2lsby9NZWdhL0dpZ2Egb24geS1heGlzLiBUaGlzIGlzIGRpZmZlcmVudCB0aGFuIDxjb2RlPmxhYmVsc0tNQjwvY29kZT4gaW4gdGhhdCBpdCB1c2VzIGJhc2UgMiwgbm90IDEwLlwiXG4gIH0sXG4gIFwiZGVsaW1pdGVyXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ1NWIHBhcnNpbmdcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBkZWxpbWl0ZXIgdG8gbG9vayBmb3Igd2hlbiBzZXBhcmF0aW5nIGZpZWxkcyBvZiBhIENTViBmaWxlLiBTZXR0aW5nIHRoaXMgdG8gYSB0YWIgaXMgbm90IHVzdWFsbHkgbmVjZXNzYXJ5LCBzaW5jZSB0YWItZGVsaW1pdGVkIGRhdGEgaXMgYXV0by1kZXRlY3RlZC5cIlxuICB9LFxuICBcImF4aXNMYWJlbEZvbnRTaXplXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIxNFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlNpemUgb2YgdGhlIGZvbnQgKGluIHBpeGVscykgdG8gdXNlIGluIHRoZSBheGlzIGxhYmVscywgYm90aCB4LSBhbmQgeS1heGlzLlwiXG4gIH0sXG4gIFwidW5kZXJsYXlDYWxsYmFja1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNhbGxiYWNrc1wiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihjb250ZXh0LCBhcmVhLCBkeWdyYXBoKVwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbIFwiY29udGV4dFwiICwgXCJ0aGUgY2FudmFzIGRyYXdpbmcgY29udGV4dCBvbiB3aGljaCB0byBkcmF3XCIgXSxcbiAgICAgIFsgXCJhcmVhXCIgLCBcIkFuIG9iamVjdCB3aXRoIHt4LHksdyxofSBwcm9wZXJ0aWVzIGRlc2NyaWJpbmcgdGhlIGRyYXdpbmcgYXJlYS5cIiBdLFxuICAgICAgWyBcImR5Z3JhcGhcIiAsIFwidGhlIHJlZmVyZW5jZSBncmFwaFwiIF1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIHNldCwgdGhpcyBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmUgdGhlIGNoYXJ0IGlzIGRyYXduLiBJdCBkZXRhaWxzIG9uIGhvdyB0byB1c2UgdGhpcy5cIlxuICB9LFxuICBcIndpZHRoXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCI0ODBcIixcbiAgICBcImxhYmVsc1wiOiBbXCJPdmVyYWxsIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaWR0aCwgaW4gcGl4ZWxzLCBvZiB0aGUgY2hhcnQuIElmIHRoZSBjb250YWluZXIgZGl2IGhhcyBiZWVuIGV4cGxpY2l0bHkgc2l6ZWQsIHRoaXMgd2lsbCBiZSBpZ25vcmVkLlwiXG4gIH0sXG4gIFwicGl4ZWxSYXRpb1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiKGRldmljZVBpeGVsUmF0aW8gLyBjb250ZXh0LmJhY2tpbmdTdG9yZVJhdGlvKVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIk92ZXJhbGwgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJPdmVycmlkZXMgdGhlIHBpeGVsIHJhdGlvIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgY2FudmFzJ3MgMmQgY29udGV4dC4gT3JkaW5hcmlseSwgdGhpcyBpcyBzZXQgdG8gdGhlIGRldmljZVBpeGVsUmF0aW8gLyAoY29udGV4dC5iYWNraW5nU3RvcmVSYXRpbyB8fCAxKSwgc28gb24gbW9iaWxlIGRldmljZXMsIHdoZXJlIHRoZSBkZXZpY2VQaXhlbFJhdGlvIGNhbiBiZSBzb21ld2hlcmUgYXJvdW5kIDMsIHBlcmZvcm1hbmNlIGNhbiBiZSBpbXByb3ZlZCBieSBvdmVycmlkaW5nIHRoaXMgdmFsdWUgdG8gc29tZXRoaW5nIGxlc3MgcHJlY2lzZSwgbGlrZSAxLCBhdCB0aGUgZXhwZW5zZSBvZiByZXNvbHV0aW9uLlwiXG4gIH0sXG4gIFwiaW50ZXJhY3Rpb25Nb2RlbFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiLi4uXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiSW50ZXJhY3RpdmUgRWxlbWVudHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiT2JqZWN0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRPRE8oa29uaWdzYmVyZyk6IGRvY3VtZW50IHRoaXNcIlxuICB9LFxuICBcInRpY2tlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiRHlncmFwaC5kYXRlVGlja2VyIG9yIER5Z3JhcGgubnVtZXJpY1RpY2tzXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKG1pbiwgbWF4LCBwaXhlbHMsIG9wdHMsIGR5Z3JhcGgsIHZhbHMpIC0+IFt7djogLi4uLCBsYWJlbDogLi4ufSwgLi4uXVwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbIFwibWluXCIgLCBcIlwiIF0sXG4gICAgICBbIFwibWF4XCIgLCBcIlwiIF0sXG4gICAgICBbIFwicGl4ZWxzXCIgLCBcIlwiIF0sXG4gICAgICBbIFwib3B0c1wiICwgXCJcIiBdLFxuICAgICAgWyBcImR5Z3JhcGhcIiAsIFwidGhlIHJlZmVyZW5jZSBncmFwaFwiIF0sXG4gICAgICBbIFwidmFsc1wiICwgXCJcIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhpcyBsZXRzIHlvdSBzcGVjaWZ5IGFuIGFyYml0cmFyeSBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aWNrIG1hcmtzIG9uIGFuIGF4aXMuIFRoZSB0aWNrIG1hcmtzIGFyZSBhbiBhcnJheSBvZiAodmFsdWUsIGxhYmVsKSBwYWlycy4gVGhlIGJ1aWx0LWluIGZ1bmN0aW9ucyBnbyB0byBncmVhdCBsZW5ndGhzIHRvIGNob29zZSBnb29kIHRpY2sgbWFya3Mgc28sIGlmIHlvdSBzZXQgdGhpcyBvcHRpb24sIHlvdSdsbCBtb3N0IGxpa2VseSB3YW50IHRvIGNhbGwgb25lIG9mIHRoZW0gYW5kIG1vZGlmeSB0aGUgcmVzdWx0LiBTZWUgZHlncmFwaC10aWNrZXJzLmpzIGZvciBhbiBleHRlbnNpdmUgZGlzY3Vzc2lvbi4gVGhpcyBpcyBzZXQgb24gYSA8YSBocmVmPSdwZXItYXhpcy5odG1sJz5wZXItYXhpczwvYT4gYmFzaXMuXCJcbiAgfSxcbiAgXCJ4QXhpc0hlaWdodFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiKG51bGwpXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSGVpZ2h0LCBpbiBwaXhlbHMsIG9mIHRoZSB4LWF4aXMuIElmIG5vdCBzZXQgZXhwbGljaXRseSwgdGhpcyBpcyBjb21wdXRlZCBiYXNlZCBvbiBheGlzTGFiZWxGb250U2l6ZSBhbmQgYXhpc1RpY2tTaXplLlwiXG4gIH0sXG4gIFwic2hvd0xhYmVsc09uSGlnaGxpZ2h0XCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJ0cnVlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiSW50ZXJhY3RpdmUgRWxlbWVudHNcIiwgXCJMZWdlbmRcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGV0aGVyIHRvIHNob3cgdGhlIGxlZ2VuZCB1cG9uIG1vdXNlb3Zlci5cIlxuICB9LFxuICBcImF4aXNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIihub25lKVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2V0IHRvIGVpdGhlciAneTEnIG9yICd5MicgdG8gYXNzaWduIGEgc2VyaWVzIHRvIGEgeS1heGlzIChwcmltYXJ5IG9yIHNlY29uZGFyeSkuIE11c3QgYmUgc2V0IHBlci1zZXJpZXMuXCJcbiAgfSxcbiAgXCJwaXhlbHNQZXJMYWJlbFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiNzAgKHgtYXhpcykgb3IgMzAgKHktYXhlcylcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIiwgXCJHcmlkXCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTnVtYmVyIG9mIHBpeGVscyB0byByZXF1aXJlIGJldHdlZW4gZWFjaCB4LSBhbmQgeS1sYWJlbC4gTGFyZ2VyIHZhbHVlcyB3aWxsIHlpZWxkIGEgc3BhcnNlciBheGlzIHdpdGggZmV3ZXIgdGlja3MuIFRoaXMgaXMgc2V0IG9uIGEgPGEgaHJlZj0ncGVyLWF4aXMuaHRtbCc+cGVyLWF4aXM8L2E+IGJhc2lzLlwiXG4gIH0sXG4gIFwibGFiZWxzRGl2XCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiTGVnZW5kXCJdLFxuICAgIFwidHlwZVwiOiBcIkRPTSBlbGVtZW50IG9yIHN0cmluZ1wiLFxuICAgIFwiZXhhbXBsZVwiOiBcIjxjb2RlIHN0eWxlPSdmb250LXNpemU6IHNtYWxsJz5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9vJyk8L2NvZGU+b3I8Y29kZT4nZm9vJ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTaG93IGRhdGEgbGFiZWxzIGluIGFuIGV4dGVybmFsIGRpdiwgcmF0aGVyIHRoYW4gb24gdGhlIGdyYXBoLiAgVGhpcyB2YWx1ZSBjYW4gZWl0aGVyIGJlIGEgZGl2IGVsZW1lbnQgb3IgYSBkaXYgaWQuXCJcbiAgfSxcbiAgXCJmcmFjdGlvbnNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ1NWIHBhcnNpbmdcIiwgXCJFcnJvciBCYXJzXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hlbiBzZXQsIGF0dGVtcHQgdG8gcGFyc2UgZWFjaCBjZWxsIGluIHRoZSBDU1YgZmlsZSBhcyBcXFwiYS9iXFxcIiwgd2hlcmUgYSBhbmQgYiBhcmUgaW50ZWdlcnMuIFRoZSByYXRpbyB3aWxsIGJlIHBsb3R0ZWQuIFRoaXMgYWxsb3dzIGNvbXB1dGF0aW9uIG9mIFdpbHNvbiBjb25maWRlbmNlIGludGVydmFscyAoc2VlIGJlbG93KS5cIlxuICB9LFxuICBcImxvZ3NjYWxlXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoZW4gc2V0IGZvciB0aGUgeS1heGlzIG9yIHgtYXhpcywgdGhlIGdyYXBoIHNob3dzIHRoYXQgYXhpcyBpbiBsb2cgc2NhbGUuIEFueSB2YWx1ZXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHplcm8gYXJlIG5vdCBkaXNwbGF5ZWQuIFNob3dpbmcgbG9nIHNjYWxlIHdpdGggcmFuZ2VzIHRoYXQgZ28gYmVsb3cgemVybyB3aWxsIHJlc3VsdCBpbiBhbiB1bnZpZXdhYmxlIGdyYXBoLlxcblxcbiBOb3QgY29tcGF0aWJsZSB3aXRoIHNob3daZXJvLiBjb25uZWN0U2VwYXJhdGVkUG9pbnRzIGlzIGlnbm9yZWQuIFRoaXMgaXMgaWdub3JlZCBmb3IgZGF0ZS1iYXNlZCB4LWF4ZXMuXCJcbiAgfSxcbiAgXCJzdHJva2VXaWR0aFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMS4wXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICBcImV4YW1wbGVcIjogXCIwLjUsIDIuMFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgd2lkdGggb2YgdGhlIGxpbmVzIGNvbm5lY3RpbmcgZGF0YSBwb2ludHMuIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5jcmVhc2UgdGhlIGNvbnRyYXN0IG9yIHNvbWUgZ3JhcGhzLlwiXG4gIH0sXG4gIFwic3Ryb2tlUGF0dGVyblwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImFycmF5PGludGVnZXI+XCIsXG4gICAgXCJleGFtcGxlXCI6IFwiWzEwLCAyLCA1LCAyXVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIGN1c3RvbSBwYXR0ZXJuIGFycmF5IHdoZXJlIHRoZSBldmVuIGluZGV4IGlzIGEgZHJhdyBhbmQgb2RkIGlzIGEgc3BhY2UgaW4gcGl4ZWxzLiBJZiBudWxsIHRoZW4gaXQgZHJhd3MgYSBzb2xpZCBsaW5lLiBUaGUgYXJyYXkgc2hvdWxkIGhhdmUgYSBldmVuIGxlbmd0aCBhcyBhbnkgb2RkIGxlbmd0aGVkIGFycmF5IGNvdWxkIGJlIGV4cHJlc3NlZCBhcyBhIHNtYWxsZXIgZXZlbiBsZW5ndGggYXJyYXkuIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgZGFzaGVkIGxpbmVzLlwiXG4gIH0sXG4gIFwic3Ryb2tlQm9yZGVyV2lkdGhcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIExpbmUgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZXhhbXBsZVwiOiBcIjEuMFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJEcmF3IGEgYm9yZGVyIGFyb3VuZCBncmFwaCBsaW5lcyB0byBtYWtlIGNyb3NzaW5nIGxpbmVzIG1vcmUgZWFzaWx5IGRpc3Rpbmd1aXNoYWJsZS4gVXNlZnVsIGZvciBncmFwaHMgd2l0aCBtYW55IGxpbmVzLlwiXG4gIH0sXG4gIFwic3Ryb2tlQm9yZGVyQ29sb3JcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIndoaXRlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJleGFtcGxlXCI6IFwicmVkLCAjY2NmZmRkXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkNvbG9yIGZvciB0aGUgbGluZSBib3JkZXIgdXNlZCBpZiBzdHJva2VCb3JkZXJXaWR0aCBpcyBzZXQuXCJcbiAgfSxcbiAgXCJ3aWxzb25JbnRlcnZhbFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwidHJ1ZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkVycm9yIEJhcnNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJVc2UgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgXFxcImZyYWN0aW9uc1xcXCIgb3B0aW9uLiBJbnN0ZWFkIG9mIHBsb3R0aW5nICsvLSBOIHN0YW5kYXJkIGRldmlhdGlvbnMsIGR5Z3JhcGhzIHdpbGwgY29tcHV0ZSBhIFdpbHNvbiBjb25maWRlbmNlIGludGVydmFsIGFuZCBwbG90IHRoYXQuIFRoaXMgaGFzIG1vcmUgcmVhc29uYWJsZSBiZWhhdmlvciBmb3IgcmF0aW9zIGNsb3NlIHRvIDAgb3IgMS5cIlxuICB9LFxuICBcImZpbGxHcmFwaFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIExpbmUgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlNob3VsZCB0aGUgYXJlYSB1bmRlcm5lYXRoIHRoZSBncmFwaCBiZSBmaWxsZWQ/IFRoaXMgb3B0aW9uIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggZXJyb3IgYmFycy4gVGhpcyBtYXkgYmUgc2V0IG9uIGEgPGEgaHJlZj0ncGVyLWF4aXMuaHRtbCc+cGVyLXNlcmllczwvYT4gYmFzaXMuXCJcbiAgfSxcbiAgXCJoaWdobGlnaHRDaXJjbGVTaXplXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIzXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiSW50ZXJhY3RpdmUgRWxlbWVudHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgc2l6ZSBpbiBwaXhlbHMgb2YgdGhlIGRvdCBkcmF3biBvdmVyIGhpZ2hsaWdodGVkIHBvaW50cy5cIlxuICB9LFxuICBcImdyaWRMaW5lQ29sb3JcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcInJnYigxMjgsMTI4LDEyOClcIixcbiAgICBcImxhYmVsc1wiOiBbXCJHcmlkXCJdLFxuICAgIFwidHlwZVwiOiBcInJlZCwgYmx1ZVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgY29sb3Igb2YgdGhlIGdyaWRsaW5lcy4gVGhpcyBtYXkgYmUgc2V0IG9uIGEgcGVyLWF4aXMgYmFzaXMgdG8gZGVmaW5lIGVhY2ggYXhpcycgZ3JpZCBzZXBhcmF0ZWx5LlwiXG4gIH0sXG4gIFwiZ3JpZExpbmVQYXR0ZXJuXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiR3JpZFwiXSxcbiAgICBcInR5cGVcIjogXCJhcnJheTxpbnRlZ2VyPlwiLFxuICAgIFwiZXhhbXBsZVwiOiBcIlsxMCwgMiwgNSwgMl1cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBjdXN0b20gcGF0dGVybiBhcnJheSB3aGVyZSB0aGUgZXZlbiBpbmRleCBpcyBhIGRyYXcgYW5kIG9kZCBpcyBhIHNwYWNlIGluIHBpeGVscy4gSWYgbnVsbCB0aGVuIGl0IGRyYXdzIGEgc29saWQgbGluZS4gVGhlIGFycmF5IHNob3VsZCBoYXZlIGEgZXZlbiBsZW5ndGggYXMgYW55IG9kZCBsZW5ndGhlZCBhcnJheSBjb3VsZCBiZSBleHByZXNzZWQgYXMgYSBzbWFsbGVyIGV2ZW4gbGVuZ3RoIGFycmF5LiBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGRhc2hlZCBncmlkbGluZXMuXCJcbiAgfSxcbiAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJbdHJ1ZSwgdHJ1ZSwgLi4uXVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcIkFycmF5IG9mIGJvb2xlYW5zXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoaWNoIHNlcmllcyBzaG91bGQgaW5pdGlhbGx5IGJlIHZpc2libGU/IE9uY2UgdGhlIER5Z3JhcGggaGFzIGJlZW4gY29uc3RydWN0ZWQsIHlvdSBjYW4gYWNjZXNzIGFuZCBtb2RpZnkgdGhlIHZpc2liaWxpdHkgb2YgZWFjaCBzZXJpZXMgdXNpbmcgdGhlIDxjb2RlPnZpc2liaWxpdHk8L2NvZGU+IGFuZCA8Y29kZT5zZXRWaXNpYmlsaXR5PC9jb2RlPiBtZXRob2RzLlwiXG4gIH0sXG4gIFwidmFsdWVSYW5nZVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiRnVsbCByYW5nZSBvZiB0aGUgaW5wdXQgaXMgc2hvd25cIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiQXJyYXkgb2YgdHdvIG51bWJlcnNcIixcbiAgICBcImV4YW1wbGVcIjogXCJbMTAsIDExMF1cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRXhwbGljaXRseSBzZXQgdGhlIHZlcnRpY2FsIHJhbmdlIG9mIHRoZSBncmFwaCB0byBbbG93LCBoaWdoXS4gVGhpcyBtYXkgYmUgc2V0IG9uIGEgcGVyLWF4aXMgYmFzaXMgdG8gZGVmaW5lIGVhY2ggeS1heGlzIHNlcGFyYXRlbHkuIElmIGVpdGhlciBsaW1pdCBpcyB1bnNwZWNpZmllZCwgaXQgd2lsbCBiZSBjYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgKGUuZy4gW251bGwsIDMwXSB0byBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZSBqdXN0IHRoZSBsb3dlciBib3VuZClcIlxuICB9LFxuICBcImNvbG9yU2F0dXJhdGlvblwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMS4wXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBTZXJpZXMgQ29sb3JzXCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0ICgwLjAgLSAxLjApXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIDxzdHJvbmc+Y29sb3JzPC9zdHJvbmc+IGlzIG5vdCBzcGVjaWZpZWQsIHNhdHVyYXRpb24gb2YgdGhlIGF1dG9tYXRpY2FsbHktZ2VuZXJhdGVkIGRhdGEgc2VyaWVzIGNvbG9ycy5cIlxuICB9LFxuICBcImhpZGVPdmVybGF5T25Nb3VzZU91dFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwidHJ1ZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkludGVyYWN0aXZlIEVsZW1lbnRzXCIsIFwiTGVnZW5kXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hldGhlciB0byBoaWRlIHRoZSBsZWdlbmQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBjaGFydCBhcmVhLlwiXG4gIH0sXG4gIFwibGVnZW5kXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJvbm1vdXNlb3ZlclwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkxlZ2VuZFwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hlbiB0byBkaXNwbGF5IHRoZSBsZWdlbmQuIEJ5IGRlZmF1bHQsIGl0IG9ubHkgYXBwZWFycyB3aGVuIGEgdXNlciBtb3VzZXMgb3ZlciB0aGUgY2hhcnQuIFNldCBpdCB0byBcXFwiYWx3YXlzXFxcIiB0byBhbHdheXMgZGlzcGxheSBhIGxlZ2VuZCBvZiBzb21lIHNvcnQuIFdoZW4gc2V0IHRvIFxcXCJmb2xsb3dcXFwiLCBsZWdlbmQgZm9sbG93cyBoaWdobGlnaHRlZCBwb2ludHMuXCJcbiAgfSxcbiAgXCJsZWdlbmRGb3JtYXR0ZXJcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJMZWdlbmRcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oZGF0YSk6IHN0cmluZ1wiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIFsgXCJkYXRhXCIsIFwiQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHNlbGVjdGlvbiAob3IgbGFjayBvZiBhIHNlbGVjdGlvbikuIFRoaXMgaW5jbHVkZXMgZm9ybWF0dGVkIHZhbHVlcyBhbmQgc2VyaWVzIGluZm9ybWF0aW9uLiBTZWUgPGEgaHJlZj1cXFwiaHR0cHM6Ly9naXRodWIuY29tL2RhbnZrL2R5Z3JhcGhzL3B1bGwvNjgzXFxcIj5oZXJlPC9hPiBmb3Igc2FtcGxlIHZhbHVlcy5cIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2V0IHRoaXMgdG8gc3VwcGx5IGEgY3VzdG9tIGZvcm1hdHRlciBmb3IgdGhlIGxlZ2VuZC4gU2VlIDxhIGhyZWY9XFxcImh0dHBzOi8vZ2l0aHViLmNvbS9kYW52ay9keWdyYXBocy9wdWxsLzY4M1xcXCI+dGhpcyBjb21tZW50PC9hPiBhbmQgdGhlIDxhIGhyZWY9XFxcInRlc3RzL2xlZ2VuZC1mb3JtYXR0ZXIuaHRtbFxcXCI+bGVnZW5kRm9ybWF0dGVyIGRlbW88L2E+IGZvciB1c2FnZS5cIlxuICB9LFxuICBcImxhYmVsc1Nob3daZXJvVmFsdWVzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJ0cnVlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiTGVnZW5kXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2hvdyB6ZXJvIHZhbHVlIGxhYmVscyBpbiB0aGUgbGFiZWxzRGl2LlwiXG4gIH0sXG4gIFwic3RlcFBsb3RcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIHNldCwgZGlzcGxheSB0aGUgZ3JhcGggYXMgYSBzdGVwIHBsb3QgaW5zdGVhZCBvZiBhIGxpbmUgcGxvdC4gVGhpcyBvcHRpb24gbWF5IGVpdGhlciBiZSBzZXQgZm9yIHRoZSB3aG9sZSBncmFwaCBvciBmb3Igc2luZ2xlIHNlcmllcy5cIlxuICB9LFxuICBcImxhYmVsc1VUQ1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJWYWx1ZSBkaXNwbGF5L2Zvcm1hdHRpbmdcIiwgXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTaG93IGRhdGUvdGltZSBsYWJlbHMgYWNjb3JkaW5nIHRvIFVUQyAoaW5zdGVhZCBvZiBsb2NhbCB0aW1lKS5cIlxuICB9LFxuICBcImxhYmVsc0tNQlwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJWYWx1ZSBkaXNwbGF5L2Zvcm1hdHRpbmdcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTaG93IEsvTS9CIGZvciB0aG91c2FuZHMvbWlsbGlvbnMvYmlsbGlvbnMgb24geS1heGlzLlwiXG4gIH0sXG4gIFwicmlnaHRHYXBcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjVcIixcbiAgICBcImxhYmVsc1wiOiBbXCJPdmVyYWxsIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJOdW1iZXIgb2YgcGl4ZWxzIHRvIGxlYXZlIGJsYW5rIGF0IHRoZSByaWdodCBlZGdlIG9mIHRoZSBEeWdyYXBoLiBUaGlzIG1ha2VzIGl0IGVhc2llciB0byBoaWdobGlnaHQgdGhlIHJpZ2h0LW1vc3QgZGF0YSBwb2ludC5cIlxuICB9LFxuICBcImRyYXdBeGVzQXRaZXJvXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoZW4gc2V0LCBkcmF3IHRoZSBYIGF4aXMgYXQgdGhlIFk9MCBwb3NpdGlvbiBhbmQgdGhlIFkgYXhpcyBhdCB0aGUgWD0wIHBvc2l0aW9uIGlmIHRob3NlIHBvc2l0aW9ucyBhcmUgaW5zaWRlIHRoZSBncmFwaCdzIHZpc2libGUgYXJlYS4gT3RoZXJ3aXNlLCBkcmF3IHRoZSBheGVzIGF0IHRoZSBib3R0b20gb3IgbGVmdCBncmFwaCBlZGdlIGFzIHVzdWFsLlwiXG4gIH0sXG4gIFwieFJhbmdlUGFkXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIwXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkFkZCB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiBleHRyYSBzcGFjZSAoaW4gcGl4ZWxzKSBhcm91bmQgdGhlIFgtYXhpcyB2YWx1ZSByYW5nZSB0byBlbnN1cmUgcG9pbnRzIGF0IHRoZSBlZGdlcyByZW1haW4gdmlzaWJsZS5cIlxuICB9LFxuICBcInlSYW5nZVBhZFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiBzZXQsIGFkZCB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiBleHRyYSBzcGFjZSAoaW4gcGl4ZWxzKSBhcm91bmQgdGhlIFktYXhpcyB2YWx1ZSByYW5nZSB0byBlbnN1cmUgcG9pbnRzIGF0IHRoZSBlZGdlcyByZW1haW4gdmlzaWJsZS4gSWYgdW5zZXQsIHVzZSB0aGUgdHJhZGl0aW9uYWwgWSBwYWRkaW5nIGFsZ29yaXRobS5cIlxuICB9LFxuICBcImF4aXNMYWJlbEZvcm1hdHRlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiRGVwZW5kcyBvbiB0aGUgZGF0YSB0eXBlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKG51bWJlciBvciBEYXRlLCBncmFudWxhcml0eSwgb3B0cywgZHlncmFwaClcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcIm51bWJlciBvciBkYXRlXCIgLCBcIkVpdGhlciBhIG51bWJlciAoZm9yIGEgbnVtZXJpYyBheGlzKSBvciBhIERhdGUgb2JqZWN0IChmb3IgYSBkYXRlIGF4aXMpXCIgXSxcbiAgICAgIFsgXCJncmFudWxhcml0eVwiICwgXCJzcGVjaWZpZXMgaG93IGZpbmUtZ3JhaW5lZCB0aGUgYXhpcyBpcy4gRm9yIGRhdGUgYXhlcywgdGhpcyBpcyBhIHJlZmVyZW5jZSB0byB0aGUgdGltZSBncmFudWxhcml0eSBlbnVtZXJhdGlvbiwgZGVmaW5lZCBpbiBkeWdyYXBoLXRpY2tlcnMuanMsIGUuZy4gRHlncmFwaC5XRUVLTFkuXCIgXSxcbiAgICAgIFsgXCJvcHRzXCIgLCBcImEgZnVuY3Rpb24gd2hpY2ggcHJvdmlkZXMgYWNjZXNzIHRvIHZhcmlvdXMgb3B0aW9ucyBvbiB0aGUgZHlncmFwaCwgZS5nLiBvcHRzKCdsYWJlbHNLTUInKS5cIiBdLFxuICAgICAgWyBcImR5Z3JhcGhcIiAsIFwidGhlIHJlZmVyZW5jZWQgZ3JhcGhcIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRnVuY3Rpb24gdG8gY2FsbCB0byBmb3JtYXQgdGhlIHRpY2sgdmFsdWVzIHRoYXQgYXBwZWFyIGFsb25nIGFuIGF4aXMuIFRoaXMgaXMgdXN1YWxseSBzZXQgb24gYSA8YSBocmVmPSdwZXItYXhpcy5odG1sJz5wZXItYXhpczwvYT4gYmFzaXMuXCJcbiAgfSxcbiAgXCJjbGlja0NhbGxiYWNrXCI6IHtcbiAgICBcInNuaXBwZXRcIjogXCJmdW5jdGlvbihlLCBkYXRlX21pbGxpcyl7PGJyPiZuYnNwOyZuYnNwO2FsZXJ0KG5ldyBEYXRlKGRhdGVfbWlsbGlzKSk7PGJyPn1cIixcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ2FsbGJhY2tzXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGUsIHgsIHBvaW50cylcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcImVcIiAsIFwiVGhlIGV2ZW50IG9iamVjdCBmb3IgdGhlIGNsaWNrXCIgXSxcbiAgICAgIFsgXCJ4XCIgLCBcIlRoZSB4IHZhbHVlIHRoYXQgd2FzIGNsaWNrZWQgKGZvciBkYXRlcywgdGhpcyBpcyBtaWxsaXNlY29uZHMgc2luY2UgZXBvY2gpXCIgXSxcbiAgICAgIFsgXCJwb2ludHNcIiAsIFwiVGhlIGNsb3Nlc3QgcG9pbnRzIGFsb25nIHRoYXQgZGF0ZS4gU2VlIDxhIGhyZWY9JyNwb2ludF9wcm9wZXJ0aWVzJz5Qb2ludCBwcm9wZXJ0aWVzPC9hPiBmb3IgZGV0YWlscy5cIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGNhbnZhcyBpcyBjbGlja2VkLlwiXG4gIH0sXG4gIFwibGFiZWxzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJbXFxcIlhcXFwiLCBcXFwiWTFcXFwiLCBcXFwiWTJcXFwiLCAuLi5dKlwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkxlZ2VuZFwiXSxcbiAgICBcInR5cGVcIjogXCJhcnJheTxzdHJpbmc+XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgbmFtZSBmb3IgZWFjaCBkYXRhIHNlcmllcywgaW5jbHVkaW5nIHRoZSBpbmRlcGVuZGVudCAoWCkgc2VyaWVzLiBGb3IgQ1NWIGZpbGVzIGFuZCBEYXRhVGFibGUgb2JqZWN0aW9ucywgdGhpcyBpcyBkZXRlcm1pbmVkIGJ5IGNvbnRleHQuIEZvciByYXcgZGF0YSwgdGhpcyBtdXN0IGJlIHNwZWNpZmllZC4gSWYgaXQgaXMgbm90LCBkZWZhdWx0IHZhbHVlcyBhcmUgc3VwcGxpZWQgYW5kIGEgd2FybmluZyBpcyBsb2dnZWQuXCJcbiAgfSxcbiAgXCJkYXRlV2luZG93XCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJGdWxsIHJhbmdlIG9mIHRoZSBpbnB1dCBpcyBzaG93blwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJBcnJheSBvZiB0d28gbnVtYmVyc1wiLFxuICAgIFwiZXhhbXBsZVwiOiBcIls8YnI+Jm5ic3A7Jm5ic3A7RGF0ZS5wYXJzZSgnMjAwNi0wMS0wMScpLDxicj4mbmJzcDsmbmJzcDsobmV3IERhdGUoKSkudmFsdWVPZigpPGJyPl1cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSW5pdGlhbGx5IHpvb20gaW4gb24gYSBzZWN0aW9uIG9mIHRoZSBncmFwaC4gSXMgb2YgdGhlIGZvcm0gW2VhcmxpZXN0LCBsYXRlc3RdLCB3aGVyZSBlYXJsaWVzdC9sYXRlc3QgYXJlIG1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaC4gSWYgdGhlIGRhdGEgZm9yIHRoZSB4LWF4aXMgaXMgbnVtZXJpYywgdGhlIHZhbHVlcyBpbiBkYXRlV2luZG93IG11c3QgYWxzbyBiZSBudW1iZXJzLlwiXG4gIH0sXG4gIFwic2hvd1JvbGxlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJJbnRlcmFjdGl2ZSBFbGVtZW50c1wiLCBcIlJvbGxpbmcgQXZlcmFnZXNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiB0aGUgcm9sbGluZyBhdmVyYWdlIHBlcmlvZCB0ZXh0IGJveCBzaG91bGQgYmUgc2hvd24uXCJcbiAgfSxcbiAgXCJzaWdtYVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMi4wXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRXJyb3IgQmFyc1wiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIGVycm9yQmFycyBpcyBzZXQsIHNoYWRlIHRoaXMgbWFueSBzdGFuZGFyZCBkZXZpYXRpb25zIGFib3ZlL2JlbG93IGVhY2ggcG9pbnQuXCJcbiAgfSxcbiAgXCJjdXN0b21CYXJzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNTViBwYXJzaW5nXCIsIFwiRXJyb3IgQmFyc1wiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoZW4gc2V0LCBwYXJzZSBlYWNoIENTViBjZWxsIGFzIFxcXCJsb3c7bWlkZGxlO2hpZ2hcXFwiLiBFcnJvciBiYXJzIHdpbGwgYmUgZHJhd24gZm9yIGVhY2ggcG9pbnQgYmV0d2VlbiBsb3cgYW5kIGhpZ2gsIHdpdGggdGhlIHNlcmllcyBpdHNlbGYgZ29pbmcgdGhyb3VnaCBtaWRkbGUuXCJcbiAgfSxcbiAgXCJjb2xvclZhbHVlXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIxLjBcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIFNlcmllcyBDb2xvcnNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZmxvYXQgKDAuMCAtIDEuMClcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgY29sb3JzIGlzIG5vdCBzcGVjaWZpZWQsIHZhbHVlIG9mIHRoZSBkYXRhIHNlcmllcyBjb2xvcnMsIGFzIGluIGh1ZS9zYXR1cmF0aW9uL3ZhbHVlLiAoMC4wLTEuMCwgZGVmYXVsdCAwLjUpXCJcbiAgfSxcbiAgXCJlcnJvckJhcnNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ1NWIHBhcnNpbmdcIiwgXCJFcnJvciBCYXJzXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRG9lcyB0aGUgZGF0YSBjb250YWluIHN0YW5kYXJkIGRldmlhdGlvbnM/IFNldHRpbmcgdGhpcyB0byB0cnVlIGFsdGVycyB0aGUgaW5wdXQgZm9ybWF0IChzZWUgYWJvdmUpLlwiXG4gIH0sXG4gIFwiZGlzcGxheUFubm90YXRpb25zXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkFubm90YXRpb25zXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiT25seSBhcHBsaWVzIHdoZW4gRHlncmFwaHMgaXMgdXNlZCBhcyBhIEdWaXogY2hhcnQuIENhdXNlcyBzdHJpbmcgY29sdW1ucyBmb2xsb3dpbmcgYSBkYXRhIHNlcmllcyB0byBiZSBpbnRlcnByZXRlZCBhcyBhbm5vdGF0aW9ucyBvbiBwb2ludHMgaW4gdGhhdCBzZXJpZXMuIFRoaXMgaXMgdGhlIHNhbWUgZm9ybWF0IHVzZWQgYnkgR29vZ2xlJ3MgQW5ub3RhdGVkVGltZUxpbmUgY2hhcnQuXCJcbiAgfSxcbiAgXCJwYW5FZGdlRnJhY3Rpb25cIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIiwgXCJJbnRlcmFjdGl2ZSBFbGVtZW50c1wiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgZmFydGhlc3QgYSBncmFwaCBtYXkgYmUgcGFubmVkLCBpbiBwZXJjZW50IG9mIHRoZSBkaXNwbGF5LiBGb3IgZXhhbXBsZSwgYSB2YWx1ZSBvZiAwLjEgbWVhbnMgdGhhdCB0aGUgZ3JhcGggY2FuIG9ubHkgYmUgcGFubmVkIDEwJSBwYXNzZWQgdGhlIGVkZ2VzIG9mIHRoZSBkaXNwbGF5ZWQgdmFsdWVzLiBudWxsIG1lYW5zIG5vIGJvdW5kcy5cIlxuICB9LFxuICBcInRpdGxlXCI6IHtcbiAgICBcImxhYmVsc1wiOiBbXCJDaGFydCBsYWJlbHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUZXh0IHRvIGRpc3BsYXkgYWJvdmUgdGhlIGNoYXJ0LiBZb3UgY2FuIHN1cHBseSBhbnkgSFRNTCBmb3IgdGhpcyB2YWx1ZSwgbm90IGp1c3QgdGV4dC4gSWYgeW91IHdpc2ggdG8gc3R5bGUgaXQgdXNpbmcgQ1NTLCB1c2UgdGhlICdkeWdyYXBoLWxhYmVsJyBvciAnZHlncmFwaC10aXRsZScgY2xhc3Nlcy5cIlxuICB9LFxuICBcInRpdGxlSGVpZ2h0XCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIxOFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNoYXJ0IGxhYmVsc1wiXSxcbiAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkhlaWdodCBvZiB0aGUgY2hhcnQgdGl0bGUsIGluIHBpeGVscy4gVGhpcyBhbHNvIGNvbnRyb2xzIHRoZSBkZWZhdWx0IGZvbnQgc2l6ZSBvZiB0aGUgdGl0bGUuIElmIHlvdSBzdHlsZSB0aGUgdGl0bGUgb24geW91ciBvd24sIHRoaXMgY29udHJvbHMgaG93IG11Y2ggc3BhY2UgaXMgc2V0IGFzaWRlIGFib3ZlIHRoZSBjaGFydCBmb3IgdGhlIHRpdGxlJ3MgZGl2LlwiXG4gIH0sXG4gIFwieGxhYmVsXCI6IHtcbiAgICBcImxhYmVsc1wiOiBbXCJDaGFydCBsYWJlbHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUZXh0IHRvIGRpc3BsYXkgYmVsb3cgdGhlIGNoYXJ0J3MgeC1heGlzLiBZb3UgY2FuIHN1cHBseSBhbnkgSFRNTCBmb3IgdGhpcyB2YWx1ZSwgbm90IGp1c3QgdGV4dC4gSWYgeW91IHdpc2ggdG8gc3R5bGUgaXQgdXNpbmcgQ1NTLCB1c2UgdGhlICdkeWdyYXBoLWxhYmVsJyBvciAnZHlncmFwaC14bGFiZWwnIGNsYXNzZXMuXCJcbiAgfSxcbiAgXCJ4TGFiZWxIZWlnaHRcIjoge1xuICAgIFwibGFiZWxzXCI6IFtcIkNoYXJ0IGxhYmVsc1wiXSxcbiAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwiMThcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSGVpZ2h0IG9mIHRoZSB4LWF4aXMgbGFiZWwsIGluIHBpeGVscy4gVGhpcyBhbHNvIGNvbnRyb2xzIHRoZSBkZWZhdWx0IGZvbnQgc2l6ZSBvZiB0aGUgeC1heGlzIGxhYmVsLiBJZiB5b3Ugc3R5bGUgdGhlIGxhYmVsIG9uIHlvdXIgb3duLCB0aGlzIGNvbnRyb2xzIGhvdyBtdWNoIHNwYWNlIGlzIHNldCBhc2lkZSBiZWxvdyB0aGUgY2hhcnQgZm9yIHRoZSB4LWF4aXMgbGFiZWwncyBkaXYuXCJcbiAgfSxcbiAgXCJ5bGFiZWxcIjoge1xuICAgIFwibGFiZWxzXCI6IFtcIkNoYXJ0IGxhYmVsc1wiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRleHQgdG8gZGlzcGxheSB0byB0aGUgbGVmdCBvZiB0aGUgY2hhcnQncyB5LWF4aXMuIFlvdSBjYW4gc3VwcGx5IGFueSBIVE1MIGZvciB0aGlzIHZhbHVlLCBub3QganVzdCB0ZXh0LiBJZiB5b3Ugd2lzaCB0byBzdHlsZSBpdCB1c2luZyBDU1MsIHVzZSB0aGUgJ2R5Z3JhcGgtbGFiZWwnIG9yICdkeWdyYXBoLXlsYWJlbCcgY2xhc3Nlcy4gVGhlIHRleHQgd2lsbCBiZSByb3RhdGVkIDkwIGRlZ3JlZXMgYnkgZGVmYXVsdCwgc28gQ1NTIHJ1bGVzIG1heSBiZWhhdmUgaW4gdW5pbnR1aXRpdmUgd2F5cy4gTm8gYWRkaXRpb25hbCBzcGFjZSBpcyBzZXQgYXNpZGUgZm9yIGEgeS1heGlzIGxhYmVsLiBJZiB5b3UgbmVlZCBtb3JlIHNwYWNlLCBpbmNyZWFzZSB0aGUgd2lkdGggb2YgdGhlIHktYXhpcyB0aWNrIGxhYmVscyB1c2luZyB0aGUgeUF4aXNMYWJlbFdpZHRoIG9wdGlvbi4gSWYgeW91IG5lZWQgYSB3aWRlciBkaXYgZm9yIHRoZSB5LWF4aXMgbGFiZWwsIGVpdGhlciBzdHlsZSBpdCB0aGF0IHdheSB3aXRoIENTUyAoYnV0IHJlbWVtYmVyIHRoYXQgaXQncyByb3RhdGVkLCBzbyB3aWR0aCBpcyBjb250cm9sbGVkIGJ5IHRoZSAnaGVpZ2h0JyBwcm9wZXJ0eSkgb3Igc2V0IHRoZSB5TGFiZWxXaWR0aCBvcHRpb24uXCJcbiAgfSxcbiAgXCJ5MmxhYmVsXCI6IHtcbiAgICBcImxhYmVsc1wiOiBbXCJDaGFydCBsYWJlbHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUZXh0IHRvIGRpc3BsYXkgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjaGFydCdzIHNlY29uZGFyeSB5LWF4aXMuIFRoaXMgbGFiZWwgaXMgb25seSBkaXNwbGF5ZWQgaWYgYSBzZWNvbmRhcnkgeS1heGlzIGlzIHByZXNlbnQuIFNlZSA8YSBocmVmPSdodHRwOi8vZHlncmFwaHMuY29tL3Rlc3RzL3R3by1heGVzLmh0bWwnPnRoaXMgdGVzdDwvYT4gZm9yIGFuIGV4YW1wbGUgb2YgaG93IHRvIGRvIHRoaXMuIFRoZSBjb21tZW50cyBmb3IgdGhlICd5bGFiZWwnIG9wdGlvbiBnZW5lcmFsbHkgYXBwbHkgaGVyZSBhcyB3ZWxsLiBUaGlzIGxhYmVsIGdldHMgYSAnZHlncmFwaC15MmxhYmVsJyBpbnN0ZWFkIG9mIGEgJ2R5Z3JhcGgteWxhYmVsJyBjbGFzcy5cIlxuICB9LFxuICBcInlMYWJlbFdpZHRoXCI6IHtcbiAgICBcImxhYmVsc1wiOiBbXCJDaGFydCBsYWJlbHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIjE4XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldpZHRoIG9mIHRoZSBkaXYgd2hpY2ggY29udGFpbnMgdGhlIHktYXhpcyBsYWJlbC4gU2luY2UgdGhlIHktYXhpcyBsYWJlbCBhcHBlYXJzIHJvdGF0ZWQgOTAgZGVncmVlcywgdGhpcyBhY3R1YWxseSBhZmZlY3RzIHRoZSBoZWlnaHQgb2YgaXRzIGRpdi5cIlxuICB9LFxuICBcImRyYXdHcmlkXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJ0cnVlIGZvciB4IGFuZCB5LCBmYWxzZSBmb3IgeTJcIixcbiAgICBcImxhYmVsc1wiOiBbXCJHcmlkXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCIgOiBcIldoZXRoZXIgdG8gZGlzcGxheSBncmlkbGluZXMgaW4gdGhlIGNoYXJ0LiBUaGlzIG1heSBiZSBzZXQgb24gYSBwZXItYXhpcyBiYXNpcyB0byBkZWZpbmUgdGhlIHZpc2liaWxpdHkgb2YgZWFjaCBheGlzJyBncmlkIHNlcGFyYXRlbHkuXCJcbiAgfSxcbiAgXCJpbmRlcGVuZGVudFRpY2tzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJ0cnVlIGZvciB5LCBmYWxzZSBmb3IgeTJcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIiwgXCJHcmlkXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCIgOiBcIk9ubHkgdmFsaWQgZm9yIHkgYW5kIHkyLCBoYXMgbm8gZWZmZWN0IG9uIHg6IFRoaXMgb3B0aW9uIGRlZmluZXMgd2hldGhlciB0aGUgeSBheGVzIHNob3VsZCBhbGlnbiB0aGVpciB0aWNrcyBvciBpZiB0aGV5IHNob3VsZCBiZSBpbmRlcGVuZGVudC4gUG9zc2libGUgY29tYmluYXRpb25zOiAxLikgeT10cnVlLCB5Mj1mYWxzZSAoZGVmYXVsdCk6IHkgaXMgdGhlIHByaW1hcnkgYXhpcyBhbmQgdGhlIHkyIHRpY2tzIGFyZSBhbGlnbmVkIHRvIHRoZSB0aGUgb25lcyBvZiB5LiAob25seSAxIGdyaWQpIDIuKSB5PWZhbHNlLCB5Mj10cnVlOiB5MiBpcyB0aGUgcHJpbWFyeSBheGlzIGFuZCB0aGUgeSB0aWNrcyBhcmUgYWxpZ25lZCB0byB0aGUgdGhlIG9uZXMgb2YgeTIuIChvbmx5IDEgZ3JpZCkgMy4pIHk9dHJ1ZSwgeTI9dHJ1ZTogQm90aCBheGlzIGFyZSBpbmRlcGVuZGVudCBhbmQgaGF2ZSB0aGVpciBvd24gdGlja3MuICgyIGdyaWRzKSA0LikgeT1mYWxzZSwgeTI9ZmFsc2U6IEludmFsaWQgY29uZmlndXJhdGlvbiBjYXVzZXMgYW4gZXJyb3IuXCJcbiAgfSxcbiAgXCJkcmF3QXhpc1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwidHJ1ZSBmb3IgeCBhbmQgeSwgZmFsc2UgZm9yIHkyXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCIgOiBcIldoZXRoZXIgdG8gZHJhdyB0aGUgc3BlY2lmaWVkIGF4aXMuIFRoaXMgbWF5IGJlIHNldCBvbiBhIHBlci1heGlzIGJhc2lzIHRvIGRlZmluZSB0aGUgdmlzaWJpbGl0eSBvZiBlYWNoIGF4aXMgc2VwYXJhdGVseS4gU2V0dGluZyB0aGlzIHRvIGZhbHNlIGFsc28gcHJldmVudHMgYXhpcyB0aWNrcyBmcm9tIGJlaW5nIGRyYXduIGFuZCByZWNsYWltcyB0aGUgc3BhY2UgZm9yIHRoZSBjaGFydCBncmlkL2xpbmVzLlwiXG4gIH0sXG4gIFwiZ3JpZExpbmVXaWR0aFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMC4zXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiR3JpZFwiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIiA6IFwiVGhpY2tuZXNzIChpbiBwaXhlbHMpIG9mIHRoZSBncmlkbGluZXMgZHJhd24gdW5kZXIgdGhlIGNoYXJ0LiBUaGUgdmVydGljYWwvaG9yaXpvbnRhbCBncmlkbGluZXMgY2FuIGJlIHR1cm5lZCBvZmYgZW50aXJlbHkgYnkgdXNpbmcgdGhlIGRyYXdHcmlkIG9wdGlvbi4gVGhpcyBtYXkgYmUgc2V0IG9uIGEgcGVyLWF4aXMgYmFzaXMgdG8gZGVmaW5lIGVhY2ggYXhpcycgZ3JpZCBzZXBhcmF0ZWx5LlwiXG4gIH0sXG4gIFwiYXhpc0xpbmVXaWR0aFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMC4zXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiIDogXCJUaGlja25lc3MgKGluIHBpeGVscykgb2YgdGhlIHgtIGFuZCB5LWF4aXMgbGluZXMuXCJcbiAgfSxcbiAgXCJheGlzTGluZUNvbG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJibGFja1wiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCIgOiBcIkNvbG9yIG9mIHRoZSB4LSBhbmQgeS1heGlzIGxpbmVzLiBBY2NlcHRzIGFueSB2YWx1ZSB3aGljaCB0aGUgSFRNTCBjYW52YXMgc3Ryb2tlU3R5bGUgYXR0cmlidXRlIHVuZGVyc3RhbmRzLCBlLmcuICdibGFjaycgb3IgJ3JnYigwLCAxMDAsIDI1NSknLlwiXG4gIH0sXG4gIFwiZmlsbEFscGhhXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIwLjE1XCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRXJyb3IgQmFyc1wiLCBcIkRhdGEgU2VyaWVzIENvbG9yc1wiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdCAoMC4wIC0gMS4wKVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIiA6IFwiRXJyb3IgYmFycyAob3IgY3VzdG9tIGJhcnMpIGZvciBlYWNoIHNlcmllcyBhcmUgZHJhd24gaW4gdGhlIHNhbWUgY29sb3IgYXMgdGhlIHNlcmllcywgYnV0IHdpdGggcGFydGlhbCB0cmFuc3BhcmVuY3kuIFRoaXMgc2V0cyB0aGUgdHJhbnNwYXJlbmN5LiBBIHZhbHVlIG9mIDAuMCBtZWFucyB0aGF0IHRoZSBlcnJvciBiYXJzIHdpbGwgbm90IGJlIGRyYXduLCB3aGVyZWFzIGEgdmFsdWUgb2YgMS4wIG1lYW5zIHRoYXQgdGhlIGVycm9yIGJhcnMgd2lsbCBiZSBhcyBkYXJrIGFzIHRoZSBsaW5lIGZvciB0aGUgc2VyaWVzIGl0c2VsZi4gVGhpcyBjYW4gYmUgdXNlZCB0byBwcm9kdWNlIGNoYXJ0IGxpbmVzIHdob3NlIHRoaWNrbmVzcyB2YXJpZXMgYXQgZWFjaCBwb2ludC5cIlxuICB9LFxuICBcImF4aXNMYWJlbFdpZHRoXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCI1MCAoeS1heGlzKSwgNjAgKHgtYXhpcylcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIiwgXCJDaGFydCBsYWJlbHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIiA6IFwiV2lkdGggKGluIHBpeGVscykgb2YgdGhlIGNvbnRhaW5pbmcgZGl2cyBmb3IgeC0gYW5kIHktYXhpcyBsYWJlbHMuIEZvciB0aGUgeS1heGlzLCB0aGlzIGFsc28gY29udHJvbHMgdGhlIHdpZHRoIG9mIHRoZSB5LWF4aXMuIE5vdGUgdGhhdCBmb3IgdGhlIHgtYXhpcywgdGhpcyBpcyBpbmRlcGVuZGVudCBmcm9tIHBpeGVsc1BlckxhYmVsLCB3aGljaCBjb250cm9scyB0aGUgc3BhY2luZyBiZXR3ZWVuIGxhYmVscy5cIlxuICB9LFxuICBcInNpZ0ZpZ3NcIiA6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiVmFsdWUgZGlzcGxheS9mb3JtYXR0aW5nXCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQnkgZGVmYXVsdCwgZHlncmFwaHMgZGlzcGxheXMgbnVtYmVycyB3aXRoIGEgZml4ZWQgbnVtYmVyIG9mIGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gSWYgeW91J2QgcHJlZmVyIHRvIGhhdmUgYSBmaXhlZCBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZmlndXJlcywgc2V0IHRoaXMgb3B0aW9uIHRvIHRoYXQgbnVtYmVyIG9mIHNpZyBmaWdzLiBBIHZhbHVlIG9mIDIsIGZvciBpbnN0YW5jZSwgd291bGQgY2F1c2UgMSB0byBiZSBkaXNwbGF5IGFzIDEuMCBhbmQgMTIzNCB0byBiZSBkaXNwbGF5ZWQgYXMgMS4yM2UrMy5cIlxuICB9LFxuICBcImRpZ2l0c0FmdGVyRGVjaW1hbFwiIDoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjJcIixcbiAgICBcImxhYmVsc1wiOiBbXCJWYWx1ZSBkaXNwbGF5L2Zvcm1hdHRpbmdcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJVbmxlc3MgaXQncyBydW4gaW4gc2NpZW50aWZpYyBtb2RlIChzZWUgdGhlIDxjb2RlPnNpZ0ZpZ3M8L2NvZGU+IG9wdGlvbiksIGR5Z3JhcGhzIGRpc3BsYXlzIG51bWJlcnMgd2l0aCA8Y29kZT5kaWdpdHNBZnRlckRlY2ltYWw8L2NvZGU+IGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gVHJhaWxpbmcgemVyb3MgYXJlIG5vdCBkaXNwbGF5ZWQsIHNvIHdpdGggYSB2YWx1ZSBvZiAyIHlvdSdsbCBnZXQgJzAnLCAnMC4xJywgJzAuMTInLCAnMTIzLjQ1JyBidXQgbm90ICcxMjMuNDU2JyAoaXQgd2lsbCBiZSByb3VuZGVkIHRvICcxMjMuNDYnKS4gTnVtYmVycyB3aXRoIGFic29sdXRlIHZhbHVlIGxlc3MgdGhhbiAwLjFeZGlnaXRzQWZ0ZXJEZWNpbWFsIChpLmUuIHRob3NlIHdoaWNoIHdvdWxkIHNob3cgdXAgYXMgJzAuMDAnKSB3aWxsIGJlIGRpc3BsYXllZCBpbiBzY2llbnRpZmljIG5vdGF0aW9uLlwiXG4gIH0sXG4gIFwibWF4TnVtYmVyV2lkdGhcIiA6IHtcbiAgICBcImRlZmF1bHRcIjogXCI2XCIsXG4gICAgXCJsYWJlbHNcIjogW1wiVmFsdWUgZGlzcGxheS9mb3JtYXR0aW5nXCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hlbiBkaXNwbGF5aW5nIG51bWJlcnMgaW4gbm9ybWFsIChub3Qgc2NpZW50aWZpYykgbW9kZSwgbGFyZ2UgbnVtYmVycyB3aWxsIGJlIGRpc3BsYXllZCB3aXRoIG1hbnkgdHJhaWxpbmcgemVyb3MgKGUuZy4gMTAwMDAwMDAwIGluc3RlYWQgb2YgMWU5KS4gVGhpcyBjYW4gbGVhZCB0byB1bndpZWxkeSB5LWF4aXMgbGFiZWxzLiBJZiB0aGVyZSBhcmUgbW9yZSB0aGFuIDxjb2RlPm1heE51bWJlcldpZHRoPC9jb2RlPiBkaWdpdHMgdG8gdGhlIGxlZnQgb2YgdGhlIGRlY2ltYWwgaW4gYSBudW1iZXIsIGR5Z3JhcGhzIHdpbGwgc3dpdGNoIHRvIHNjaWVudGlmaWMgbm90YXRpb24sIGV2ZW4gd2hlbiBub3Qgb3BlcmF0aW5nIGluIHNjaWVudGlmaWMgbW9kZS4gSWYgeW91J2QgbGlrZSB0byBzZWUgYWxsIHRob3NlIGRpZ2l0cywgc2V0IHRoaXMgdG8gc29tZXRoaW5nIGxhcmdlLCBsaWtlIDIwIG9yIDMwLlwiXG4gIH0sXG4gIFwiZmlsZVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiKHNldCB3aGVuIGNvbnN0cnVjdGVkKVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGFcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nIChVUkwgb2YgQ1NWIG9yIENTViksIEdWaXogRGF0YVRhYmxlIG9yIDJEIEFycmF5XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlNldHMgdGhlIGRhdGEgYmVpbmcgZGlzcGxheWVkIGluIHRoZSBjaGFydC4gVGhpcyBjYW4gb25seSBiZSBzZXQgd2hlbiBjYWxsaW5nIHVwZGF0ZU9wdGlvbnM7IGl0IGNhbm5vdCBiZSBzZXQgZnJvbSB0aGUgY29uc3RydWN0b3IuIEZvciBhIGZ1bGwgZGVzY3JpcHRpb24gb2YgdmFsaWQgZGF0YSBmb3JtYXRzLCBzZWUgdGhlIDxhIGhyZWY9J2h0dHA6Ly9keWdyYXBocy5jb20vZGF0YS5odG1sJz5EYXRhIEZvcm1hdHM8L2E+IHBhZ2UuXCJcbiAgfSxcbiAgXCJ0aW1pbmdOYW1lXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogWyBcIkRlYnVnZ2luZ1wiLCBcIkRlcHJlY2F0ZWRcIiBdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTZXQgdGhpcyBvcHRpb24gdG8gbG9nIHRpbWluZyBpbmZvcm1hdGlvbi4gVGhlIHZhbHVlIG9mIHRoZSBvcHRpb24gd2lsbCBiZSBsb2dnZWQgYWxvbmcgd2l0aCB0aGUgdGltaW1nLCBzbyB0aGF0IHlvdSBjYW4gZGlzdGluZ3Vpc2ggbXVsdGlwbGUgZHlncmFwaHMgb24gdGhlIHNhbWUgcGFnZS5cIlxuICB9LFxuICBcInNob3dSYW5nZVNlbGVjdG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2hvdyBvciBoaWRlIHRoZSByYW5nZSBzZWxlY3RvciB3aWRnZXQuXCJcbiAgfSxcbiAgXCJyYW5nZVNlbGVjdG9ySGVpZ2h0XCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCI0MFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSGVpZ2h0LCBpbiBwaXhlbHMsIG9mIHRoZSByYW5nZSBzZWxlY3RvciB3aWRnZXQuIFRoaXMgb3B0aW9uIGNhbiBvbmx5IGJlIHNwZWNpZmllZCBhdCBEeWdyYXBoIGNyZWF0aW9uIHRpbWUuXCJcbiAgfSxcbiAgXCJyYW5nZVNlbGVjdG9yUGxvdFN0cm9rZUNvbG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIjODA4RkFCXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiUmFuZ2UgU2VsZWN0b3JcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSByYW5nZSBzZWxlY3RvciBtaW5pIHBsb3Qgc3Ryb2tlIGNvbG9yLiBUaGlzIGNhbiBiZSBvZiB0aGUgZm9ybSBcXFwiI0FBQkJDQ1xcXCIgb3IgXFxcInJnYigyNTUsMTAwLDIwMClcXFwiIG9yIFxcXCJ5ZWxsb3dcXFwiLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBudWxsIG9yIFxcXCJcXFwiIHRvIHR1cm4gb2ZmIHN0cm9rZS5cIlxuICB9LFxuICBcInJhbmdlU2VsZWN0b3JQbG90RmlsbENvbG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIjQTdCMUM0XCIsXG4gICAgXCJsYWJlbHNcIjogW1wiUmFuZ2UgU2VsZWN0b3JcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSByYW5nZSBzZWxlY3RvciBtaW5pIHBsb3QgZmlsbCBjb2xvci4gVGhpcyBjYW4gYmUgb2YgdGhlIGZvcm0gXFxcIiNBQUJCQ0NcXFwiIG9yIFxcXCJyZ2IoMjU1LDEwMCwyMDApXFxcIiBvciBcXFwieWVsbG93XFxcIi4gWW91IGNhbiBhbHNvIHNwZWNpZnkgbnVsbCBvciBcXFwiXFxcIiB0byB0dXJuIG9mZiBmaWxsLlwiXG4gIH0sXG4gIFwicmFuZ2VTZWxlY3RvclBsb3RGaWxsR3JhZGllbnRDb2xvclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwid2hpdGVcIixcbiAgICBcImxhYmVsc1wiOiBbXCJSYW5nZSBTZWxlY3RvclwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHRvcCBjb2xvciBmb3IgdGhlIHJhbmdlIHNlbGVjdG9yIG1pbmkgcGxvdCBmaWxsIGNvbG9yIGdyYWRpZW50LiBUaGlzIGNhbiBiZSBvZiB0aGUgZm9ybSBcXFwiI0FBQkJDQ1xcXCIgb3IgXFxcInJnYigyNTUsMTAwLDIwMClcXFwiIG9yIFxcXCJyZ2JhKDI1NSwxMDAsMjAwLDQyKVxcXCIgb3IgXFxcInllbGxvd1xcXCIuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IG51bGwgb3IgXFxcIlxcXCIgdG8gZGlzYWJsZSB0aGUgZ3JhZGllbnQgYW5kIGZpbGwgd2l0aCBvbmUgc2luZ2xlIGNvbG9yLlwiXG4gIH0sXG4gIFwicmFuZ2VTZWxlY3RvckJhY2tncm91bmRTdHJva2VDb2xvclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZ3JheVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgY29sb3Igb2YgdGhlIGxpbmVzIGJlbG93IGFuZCBvbiBib3RoIHNpZGVzIG9mIHRoZSByYW5nZSBzZWxlY3RvciBtaW5pIHBsb3QuIFRoaXMgY2FuIGJlIG9mIHRoZSBmb3JtIFxcXCIjQUFCQkNDXFxcIiBvciBcXFwicmdiKDI1NSwxMDAsMjAwKVxcXCIgb3IgXFxcInllbGxvd1xcXCIuXCJcbiAgfSxcbiAgXCJyYW5nZVNlbGVjdG9yQmFja2dyb3VuZExpbmVXaWR0aFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSB3aWR0aCBvZiB0aGUgbGluZXMgYmVsb3cgYW5kIG9uIGJvdGggc2lkZXMgb2YgdGhlIHJhbmdlIHNlbGVjdG9yIG1pbmkgcGxvdC5cIlxuICB9LFxuICBcInJhbmdlU2VsZWN0b3JQbG90TGluZVdpZHRoXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIxLjVcIixcbiAgICBcImxhYmVsc1wiOiBbXCJSYW5nZSBTZWxlY3RvclwiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgd2lkdGggb2YgdGhlIHJhbmdlIHNlbGVjdG9yIG1pbmkgcGxvdCBsaW5lLlwiXG4gIH0sXG4gIFwicmFuZ2VTZWxlY3RvckZvcmVncm91bmRTdHJva2VDb2xvclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiYmxhY2tcIixcbiAgICBcImxhYmVsc1wiOiBbXCJSYW5nZSBTZWxlY3RvclwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBsaW5lcyBpbiB0aGUgaW50ZXJhY3RpdmUgbGF5ZXIgb2YgdGhlIHJhbmdlIHNlbGVjdG9yLiBUaGlzIGNhbiBiZSBvZiB0aGUgZm9ybSBcXFwiI0FBQkJDQ1xcXCIgb3IgXFxcInJnYigyNTUsMTAwLDIwMClcXFwiIG9yIFxcXCJ5ZWxsb3dcXFwiLlwiXG4gIH0sXG4gIFwicmFuZ2VTZWxlY3RvckZvcmVncm91bmRMaW5lV2lkdGhcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjFcIixcbiAgICBcImxhYmVsc1wiOiBbXCJSYW5nZSBTZWxlY3RvclwiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgd2lkdGggdGhlIGxpbmVzIGluIHRoZSBpbnRlcmFjdGl2ZSBsYXllciBvZiB0aGUgcmFuZ2Ugc2VsZWN0b3IuXCJcbiAgfSxcbiAgXCJyYW5nZVNlbGVjdG9yQWxwaGFcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjAuNlwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0ICgwLjAgLSAxLjApXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSB0cmFuc3BhcmVuY3kgb2YgdGhlIHZlaWwgdGhhdCBpcyBkcmF3biBvdmVyIHRoZSB1bnNlbGVjdGVkIHBvcnRpb25zIG9mIHRoZSByYW5nZSBzZWxlY3RvciBtaW5pIHBsb3QuIEEgdmFsdWUgb2YgMCByZXByZXNlbnRzIGZ1bGwgdHJhbnNwYXJlbmN5IGFuZCB0aGUgdW5zZWxlY3RlZCBwb3J0aW9ucyBvZiB0aGUgbWluaSBwbG90IHdpbGwgYXBwZWFyIGFzIG5vcm1hbC4gQSB2YWx1ZSBvZiAxIHJlcHJlc2VudHMgZnVsbCBvcGFjaXR5IGFuZCB0aGUgdW5zZWxlY3RlZCBwb3J0aW9ucyBvZiB0aGUgbWluaSBwbG90IHdpbGwgYmUgaGlkZGVuLlwiXG4gIH0sXG4gIFwic2hvd0luUmFuZ2VTZWxlY3RvclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTWFyayB0aGlzIHNlcmllcyBmb3IgaW5jbHVzaW9uIGluIHRoZSByYW5nZSBzZWxlY3Rvci4gVGhlIG1pbmkgcGxvdCBjdXJ2ZSB3aWxsIGJlIGFuIGF2ZXJhZ2Ugb2YgYWxsIHN1Y2ggc2VyaWVzLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgZm9yIGFueSBzZXJpZXMsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGF2ZXJhZ2UgYWxsIHRoZSB2aXNpYmxlIHNlcmllcy4gU2V0dGluZyBpdCBmb3Igb25lIHNlcmllcyB3aWxsIHJlc3VsdCBpbiB0aGF0IHNlcmllcyBiZWluZyBjaGFydGVkIGFsb25lIGluIHRoZSByYW5nZSBzZWxlY3Rvci4gT25jZSBpdCdzIHNldCBmb3IgYSBzaW5nbGUgc2VyaWVzLCBpdCBuZWVkcyB0byBiZSBzZXQgZm9yIGFsbCBzZXJpZXMgd2hpY2ggc2hvdWxkIGJlIGluY2x1ZGVkIChyZWdhcmRsZXNzIG9mIHZpc2liaWxpdHkpLlwiXG4gIH0sXG4gIFwiYW5pbWF0ZWRab29tc1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJJbnRlcmFjdGl2ZSBFbGVtZW50c1wiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlNldCB0aGlzIG9wdGlvbiB0byBhbmltYXRlIHRoZSB0cmFuc2l0aW9uIGJldHdlZW4gem9vbSB3aW5kb3dzLiBBcHBsaWVzIHRvIHByb2dyYW1tYXRpYyBhbmQgaW50ZXJhY3RpdmUgem9vbXMuIE5vdGUgdGhhdCBpZiB5b3UgYWxzbyBzZXQgYSBkcmF3Q2FsbGJhY2ssIGl0IHdpbGwgYmUgY2FsbGVkIHNldmVyYWwgdGltZXMgb24gZWFjaCB6b29tLiBJZiB5b3Ugc2V0IGEgem9vbUNhbGxiYWNrLCBpdCB3aWxsIG9ubHkgYmUgY2FsbGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGUuXCJcbiAgfSxcbiAgXCJwbG90dGVyXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJbRHlncmFwaENhbnZhc1JlbmRlcmVyLlBsb3R0ZXJzLmZpbGxQbG90dGVyLCBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuUGxvdHRlcnMuZXJyb3JQbG90dGVyLCBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuUGxvdHRlcnMubGluZVBsb3R0ZXJdXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYXJyYXkgb3IgZnVuY3Rpb25cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBmdW5jdGlvbiAob3IgYXJyYXkgb2YgZnVuY3Rpb25zKSB3aGljaCBwbG90IGVhY2ggZGF0YSBzZXJpZXMgb24gdGhlIGNoYXJ0LiBUT0RPKGRhbnZrKTogbW9yZSBkZXRhaWxzISBNYXkgYmUgc2V0IHBlci1zZXJpZXMuXCJcbiAgfSxcbiAgXCJheGVzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ29uZmlndXJhdGlvblwiXSxcbiAgICBcInR5cGVcIjogXCJPYmplY3RcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRGVmaW5lcyBwZXItYXhpcyBvcHRpb25zLiBWYWxpZCBrZXlzIGFyZSAneCcsICd5JyBhbmQgJ3kyJy4gT25seSBzb21lIG9wdGlvbnMgbWF5IGJlIHNldCBvbiBhIHBlci1heGlzIGJhc2lzLiBJZiBhbiBvcHRpb24gbWF5IGJlIHNldCBpbiB0aGlzIHdheSwgaXQgd2lsbCBiZSBub3RlZCBvbiB0aGlzIHBhZ2UuIFNlZSBhbHNvIGRvY3VtZW50YXRpb24gb24gPGEgaHJlZj0naHR0cDovL2R5Z3JhcGhzLmNvbS9wZXItYXhpcy5odG1sJz5wZXItc2VyaWVzIGFuZCBwZXItYXhpcyBvcHRpb25zPC9hPi5cIlxuICB9LFxuICBcInNlcmllc1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlNlcmllc1wiXSxcbiAgICBcInR5cGVcIjogXCJPYmplY3RcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRGVmaW5lcyBwZXItc2VyaWVzIG9wdGlvbnMuIEl0cyBrZXlzIG1hdGNoIHRoZSB5LWF4aXMgbGFiZWwgbmFtZXMsIGFuZCB0aGUgdmFsdWVzIGFyZSBkaWN0aW9uYXJpZXMgdGhlbXNlbHZlcyB0aGF0IGNvbnRhaW4gb3B0aW9ucyBzcGVjaWZpYyB0byB0aGF0IHNlcmllcy5cIlxuICB9LFxuICBcInBsdWdpbnNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIltdXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ29uZmlndXJhdGlvblwiXSxcbiAgICBcInR5cGVcIjogXCJBcnJheTxwbHVnaW4+XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkRlZmluZXMgcGVyLWdyYXBoIHBsdWdpbnMuIFVzZWZ1bCBmb3IgcGVyLWdyYXBoIGN1c3RvbWl6YXRpb25cIlxuICB9LFxuICBcImRhdGFIYW5kbGVyXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIoZGVwZW5kcyBvbiBkYXRhKVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGFcIl0sXG4gICAgXCJ0eXBlXCI6IFwiRHlncmFwaC5EYXRhSGFuZGxlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJDdXN0b20gRGF0YUhhbmRsZXIuIFRoaXMgaXMgYW4gYWR2YW5jZWQgY3VzdG9taXphdGlvbi4gU2VlIGh0dHA6Ly9iaXQubHkvMTUxRTdBcS5cIlxuICB9XG59XG47ICAvLyA8L0pTT04+XG4vLyBOT1RFOiBpbiBhZGRpdGlvbiB0byBwYXJzaW5nIGFzIEpTLCB0aGlzIHNuaXBwZXQgaXMgZXhwZWN0ZWQgdG8gYmUgdmFsaWRcbi8vIEpTT04uIFRoaXMgYXNzdW1wdGlvbiBjYW5ub3QgYmUgY2hlY2tlZCBpbiBKUywgYnV0IGl0IHdpbGwgYmUgY2hlY2tlZCB3aGVuXG4vLyBkb2N1bWVudGF0aW9uIGlzIGdlbmVyYXRlZCBieSB0aGUgZ2VuZXJhdGUtZG9jdW1lbnRhdGlvbi5weSBzY3JpcHQuIEZvciB0aGVcbi8vIG1vc3QgcGFydCwgdGhpcyBqdXN0IG1lYW5zIHRoYXQgeW91IHNob3VsZCBhbHdheXMgdXNlIGRvdWJsZSBxdW90ZXMuXG5cbi8vIERvIGEgcXVpY2sgc2FuaXR5IGNoZWNrIG9uIHRoZSBvcHRpb25zIHJlZmVyZW5jZS5cbnZhciB3YXJuID0gZnVuY3Rpb24obXNnKSB7IGlmICh3aW5kb3cuY29uc29sZSkgd2luZG93LmNvbnNvbGUud2Fybihtc2cpOyB9O1xudmFyIGZsZHMgPSBbJ3R5cGUnLCAnZGVmYXVsdCcsICdkZXNjcmlwdGlvbiddO1xudmFyIHZhbGlkX2NhdHMgPSBbXG4gJ0Fubm90YXRpb25zJyxcbiAnQXhpcyBkaXNwbGF5JyxcbiAnQ2hhcnQgbGFiZWxzJyxcbiAnQ1NWIHBhcnNpbmcnLFxuICdDYWxsYmFja3MnLFxuICdEYXRhJyxcbiAnRGF0YSBMaW5lIGRpc3BsYXknLFxuICdEYXRhIFNlcmllcyBDb2xvcnMnLFxuICdFcnJvciBCYXJzJyxcbiAnR3JpZCcsXG4gJ0ludGVyYWN0aXZlIEVsZW1lbnRzJyxcbiAnUmFuZ2UgU2VsZWN0b3InLFxuICdMZWdlbmQnLFxuICdPdmVyYWxsIGRpc3BsYXknLFxuICdSb2xsaW5nIEF2ZXJhZ2VzJyxcbiAnU2VyaWVzJyxcbiAnVmFsdWUgZGlzcGxheS9mb3JtYXR0aW5nJyxcbiAnWm9vbWluZycsXG4gJ0RlYnVnZ2luZycsXG4gJ0NvbmZpZ3VyYXRpb24nLFxuICdEZXByZWNhdGVkJ1xuXTtcbnZhciBpO1xudmFyIGNhdHMgPSB7fTtcbmZvciAoaSA9IDA7IGkgPCB2YWxpZF9jYXRzLmxlbmd0aDsgaSsrKSBjYXRzW3ZhbGlkX2NhdHNbaV1dID0gdHJ1ZTtcblxuZm9yICh2YXIgayBpbiBPUFRJT05TX1JFRkVSRU5DRSkge1xuICBpZiAoIU9QVElPTlNfUkVGRVJFTkNFLmhhc093blByb3BlcnR5KGspKSBjb250aW51ZTtcbiAgdmFyIG9wID0gT1BUSU9OU19SRUZFUkVOQ0Vba107XG4gIGZvciAoaSA9IDA7IGkgPCBmbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFvcC5oYXNPd25Qcm9wZXJ0eShmbGRzW2ldKSkge1xuICAgICAgd2FybignT3B0aW9uICcgKyBrICsgJyBtaXNzaW5nIFwiJyArIGZsZHNbaV0gKyAnXCIgcHJvcGVydHknKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZihvcFtmbGRzW2ldXSkgIT0gJ3N0cmluZycpIHtcbiAgICAgIHdhcm4oayArICcuJyArIGZsZHNbaV0gKyAnIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcnKTtcbiAgICB9XG4gIH1cbiAgdmFyIGxhYmVscyA9IG9wLmxhYmVscztcbiAgaWYgKHR5cGVvZihsYWJlbHMpICE9PSAnb2JqZWN0Jykge1xuICAgIHdhcm4oJ09wdGlvbiBcIicgKyBrICsgJ1wiIGlzIG1pc3NpbmcgYSBcImxhYmVsc1wiOiBbLi4uXSBvcHRpb24nKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWNhdHMuaGFzT3duUHJvcGVydHkobGFiZWxzW2ldKSkge1xuICAgICAgICB3YXJuKCdPcHRpb24gXCInICsgayArICdcIiBoYXMgbGFiZWwgXCInICsgbGFiZWxzW2ldICtcbiAgICAgICAgICAgICAnXCIsIHdoaWNoIGlzIGludmFsaWQuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbn1cbn1cblxuZXhwb3J0IGRlZmF1bHQgT1BUSU9OU19SRUZFUkVOQ0U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLW9wdGlvbnMtcmVmZXJlbmNlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__ = __webpack_require__(8);\n/**\n * To create a \"drag\" interaction, you typically register a mousedown event\n * handler on the element where the drag begins. In that handler, you register a\n * mouseup handler on the window to determine when the mouse is released,\n * wherever that release happens. This works well, except when the user releases\n * the mouse over an off-domain iframe. In that case, the mouseup event is\n * handled by the iframe and never bubbles up to the window handler.\n *\n * To deal with this issue, we cover iframes with high z-index divs to make sure\n * they don't capture mouseup.\n *\n * Usage:\n * element.addEventListener('mousedown', function() {\n *   var tarper = new IFrameTarp();\n *   tarper.cover();\n *   var mouseUpHandler = function() {\n *     ...\n *     window.removeEventListener(mouseUpHandler);\n *     tarper.uncover();\n *   };\n *   window.addEventListener('mouseup', mouseUpHandler);\n * };\n *\n * @constructor\n */\n\n\nfunction IFrameTarp() {\n  /** @type {Array.<!HTMLDivElement>} */\n  this.tarps = [];\n};\n\n/**\n * Find all the iframes in the document and cover them with high z-index\n * transparent divs.\n */\nIFrameTarp.prototype.cover = function () {\n  var iframes = document.getElementsByTagName(\"iframe\");\n  for (var i = 0; i < iframes.length; i++) {\n    var iframe = iframes[i];\n    var pos = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"k\" /* findPos */](iframe),\n        x = pos.x,\n        y = pos.y,\n        width = iframe.offsetWidth,\n        height = iframe.offsetHeight;\n\n    var div = document.createElement(\"div\");\n    div.style.position = \"absolute\";\n    div.style.left = x + 'px';\n    div.style.top = y + 'px';\n    div.style.width = width + 'px';\n    div.style.height = height + 'px';\n    div.style.zIndex = 999;\n    document.body.appendChild(div);\n    this.tarps.push(div);\n  }\n};\n\n/**\n * Remove all the iframe covers. You should call this in a mouseup handler.\n */\nIFrameTarp.prototype.uncover = function () {\n  for (var i = 0; i < this.tarps.length; i++) {\n    this.tarps[i].parentNode.removeChild(this.tarps[i]);\n  }\n  this.tarps = [];\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (IFrameTarp);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9pZnJhbWUtdGFycC5qcz8xODQzIl0sIm5hbWVzIjpbIklGcmFtZVRhcnAiLCJ0YXJwcyIsInByb3RvdHlwZSIsImNvdmVyIiwiaWZyYW1lcyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpIiwibGVuZ3RoIiwiaWZyYW1lIiwicG9zIiwieCIsInkiLCJ3aWR0aCIsIm9mZnNldFdpZHRoIiwiaGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwiZGl2IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwicG9zaXRpb24iLCJsZWZ0IiwidG9wIiwiekluZGV4IiwiYm9keSIsImFwcGVuZENoaWxkIiwicHVzaCIsInVuY292ZXIiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7O0FBRUEsU0FBU0EsVUFBVCxHQUFzQjtBQUNwQjtBQUNBLE9BQUtDLEtBQUwsR0FBYSxFQUFiO0FBQ0Q7O0FBRUQ7Ozs7QUFJQUQsV0FBV0UsU0FBWCxDQUFxQkMsS0FBckIsR0FBNkIsWUFBVztBQUN0QyxNQUFJQyxVQUFVQyxTQUFTQyxvQkFBVCxDQUE4QixRQUE5QixDQUFkO0FBQ0EsT0FBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlILFFBQVFJLE1BQTVCLEVBQW9DRCxHQUFwQyxFQUF5QztBQUN2QyxRQUFJRSxTQUFTTCxRQUFRRyxDQUFSLENBQWI7QUFDQSxRQUFJRyxNQUFNLGdFQUFjRCxNQUFkLENBQVY7QUFBQSxRQUNJRSxJQUFJRCxJQUFJQyxDQURaO0FBQUEsUUFFSUMsSUFBSUYsSUFBSUUsQ0FGWjtBQUFBLFFBR0lDLFFBQVFKLE9BQU9LLFdBSG5CO0FBQUEsUUFJSUMsU0FBU04sT0FBT08sWUFKcEI7O0FBTUEsUUFBSUMsTUFBTVosU0FBU2EsYUFBVCxDQUF1QixLQUF2QixDQUFWO0FBQ0FELFFBQUlFLEtBQUosQ0FBVUMsUUFBVixHQUFxQixVQUFyQjtBQUNBSCxRQUFJRSxLQUFKLENBQVVFLElBQVYsR0FBaUJWLElBQUksSUFBckI7QUFDQU0sUUFBSUUsS0FBSixDQUFVRyxHQUFWLEdBQWdCVixJQUFJLElBQXBCO0FBQ0FLLFFBQUlFLEtBQUosQ0FBVU4sS0FBVixHQUFrQkEsUUFBUSxJQUExQjtBQUNBSSxRQUFJRSxLQUFKLENBQVVKLE1BQVYsR0FBbUJBLFNBQVMsSUFBNUI7QUFDQUUsUUFBSUUsS0FBSixDQUFVSSxNQUFWLEdBQW1CLEdBQW5CO0FBQ0FsQixhQUFTbUIsSUFBVCxDQUFjQyxXQUFkLENBQTBCUixHQUExQjtBQUNBLFNBQUtoQixLQUFMLENBQVd5QixJQUFYLENBQWdCVCxHQUFoQjtBQUNEO0FBQ0YsQ0FwQkQ7O0FBc0JBOzs7QUFHQWpCLFdBQVdFLFNBQVgsQ0FBcUJ5QixPQUFyQixHQUErQixZQUFXO0FBQ3hDLE9BQUssSUFBSXBCLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLTixLQUFMLENBQVdPLE1BQS9CLEVBQXVDRCxHQUF2QyxFQUE0QztBQUMxQyxTQUFLTixLQUFMLENBQVdNLENBQVgsRUFBY3FCLFVBQWQsQ0FBeUJDLFdBQXpCLENBQXFDLEtBQUs1QixLQUFMLENBQVdNLENBQVgsQ0FBckM7QUFDRDtBQUNELE9BQUtOLEtBQUwsR0FBYSxFQUFiO0FBQ0QsQ0FMRDs7QUFPQSx5REFBZUQsVUFBZiIsImZpbGUiOiIyMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVG8gY3JlYXRlIGEgXCJkcmFnXCIgaW50ZXJhY3Rpb24sIHlvdSB0eXBpY2FsbHkgcmVnaXN0ZXIgYSBtb3VzZWRvd24gZXZlbnRcbiAqIGhhbmRsZXIgb24gdGhlIGVsZW1lbnQgd2hlcmUgdGhlIGRyYWcgYmVnaW5zLiBJbiB0aGF0IGhhbmRsZXIsIHlvdSByZWdpc3RlciBhXG4gKiBtb3VzZXVwIGhhbmRsZXIgb24gdGhlIHdpbmRvdyB0byBkZXRlcm1pbmUgd2hlbiB0aGUgbW91c2UgaXMgcmVsZWFzZWQsXG4gKiB3aGVyZXZlciB0aGF0IHJlbGVhc2UgaGFwcGVucy4gVGhpcyB3b3JrcyB3ZWxsLCBleGNlcHQgd2hlbiB0aGUgdXNlciByZWxlYXNlc1xuICogdGhlIG1vdXNlIG92ZXIgYW4gb2ZmLWRvbWFpbiBpZnJhbWUuIEluIHRoYXQgY2FzZSwgdGhlIG1vdXNldXAgZXZlbnQgaXNcbiAqIGhhbmRsZWQgYnkgdGhlIGlmcmFtZSBhbmQgbmV2ZXIgYnViYmxlcyB1cCB0byB0aGUgd2luZG93IGhhbmRsZXIuXG4gKlxuICogVG8gZGVhbCB3aXRoIHRoaXMgaXNzdWUsIHdlIGNvdmVyIGlmcmFtZXMgd2l0aCBoaWdoIHotaW5kZXggZGl2cyB0byBtYWtlIHN1cmVcbiAqIHRoZXkgZG9uJ3QgY2FwdHVyZSBtb3VzZXVwLlxuICpcbiAqIFVzYWdlOlxuICogZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbigpIHtcbiAqICAgdmFyIHRhcnBlciA9IG5ldyBJRnJhbWVUYXJwKCk7XG4gKiAgIHRhcnBlci5jb3ZlcigpO1xuICogICB2YXIgbW91c2VVcEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAqICAgICAuLi5cbiAqICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihtb3VzZVVwSGFuZGxlcik7XG4gKiAgICAgdGFycGVyLnVuY292ZXIoKTtcbiAqICAgfTtcbiAqICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZVVwSGFuZGxlcik7XG4gKiB9O1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2R5Z3JhcGgtdXRpbHMnO1xuXG5mdW5jdGlvbiBJRnJhbWVUYXJwKCkge1xuICAvKiogQHR5cGUge0FycmF5LjwhSFRNTERpdkVsZW1lbnQ+fSAqL1xuICB0aGlzLnRhcnBzID0gW107XG59O1xuXG4vKipcbiAqIEZpbmQgYWxsIHRoZSBpZnJhbWVzIGluIHRoZSBkb2N1bWVudCBhbmQgY292ZXIgdGhlbSB3aXRoIGhpZ2ggei1pbmRleFxuICogdHJhbnNwYXJlbnQgZGl2cy5cbiAqL1xuSUZyYW1lVGFycC5wcm90b3R5cGUuY292ZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlmcmFtZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlmcmFtZVwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlmcmFtZSA9IGlmcmFtZXNbaV07XG4gICAgdmFyIHBvcyA9IHV0aWxzLmZpbmRQb3MoaWZyYW1lKSxcbiAgICAgICAgeCA9IHBvcy54LFxuICAgICAgICB5ID0gcG9zLnksXG4gICAgICAgIHdpZHRoID0gaWZyYW1lLm9mZnNldFdpZHRoLFxuICAgICAgICBoZWlnaHQgPSBpZnJhbWUub2Zmc2V0SGVpZ2h0O1xuXG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGRpdi5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgZGl2LnN0eWxlLnRvcCA9IHkgKyAncHgnO1xuICAgIGRpdi5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICBkaXYuc3R5bGUuekluZGV4ID0gOTk5O1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICB0aGlzLnRhcnBzLnB1c2goZGl2KTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIHRoZSBpZnJhbWUgY292ZXJzLiBZb3Ugc2hvdWxkIGNhbGwgdGhpcyBpbiBhIG1vdXNldXAgaGFuZGxlci5cbiAqL1xuSUZyYW1lVGFycC5wcm90b3R5cGUudW5jb3ZlciA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGFycHMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnRhcnBzW2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy50YXJwc1tpXSk7XG4gIH1cbiAgdGhpcy50YXJwcyA9IFtdO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSUZyYW1lVGFycDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZHlncmFwaHMvc3JjL2lmcmFtZS10YXJwLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/* styles */\n__webpack_require__(36)\n\nvar Component = __webpack_require__(5)(\n  /* script */\n  __webpack_require__(35),\n  /* template */\n  null,\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = \"/home/fzab/dev/vue/vue-dygraphs/src/components/Dygraphs.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key !== \"__esModule\"})) {console.error(\"named exports are not supported in *.vue files.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-06a2a9a8\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-06a2a9a8\", Component.options)\n  }\n})()}\n\nmodule.exports = Component.exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9EeWdyYXBocy52dWU/YmRiMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQSxzQkFBZ0c7O0FBRWhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsaURBQWlELElBQUk7O0FBRXBJO0FBQ0EsWUFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwiZmlsZSI6IjIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKiBzdHlsZXMgKi9cbnJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwib21pdFxcXCI6MCxcXFwicmVtb3ZlXFxcIjp0cnVlfSFjc3MtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlcj9pZD1kYXRhLXYtMDZhMmE5YTghLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9EeWdyYXBocy52dWVcIilcblxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vRHlncmFwaHMudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIGNzc01vZHVsZXMgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCIvaG9tZS9memFiL2Rldi92dWUvdnVlLWR5Z3JhcGhzL3NyYy9jb21wb25lbnRzL0R5Z3JhcGhzLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMDZhMmE5YThcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0wNmEyYTlhOFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy9EeWdyYXBocy52dWVcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///21\n");

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_dygraph__ = __webpack_require__(13);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__src_dygraph__[\"a\"]; });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22\n");

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bars__ = __webpack_require__(9);\n/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler implementation for the custom bars option.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * @constructor\n * @extends Dygraph.DataHandlers.BarsHandler\n */\nvar CustomBarsHandler = function CustomBarsHandler() {};\n\nCustomBarsHandler.prototype = new __WEBPACK_IMPORTED_MODULE_0__bars__[\"a\" /* default */]();\n\n/** @inheritDoc */\nCustomBarsHandler.prototype.extractSeries = function (rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var x, y, point;\n  var logScale = options.get('logscale');\n  for (var j = 0; j < rawData.length; j++) {\n    x = rawData[j][0];\n    point = rawData[j][i];\n    if (logScale && point !== null) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point[0] <= 0 || point[1] <= 0 || point[2] <= 0) {\n        point = null;\n      }\n    }\n    // Extract to the unified data format.\n    if (point !== null) {\n      y = point[1];\n      if (y !== null && !isNaN(y)) {\n        series.push([x, y, [point[0], point[2]]]);\n      } else {\n        series.push([x, y, [y, y]]);\n      }\n    } else {\n      series.push([x, null, [null, null]]);\n    }\n  }\n  return series;\n};\n\n/** @inheritDoc */\nCustomBarsHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n  var y, low, high, mid, count, i, extremes;\n\n  low = 0;\n  mid = 0;\n  high = 0;\n  count = 0;\n  for (i = 0; i < originalData.length; i++) {\n    y = originalData[i][1];\n    extremes = originalData[i][2];\n    rollingData[i] = originalData[i];\n\n    if (y !== null && !isNaN(y)) {\n      low += extremes[0];\n      mid += y;\n      high += extremes[1];\n      count += 1;\n    }\n    if (i - rollPeriod >= 0) {\n      var prev = originalData[i - rollPeriod];\n      if (prev[1] !== null && !isNaN(prev[1])) {\n        low -= prev[2][0];\n        mid -= prev[1];\n        high -= prev[2][1];\n        count -= 1;\n      }\n    }\n    if (count) {\n      rollingData[i] = [originalData[i][0], 1.0 * mid / count, [1.0 * low / count, 1.0 * high / count]];\n    } else {\n      rollingData[i] = [originalData[i][0], null, [null, null]];\n    }\n  }\n\n  return rollingData;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (CustomBarsHandler);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9iYXJzLWN1c3RvbS5qcz8wZDFmIl0sIm5hbWVzIjpbIkN1c3RvbUJhcnNIYW5kbGVyIiwicHJvdG90eXBlIiwiZXh0cmFjdFNlcmllcyIsInJhd0RhdGEiLCJpIiwib3B0aW9ucyIsInNlcmllcyIsIngiLCJ5IiwicG9pbnQiLCJsb2dTY2FsZSIsImdldCIsImoiLCJsZW5ndGgiLCJpc05hTiIsInB1c2giLCJyb2xsaW5nQXZlcmFnZSIsIm9yaWdpbmFsRGF0YSIsInJvbGxQZXJpb2QiLCJNYXRoIiwibWluIiwicm9sbGluZ0RhdGEiLCJsb3ciLCJoaWdoIiwibWlkIiwiY291bnQiLCJleHRyZW1lcyIsInByZXYiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Ozs7OztBQU1BOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQSxJQUFJQSxvQkFBb0IsU0FBcEJBLGlCQUFvQixHQUFXLENBQ2xDLENBREQ7O0FBR0FBLGtCQUFrQkMsU0FBbEIsR0FBOEIsSUFBSSxzREFBSixFQUE5Qjs7QUFFQTtBQUNBRCxrQkFBa0JDLFNBQWxCLENBQTRCQyxhQUE1QixHQUE0QyxVQUFTQyxPQUFULEVBQWtCQyxDQUFsQixFQUFxQkMsT0FBckIsRUFBOEI7QUFDeEU7QUFDQSxNQUFJQyxTQUFTLEVBQWI7QUFDQSxNQUFJQyxDQUFKLEVBQU9DLENBQVAsRUFBVUMsS0FBVjtBQUNBLE1BQUlDLFdBQVdMLFFBQVFNLEdBQVIsQ0FBWSxVQUFaLENBQWY7QUFDQSxPQUFNLElBQUlDLElBQUksQ0FBZCxFQUFpQkEsSUFBSVQsUUFBUVUsTUFBN0IsRUFBcUNELEdBQXJDLEVBQTBDO0FBQ3hDTCxRQUFJSixRQUFRUyxDQUFSLEVBQVcsQ0FBWCxDQUFKO0FBQ0FILFlBQVFOLFFBQVFTLENBQVIsRUFBV1IsQ0FBWCxDQUFSO0FBQ0EsUUFBSU0sWUFBWUQsVUFBVSxJQUExQixFQUFnQztBQUM5QjtBQUNBO0FB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RixFQUFRLElBQVIsQ0FBNUIsQ0FBakI7QUFDRDtBQUNGOztBQUVELFNBQU9pQixXQUFQO0FBQ0QsQ0ExQ0Q7O0FBNENBLHlEQUFlckIsaUJBQWYiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMyBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGF0YUhhbmRsZXIgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBjdXN0b20gYmFycyBvcHRpb24uXG4gKiBAYXV0aG9yIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgQmFyc0hhbmRsZXIgZnJvbSAnLi9iYXJzJztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIER5Z3JhcGguRGF0YUhhbmRsZXJzLkJhcnNIYW5kbGVyXG4gKi9cbnZhciBDdXN0b21CYXJzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xufTtcblxuQ3VzdG9tQmFyc0hhbmRsZXIucHJvdG90eXBlID0gbmV3IEJhcnNIYW5kbGVyKCk7XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuQ3VzdG9tQmFyc0hhbmRsZXIucHJvdG90eXBlLmV4dHJhY3RTZXJpZXMgPSBmdW5jdGlvbihyYXdEYXRhLCBpLCBvcHRpb25zKSB7XG4gIC8vIFRPRE8oZGFudmspOiBwcmUtYWxsb2NhdGUgc2VyaWVzIGhlcmUuXG4gIHZhciBzZXJpZXMgPSBbXTtcbiAgdmFyIHgsIHksIHBvaW50O1xuICB2YXIgbG9nU2NhbGUgPSBvcHRpb25zLmdldCgnbG9nc2NhbGUnKTtcbiAgZm9yICggdmFyIGogPSAwOyBqIDwgcmF3RGF0YS5sZW5ndGg7IGorKykge1xuICAgIHggPSByYXdEYXRhW2pdWzBdO1xuICAgIHBvaW50ID0gcmF3RGF0YVtqXVtpXTtcbiAgICBpZiAobG9nU2NhbGUgJiYgcG9pbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIE9uIHRoZSBsb2cgc2NhbGUsIHBvaW50cyBsZXNzIHRoYW4gemVybyBkbyBub3QgZXhpc3QuXG4gICAgICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgZ2FwIGluIHRoZSBjaGFydC5cbiAgICAgIGlmIChwb2ludFswXSA8PSAwIHx8IHBvaW50WzFdIDw9IDAgfHwgcG9pbnRbMl0gPD0gMCkge1xuICAgICAgICBwb2ludCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEV4dHJhY3QgdG8gdGhlIHVuaWZpZWQgZGF0YSBmb3JtYXQuXG4gICAgaWYgKHBvaW50ICE9PSBudWxsKSB7XG4gICAgICB5ID0gcG9pbnRbMV07XG4gICAgICBpZiAoeSAhPT0gbnVsbCAmJiAhaXNOYU4oeSkpIHtcbiAgICAgICAgc2VyaWVzLnB1c2goWyB4LCB5LCBbIHBvaW50WzBdLCBwb2ludFsyXSBdIF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWVzLnB1c2goWyB4LCB5LCBbIHksIHkgXSBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWVzLnB1c2goWyB4LCBudWxsLCBbIG51bGwsIG51bGwgXSBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmllcztcbn07XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuQ3VzdG9tQmFyc0hhbmRsZXIucHJvdG90eXBlLnJvbGxpbmdBdmVyYWdlID1cbiAgICBmdW5jdGlvbihvcmlnaW5hbERhdGEsIHJvbGxQZXJpb2QsIG9wdGlvbnMpIHtcbiAgcm9sbFBlcmlvZCA9IE1hdGgubWluKHJvbGxQZXJpb2QsIG9yaWdpbmFsRGF0YS5sZW5ndGgpO1xuICB2YXIgcm9sbGluZ0RhdGEgPSBbXTtcbiAgdmFyIHksIGxvdywgaGlnaCwgbWlkLGNvdW50LCBpLCBleHRyZW1lcztcblxuICBsb3cgPSAwO1xuICBtaWQgPSAwO1xuICBoaWdoID0gMDtcbiAgY291bnQgPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgb3JpZ2luYWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgeSA9IG9yaWdpbmFsRGF0YVtpXVsxXTtcbiAgICBleHRyZW1lcyA9IG9yaWdpbmFsRGF0YVtpXVsyXTtcbiAgICByb2xsaW5nRGF0YVtpXSA9IG9yaWdpbmFsRGF0YVtpXTtcblxuICAgIGlmICh5ICE9PSBudWxsICYmICFpc05hTih5KSkge1xuICAgICAgbG93ICs9IGV4dHJlbWVzWzBdO1xuICAgICAgbWlkICs9IHk7XG4gICAgICBoaWdoICs9IGV4dHJlbWVzWzFdO1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgaWYgKGkgLSByb2xsUGVyaW9kID49IDApIHtcbiAgICAgIHZhciBwcmV2ID0gb3JpZ2luYWxEYXRhW2kgLSByb2xsUGVyaW9kXTtcbiAgICAgIGlmIChwcmV2WzFdICE9PSBudWxsICYmICFpc05hTihwcmV2WzFdKSkge1xuICAgICAgICBsb3cgLT0gcHJldlsyXVswXTtcbiAgICAgICAgbWlkIC09IHByZXZbMV07XG4gICAgICAgIGhpZ2ggLT0gcHJldlsyXVsxXTtcbiAgICAgICAgY291bnQgLT0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICByb2xsaW5nRGF0YVtpXSA9IFtcbiAgICAgICAgICBvcmlnaW5hbERhdGFbaV1bMF0sXG4gICAgICAgICAgMS4wICogbWlkIC8gY291bnQsIFxuICAgICAgICAgIFsgMS4wICogbG93IC8gY291bnQsXG4gICAgICAgICAgICAxLjAgKiBoaWdoIC8gY291bnQgXSBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByb2xsaW5nRGF0YVtpXSA9IFsgb3JpZ2luYWxEYXRhW2ldWzBdLCBudWxsLCBbIG51bGwsIG51bGwgXSBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb2xsaW5nRGF0YTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEN1c3RvbUJhcnNIYW5kbGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9keWdyYXBocy9zcmMvZGF0YWhhbmRsZXIvYmFycy1jdXN0b20uanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n");

/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bars__ = __webpack_require__(9);\n/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler implementation for the error bars option.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * @constructor\n * @extends BarsHandler\n */\nvar ErrorBarsHandler = function ErrorBarsHandler() {};\n\nErrorBarsHandler.prototype = new __WEBPACK_IMPORTED_MODULE_0__bars__[\"a\" /* default */]();\n\n/** @inheritDoc */\nErrorBarsHandler.prototype.extractSeries = function (rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var x, y, variance, point;\n  var sigma = options.get(\"sigma\");\n  var logScale = options.get('logscale');\n  for (var j = 0; j < rawData.length; j++) {\n    x = rawData[j][0];\n    point = rawData[j][i];\n    if (logScale && point !== null) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point[0] <= 0 || point[0] - sigma * point[1] <= 0) {\n        point = null;\n      }\n    }\n    // Extract to the unified data format.\n    if (point !== null) {\n      y = point[0];\n      if (y !== null && !isNaN(y)) {\n        variance = sigma * point[1];\n        // preserve original error value in extras for further\n        // filtering\n        series.push([x, y, [y - variance, y + variance, point[1]]]);\n      } else {\n        series.push([x, y, [y, y, y]]);\n      }\n    } else {\n      series.push([x, null, [null, null, null]]);\n    }\n  }\n  return series;\n};\n\n/** @inheritDoc */\nErrorBarsHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n  var sigma = options.get(\"sigma\");\n\n  var i, j, y, v, sum, num_ok, stddev, variance, value;\n\n  // Calculate the rolling average for the first rollPeriod - 1 points\n  // where there is not enough data to roll over the full number of points\n  for (i = 0; i < originalData.length; i++) {\n    sum = 0;\n    variance = 0;\n    num_ok = 0;\n    for (j = Math.max(0, i - rollPeriod + 1); j < i + 1; j++) {\n      y = originalData[j][1];\n      if (y === null || isNaN(y)) continue;\n      num_ok++;\n      sum += y;\n      variance += Math.pow(originalData[j][2][2], 2);\n    }\n    if (num_ok) {\n      stddev = Math.sqrt(variance) / num_ok;\n      value = sum / num_ok;\n      rollingData[i] = [originalData[i][0], value, [value - sigma * stddev, value + sigma * stddev]];\n    } else {\n      // This explicitly preserves NaNs to aid with \"independent\n      // series\".\n      // See testRollingAveragePreservesNaNs.\n      v = rollPeriod == 1 ? originalData[i][1] : null;\n      rollingData[i] = [originalData[i][0], v, [v, v]];\n    }\n  }\n\n  return rollingData;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ErrorBarsHandler);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9iYXJzLWVycm9yLmpzP2E3N2UiXSwibmFtZXMiOlsiRXJyb3JCYXJzSGFuZGxlciIsInByb3RvdHlwZSIsImV4dHJhY3RTZXJpZXMiLCJyYXdEYXRhIiwiaSIsIm9wdGlvbnMiLCJzZXJpZXMiLCJ4IiwieSIsInZhcmlhbmNlIiwicG9pbnQiLCJzaWdtYSIsImdldCIsImxvZ1NjYWxlIiwiaiIsImxlbmd0aCIsImlzTmFOIiwicHVzaCIsInJvbGxpbmdBdmVyYWdlIiwib3JpZ2luYWxEYXRhIiwicm9sbFBlcmlvZCIsIk1hdGgiLCJtaW4iLCJyb2xsaW5nRGF0YSIsInYiLCJzdW0iLCJudW1fb2siLCJzdGRkZXYiLCJ2YWx1ZSIsIm1heCIsInBvdyIsInNxcnQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Ozs7OztBQU1BOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQSxJQUFJQSxtQkFBbUIsU0FBbkJBLGdCQUFtQixHQUFXLENBQ2pDLENBREQ7O0FBR0FBLGlCQUFpQkMsU0FBakIsR0FBNkIsSUFBSSxzREFBSixFQUE3Qjs7QUFFQTtBQUNBRCxpQkFBaUJDLFNBQWpCLENBQTJCQyxhQUEzQixHQUEyQyxVQUFTQyxPQUFULEVBQWtCQyxDQUFsQixFQUFxQkMsT0FBckIsRUFBOEI7QUFDdkU7QUFDQSxNQUFJQyxTQUFTLEVBQWI7QUFDQSxNQUFJQyxDQUFKLEVBQU9DLENBQVAsRUFBVUMsUUFBVixFQUFvQkMsS0FBcEI7QUFDQSxNQUFJQyxRQUFRTixRQUFRTyxHQUFSLENBQVksT0FBWixDQUFaO0FBQ0EsTUFBSUMsV0FBV1IsUUFBUU8sR0FBUixDQUFZLFVBQVosQ0FBZjtBQUNBLE9BQU0sSUFBSUUsSUFBSSxDQUFkLEVBQWlCQSxJQUFJWCxRQUFRWSxNQUE3QixFQUFxQ0QsR0FBckMsRUFBMEM7QUFDeENQLFFBQUlKLFFBQVFXLENBQVIsRUFBVyxDQUFYLENBQUo7QUFDQUosWUFBUVAsUUFBUVcsQ0FBUixFQUFXVixDQUFYLENBQVI7QUFDQSxRQUFJUyxZQUFZSCxVQUFVLElBQTFCLEVBQWdDO0FBQzlCO0FBQ0E7QUFDQSxVQUFJQSxNQUFNLENBQU4sS0FBWSxDQUFaLElBQWlCQSxNQUFNLENBQU4sSUFBV0MsUUFBUUQsTUFBTSxDQUFOLENBQW5CLElBQStCLENBQXBELEVBQXVEO0FBQ3JEQSxnQkFBUSxJQUFSO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsUUFBSUEsVUFBVSxJQUFkLEVBQW9CO0FBQ2xCRixVQUFJRSxNQUFNLENBQU4sQ0FBSjtBQUNBLFVBQUlGLE1BQU0sSUFBTixJQUFjLENBQUNRLE1BQU1SLENBQU4sQ0FBbkIsRUFBNkI7QUFDM0JDLG1CQUFXRSxRQUFRRCxNQUFNLENBQU4sQ0FBbkI7QUFDQTtBQUNBO0FBQ0FKLGVBQU9XLElBQVAsQ0FBWSxDQUFFVixDQUFGLEVBQUtDLENBQUwsRUFBUSxDQUFFQSxJQUFJQyxRQUFOLEVBQWdCRCxJQUFJQyxRQUFwQixFQUE4QkMsTUFBTSxDQUFOLENBQTlCLENBQVIsQ0FBWjtBQUNELE9BTEQsTUFLTztBQUNMSixlQUFPVyxJQUFQLENBQVksQ0FBRVYsQ0FBRixFQUFLQyxDQUFMLEVBQVEsQ0FBRUEsQ0FBRixFQUFLQSxDQUFMLEVBQVFBLENBQVIsQ0FBUixDQUFaO0FBQ0Q7QUFDRixLQVZELE1BVU87QUFDTEYsYUFBT1csSUFBUCxDQUFZLENBQUVWLENBQUYsRUFBSyxJQUFMLEVBQVcsQ0FBRSxJQUFGLEVBQVEsSUFBUixFQUFjLElBQWQsQ0FBWCxDQUFaO0FBQ0Q7QUFDRjtBQUNELFNBQU9ELE1BQVA7QUFDRCxDQWhDRDs7QUFrQ0E7QUFDQU4saUJBQWlCQyxTQUFqQixDQUEyQmlCLGNBQTNCLEdBQ0ksVUFBU0MsWUFBVCxFQUF1QkMsVUFBdkIsRUFBbUNmLE9BQW5DLEVBQTRDO0FBQzlDZSxlQUFhQyxLQUFLQyxHQUFMLENBQVNGLFVBQVQsRUFBcUJELGFBQWFKLE1BQWxDLENBQWI7QUFDQSxNQUFJUSxjQUFjLEVBQWxCO0FBQ0EsTUFBSVosUUFBUU4sUUFBUU8sR0FBUixDQUFZLE9BQVosQ0FBWjs7QUFFQSxNQUFJUixDQUFKLEVBQU9VLENBQVAsRUFBVU4sQ0FBVixFQUFhZ0IsQ0FBYixFQUFnQkMsR0FBaEIsRUFBcUJDLE1BQXJCLEVBQTZCQyxNQUE3QixFQUFxQ2xCLFFBQXJDLEVBQStDbUIsS0FBL0M7O0FBRUE7QUFDQTtBQUNBLE9BQUt4QixJQUFJLENBQVQsRUFBWUEsSUFBSWUsYUFBYUosTUFBN0IsRUFBcUNYLEdBQXJDLEVBQTBDO0FBQ3hDcUIsVUFBTSxDQUFOO0FBQ0FoQixlQUFXLENBQVg7QUFDQWlCLGFBQVMsQ0FBVDtBQUNBLFNBQUtaLElBQUlPLEtBQUtRLEdBQUwsQ0FBUyxDQUFULEVBQVl6QixJQUFJZ0IsVUFBSixHQUFpQixDQUE3QixDQUFULEVBQTBDTixJQUFJVixJQUFJLENBQWxELEVBQXFEVSxHQUFyRCxFQUEwRDtBQUN4RE4sVUFBSVcsYUFBYUwsQ0FBYixFQUFnQixDQUFoQixDQUFKO0FBQ0EsVUFBSU4sTUFBTSxJQUFOLElBQWNRLE1BQU1SLENBQU4sQ0FBbEIsRUFDRTtBQUNGa0I7QUFDQUQsYUFBT2pCLENBQVA7QUFDQUMsa0JBQVlZLEtBQUtTLEdBQUwsQ0FBU1gsYUFBYUwsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixDQUFULEVBQWdDLENBQWhDLENBQVo7QUFDRDtBQUNELFFBQUlZLE1BQUosRUFBWTtBQUNWQyxlQUFTTixLQUFLVSxJQUFMLENBQVV0QixRQUFWLElBQXNCaUIsTUFBL0I7QUFDQUUsY0FBUUgsTUFBTUMsTUFBZDtBQUNBSCxrQkFBWW5CLENBQVosSUFBaUIsQ0FBRWUsYUFBYWYsQ0FBYixFQUFnQixDQUFoQixDQUFGLEVBQXNCd0IsS0FBdEIsRUFDYixDQUFDQSxRQUFRakIsUUFBUWdCLE1BQWpCLEVBQXlCQyxRQUFRakIsUUFBUWdCLE1BQXpDLENBRGEsQ0FBakI7QUFFRCxLQUxELE1BS087QUFDTDtBQUNBO0FBQ0E7QUFDQUgsVUFBS0osY0FBYyxDQUFmLEdBQW9CRCxhQUFhZixDQUFiLEVBQWdCLENBQWhCLENBQXBCLEdBQXlDLElBQTdDO0FBQ0FtQixrQkFBWW5CLENBQVosSUFBaUIsQ0FBRWUsYUFBYWYsQ0FBYixFQUFnQixDQUFoQixDQUFGLEVBQXNCb0IsQ0FBdEIsRUFBeUIsQ0FBRUEsQ0FBRixFQUFLQSxDQUFMLENBQXpCLENBQWpCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPRCxXQUFQO0FBQ0QsQ0FyQ0Q7O0FBdUNBLHlEQUFldkIsZ0JBQWYiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMyBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGF0YUhhbmRsZXIgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBlcnJvciBiYXJzIG9wdGlvbi5cbiAqIEBhdXRob3IgRGF2aWQgRWJlcmxlaW4gKGRhdmlkLmViZXJsZWluQGNoLnNhdXRlci1iYy5jb20pXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBCYXJzSGFuZGxlciBmcm9tICcuL2JhcnMnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQmFyc0hhbmRsZXJcbiAqL1xudmFyIEVycm9yQmFyc0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcbn07XG5cbkVycm9yQmFyc0hhbmRsZXIucHJvdG90eXBlID0gbmV3IEJhcnNIYW5kbGVyKCk7XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuRXJyb3JCYXJzSGFuZGxlci5wcm90b3R5cGUuZXh0cmFjdFNlcmllcyA9IGZ1bmN0aW9uKHJhd0RhdGEsIGksIG9wdGlvbnMpIHtcbiAgLy8gVE9ETyhkYW52ayk6IHByZS1hbGxvY2F0ZSBzZXJpZXMgaGVyZS5cbiAgdmFyIHNlcmllcyA9IFtdO1xuICB2YXIgeCwgeSwgdmFyaWFuY2UsIHBvaW50O1xuICB2YXIgc2lnbWEgPSBvcHRpb25zLmdldChcInNpZ21hXCIpO1xuICB2YXIgbG9nU2NhbGUgPSBvcHRpb25zLmdldCgnbG9nc2NhbGUnKTtcbiAgZm9yICggdmFyIGogPSAwOyBqIDwgcmF3RGF0YS5sZW5ndGg7IGorKykge1xuICAgIHggPSByYXdEYXRhW2pdWzBdO1xuICAgIHBvaW50ID0gcmF3RGF0YVtqXVtpXTtcbiAgICBpZiAobG9nU2NhbGUgJiYgcG9pbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIE9uIHRoZSBsb2cgc2NhbGUsIHBvaW50cyBsZXNzIHRoYW4gemVybyBkbyBub3QgZXhpc3QuXG4gICAgICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgZ2FwIGluIHRoZSBjaGFydC5cbiAgICAgIGlmIChwb2ludFswXSA8PSAwIHx8IHBvaW50WzBdIC0gc2lnbWEgKiBwb2ludFsxXSA8PSAwKSB7XG4gICAgICAgIHBvaW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRXh0cmFjdCB0byB0aGUgdW5pZmllZCBkYXRhIGZvcm1hdC5cbiAgICBpZiAocG9pbnQgIT09IG51bGwpIHtcbiAgICAgIHkgPSBwb2ludFswXTtcbiAgICAgIGlmICh5ICE9PSBudWxsICYmICFpc05hTih5KSkge1xuICAgICAgICB2YXJpYW5jZSA9IHNpZ21hICogcG9pbnRbMV07XG4gICAgICAgIC8vIHByZXNlcnZlIG9yaWdpbmFsIGVycm9yIHZhbHVlIGluIGV4dHJhcyBmb3IgZnVydGhlclxuICAgICAgICAvLyBmaWx0ZXJpbmdcbiAgICAgICAgc2VyaWVzLnB1c2goWyB4LCB5LCBbIHkgLSB2YXJpYW5jZSwgeSArIHZhcmlhbmNlLCBwb2ludFsxXSBdIF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWVzLnB1c2goWyB4LCB5LCBbIHksIHksIHkgXSBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWVzLnB1c2goWyB4LCBudWxsLCBbIG51bGwsIG51bGwsIG51bGwgXSBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmllcztcbn07XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuRXJyb3JCYXJzSGFuZGxlci5wcm90b3R5cGUucm9sbGluZ0F2ZXJhZ2UgPVxuICAgIGZ1bmN0aW9uKG9yaWdpbmFsRGF0YSwgcm9sbFBlcmlvZCwgb3B0aW9ucykge1xuICByb2xsUGVyaW9kID0gTWF0aC5taW4ocm9sbFBlcmlvZCwgb3JpZ2luYWxEYXRhLmxlbmd0aCk7XG4gIHZhciByb2xsaW5nRGF0YSA9IFtdO1xuICB2YXIgc2lnbWEgPSBvcHRpb25zLmdldChcInNpZ21hXCIpO1xuXG4gIHZhciBpLCBqLCB5LCB2LCBzdW0sIG51bV9vaywgc3RkZGV2LCB2YXJpYW5jZSwgdmFsdWU7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSByb2xsaW5nIGF2ZXJhZ2UgZm9yIHRoZSBmaXJzdCByb2xsUGVyaW9kIC0gMSBwb2ludHNcbiAgLy8gd2hlcmUgdGhlcmUgaXMgbm90IGVub3VnaCBkYXRhIHRvIHJvbGwgb3ZlciB0aGUgZnVsbCBudW1iZXIgb2YgcG9pbnRzXG4gIGZvciAoaSA9IDA7IGkgPCBvcmlnaW5hbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBzdW0gPSAwO1xuICAgIHZhcmlhbmNlID0gMDtcbiAgICBudW1fb2sgPSAwO1xuICAgIGZvciAoaiA9IE1hdGgubWF4KDAsIGkgLSByb2xsUGVyaW9kICsgMSk7IGogPCBpICsgMTsgaisrKSB7XG4gICAgICB5ID0gb3JpZ2luYWxEYXRhW2pdWzFdO1xuICAgICAgaWYgKHkgPT09IG51bGwgfHwgaXNOYU4oeSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgbnVtX29rKys7XG4gICAgICBzdW0gKz0geTtcbiAgICAgIHZhcmlhbmNlICs9IE1hdGgucG93KG9yaWdpbmFsRGF0YVtqXVsyXVsyXSwgMik7XG4gICAgfVxuICAgIGlmIChudW1fb2spIHtcbiAgICAgIHN0ZGRldiA9IE1hdGguc3FydCh2YXJpYW5jZSkgLyBudW1fb2s7XG4gICAgICB2YWx1ZSA9IHN1bSAvIG51bV9vaztcbiAgICAgIHJvbGxpbmdEYXRhW2ldID0gWyBvcmlnaW5hbERhdGFbaV1bMF0sIHZhbHVlLFxuICAgICAgICAgIFt2YWx1ZSAtIHNpZ21hICogc3RkZGV2LCB2YWx1ZSArIHNpZ21hICogc3RkZGV2XSBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGV4cGxpY2l0bHkgcHJlc2VydmVzIE5hTnMgdG8gYWlkIHdpdGggXCJpbmRlcGVuZGVudFxuICAgICAgLy8gc2VyaWVzXCIuXG4gICAgICAvLyBTZWUgdGVzdFJvbGxpbmdBdmVyYWdlUHJlc2VydmVzTmFOcy5cbiAgICAgIHYgPSAocm9sbFBlcmlvZCA9PSAxKSA/IG9yaWdpbmFsRGF0YVtpXVsxXSA6IG51bGw7XG4gICAgICByb2xsaW5nRGF0YVtpXSA9IFsgb3JpZ2luYWxEYXRhW2ldWzBdLCB2LCBbIHYsIHYgXSBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb2xsaW5nRGF0YTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVycm9yQmFyc0hhbmRsZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9iYXJzLWVycm9yLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///24\n");

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bars__ = __webpack_require__(9);\n/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler implementation for the combination \n * of error bars and fractions options.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * @constructor\n * @extends Dygraph.DataHandlers.BarsHandler\n */\nvar FractionsBarsHandler = function FractionsBarsHandler() {};\n\nFractionsBarsHandler.prototype = new __WEBPACK_IMPORTED_MODULE_0__bars__[\"a\" /* default */]();\n\n/** @inheritDoc */\nFractionsBarsHandler.prototype.extractSeries = function (rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var x, y, point, num, den, value, stddev, variance;\n  var mult = 100.0;\n  var sigma = options.get(\"sigma\");\n  var logScale = options.get('logscale');\n  for (var j = 0; j < rawData.length; j++) {\n    x = rawData[j][0];\n    point = rawData[j][i];\n    if (logScale && point !== null) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point[0] <= 0 || point[1] <= 0) {\n        point = null;\n      }\n    }\n    // Extract to the unified data format.\n    if (point !== null) {\n      num = point[0];\n      den = point[1];\n      if (num !== null && !isNaN(num)) {\n        value = den ? num / den : 0.0;\n        stddev = den ? sigma * Math.sqrt(value * (1 - value) / den) : 1.0;\n        variance = mult * stddev;\n        y = mult * value;\n        // preserve original values in extras for further filtering\n        series.push([x, y, [y - variance, y + variance, num, den]]);\n      } else {\n        series.push([x, num, [num, num, num, den]]);\n      }\n    } else {\n      series.push([x, null, [null, null, null, null]]);\n    }\n  }\n  return series;\n};\n\n/** @inheritDoc */\nFractionsBarsHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n  var sigma = options.get(\"sigma\");\n  var wilsonInterval = options.get(\"wilsonInterval\");\n\n  var low, high, i, stddev;\n  var num = 0;\n  var den = 0; // numerator/denominator\n  var mult = 100.0;\n  for (i = 0; i < originalData.length; i++) {\n    num += originalData[i][2][2];\n    den += originalData[i][2][3];\n    if (i - rollPeriod >= 0) {\n      num -= originalData[i - rollPeriod][2][2];\n      den -= originalData[i - rollPeriod][2][3];\n    }\n\n    var date = originalData[i][0];\n    var value = den ? num / den : 0.0;\n    if (wilsonInterval) {\n      // For more details on this confidence interval, see:\n      // http://en.wikipedia.org/wiki/Binomial_confidence_interval\n      if (den) {\n        var p = value < 0 ? 0 : value,\n            n = den;\n        var pm = sigma * Math.sqrt(p * (1 - p) / n + sigma * sigma / (4 * n * n));\n        var denom = 1 + sigma * sigma / den;\n        low = (p + sigma * sigma / (2 * den) - pm) / denom;\n        high = (p + sigma * sigma / (2 * den) + pm) / denom;\n        rollingData[i] = [date, p * mult, [low * mult, high * mult]];\n      } else {\n        rollingData[i] = [date, 0, [0, 0]];\n      }\n    } else {\n      stddev = den ? sigma * Math.sqrt(value * (1 - value) / den) : 1.0;\n      rollingData[i] = [date, mult * value, [mult * (value - stddev), mult * (value + stddev)]];\n    }\n  }\n\n  return rollingData;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (FractionsBarsHandler);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9iYXJzLWZyYWN0aW9ucy5qcz8yODdiIl0sIm5hbWVzIjpbIkZyYWN0aW9uc0JhcnNIYW5kbGVyIiwicHJvdG90eXBlIiwiZXh0cmFjdFNlcmllcyIsInJhd0RhdGEiLCJpIiwib3B0aW9ucyIsInNlcmllcyIsIngiLCJ5IiwicG9pbnQiLCJudW0iLCJkZW4iLCJ2YWx1ZSIsInN0ZGRldiIsInZhcmlhbmNlIiwibXVsdCIsInNpZ21hIiwiZ2V0IiwibG9nU2NhbGUiLCJqIiwibGVuZ3RoIiwiaXNOYU4iLCJNYXRoIiwic3FydCIsInB1c2giLCJyb2xsaW5nQXZlcmFnZSIsIm9yaWdpbmFsRGF0YSIsInJvbGxQZXJpb2QiLCJtaW4iLCJyb2xsaW5nRGF0YSIsIndpbHNvbkludGVydmFsIiwibG93IiwiaGlnaCIsImRhdGUiLCJwIiwibiIsInBtIiwiZGVub20iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUEsSUFBSUEsdUJBQXVCLFNBQXZCQSxvQkFBdUIsR0FBVyxDQUNyQyxDQUREOztBQUdBQSxxQkFBcUJDLFNBQXJCLEdBQWlDLElBQUksc0RBQUosRUFBakM7O0FBRUE7QUFDQUQscUJBQXFCQyxTQUFyQixDQUErQkMsYUFBL0IsR0FBK0MsVUFBU0MsT0FBVCxFQUFrQkMsQ0FBbEIsRUFBcUJDLE9BQXJCLEVBQThCO0FBQzNFO0FBQ0EsTUFBSUMsU0FBUyxFQUFiO0FBQ0EsTUFBSUMsQ0FBSixFQUFPQyxDQUFQLEVBQVVDLEtBQVYsRUFBaUJDLEdBQWpCLEVBQXNCQyxHQUF0QixFQUEyQkMsS0FBM0IsRUFBa0NDLE1BQWxDLEVBQTBDQyxRQUExQztBQUNBLE1BQUlDLE9BQU8sS0FBWDtBQUNBLE1BQUlDLFFBQVFYLFFBQVFZLEdBQVIsQ0FBWSxPQUFaLENBQVo7QUFDQSxNQUFJQyxXQUFXYixRQUFRWSxHQUFS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QUYsRUFBUWxCLE9BQU9ILEtBQWYsRUFDRSxDQUFFRyxRQUFRSCxRQUFRQyxNQUFoQixDQUFGLEVBQTJCRSxRQUFRSCxRQUFRQyxNQUFoQixDQUEzQixDQURGLENBQWpCO0FBRUQ7QUFDRjs7QUFFRCxTQUFPZ0IsV0FBUDtBQUNELENBM0NEOztBQTZDQSx5REFBZTdCLG9CQUFmIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTMgRGF2aWQgRWJlcmxlaW4gKGRhdmlkLmViZXJsZWluQGNoLnNhdXRlci1iYy5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERhdGFIYW5kbGVyIGltcGxlbWVudGF0aW9uIGZvciB0aGUgY29tYmluYXRpb24gXG4gKiBvZiBlcnJvciBiYXJzIGFuZCBmcmFjdGlvbnMgb3B0aW9ucy5cbiAqIEBhdXRob3IgRGF2aWQgRWJlcmxlaW4gKGRhdmlkLmViZXJsZWluQGNoLnNhdXRlci1iYy5jb20pXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBCYXJzSGFuZGxlciBmcm9tICcuL2JhcnMnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRHlncmFwaC5EYXRhSGFuZGxlcnMuQmFyc0hhbmRsZXJcbiAqL1xudmFyIEZyYWN0aW9uc0JhcnNIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG59O1xuXG5GcmFjdGlvbnNCYXJzSGFuZGxlci5wcm90b3R5cGUgPSBuZXcgQmFyc0hhbmRsZXIoKTtcblxuLyoqIEBpbmhlcml0RG9jICovXG5GcmFjdGlvbnNCYXJzSGFuZGxlci5wcm90b3R5cGUuZXh0cmFjdFNlcmllcyA9IGZ1bmN0aW9uKHJhd0RhdGEsIGksIG9wdGlvbnMpIHtcbiAgLy8gVE9ETyhkYW52ayk6IHByZS1hbGxvY2F0ZSBzZXJpZXMgaGVyZS5cbiAgdmFyIHNlcmllcyA9IFtdO1xuICB2YXIgeCwgeSwgcG9pbnQsIG51bSwgZGVuLCB2YWx1ZSwgc3RkZGV2LCB2YXJpYW5jZTtcbiAgdmFyIG11bHQgPSAxMDAuMDtcbiAgdmFyIHNpZ21hID0gb3B0aW9ucy5nZXQoXCJzaWdtYVwiKTtcbiAgdmFyIGxvZ1NjYWxlID0gb3B0aW9ucy5nZXQoJ2xvZ3NjYWxlJyk7XG4gIGZvciAoIHZhciBqID0gMDsgaiA8IHJhd0RhdGEubGVuZ3RoOyBqKyspIHtcbiAgICB4ID0gcmF3RGF0YVtqXVswXTtcbiAgICBwb2ludCA9IHJhd0RhdGFbal1baV07XG4gICAgaWYgKGxvZ1NjYWxlICYmIHBvaW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBPbiB0aGUgbG9nIHNjYWxlLCBwb2ludHMgbGVzcyB0aGFuIHplcm8gZG8gbm90IGV4aXN0LlxuICAgICAgLy8gVGhpcyB3aWxsIGNyZWF0ZSBhIGdhcCBpbiB0aGUgY2hhcnQuXG4gICAgICBpZiAocG9pbnRbMF0gPD0gMCB8fCBwb2ludFsxXSA8PSAwKSB7XG4gICAgICAgIHBvaW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRXh0cmFjdCB0byB0aGUgdW5pZmllZCBkYXRhIGZvcm1hdC5cbiAgICBpZiAocG9pbnQgIT09IG51bGwpIHtcbiAgICAgIG51bSA9IHBvaW50WzBdO1xuICAgICAgZGVuID0gcG9pbnRbMV07XG4gICAgICBpZiAobnVtICE9PSBudWxsICYmICFpc05hTihudW0pKSB7XG4gICAgICAgIHZhbHVlID0gZGVuID8gbnVtIC8gZGVuIDogMC4wO1xuICAgICAgICBzdGRkZXYgPSBkZW4gPyBzaWdtYSAqIE1hdGguc3FydCh2YWx1ZSAqICgxIC0gdmFsdWUpIC8gZGVuKSA6IDEuMDtcbiAgICAgICAgdmFyaWFuY2UgPSBtdWx0ICogc3RkZGV2O1xuICAgICAgICB5ID0gbXVsdCAqIHZhbHVlO1xuICAgICAgICAvLyBwcmVzZXJ2ZSBvcmlnaW5hbCB2YWx1ZXMgaW4gZXh0cmFzIGZvciBmdXJ0aGVyIGZpbHRlcmluZ1xuICAgICAgICBzZXJpZXMucHVzaChbIHgsIHksIFsgeSAtIHZhcmlhbmNlLCB5ICsgdmFyaWFuY2UsIG51bSwgZGVuIF0gXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpZXMucHVzaChbIHgsIG51bSwgWyBudW0sIG51bSwgbnVtLCBkZW4gXSBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWVzLnB1c2goWyB4LCBudWxsLCBbIG51bGwsIG51bGwsIG51bGwsIG51bGwgXSBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmllcztcbn07XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuRnJhY3Rpb25zQmFyc0hhbmRsZXIucHJvdG90eXBlLnJvbGxpbmdBdmVyYWdlID1cbiAgICBmdW5jdGlvbihvcmlnaW5hbERhdGEsIHJvbGxQZXJpb2QsIG9wdGlvbnMpIHtcbiAgcm9sbFBlcmlvZCA9IE1hdGgubWluKHJvbGxQZXJpb2QsIG9yaWdpbmFsRGF0YS5sZW5ndGgpO1xuICB2YXIgcm9sbGluZ0RhdGEgPSBbXTtcbiAgdmFyIHNpZ21hID0gb3B0aW9ucy5nZXQoXCJzaWdtYVwiKTtcbiAgdmFyIHdpbHNvbkludGVydmFsID0gb3B0aW9ucy5nZXQoXCJ3aWxzb25JbnRlcnZhbFwiKTtcblxuICB2YXIgbG93LCBoaWdoLCBpLCBzdGRkZXY7XG4gIHZhciBudW0gPSAwO1xuICB2YXIgZGVuID0gMDsgLy8gbnVtZXJhdG9yL2Rlbm9taW5hdG9yXG4gIHZhciBtdWx0ID0gMTAwLjA7XG4gIGZvciAoaSA9IDA7IGkgPCBvcmlnaW5hbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBudW0gKz0gb3JpZ2luYWxEYXRhW2ldWzJdWzJdO1xuICAgIGRlbiArPSBvcmlnaW5hbERhdGFbaV1bMl1bM107XG4gICAgaWYgKGkgLSByb2xsUGVyaW9kID49IDApIHtcbiAgICAgIG51bSAtPSBvcmlnaW5hbERhdGFbaSAtIHJvbGxQZXJpb2RdWzJdWzJdO1xuICAgICAgZGVuIC09IG9yaWdpbmFsRGF0YVtpIC0gcm9sbFBlcmlvZF1bMl1bM107XG4gICAgfVxuXG4gICAgdmFyIGRhdGUgPSBvcmlnaW5hbERhdGFbaV1bMF07XG4gICAgdmFyIHZhbHVlID0gZGVuID8gbnVtIC8gZGVuIDogMC4wO1xuICAgIGlmICh3aWxzb25JbnRlcnZhbCkge1xuICAgICAgLy8gRm9yIG1vcmUgZGV0YWlscyBvbiB0aGlzIGNvbmZpZGVuY2UgaW50ZXJ2YWwsIHNlZTpcbiAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmlub21pYWxfY29uZmlkZW5jZV9pbnRlcnZhbFxuICAgICAgaWYgKGRlbikge1xuICAgICAgICB2YXIgcCA9IHZhbHVlIDwgMCA/IDAgOiB2YWx1ZSwgbiA9IGRlbjtcbiAgICAgICAgdmFyIHBtID0gc2lnbWEgKiBNYXRoLnNxcnQocCAqICgxIC0gcCkgLyBuICsgc2lnbWEgKiBzaWdtYSAvICg0ICogbiAqIG4pKTtcbiAgICAgICAgdmFyIGRlbm9tID0gMSArIHNpZ21hICogc2lnbWEgLyBkZW47XG4gICAgICAgIGxvdyA9IChwICsgc2lnbWEgKiBzaWdtYSAvICgyICogZGVuKSAtIHBtKSAvIGRlbm9tO1xuICAgICAgICBoaWdoID0gKHAgKyBzaWdtYSAqIHNpZ21hIC8gKDIgKiBkZW4pICsgcG0pIC8gZGVub207XG4gICAgICAgIHJvbGxpbmdEYXRhW2ldID0gWyBkYXRlLCBwICogbXVsdCxcbiAgICAgICAgICAgIFsgbG93ICogbXVsdCwgaGlnaCAqIG11bHQgXSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9sbGluZ0RhdGFbaV0gPSBbIGRhdGUsIDAsIFsgMCwgMCBdIF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ZGRldiA9IGRlbiA/IHNpZ21hICogTWF0aC5zcXJ0KHZhbHVlICogKDEgLSB2YWx1ZSkgLyBkZW4pIDogMS4wO1xuICAgICAgcm9sbGluZ0RhdGFbaV0gPSBbIGRhdGUsIG11bHQgKiB2YWx1ZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgWyBtdWx0ICogKHZhbHVlIC0gc3RkZGV2KSwgbXVsdCAqICh2YWx1ZSArIHN0ZGRldikgXSBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb2xsaW5nRGF0YTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZyYWN0aW9uc0JhcnNIYW5kbGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9keWdyYXBocy9zcmMvZGF0YWhhbmRsZXIvYmFycy1mcmFjdGlvbnMuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///25\n");

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__datahandler__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__default__ = __webpack_require__(15);\n/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler implementation for the fractions option.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\n\n\n\n\n/**\n * @extends DefaultHandler\n * @constructor\n */\nvar DefaultFractionHandler = function DefaultFractionHandler() {};\n\nDefaultFractionHandler.prototype = new __WEBPACK_IMPORTED_MODULE_1__default__[\"a\" /* default */]();\n\nDefaultFractionHandler.prototype.extractSeries = function (rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var x, y, point, num, den, value;\n  var mult = 100.0;\n  var logScale = options.get('logscale');\n  for (var j = 0; j < rawData.length; j++) {\n    x = rawData[j][0];\n    point = rawData[j][i];\n    if (logScale && point !== null) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point[0] <= 0 || point[1] <= 0) {\n        point = null;\n      }\n    }\n    // Extract to the unified data format.\n    if (point !== null) {\n      num = point[0];\n      den = point[1];\n      if (num !== null && !isNaN(num)) {\n        value = den ? num / den : 0.0;\n        y = mult * value;\n        // preserve original values in extras for further filtering\n        series.push([x, y, [num, den]]);\n      } else {\n        series.push([x, num, [num, den]]);\n      }\n    } else {\n      series.push([x, null, [null, null]]);\n    }\n  }\n  return series;\n};\n\nDefaultFractionHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n\n  var i;\n  var num = 0;\n  var den = 0; // numerator/denominator\n  var mult = 100.0;\n  for (i = 0; i < originalData.length; i++) {\n    num += originalData[i][2][0];\n    den += originalData[i][2][1];\n    if (i - rollPeriod >= 0) {\n      num -= originalData[i - rollPeriod][2][0];\n      den -= originalData[i - rollPeriod][2][1];\n    }\n\n    var date = originalData[i][0];\n    var value = den ? num / den : 0.0;\n    rollingData[i] = [date, mult * value];\n  }\n\n  return rollingData;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DefaultFractionHandler);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9kZWZhdWx0LWZyYWN0aW9ucy5qcz8yMDg0Il0sIm5hbWVzIjpbIkRlZmF1bHRGcmFjdGlvbkhhbmRsZXIiLCJwcm90b3R5cGUiLCJleHRyYWN0U2VyaWVzIiwicmF3RGF0YSIsImkiLCJvcHRpb25zIiwic2VyaWVzIiwieCIsInkiLCJwb2ludCIsIm51bSIsImRlbiIsInZhbHVlIiwibXVsdCIsImxvZ1NjYWxlIiwiZ2V0IiwiaiIsImxlbmd0aCIsImlzTmFOIiwicHVzaCIsInJvbGxpbmdBdmVyYWdlIiwib3JpZ2luYWxEYXRhIiwicm9sbFBlcmlvZCIsIk1hdGgiLCJtaW4iLCJyb2xsaW5nRGF0YSIsImRhdGUiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUFBOzs7Ozs7QUFNQTs7Ozs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7QUFJQSxJQUFJQSx5QkFBeUIsU0FBekJBLHNCQUF5QixHQUFXLENBQ3ZDLENBREQ7O0FBR0FBLHVCQUF1QkMsU0FBdkIsR0FBbUMsSUFBSSx5REFBSixFQUFuQzs7QUFFQUQsdUJBQXVCQyxTQUF2QixDQUFpQ0MsYUFBakMsR0FBaUQsVUFBU0MsT0FBVCxFQUFrQkMsQ0FBbEIsRUFBcUJDLE9BQXJCLEVBQThCO0FBQzdFO0FBQ0EsTUFBSUMsU0FBUyxFQUFiO0FBQ0EsTUFBSUMsQ0FBSixFQUFPQyxDQUFQLEVBQVVDLEtBQVYsRUFBaUJDLEdBQWpCLEVBQXNCQyxHQUF0QixFQUEyQkMsS0FBM0I7QUFDQSxNQUFJQyxPQUFPLEtBQVg7QUFDQSxNQUFJQyxXQUFXVCxRQUFRVSxHQUFSLENBQVksVUFBWixDQUFmO0FBQ0EsT0FBTSxJQUFJQyxJQUFJLENBQWQsRUFBaUJBLElBQUliLFFBQVFjLE1BQTdCLEVBQXFDRCxHQUFyQyxFQUEwQztBQUN4Q1QsUUFBSUosUUFBUWEsQ0FBUixFQUFXLENBQVgsQ0FBSjtBQUNBUCxZQUFRTixRQUFRYSxDQUFSLEVBQVdaLENBQVgsQ0FBUjtBQUNBLFFBQUlVLFlBQVlMLFVBQVUsSUFBMUIsRUFBZ0M7QUFDOUI7QUFDQTtBQUNBLFVBQUlBLE1BQU0sQ0FBTixLQUFZLENBQVosSUFBaUJBLE1BQU0sQ0FBTixLQUFZLENBQWpDLEVBQW9DO0FBQ2xDQSxnQkFBUSxJQUFSO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsUUFBSUEsVUFBVSxJQUFkLEVBQW9CO0FBQ2xCQyxZQUFNRCxNQUFNLENBQU4sQ0FBTjtBQUNBRSxZQUFNRixNQUFNLENBQU4sQ0FBTjtBQUNBLFVBQUlDLFFBQVEsSUFBUixJQUFnQixDQUFDUSxNQUFNUixHQUFOLENBQXJCLEVBQWlDO0FBQy9CRSxnQkFBUUQsTUFBTUQsTUFBTUMsR0FBWixHQUFrQixHQUExQjtBQUNBSCxZQUFJSyxPQUFPRCxLQUFYO0FBQ0E7QUFDQU4sZUFBT2EsSUFBUCxDQUFZLENBQUVaLENBQUYsRUFBS0MsQ0FBTCxFQUFRLENBQUVFLEdBQUYsRUFBT0MsR0FBUCxDQUFSLENBQVo7QUFDRCxPQUxELE1BS087QUFDTEwsZUFBT2EsSUFBUCxDQUFZLENBQUVaLENBQUYsRUFBS0csR0FBTCxFQUFVLENBQUVBLEdBQUYsRUFBT0MsR0FBUCxDQUFWLENBQVo7QUFDRDtBQUNGLEtBWEQsTUFXTztBQUNMTCxhQUFPYSxJQUFQLENBQVksQ0FBRVosQ0FBRixFQUFLLElBQUwsRUFBVyxDQUFFLElBQUYsRUFBUSxJQUFSLENBQVgsQ0FBWjtBQUNEO0FBQ0Y7QUFDRCxTQUFPRCxNQUFQO0FBQ0QsQ0FqQ0Q7O0FBbUNBTix1QkFBdUJDLFNBQXZCLENBQWlDbUIsY0FBakMsR0FBa0QsVUFBU0MsWUFBVCxFQUF1QkMsVUFBdkIsRUFDOUNqQixPQUQ4QyxFQUNyQztBQUNYaUIsZUFBYUMsS0FBS0MsR0FBTCxDQUFTRixVQUFULEVBQXFCRCxhQUFhSixNQUFsQyxDQUFiO0FBQ0EsTUFBSVEsY0FBYyxFQUFsQjs7QUFFQSxNQUFJckIsQ0FBSjtBQUNBLE1BQUlNLE1BQU0sQ0FBVjtBQUNBLE1BQUlDLE1BQU0sQ0FBVixDQU5XLENBTUU7QUFDYixNQUFJRSxPQUFPLEtBQVg7QUFDQSxPQUFLVCxJQUFJLENBQVQsRUFBWUEsSUFBSWlCLGFBQWFKLE1BQTdCLEVBQXFDYixHQUFyQyxFQUEwQztBQUN4Q00sV0FBT1csYUFBYWpCLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsQ0FBUDtBQUNBTyxXQUFPVSxhQUFhakIsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixDQUFQO0FBQ0EsUUFBSUEsSUFBSWtCLFVBQUosSUFBa0IsQ0FBdEIsRUFBeUI7QUFDdkJaLGFBQU9XLGFBQWFqQixJQUFJa0IsVUFBakIsRUFBNkIsQ0FBN0IsRUFBZ0MsQ0FBaEMsQ0FBUDtBQUNBWCxhQUFPVSxhQUFhakIsSUFBSWtCLFVBQWpCLEVBQTZCLENBQTdCLEVBQWdDLENBQWhDLENBQVA7QUFDRDs7QUFFRCxRQUFJSSxPQUFPTCxhQUFhakIsQ0FBYixFQUFnQixDQUFoQixDQUFYO0FBQ0EsUUFBSVEsUUFBUUQsTUFBTUQsTUFBTUMsR0FBWixHQUFrQixHQUE5QjtBQUNBYyxnQkFBWXJCLENBQVosSUFBaUIsQ0FBRXNCLElBQUYsRUFBUWIsT0FBT0QsS0FBZixDQUFqQjtBQUNEOztBQUVELFNBQU9hLFdBQVA7QUFDRCxDQXZCRDs7QUF5QkEseURBQWV6QixzQkFBZiIsImZpbGUiOiIyNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEzIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEYXRhSGFuZGxlciBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIGZyYWN0aW9ucyBvcHRpb24uXG4gKiBAYXV0aG9yIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRHlncmFwaERhdGFIYW5kbGVyIGZyb20gJy4vZGF0YWhhbmRsZXInO1xuaW1wb3J0IERlZmF1bHRIYW5kbGVyIGZyb20gJy4vZGVmYXVsdCc7XG5cbi8qKlxuICogQGV4dGVuZHMgRGVmYXVsdEhhbmRsZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRGVmYXVsdEZyYWN0aW9uSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xufTtcbiAgXG5EZWZhdWx0RnJhY3Rpb25IYW5kbGVyLnByb3RvdHlwZSA9IG5ldyBEZWZhdWx0SGFuZGxlcigpO1xuXG5EZWZhdWx0RnJhY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5leHRyYWN0U2VyaWVzID0gZnVuY3Rpb24ocmF3RGF0YSwgaSwgb3B0aW9ucykge1xuICAvLyBUT0RPKGRhbnZrKTogcHJlLWFsbG9jYXRlIHNlcmllcyBoZXJlLlxuICB2YXIgc2VyaWVzID0gW107XG4gIHZhciB4LCB5LCBwb2ludCwgbnVtLCBkZW4sIHZhbHVlO1xuICB2YXIgbXVsdCA9IDEwMC4wO1xuICB2YXIgbG9nU2NhbGUgPSBvcHRpb25zLmdldCgnbG9nc2NhbGUnKTtcbiAgZm9yICggdmFyIGogPSAwOyBqIDwgcmF3RGF0YS5sZW5ndGg7IGorKykge1xuICAgIHggPSByYXdEYXRhW2pdWzBdO1xuICAgIHBvaW50ID0gcmF3RGF0YVtqXVtpXTtcbiAgICBpZiAobG9nU2NhbGUgJiYgcG9pbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIE9uIHRoZSBsb2cgc2NhbGUsIHBvaW50cyBsZXNzIHRoYW4gemVybyBkbyBub3QgZXhpc3QuXG4gICAgICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgZ2FwIGluIHRoZSBjaGFydC5cbiAgICAgIGlmIChwb2ludFswXSA8PSAwIHx8IHBvaW50WzFdIDw9IDApIHtcbiAgICAgICAgcG9pbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBFeHRyYWN0IHRvIHRoZSB1bmlmaWVkIGRhdGEgZm9ybWF0LlxuICAgIGlmIChwb2ludCAhPT0gbnVsbCkge1xuICAgICAgbnVtID0gcG9pbnRbMF07XG4gICAgICBkZW4gPSBwb2ludFsxXTtcbiAgICAgIGlmIChudW0gIT09IG51bGwgJiYgIWlzTmFOKG51bSkpIHtcbiAgICAgICAgdmFsdWUgPSBkZW4gPyBudW0gLyBkZW4gOiAwLjA7XG4gICAgICAgIHkgPSBtdWx0ICogdmFsdWU7XG4gICAgICAgIC8vIHByZXNlcnZlIG9yaWdpbmFsIHZhbHVlcyBpbiBleHRyYXMgZm9yIGZ1cnRoZXIgZmlsdGVyaW5nXG4gICAgICAgIHNlcmllcy5wdXNoKFsgeCwgeSwgWyBudW0sIGRlbiBdIF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWVzLnB1c2goWyB4LCBudW0sIFsgbnVtLCBkZW4gXSBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWVzLnB1c2goWyB4LCBudWxsLCBbIG51bGwsIG51bGwgXSBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmllcztcbn07XG5cbkRlZmF1bHRGcmFjdGlvbkhhbmRsZXIucHJvdG90eXBlLnJvbGxpbmdBdmVyYWdlID0gZnVuY3Rpb24ob3JpZ2luYWxEYXRhLCByb2xsUGVyaW9kLFxuICAgIG9wdGlvbnMpIHtcbiAgcm9sbFBlcmlvZCA9IE1hdGgubWluKHJvbGxQZXJpb2QsIG9yaWdpbmFsRGF0YS5sZW5ndGgpO1xuICB2YXIgcm9sbGluZ0RhdGEgPSBbXTtcblxuICB2YXIgaTtcbiAgdmFyIG51bSA9IDA7XG4gIHZhciBkZW4gPSAwOyAvLyBudW1lcmF0b3IvZGVub21pbmF0b3JcbiAgdmFyIG11bHQgPSAxMDAuMDtcbiAgZm9yIChpID0gMDsgaSA8IG9yaWdpbmFsRGF0YS5sZW5ndGg7IGkrKykge1xuICAgIG51bSArPSBvcmlnaW5hbERhdGFbaV1bMl1bMF07XG4gICAgZGVuICs9IG9yaWdpbmFsRGF0YVtpXVsyXVsxXTtcbiAgICBpZiAoaSAtIHJvbGxQZXJpb2QgPj0gMCkge1xuICAgICAgbnVtIC09IG9yaWdpbmFsRGF0YVtpIC0gcm9sbFBlcmlvZF1bMl1bMF07XG4gICAgICBkZW4gLT0gb3JpZ2luYWxEYXRhW2kgLSByb2xsUGVyaW9kXVsyXVsxXTtcbiAgICB9XG5cbiAgICB2YXIgZGF0ZSA9IG9yaWdpbmFsRGF0YVtpXVswXTtcbiAgICB2YXIgdmFsdWUgPSBkZW4gPyBudW0gLyBkZW4gOiAwLjA7XG4gICAgcm9sbGluZ0RhdGFbaV0gPSBbIGRhdGUsIG11bHQgKiB2YWx1ZSBdO1xuICB9XG5cbiAgcmV0dXJuIHJvbGxpbmdEYXRhO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRGVmYXVsdEZyYWN0aW9uSGFuZGxlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZHlncmFwaHMvc3JjL2RhdGFoYW5kbGVyL2RlZmF1bHQtZnJhY3Rpb25zLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26\n");

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph__ = __webpack_require__(13);\n/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview A wrapper around the Dygraph class which implements the\n * interface for a GViz (aka Google Visualization API) visualization.\n * It is designed to be a drop-in replacement for Google's AnnotatedTimeline,\n * so the documentation at\n * http://code.google.com/apis/chart/interactive/docs/gallery/annotatedtimeline.html\n * translates over directly.\n *\n * For a full demo, see:\n * - http://dygraphs.com/tests/gviz.html\n * - http://dygraphs.com/tests/annotation-gviz.html\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * A wrapper around Dygraph that implements the gviz API.\n * @param {!HTMLDivElement} container The DOM object the visualization should\n *     live in.\n * @constructor\n */\nvar GVizChart = function GVizChart(container) {\n  this.container = container;\n};\n\n/**\n * @param {GVizDataTable} data\n * @param {Object.<*>} options\n */\nGVizChart.prototype.draw = function (data, options) {\n  // Clear out any existing dygraph.\n  // TODO(danvk): would it make more sense to simply redraw using the current\n  // date_graph object?\n  this.container.innerHTML = '';\n  if (typeof this.date_graph != 'undefined') {\n    this.date_graph.destroy();\n  }\n\n  this.date_graph = new __WEBPACK_IMPORTED_MODULE_0__dygraph__[\"a\" /* default */](this.container, data, options);\n};\n\n/**\n * Google charts compatible setSelection\n * Only row selection is supported, all points in the row will be highlighted\n * @param {Array.<{row:number}>} selection_array array of the selected cells\n * @public\n */\nGVizChart.prototype.setSelection = function (selection_array) {\n  var row = false;\n  if (selection_array.length) {\n    row = selection_array[0].row;\n  }\n  this.date_graph.setSelection(row);\n};\n\n/**\n * Google charts compatible getSelection implementation\n * @return {Array.<{row:number,column:number}>} array of the selected cells\n * @public\n */\nGVizChart.prototype.getSelection = function () {\n  var selection = [];\n\n  var row = this.date_graph.getSelection();\n\n  if (row < 0) return selection;\n\n  var points = this.date_graph.layout_.points;\n  for (var setIdx = 0; setIdx < points.length; ++setIdx) {\n    selection.push({ row: row, column: setIdx + 1 });\n  }\n\n  return selection;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (GVizChart);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLWd2aXouanM/MTYwNSJdLCJuYW1lcyI6WyJHVml6Q2hhcnQiLCJjb250YWluZXIiLCJwcm90b3R5cGUiLCJkcmF3IiwiZGF0YSIsIm9wdGlvbnMiLCJpbm5lckhUTUwiLCJkYXRlX2dyYXBoIiwiZGVzdHJveSIsInNldFNlbGVjdGlvbiIsInNlbGVjdGlvbl9hcnJheSIsInJvdyIsImxlbmd0aCIsImdldFNlbGVjdGlvbiIsInNlbGVjdGlvbiIsInBvaW50cyIsImxheW91dF8iLCJzZXRJZHgiLCJwdXNoIiwiY29sdW1uIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOzs7Ozs7QUFNQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7OztBQU1BLElBQUlBLFlBQVksU0FBWkEsU0FBWSxDQUFTQyxTQUFULEVBQW9CO0FBQ2xDLE9BQUtBLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0QsQ0FGRDs7QUFJQTs7OztBQUlBRCxVQUFVRSxTQUFWLENBQW9CQyxJQUFwQixHQUEyQixVQUFTQyxJQUFULEVBQWVDLE9BQWYsRUFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsT0FBS0osU0FBTCxDQUFlSyxTQUFmLEdBQTJCLEVBQTNCO0FBQ0EsTUFBSSxPQUFPLEtBQUtDLFVBQVosSUFBMkIsV0FBL0IsRUFBNEM7QUFDMUMsU0FBS0EsVUFBTCxDQUFnQkMsT0FBaEI7QUFDRDs7QUFFRCxPQUFLRCxVQUFMLEdBQWtCLElBQUkseURBQUosQ0FBWSxLQUFLTixTQUFqQixFQUE0QkcsSUFBNUIsRUFBa0NDLE9BQWxDLENBQWxCO0FBQ0QsQ0FWRDs7QUFZQTs7Ozs7O0FBTUFMLFVBQVVFLFNBQVYsQ0FBb0JPLFlBQXBCLEdBQW1DLFVBQVNDLGVBQVQsRUFBMEI7QUFDM0QsTUFBSUMsTUFBTSxLQUFWO0FBQ0EsTUFBSUQsZ0JBQWdCRSxNQUFwQixFQUE0QjtBQUMxQkQsVUFBTUQsZ0JBQWdCLENBQWhCLEVBQW1CQyxHQUF6QjtBQUNEO0FBQ0QsT0FBS0osVUFBTCxDQUFnQkUsWUFBaEIsQ0FBNkJFLEdBQTdCO0FBQ0QsQ0FORDs7QUFRQTs7Ozs7QUFLQVgsVUFBVUUsU0FBVixDQUFvQlcsWUFBcEIsR0FBbUMsWUFBVztBQUM1QyxNQUFJQyxZQUFZLEVBQWhCOztBQUVBLE1BQUlILE1BQU0sS0FBS0osVUFBTCxDQUFnQk0sWUFBaEIsRUFBVjs7QUFFQSxNQUFJRixNQUFNLENBQVYsRUFBYSxPQUFPRyxTQUFQOztBQUViLE1BQUlDLFNBQVMsS0FBS1IsVUFBTCxDQUFnQlMsT0FBaEIsQ0FBd0JELE1BQXJDO0FBQ0EsT0FBSyxJQUFJRSxTQUFTLENBQWxCLEVBQXFCQSxTQUFTRixPQUFPSCxNQUFyQyxFQUE2QyxFQUFFSyxNQUEvQyxFQUF1RDtBQUNyREgsY0FBVUksSUFBVixDQUFlLEVBQUNQLEtBQUtBLEdBQU4sRUFBV1EsUUFBUUYsU0FBUyxDQUE1QixFQUFmO0FBQ0Q7O0FBRUQsU0FBT0gsU0FBUDtBQUNELENBYkQ7O0FBZUEseURBQWVkLFNBQWYiLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMSBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBBIHdyYXBwZXIgYXJvdW5kIHRoZSBEeWdyYXBoIGNsYXNzIHdoaWNoIGltcGxlbWVudHMgdGhlXG4gKiBpbnRlcmZhY2UgZm9yIGEgR1ZpeiAoYWthIEdvb2dsZSBWaXN1YWxpemF0aW9uIEFQSSkgdmlzdWFsaXphdGlvbi5cbiAqIEl0IGlzIGRlc2lnbmVkIHRvIGJlIGEgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgR29vZ2xlJ3MgQW5ub3RhdGVkVGltZWxpbmUsXG4gKiBzbyB0aGUgZG9jdW1lbnRhdGlvbiBhdFxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9hcGlzL2NoYXJ0L2ludGVyYWN0aXZlL2RvY3MvZ2FsbGVyeS9hbm5vdGF0ZWR0aW1lbGluZS5odG1sXG4gKiB0cmFuc2xhdGVzIG92ZXIgZGlyZWN0bHkuXG4gKlxuICogRm9yIGEgZnVsbCBkZW1vLCBzZWU6XG4gKiAtIGh0dHA6Ly9keWdyYXBocy5jb20vdGVzdHMvZ3Zpei5odG1sXG4gKiAtIGh0dHA6Ly9keWdyYXBocy5jb20vdGVzdHMvYW5ub3RhdGlvbi1ndml6Lmh0bWxcbiAqL1xuXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IER5Z3JhcGggZnJvbSAnLi9keWdyYXBoJztcblxuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIER5Z3JhcGggdGhhdCBpbXBsZW1lbnRzIHRoZSBndml6IEFQSS5cbiAqIEBwYXJhbSB7IUhUTUxEaXZFbGVtZW50fSBjb250YWluZXIgVGhlIERPTSBvYmplY3QgdGhlIHZpc3VhbGl6YXRpb24gc2hvdWxkXG4gKiAgICAgbGl2ZSBpbi5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgR1ZpekNoYXJ0ID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0dWaXpEYXRhVGFibGV9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0LjwqPn0gb3B0aW9uc1xuICovXG5HVml6Q2hhcnQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XG4gIC8vIENsZWFyIG91dCBhbnkgZXhpc3RpbmcgZHlncmFwaC5cbiAgLy8gVE9ETyhkYW52ayk6IHdvdWxkIGl0IG1ha2UgbW9yZSBzZW5zZSB0byBzaW1wbHkgcmVkcmF3IHVzaW5nIHRoZSBjdXJyZW50XG4gIC8vIGRhdGVfZ3JhcGggb2JqZWN0P1xuICB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgaWYgKHR5cGVvZih0aGlzLmRhdGVfZ3JhcGgpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5kYXRlX2dyYXBoLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHRoaXMuZGF0ZV9ncmFwaCA9IG5ldyBEeWdyYXBoKHRoaXMuY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogR29vZ2xlIGNoYXJ0cyBjb21wYXRpYmxlIHNldFNlbGVjdGlvblxuICogT25seSByb3cgc2VsZWN0aW9uIGlzIHN1cHBvcnRlZCwgYWxsIHBvaW50cyBpbiB0aGUgcm93IHdpbGwgYmUgaGlnaGxpZ2h0ZWRcbiAqIEBwYXJhbSB7QXJyYXkuPHtyb3c6bnVtYmVyfT59IHNlbGVjdGlvbl9hcnJheSBhcnJheSBvZiB0aGUgc2VsZWN0ZWQgY2VsbHNcbiAqIEBwdWJsaWNcbiAqL1xuR1ZpekNoYXJ0LnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbihzZWxlY3Rpb25fYXJyYXkpIHtcbiAgdmFyIHJvdyA9IGZhbHNlO1xuICBpZiAoc2VsZWN0aW9uX2FycmF5Lmxlbmd0aCkge1xuICAgIHJvdyA9IHNlbGVjdGlvbl9hcnJheVswXS5yb3c7XG4gIH1cbiAgdGhpcy5kYXRlX2dyYXBoLnNldFNlbGVjdGlvbihyb3cpO1xufTtcblxuLyoqXG4gKiBHb29nbGUgY2hhcnRzIGNvbXBhdGlibGUgZ2V0U2VsZWN0aW9uIGltcGxlbWVudGF0aW9uXG4gKiBAcmV0dXJuIHtBcnJheS48e3JvdzpudW1iZXIsY29sdW1uOm51bWJlcn0+fSBhcnJheSBvZiB0aGUgc2VsZWN0ZWQgY2VsbHNcbiAqIEBwdWJsaWNcbiAqL1xuR1ZpekNoYXJ0LnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IFtdO1xuXG4gIHZhciByb3cgPSB0aGlzLmRhdGVfZ3JhcGguZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKHJvdyA8IDApIHJldHVybiBzZWxlY3Rpb247XG5cbiAgdmFyIHBvaW50cyA9IHRoaXMuZGF0ZV9ncmFwaC5sYXlvdXRfLnBvaW50cztcbiAgZm9yICh2YXIgc2V0SWR4ID0gMDsgc2V0SWR4IDwgcG9pbnRzLmxlbmd0aDsgKytzZXRJZHgpIHtcbiAgICBzZWxlY3Rpb24ucHVzaCh7cm93OiByb3csIGNvbHVtbjogc2V0SWR4ICsgMX0pO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdWaXpDaGFydDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZHlncmFwaHMvc3JjL2R5Z3JhcGgtZ3Zpei5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///27\n");

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dygraph_default_attrs__ = __webpack_require__(17);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__dygraph_options_reference__ = __webpack_require__(19);\n/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DygraphOptions is responsible for parsing and returning\n * information about options.\n */\n\n// TODO: remove this jshint directive & fix the warnings.\n/*jshint sub:true */\n\n\n\n\n\n\n/*\n * Interesting member variables: (REMOVING THIS LIST AS I CLOSURIZE)\n * global_ - global attributes (common among all graphs, AIUI)\n * user - attributes set by the user\n * series_ - { seriesName -> { idx, yAxis, options }}\n */\n\n/**\n * This parses attributes into an object that can be easily queried.\n *\n * It doesn't necessarily mean that all options are available, specifically\n * if labels are not yet available, since those drive details of the per-series\n * and per-axis options.\n *\n * @param {Dygraph} dygraph The chart to which these options belong.\n * @constructor\n */\nvar DygraphOptions = function DygraphOptions(dygraph) {\n  /**\n   * The dygraph.\n   * @type {!Dygraph}\n   */\n  this.dygraph_ = dygraph;\n\n  /**\n   * Array of axis index to { series : [ series names ] , options : { axis-specific options. }\n   * @type {Array.<{series : Array.<string>, options : Object}>} @private\n   */\n  this.yAxes_ = [];\n\n  /**\n   * Contains x-axis specific options, which are stored in the options key.\n   * This matches the yAxes_ object structure (by being a dictionary with an\n   * options element) allowing for shared code.\n   * @type {options: Object} @private\n   */\n  this.xAxis_ = {};\n  this.series_ = {};\n\n  // Once these two objects are initialized, you can call get();\n  this.global_ = this.dygraph_.attrs_;\n  this.user_ = this.dygraph_.user_attrs_ || {};\n\n  /**\n   * A list of series in columnar order.\n   * @type {Array.<string>}\n   */\n  this.labels_ = [];\n\n  this.highlightSeries_ = this.get(\"highlightSeriesOpts\") || {};\n  this.reparseSeries();\n};\n\n/**\n * Not optimal, but does the trick when you're only using two axes.\n * If we move to more axes, this can just become a function.\n *\n * @type {Object.<number>}\n * @private\n */\nDygraphOptions.AXIS_STRING_MAPPINGS_ = {\n  'y': 0,\n  'Y': 0,\n  'y1': 0,\n  'Y1': 0,\n  'y2': 1,\n  'Y2': 1\n};\n\n/**\n * @param {string|number} axis\n * @private\n */\nDygraphOptions.axisToIndex_ = function (axis) {\n  if (typeof axis == \"string\") {\n    if (DygraphOptions.AXIS_STRING_MAPPINGS_.hasOwnProperty(axis)) {\n      return DygraphOptions.AXIS_STRING_MAPPINGS_[axis];\n    }\n    throw \"Unknown axis : \" + axis;\n  }\n  if (typeof axis == \"number\") {\n    if (axis === 0 || axis === 1) {\n      return axis;\n    }\n    throw \"Dygraphs only supports two y-axes, indexed from 0-1.\";\n  }\n  if (axis) {\n    throw \"Unknown axis : \" + axis;\n  }\n  // No axis specification means axis 0.\n  return 0;\n};\n\n/**\n * Reparses options that are all related to series. This typically occurs when\n * options are either updated, or source data has been made available.\n *\n * TODO(konigsberg): The method name is kind of weak; fix.\n */\nDygraphOptions.prototype.reparseSeries = function () {\n  var labels = this.get(\"labels\");\n  if (!labels) {\n    return; // -- can't do more for now, will parse after getting the labels.\n  }\n\n  this.labels_ = labels.slice(1);\n\n  this.yAxes_ = [{ series: [], options: {} }]; // Always one axis at least.\n  this.xAxis_ = { options: {} };\n  this.series_ = {};\n\n  // Series are specified in the series element:\n  //\n  // {\n  //   labels: [ \"X\", \"foo\", \"bar\" ],\n  //   pointSize: 3,\n  //   series : {\n  //     foo : {}, // options for foo\n  //     bar : {} // options for bar\n  //   }\n  // }\n  //\n  // So, if series is found, it's expected to contain per-series data, otherwise set a\n  // default.\n  var seriesDict = this.user_.series || {};\n  for (var idx = 0; idx < this.labels_.length; idx++) {\n    var seriesName = this.labels_[idx];\n    var optionsForSeries = seriesDict[seriesName] || {};\n    var yAxis = DygraphOptions.axisToIndex_(optionsForSeries[\"axis\"]);\n\n    this.series_[seriesName] = {\n      idx: idx,\n      yAxis: yAxis,\n      options: optionsForSeries };\n\n    if (!this.yAxes_[yAxis]) {\n      this.yAxes_[yAxis] = { series: [seriesName], options: {} };\n    } else {\n      this.yAxes_[yAxis].series.push(seriesName);\n    }\n  }\n\n  var axis_opts = this.user_[\"axes\"] || {};\n  __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"a\" /* update */](this.yAxes_[0].options, axis_opts[\"y\"] || {});\n  if (this.yAxes_.length > 1) {\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"a\" /* update */](this.yAxes_[1].options, axis_opts[\"y2\"] || {});\n  }\n  __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"a\" /* update */](this.xAxis_.options, axis_opts[\"x\"] || {});\n\n  // For \"production\" code, this gets removed by uglifyjs.\n  if (typeof process !== 'undefined') {\n    if (process.env.NODE_ENV != 'production') {\n      this.validateOptions_();\n    }\n  }\n};\n\n/**\n * Get a global value.\n *\n * @param {string} name the name of the option.\n */\nDygraphOptions.prototype.get = function (name) {\n  var result = this.getGlobalUser_(name);\n  if (result !== null) {\n    return result;\n  }\n  return this.getGlobalDefault_(name);\n};\n\nDygraphOptions.prototype.getGlobalUser_ = function (name) {\n  if (this.user_.hasOwnProperty(name)) {\n    return this.user_[name];\n  }\n  return null;\n};\n\nDygraphOptions.prototype.getGlobalDefault_ = function (name) {\n  if (this.global_.hasOwnProperty(name)) {\n    return this.global_[name];\n  }\n  if (__WEBPACK_IMPORTED_MODULE_1__dygraph_default_attrs__[\"a\" /* default */].hasOwnProperty(name)) {\n    return __WEBPACK_IMPORTED_MODULE_1__dygraph_default_attrs__[\"a\" /* default */][name];\n  }\n  return null;\n};\n\n/**\n * Get a value for a specific axis. If there is no specific value for the axis,\n * the global value is returned.\n *\n * @param {string} name the name of the option.\n * @param {string|number} axis the axis to search. Can be the string representation\n * (\"y\", \"y2\") or the axis number (0, 1).\n */\nDygraphOptions.prototype.getForAxis = function (name, axis) {\n  var axisIdx;\n  var axisString;\n\n  // Since axis can be a number or a string, straighten everything out here.\n  if (typeof axis == 'number') {\n    axisIdx = axis;\n    axisString = axisIdx === 0 ? \"y\" : \"y2\";\n  } else {\n    if (axis == \"y1\") {\n      axis = \"y\";\n    } // Standardize on 'y'. Is this bad? I think so.\n    if (axis == \"y\") {\n      axisIdx = 0;\n    } else if (axis == \"y2\") {\n      axisIdx = 1;\n    } else if (axis == \"x\") {\n      axisIdx = -1; // simply a placeholder for below.\n    } else {\n      throw \"Unknown axis \" + axis;\n    }\n    axisString = axis;\n  }\n\n  var userAxis = axisIdx == -1 ? this.xAxis_ : this.yAxes_[axisIdx];\n\n  // Search the user-specified axis option first.\n  if (userAxis) {\n    // This condition could be removed if we always set up this.yAxes_ for y2.\n    var axisOptions = userAxis.options;\n    if (axisOptions.hasOwnProperty(name)) {\n      return axisOptions[name];\n    }\n  }\n\n  // User-specified global options second.\n  // But, hack, ignore globally-specified 'logscale' for 'x' axis declaration.\n  if (!(axis === 'x' && name === 'logscale')) {\n    var result = this.getGlobalUser_(name);\n    if (result !== null) {\n      return result;\n    }\n  }\n  // Default axis options third.\n  var defaultAxisOptions = __WEBPACK_IMPORTED_MODULE_1__dygraph_default_attrs__[\"a\" /* default */].axes[axisString];\n  if (defaultAxisOptions.hasOwnProperty(name)) {\n    return defaultAxisOptions[name];\n  }\n\n  // Default global options last.\n  return this.getGlobalDefault_(name);\n};\n\n/**\n * Get a value for a specific series. If there is no specific value for the series,\n * the value for the axis is returned (and afterwards, the global value.)\n *\n * @param {string} name the name of the option.\n * @param {string} series the series to search.\n */\nDygraphOptions.prototype.getForSeries = function (name, series) {\n  // Honors indexes as series.\n  if (series === this.dygraph_.getHighlightSeries()) {\n    if (this.highlightSeries_.hasOwnProperty(name)) {\n      return this.highlightSeries_[name];\n    }\n  }\n\n  if (!this.series_.hasOwnProperty(series)) {\n    throw \"Unknown series: \" + series;\n  }\n\n  var seriesObj = this.series_[series];\n  var seriesOptions = seriesObj[\"options\"];\n  if (seriesOptions.hasOwnProperty(name)) {\n    return seriesOptions[name];\n  }\n\n  return this.getForAxis(name, seriesObj[\"yAxis\"]);\n};\n\n/**\n * Returns the number of y-axes on the chart.\n * @return {number} the number of axes.\n */\nDygraphOptions.prototype.numAxes = function () {\n  return this.yAxes_.length;\n};\n\n/**\n * Return the y-axis for a given series, specified by name.\n */\nDygraphOptions.prototype.axisForSeries = function (series) {\n  return this.series_[series].yAxis;\n};\n\n/**\n * Returns the options for the specified axis.\n */\n// TODO(konigsberg): this is y-axis specific. Support the x axis.\nDygraphOptions.prototype.axisOptions = function (yAxis) {\n  return this.yAxes_[yAxis].options;\n};\n\n/**\n * Return the series associated with an axis.\n */\nDygraphOptions.prototype.seriesForAxis = function (yAxis) {\n  return this.yAxes_[yAxis].series;\n};\n\n/**\n * Return the list of all series, in their columnar order.\n */\nDygraphOptions.prototype.seriesNames = function () {\n  return this.labels_;\n};\n\n// For \"production\" code, this gets removed by uglifyjs.\nif (typeof process !== 'undefined') {\n  if (process.env.NODE_ENV != 'production') {\n\n    /**\n     * Validate all options.\n     * This requires OPTIONS_REFERENCE, which is only available in debug builds.\n     * @private\n     */\n    DygraphOptions.prototype.validateOptions_ = function () {\n      if (typeof __WEBPACK_IMPORTED_MODULE_2__dygraph_options_reference__[\"a\" /* default */] === 'undefined') {\n        throw 'Called validateOptions_ in prod build.';\n      }\n\n      var that = this;\n      var validateOption = function validateOption(optionName) {\n        if (!__WEBPACK_IMPORTED_MODULE_2__dygraph_options_reference__[\"a\" /* default */][optionName]) {\n          that.warnInvalidOption_(optionName);\n        }\n      };\n\n      var optionsDicts = [this.xAxis_.options, this.yAxes_[0].options, this.yAxes_[1] && this.yAxes_[1].options, this.global_, this.user_, this.highlightSeries_];\n      var names = this.seriesNames();\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        if (this.series_.hasOwnProperty(name)) {\n          optionsDicts.push(this.series_[name].options);\n        }\n      }\n      for (var i = 0; i < optionsDicts.length; i++) {\n        var dict = optionsDicts[i];\n        if (!dict) continue;\n        for (var optionName in dict) {\n          if (dict.hasOwnProperty(optionName)) {\n            validateOption(optionName);\n          }\n        }\n      }\n    };\n\n    var WARNINGS = {}; // Only show any particular warning once.\n\n    /**\n     * Logs a warning about invalid options.\n     * TODO: make this throw for testing\n     * @private\n     */\n    DygraphOptions.prototype.warnInvalidOption_ = function (optionName) {\n      if (!WARNINGS[optionName]) {\n        WARNINGS[optionName] = true;\n        var isSeries = this.labels_.indexOf(optionName) >= 0;\n        if (isSeries) {\n          console.warn('Use new-style per-series options (saw ' + optionName + ' as top-level options key). See http://bit.ly/1tceaJs');\n        } else {\n          console.warn('Unknown option ' + optionName + ' (full list of options at dygraphs.com/options.html');\n        }\n        throw \"invalid option \" + optionName;\n      }\n    };\n\n    // Reset list of previously-shown warnings. Used for testing.\n    DygraphOptions.resetWarnings_ = function () {\n      WARNINGS = {};\n    };\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DygraphOptions);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(14)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9keWdyYXBoLW9wdGlvbnMuanM/OTFlYiJdLCJuYW1lcyI6WyJEeWdyYXBoT3B0aW9ucyIsImR5Z3JhcGgiLCJkeWdyYXBoXyIsInlBeGVzXyIsInhBeGlzXyIsInNlcmllc18iLCJnbG9iYWxfIiwiYXR0cnNfIiwidXNlcl8iLCJ1c2VyX2F0dHJzXyIsImxhYmVsc18iLCJoaWdobGlnaHRTZXJpZXNfIiwiZ2V0IiwicmVwYXJzZVNlcmllcyIsIkFYSVNfU1RSSU5HX01BUFBJTkdTXyIsImF4aXNUb0luZGV4XyIsImF4aXMiLCJoYXNPd25Qcm9wZXJ0eSIsInByb3RvdHlwZSIsImxhYmVscyIsInNsaWNlIiwic2VyaWVzIiwib3B0aW9ucyIsInNlcmllc0RpY3QiLCJpZHgiLCJsZW5ndGgiLCJzZXJpZXNOYW1lIiwib3B0aW9uc0ZvclNlcmllcyIsInlBeGlzIiwicHVzaCIsImF4aXNfb3B0cyIsInV0aWxzIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwidmFsaWRhdGVPcHRpb25zXyIsIm5hbWUiLCJyZXN1bHQiLCJnZXRHbG9iYWxVc2VyXyIsImdldEdsb2JhbERlZmF1bHRfIiwiREVGQVVMVF9BVFRSUyIsImdldEZvckF4aXMiLCJheGlzSWR4IiwiYXhpc1N0cmluZyIsInVzZXJBeGlzIiwiYXhpc09wdGlvbnMiLCJkZWZhdWx0QXhpc09wdGlvbnMiLCJheGVzIiwiZ2V0Rm9yU2VyaWVzIiwiZ2V0SGlnaGxpZ2h0U2VyaWVzIiwic2VyaWVzT2JqIiwic2VyaWVzT3B0aW9ucyIsIm51bUF4ZXMiLCJheGlzRm9yU2VyaWVzIiwic2VyaWVzRm9yQXhpcyIsInNlcmllc05hbWVzIiwidGhhdCIsInZhbGlkYXRlT3B0aW9uIiwib3B0aW9uTmFtZSIsIk9QVElPTlNfUkVGRVJFTkNFIiwid2FybkludmFsaWRPcHRpb25fIiwib3B0aW9uc0RpY3RzIiwibmFtZXMiLCJpIiwiZGljdCIsIldBUk5JTkdTIiwi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QWdDLFlBQVc7QUFDekNMLGlCQUFXLEVBQVg7QUFDRCxLQUZEO0FBSUM7QUFDQTs7QUFFRCx5REFBZWpFLGNBQWYsRSIsImZpbGUiOiIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDExIERhbiBWYW5kZXJrYW0gKGRhbnZka0BnbWFpbC5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IER5Z3JhcGhPcHRpb25zIGlzIHJlc3BvbnNpYmxlIGZvciBwYXJzaW5nIGFuZCByZXR1cm5pbmdcbiAqIGluZm9ybWF0aW9uIGFib3V0IG9wdGlvbnMuXG4gKi9cblxuLy8gVE9ETzogcmVtb3ZlIHRoaXMganNoaW50IGRpcmVjdGl2ZSAmIGZpeCB0aGUgd2FybmluZ3MuXG4vKmpzaGludCBzdWI6dHJ1ZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vZHlncmFwaC11dGlscyc7XG5pbXBvcnQgREVGQVVMVF9BVFRSUyBmcm9tICcuL2R5Z3JhcGgtZGVmYXVsdC1hdHRycyc7XG5pbXBvcnQgT1BUSU9OU19SRUZFUkVOQ0UgZnJvbSAnLi9keWdyYXBoLW9wdGlvbnMtcmVmZXJlbmNlJztcblxuLypcbiAqIEludGVyZXN0aW5nIG1lbWJlciB2YXJpYWJsZXM6IChSRU1PVklORyBUSElTIExJU1QgQVMgSSBDTE9TVVJJWkUpXG4gKiBnbG9iYWxfIC0gZ2xvYmFsIGF0dHJpYnV0ZXMgKGNvbW1vbiBhbW9uZyBhbGwgZ3JhcGhzLCBBSVVJKVxuICogdXNlciAtIGF0dHJpYnV0ZXMgc2V0IGJ5IHRoZSB1c2VyXG4gKiBzZXJpZXNfIC0geyBzZXJpZXNOYW1lIC0+IHsgaWR4LCB5QXhpcywgb3B0aW9ucyB9fVxuICovXG5cbi8qKlxuICogVGhpcyBwYXJzZXMgYXR0cmlidXRlcyBpbnRvIGFuIG9iamVjdCB0aGF0IGNhbiBiZSBlYXNpbHkgcXVlcmllZC5cbiAqXG4gKiBJdCBkb2Vzbid0IG5lY2Vzc2FyaWx5IG1lYW4gdGhhdCBhbGwgb3B0aW9ucyBhcmUgYXZhaWxhYmxlLCBzcGVjaWZpY2FsbHlcbiAqIGlmIGxhYmVscyBhcmUgbm90IHlldCBhdmFpbGFibGUsIHNpbmNlIHRob3NlIGRyaXZlIGRldGFpbHMgb2YgdGhlIHBlci1zZXJpZXNcbiAqIGFuZCBwZXItYXhpcyBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7RHlncmFwaH0gZHlncmFwaCBUaGUgY2hhcnQgdG8gd2hpY2ggdGhlc2Ugb3B0aW9ucyBiZWxvbmcuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIER5Z3JhcGhPcHRpb25zID0gZnVuY3Rpb24oZHlncmFwaCkge1xuICAvKipcbiAgICogVGhlIGR5Z3JhcGguXG4gICAqIEB0eXBlIHshRHlncmFwaH1cbiAgICovXG4gIHRoaXMuZHlncmFwaF8gPSBkeWdyYXBoO1xuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBheGlzIGluZGV4IHRvIHsgc2VyaWVzIDogWyBzZXJpZXMgbmFtZXMgXSAsIG9wdGlvbnMgOiB7IGF4aXMtc3BlY2lmaWMgb3B0aW9ucy4gfVxuICAgKiBAdHlwZSB7QXJyYXkuPHtzZXJpZXMgOiBBcnJheS48c3RyaW5nPiwgb3B0aW9ucyA6IE9iamVjdH0+fSBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy55QXhlc18gPSBbXTtcblxuICAvKipcbiAgICogQ29udGFpbnMgeC1heGlzIHNwZWNpZmljIG9wdGlvbnMsIHdoaWNoIGFyZSBzdG9yZWQgaW4gdGhlIG9wdGlvbnMga2V5LlxuICAgKiBUaGlzIG1hdGNoZXMgdGhlIHlBeGVzXyBvYmplY3Qgc3RydWN0dXJlIChieSBiZWluZyBhIGRpY3Rpb25hcnkgd2l0aCBhblxuICAgKiBvcHRpb25zIGVsZW1lbnQpIGFsbG93aW5nIGZvciBzaGFyZWQgY29kZS5cbiAgICogQHR5cGUge29wdGlvbnM6IE9iamVjdH0gQHByaXZhdGVcbiAgICovXG4gIHRoaXMueEF4aXNfID0ge307XG4gIHRoaXMuc2VyaWVzXyA9IHt9O1xuXG4gIC8vIE9uY2UgdGhlc2UgdHdvIG9iamVjdHMgYXJlIGluaXRpYWxpemVkLCB5b3UgY2FuIGNhbGwgZ2V0KCk7XG4gIHRoaXMuZ2xvYmFsXyA9IHRoaXMuZHlncmFwaF8uYXR0cnNfO1xuICB0aGlzLnVzZXJfID0gdGhpcy5keWdyYXBoXy51c2VyX2F0dHJzXyB8fCB7fTtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIHNlcmllcyBpbiBjb2x1bW5hciBvcmRlci5cbiAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgKi9cbiAgdGhpcy5sYWJlbHNfID0gW107XG5cbiAgdGhpcy5oaWdobGlnaHRTZXJpZXNfID0gdGhpcy5nZXQoXCJoaWdobGlnaHRTZXJpZXNPcHRzXCIpIHx8IHt9O1xuICB0aGlzLnJlcGFyc2VTZXJpZXMoKTtcbn07XG5cbi8qKlxuICogTm90IG9wdGltYWwsIGJ1dCBkb2VzIHRoZSB0cmljayB3aGVuIHlvdSdyZSBvbmx5IHVzaW5nIHR3byBheGVzLlxuICogSWYgd2UgbW92ZSB0byBtb3JlIGF4ZXMsIHRoaXMgY2FuIGp1c3QgYmVjb21lIGEgZnVuY3Rpb24uXG4gKlxuICogQHR5cGUge09iamVjdC48bnVtYmVyPn1cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhPcHRpb25zLkFYSVNfU1RSSU5HX01BUFBJTkdTXyA9IHtcbiAgJ3knIDogMCxcbiAgJ1knIDogMCxcbiAgJ3kxJyA6IDAsXG4gICdZMScgOiAwLFxuICAneTInIDogMSxcbiAgJ1kyJyA6IDFcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBheGlzXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoT3B0aW9ucy5heGlzVG9JbmRleF8gPSBmdW5jdGlvbihheGlzKSB7XG4gIGlmICh0eXBlb2YoYXhpcykgPT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChEeWdyYXBoT3B0aW9ucy5BWElTX1NUUklOR19NQVBQSU5HU18uaGFzT3duUHJvcGVydHkoYXhpcykpIHtcbiAgICAgIHJldHVybiBEeWdyYXBoT3B0aW9ucy5BWElTX1NUUklOR19NQVBQSU5HU19bYXhpc107XG4gICAgfVxuICAgIHRocm93IFwiVW5rbm93biBheGlzIDogXCIgKyBheGlzO1xuICB9XG4gIGlmICh0eXBlb2YoYXhpcykgPT0gXCJudW1iZXJcIikge1xuICAgIGlmIChheGlzID09PSAwIHx8IGF4aXMgPT09IDEpIHtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH1cbiAgICB0aHJvdyBcIkR5Z3JhcGhzIG9ubHkgc3VwcG9ydHMgdHdvIHktYXhlcywgaW5kZXhlZCBmcm9tIDAtMS5cIjtcbiAgfVxuICBpZiAoYXhpcykge1xuICAgIHRocm93IFwiVW5rbm93biBheGlzIDogXCIgKyBheGlzO1xuICB9XG4gIC8vIE5vIGF4aXMgc3BlY2lmaWNhdGlvbiBtZWFucyBheGlzIDAuXG4gIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBSZXBhcnNlcyBvcHRpb25zIHRoYXQgYXJlIGFsbCByZWxhdGVkIHRvIHNlcmllcy4gVGhpcyB0eXBpY2FsbHkgb2NjdXJzIHdoZW5cbiAqIG9wdGlvbnMgYXJlIGVpdGhlciB1cGRhdGVkLCBvciBzb3VyY2UgZGF0YSBoYXMgYmVlbiBtYWRlIGF2YWlsYWJsZS5cbiAqXG4gKiBUT0RPKGtvbmlnc2JlcmcpOiBUaGUgbWV0aG9kIG5hbWUgaXMga2luZCBvZiB3ZWFrOyBmaXguXG4gKi9cbkR5Z3JhcGhPcHRpb25zLnByb3RvdHlwZS5yZXBhcnNlU2VyaWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsYWJlbHMgPSB0aGlzLmdldChcImxhYmVsc1wiKTtcbiAgaWYgKCFsYWJlbHMpIHtcbiAgICByZXR1cm47IC8vIC0tIGNhbid0IGRvIG1vcmUgZm9yIG5vdywgd2lsbCBwYXJzZSBhZnRlciBnZXR0aW5nIHRoZSBsYWJlbHMuXG4gIH1cblxuICB0aGlzLmxhYmVsc18gPSBsYWJlbHMuc2xpY2UoMSk7XG5cbiAgdGhpcy55QXhlc18gPSBbIHsgc2VyaWVzIDogW10sIG9wdGlvbnMgOiB7fX0gXTsgLy8gQWx3YXlzIG9uZSBheGlzIGF0IGxlYXN0LlxuICB0aGlzLnhBeGlzXyA9IHsgb3B0aW9ucyA6IHt9IH07XG4gIHRoaXMuc2VyaWVzXyA9IHt9O1xuXG4gIC8vIFNlcmllcyBhcmUgc3BlY2lmaWVkIGluIHRoZSBzZXJpZXMgZWxlbWVudDpcbiAgLy9cbiAgLy8ge1xuICAvLyAgIGxhYmVsczogWyBcIlhcIiwgXCJmb29cIiwgXCJiYXJcIiBdLFxuICAvLyAgIHBvaW50U2l6ZTogMyxcbiAgLy8gICBzZXJpZXMgOiB7XG4gIC8vICAgICBmb28gOiB7fSwgLy8gb3B0aW9ucyBmb3IgZm9vXG4gIC8vICAgICBiYXIgOiB7fSAvLyBvcHRpb25zIGZvciBiYXJcbiAgLy8gICB9XG4gIC8vIH1cbiAgLy9cbiAgLy8gU28sIGlmIHNlcmllcyBpcyBmb3VuZCwgaXQncyBleHBlY3RlZCB0byBjb250YWluIHBlci1zZXJpZXMgZGF0YSwgb3RoZXJ3aXNlIHNldCBhXG4gIC8vIGRlZmF1bHQuXG4gIHZhciBzZXJpZXNEaWN0ID0gdGhpcy51c2VyXy5zZXJpZXMgfHwge307XG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHRoaXMubGFiZWxzXy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdmFyIHNlcmllc05hbWUgPSB0aGlzLmxhYmVsc19baWR4XTtcbiAgICB2YXIgb3B0aW9uc0ZvclNlcmllcyA9IHNlcmllc0RpY3Rbc2VyaWVzTmFtZV0gfHwge307XG4gICAgdmFyIHlBeGlzID0gRHlncmFwaE9wdGlvbnMuYXhpc1RvSW5kZXhfKG9wdGlvbnNGb3JTZXJpZXNbXCJheGlzXCJdKTtcblxuICAgIHRoaXMuc2VyaWVzX1tzZXJpZXNOYW1lXSA9IHtcbiAgICAgIGlkeDogaWR4LFxuICAgICAgeUF4aXM6IHlBeGlzLFxuICAgICAgb3B0aW9ucyA6IG9wdGlvbnNGb3JTZXJpZXMgfTtcblxuICAgIGlmICghdGhpcy55QXhlc19beUF4aXNdKSB7XG4gICAgICB0aGlzLnlBeGVzX1t5QXhpc10gPSAgeyBzZXJpZXMgOiBbIHNlcmllc05hbWUgXSwgb3B0aW9ucyA6IHt9IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueUF4ZXNfW3lBeGlzXS5zZXJpZXMucHVzaChzZXJpZXNOYW1lKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXhpc19vcHRzID0gdGhpcy51c2VyX1tcImF4ZXNcIl0gfHwge307XG4gIHV0aWxzLnVwZGF0ZSh0aGlzLnlBeGVzX1swXS5vcHRpb25zLCBheGlzX29wdHNbXCJ5XCJdIHx8IHt9KTtcbiAgaWYgKHRoaXMueUF4ZXNfLmxlbmd0aCA+IDEpIHtcbiAgICB1dGlscy51cGRhdGUodGhpcy55QXhlc19bMV0ub3B0aW9ucywgYXhpc19vcHRzW1wieTJcIl0gfHwge30pO1xuICB9XG4gIHV0aWxzLnVwZGF0ZSh0aGlzLnhBeGlzXy5vcHRpb25zLCBheGlzX29wdHNbXCJ4XCJdIHx8IHt9KTtcblxuICAvLyBGb3IgXCJwcm9kdWN0aW9uXCIgY29kZSwgdGhpcyBnZXRzIHJlbW92ZWQgYnkgdWdsaWZ5anMuXG4gIGlmICh0eXBlb2YocHJvY2VzcykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhpcy52YWxpZGF0ZU9wdGlvbnNfKCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdldCBhIGdsb2JhbCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgb3B0aW9uLlxuICovXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5nZXRHbG9iYWxVc2VyXyhuYW1lKTtcbiAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZ2V0R2xvYmFsRGVmYXVsdF8obmFtZSk7XG59O1xuXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUuZ2V0R2xvYmFsVXNlcl8gPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICh0aGlzLnVzZXJfLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlcl9bbmFtZV07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUuZ2V0R2xvYmFsRGVmYXVsdF8gPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICh0aGlzLmdsb2JhbF8uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gdGhpcy5nbG9iYWxfW25hbWVdO1xuICB9XG4gIGlmIChERUZBVUxUX0FUVFJTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIERFRkFVTFRfQVRUUlNbbmFtZV07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEdldCBhIHZhbHVlIGZvciBhIHNwZWNpZmljIGF4aXMuIElmIHRoZXJlIGlzIG5vIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgYXhpcyxcbiAqIHRoZSBnbG9iYWwgdmFsdWUgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIG9wdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gYXhpcyB0aGUgYXhpcyB0byBzZWFyY2guIENhbiBiZSB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiAoXCJ5XCIsIFwieTJcIikgb3IgdGhlIGF4aXMgbnVtYmVyICgwLCAxKS5cbiAqL1xuRHlncmFwaE9wdGlvbnMucHJvdG90eXBlLmdldEZvckF4aXMgPSBmdW5jdGlvbihuYW1lLCBheGlzKSB7XG4gIHZhciBheGlzSWR4O1xuICB2YXIgYXhpc1N0cmluZztcblxuICAvLyBTaW5jZSBheGlzIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZywgc3RyYWlnaHRlbiBldmVyeXRoaW5nIG91dCBoZXJlLlxuICBpZiAodHlwZW9mKGF4aXMpID09ICdudW1iZXInKSB7XG4gICAgYXhpc0lkeCA9IGF4aXM7XG4gICAgYXhpc1N0cmluZyA9IGF4aXNJZHggPT09IDAgPyBcInlcIiA6IFwieTJcIjtcbiAgfSBlbHNlIHtcbiAgICBpZiAoYXhpcyA9PSBcInkxXCIpIHsgYXhpcyA9IFwieVwiOyB9IC8vIFN0YW5kYXJkaXplIG9uICd5Jy4gSXMgdGhpcyBiYWQ/IEkgdGhpbmsgc28uXG4gICAgaWYgKGF4aXMgPT0gXCJ5XCIpIHtcbiAgICAgIGF4aXNJZHggPSAwO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PSBcInkyXCIpIHtcbiAgICAgIGF4aXNJZHggPSAxO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PSBcInhcIikge1xuICAgICAgYXhpc0lkeCA9IC0xOyAvLyBzaW1wbHkgYSBwbGFjZWhvbGRlciBmb3IgYmVsb3cuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IFwiVW5rbm93biBheGlzIFwiICsgYXhpcztcbiAgICB9XG4gICAgYXhpc1N0cmluZyA9IGF4aXM7XG4gIH1cblxuICB2YXIgdXNlckF4aXMgPSAoYXhpc0lkeCA9PSAtMSkgPyB0aGlzLnhBeGlzXyA6IHRoaXMueUF4ZXNfW2F4aXNJZHhdO1xuXG4gIC8vIFNlYXJjaCB0aGUgdXNlci1zcGVjaWZpZWQgYXhpcyBvcHRpb24gZmlyc3QuXG4gIGlmICh1c2VyQXhpcykgeyAvLyBUaGlzIGNvbmRpdGlvbiBjb3VsZCBiZSByZW1vdmVkIGlmIHdlIGFsd2F5cyBzZXQgdXAgdGhpcy55QXhlc18gZm9yIHkyLlxuICAgIHZhciBheGlzT3B0aW9ucyA9IHVzZXJBeGlzLm9wdGlvbnM7XG4gICAgaWYgKGF4aXNPcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gYXhpc09wdGlvbnNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlci1zcGVjaWZpZWQgZ2xvYmFsIG9wdGlvbnMgc2Vjb25kLlxuICAvLyBCdXQsIGhhY2ssIGlnbm9yZSBnbG9iYWxseS1zcGVjaWZpZWQgJ2xvZ3NjYWxlJyBmb3IgJ3gnIGF4aXMgZGVjbGFyYXRpb24uXG4gIGlmICghKGF4aXMgPT09ICd4JyAmJiBuYW1lID09PSAnbG9nc2NhbGUnKSkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmdldEdsb2JhbFVzZXJfKG5hbWUpO1xuICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIC8vIERlZmF1bHQgYXhpcyBvcHRpb25zIHRoaXJkLlxuICB2YXIgZGVmYXVsdEF4aXNPcHRpb25zID0gREVGQVVMVF9BVFRSUy5heGVzW2F4aXNTdHJpbmddO1xuICBpZiAoZGVmYXVsdEF4aXNPcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRBeGlzT3B0aW9uc1tuYW1lXTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgZ2xvYmFsIG9wdGlvbnMgbGFzdC5cbiAgcmV0dXJuIHRoaXMuZ2V0R2xvYmFsRGVmYXVsdF8obmFtZSk7XG59O1xuXG4vKipcbiAqIEdldCBhIHZhbHVlIGZvciBhIHNwZWNpZmljIHNlcmllcy4gSWYgdGhlcmUgaXMgbm8gc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBzZXJpZXMsXG4gKiB0aGUgdmFsdWUgZm9yIHRoZSBheGlzIGlzIHJldHVybmVkIChhbmQgYWZ0ZXJ3YXJkcywgdGhlIGdsb2JhbCB2YWx1ZS4pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIG9wdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZXJpZXMgdGhlIHNlcmllcyB0byBzZWFyY2guXG4gKi9cbkR5Z3JhcGhPcHRpb25zLnByb3RvdHlwZS5nZXRGb3JTZXJpZXMgPSBmdW5jdGlvbihuYW1lLCBzZXJpZXMpIHtcbiAgLy8gSG9ub3JzIGluZGV4ZXMgYXMgc2VyaWVzLlxuICBpZiAoc2VyaWVzID09PSB0aGlzLmR5Z3JhcGhfLmdldEhpZ2hsaWdodFNlcmllcygpKSB7XG4gICAgaWYgKHRoaXMuaGlnaGxpZ2h0U2VyaWVzXy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGlnaGxpZ2h0U2VyaWVzX1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRoaXMuc2VyaWVzXy5oYXNPd25Qcm9wZXJ0eShzZXJpZXMpKSB7XG4gICAgdGhyb3cgXCJVbmtub3duIHNlcmllczogXCIgKyBzZXJpZXM7XG4gIH1cblxuICB2YXIgc2VyaWVzT2JqID0gdGhpcy5zZXJpZXNfW3Nlcmllc107XG4gIHZhciBzZXJpZXNPcHRpb25zID0gc2VyaWVzT2JqW1wib3B0aW9uc1wiXTtcbiAgaWYgKHNlcmllc09wdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gc2VyaWVzT3B0aW9uc1tuYW1lXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmdldEZvckF4aXMobmFtZSwgc2VyaWVzT2JqW1wieUF4aXNcIl0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgeS1heGVzIG9uIHRoZSBjaGFydC5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIG51bWJlciBvZiBheGVzLlxuICovXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUubnVtQXhlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy55QXhlc18ubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHktYXhpcyBmb3IgYSBnaXZlbiBzZXJpZXMsIHNwZWNpZmllZCBieSBuYW1lLlxuICovXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUuYXhpc0ZvclNlcmllcyA9IGZ1bmN0aW9uKHNlcmllcykge1xuICByZXR1cm4gdGhpcy5zZXJpZXNfW3Nlcmllc10ueUF4aXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9wdGlvbnMgZm9yIHRoZSBzcGVjaWZpZWQgYXhpcy5cbiAqL1xuLy8gVE9ETyhrb25pZ3NiZXJnKTogdGhpcyBpcyB5LWF4aXMgc3BlY2lmaWMuIFN1cHBvcnQgdGhlIHggYXhpcy5cbkR5Z3JhcGhPcHRpb25zLnByb3RvdHlwZS5heGlzT3B0aW9ucyA9IGZ1bmN0aW9uKHlBeGlzKSB7XG4gIHJldHVybiB0aGlzLnlBeGVzX1t5QXhpc10ub3B0aW9ucztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzZXJpZXMgYXNzb2NpYXRlZCB3aXRoIGFuIGF4aXMuXG4gKi9cbkR5Z3JhcGhPcHRpb25zLnByb3RvdHlwZS5zZXJpZXNGb3JBeGlzID0gZnVuY3Rpb24oeUF4aXMpIHtcbiAgcmV0dXJuIHRoaXMueUF4ZXNfW3lBeGlzXS5zZXJpZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdCBvZiBhbGwgc2VyaWVzLCBpbiB0aGVpciBjb2x1bW5hciBvcmRlci5cbiAqL1xuRHlncmFwaE9wdGlvbnMucHJvdG90eXBlLnNlcmllc05hbWVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmxhYmVsc187XG59O1xuXG4vLyBGb3IgXCJwcm9kdWN0aW9uXCIgY29kZSwgdGhpcyBnZXRzIHJlbW92ZWQgYnkgdWdsaWZ5anMuXG5pZiAodHlwZW9mKHByb2Nlc3MpICE9PSAndW5kZWZpbmVkJykge1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9ICdwcm9kdWN0aW9uJykge1xuXG4vKipcbiAqIFZhbGlkYXRlIGFsbCBvcHRpb25zLlxuICogVGhpcyByZXF1aXJlcyBPUFRJT05TX1JFRkVSRU5DRSwgd2hpY2ggaXMgb25seSBhdmFpbGFibGUgaW4gZGVidWcgYnVpbGRzLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaE9wdGlvbnMucHJvdG90eXBlLnZhbGlkYXRlT3B0aW9uc18gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiBPUFRJT05TX1JFRkVSRU5DRSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyAnQ2FsbGVkIHZhbGlkYXRlT3B0aW9uc18gaW4gcHJvZCBidWlsZC4nO1xuICB9XG5cbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB2YXIgdmFsaWRhdGVPcHRpb24gPSBmdW5jdGlvbihvcHRpb25OYW1lKSB7XG4gICAgaWYgKCFPUFRJT05TX1JFRkVSRU5DRVtvcHRpb25OYW1lXSkge1xuICAgICAgdGhhdC53YXJuSW52YWxpZE9wdGlvbl8ob3B0aW9uTmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBvcHRpb25zRGljdHMgPSBbdGhpcy54QXhpc18ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnlBeGVzX1swXS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMueUF4ZXNfWzFdICYmIHRoaXMueUF4ZXNfWzFdLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxfLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlcl8sXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRTZXJpZXNfXTtcbiAgdmFyIG5hbWVzID0gdGhpcy5zZXJpZXNOYW1lcygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICBpZiAodGhpcy5zZXJpZXNfLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBvcHRpb25zRGljdHMucHVzaCh0aGlzLnNlcmllc19bbmFtZV0ub3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9uc0RpY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpY3QgPSBvcHRpb25zRGljdHNbaV07XG4gICAgaWYgKCFkaWN0KSBjb250aW51ZTtcbiAgICBmb3IgKHZhciBvcHRpb25OYW1lIGluIGRpY3QpIHtcbiAgICAgIGlmIChkaWN0Lmhhc093blByb3BlcnR5KG9wdGlvbk5hbWUpKSB7XG4gICAgICAgIHZhbGlkYXRlT3B0aW9uKG9wdGlvbk5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIFdBUk5JTkdTID0ge307ICAvLyBPbmx5IHNob3cgYW55IHBhcnRpY3VsYXIgd2FybmluZyBvbmNlLlxuXG4vKipcbiAqIExvZ3MgYSB3YXJuaW5nIGFib3V0IGludmFsaWQgb3B0aW9ucy5cbiAqIFRPRE86IG1ha2UgdGhpcyB0aHJvdyBmb3IgdGVzdGluZ1xuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaE9wdGlvbnMucHJvdG90eXBlLndhcm5JbnZhbGlkT3B0aW9uXyA9IGZ1bmN0aW9uKG9wdGlvbk5hbWUpIHtcbiAgaWYgKCFXQVJOSU5HU1tvcHRpb25OYW1lXSkge1xuICAgIFdBUk5JTkdTW29wdGlvbk5hbWVdID0gdHJ1ZTtcbiAgICB2YXIgaXNTZXJpZXMgPSAodGhpcy5sYWJlbHNfLmluZGV4T2Yob3B0aW9uTmFtZSkgPj0gMCk7XG4gICAgaWYgKGlzU2VyaWVzKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1VzZSBuZXctc3R5bGUgcGVyLXNlcmllcyBvcHRpb25zIChzYXcgJyArIG9wdGlvbk5hbWUgKyAnIGFzIHRvcC1sZXZlbCBvcHRpb25zIGtleSkuIFNlZSBodHRwOi8vYml0Lmx5LzF0Y2VhSnMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdVbmtub3duIG9wdGlvbiAnICsgb3B0aW9uTmFtZSArICcgKGZ1bGwgbGlzdCBvZiBvcHRpb25zIGF0IGR5Z3JhcGhzLmNvbS9vcHRpb25zLmh0bWwnKTtcbiAgICB9XG4gICAgdGhyb3cgXCJpbnZhbGlkIG9wdGlvbiBcIiArIG9wdGlvbk5hbWU7XG4gIH1cbn07XG5cbi8vIFJlc2V0IGxpc3Qgb2YgcHJldmlvdXNseS1zaG93biB3YXJuaW5ncy4gVXNlZCBmb3IgdGVzdGluZy5cbkR5Z3JhcGhPcHRpb25zLnJlc2V0V2FybmluZ3NfID0gZnVuY3Rpb24oKSB7XG4gIFdBUk5JTkdTID0ge307XG59O1xuXG59XG59XG5cbmV4cG9ydCBkZWZhdWx0IER5Z3JhcGhPcHRpb25zO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9keWdyYXBocy9zcmMvZHlncmFwaC1vcHRpb25zLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///28\n");

/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/*global Dygraph:false */\n\n\n\n/**\nCurrent bits of jankiness:\n- Uses dygraph.layout_ to get the parsed annotations.\n- Uses dygraph.plotter_.area\n\nIt would be nice if the plugin didn't require so much special support inside\nthe core dygraphs classes, but annotations involve quite a bit of parsing and\nlayout.\n\nTODO(danvk): cache DOM elements.\n*/\n\nvar annotations = function annotations() {\n  this.annotations_ = [];\n};\n\nannotations.prototype.toString = function () {\n  return \"Annotations Plugin\";\n};\n\nannotations.prototype.activate = function (g) {\n  return {\n    clearChart: this.clearChart,\n    didDrawChart: this.didDrawChart\n  };\n};\n\nannotations.prototype.detachLabels = function () {\n  for (var i = 0; i < this.annotations_.length; i++) {\n    var a = this.annotations_[i];\n    if (a.parentNode) a.parentNode.removeChild(a);\n    this.annotations_[i] = null;\n  }\n  this.annotations_ = [];\n};\n\nannotations.prototype.clearChart = function (e) {\n  this.detachLabels();\n};\n\nannotations.prototype.didDrawChart = function (e) {\n  var g = e.dygraph;\n\n  // Early out in the (common) case of zero annotations.\n  var points = g.layout_.annotated_points;\n  if (!points || points.length === 0) return;\n\n  var containerDiv = e.canvas.parentNode;\n\n  var bindEvt = function bindEvt(eventName, classEventName, pt) {\n    return function (annotation_event) {\n      var a = pt.annotation;\n      if (a.hasOwnProperty(eventName)) {\n        a[eventName](a, pt, g, annotation_event);\n      } else if (g.getOption(classEventName)) {\n        g.getOption(classEventName)(a, pt, g, annotation_event);\n      }\n    };\n  };\n\n  // Add the annotations one-by-one.\n  var area = e.dygraph.getArea();\n\n  // x-coord to sum of previous annotation's heights (used for stacking).\n  var xToUsedHeight = {};\n\n  for (var i = 0; i < points.length; i++) {\n    var p = points[i];\n    if (p.canvasx < area.x || p.canvasx > area.x + area.w || p.canvasy < area.y || p.canvasy > area.y + area.h) {\n      continue;\n    }\n\n    var a = p.annotation;\n    var tick_height = 6;\n    if (a.hasOwnProperty(\"tickHeight\")) {\n      tick_height = a.tickHeight;\n    }\n\n    // TODO: deprecate axisLabelFontSize in favor of CSS\n    var div = document.createElement(\"div\");\n    div.style['fontSize'] = g.getOption('axisLabelFontSize') + \"px\";\n    var className = 'dygraph-annotation';\n    if (!a.hasOwnProperty('icon')) {\n      // camelCase class names are deprecated.\n      className += ' dygraphDefaultAnnotation dygraph-default-annotation';\n    }\n    if (a.hasOwnProperty('cssClass')) {\n      className += \" \" + a.cssClass;\n    }\n    div.className = className;\n\n    var width = a.hasOwnProperty('width') ? a.width : 16;\n    var height = a.hasOwnProperty('height') ? a.height : 16;\n    if (a.hasOwnProperty('icon')) {\n      var img = document.createElement(\"img\");\n      img.src = a.icon;\n      img.width = width;\n      img.height = height;\n      div.appendChild(img);\n    } else if (p.annotation.hasOwnProperty('shortText')) {\n      div.appendChild(document.createTextNode(p.annotation.shortText));\n    }\n    var left = p.canvasx - width / 2;\n    div.style.left = left + \"px\";\n    var divTop = 0;\n    if (a.attachAtBottom) {\n      var y = area.y + area.h - height - tick_height;\n      if (xToUsedHeight[left]) {\n        y -= xToUsedHeight[left];\n      } else {\n        xToUsedHeight[left] = 0;\n      }\n      xToUsedHeight[left] += tick_height + height;\n      divTop = y;\n    } else {\n      divTop = p.canvasy - height - tick_height;\n    }\n    div.style.top = divTop + \"px\";\n    div.style.width = width + \"px\";\n    div.style.height = height + \"px\";\n    div.title = p.annotation.text;\n    div.style.color = g.colorsMap_[p.name];\n    div.style.borderColor = g.colorsMap_[p.name];\n    a.div = div;\n\n    g.addAndTrackEvent(div, 'click', bindEvt('clickHandler', 'annotationClickHandler', p, this));\n    g.addAndTrackEvent(div, 'mouseover', bindEvt('mouseOverHandler', 'annotationMouseOverHandler', p, this));\n    g.addAndTrackEvent(div, 'mouseout', bindEvt('mouseOutHandler', 'annotationMouseOutHandler', p, this));\n    g.addAndTrackEvent(div, 'dblclick', bindEvt('dblClickHandler', 'annotationDblClickHandler', p, this));\n\n    containerDiv.appendChild(div);\n    this.annotations_.push(div);\n\n    var ctx = e.drawingContext;\n    ctx.save();\n    ctx.strokeStyle = a.hasOwnProperty('tickColor') ? a.tickColor : g.colorsMap_[p.name];\n    ctx.lineWidth = a.hasOwnProperty('tickWidth') ? a.tickWidth : g.getOption('strokeWidth');\n    ctx.beginPath();\n    if (!a.attachAtBottom) {\n      ctx.moveTo(p.canvasx, p.canvasy);\n      ctx.lineTo(p.canvasx, p.canvasy - 2 - tick_height);\n    } else {\n      var y = divTop + height;\n      ctx.moveTo(p.canvasx, y);\n      ctx.lineTo(p.canvasx, y + tick_height);\n    }\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n  }\n};\n\nannotations.prototype.destroy = function () {\n  this.detachLabels();\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (annotations);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL2Fubm90YXRpb25zLmpzPzY1ZTYiXSwibmFtZXMiOlsiYW5ub3RhdGlvbnMiLCJhbm5vdGF0aW9uc18iLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImFjdGl2YXRlIiwiZyIsImNsZWFyQ2hhcnQiLCJkaWREcmF3Q2hhcnQiLCJkZXRhY2hMYWJlbHMiLCJpIiwibGVuZ3RoIiwiYSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImUiLCJkeWdyYXBoIiwicG9pbnRzIiwibGF5b3V0XyIsImFubm90YXRlZF9wb2ludHMiLCJjb250YWluZXJEaXYiLCJjYW52YXMiLCJiaW5kRXZ0IiwiZXZlbnROYW1lIiwiY2xhc3NFdmVudE5hbWUiLCJwdCIsImFubm90YXRpb25fZXZlbnQiLCJhbm5vdGF0aW9uIiwiaGFzT3duUHJvcGVydHkiLCJnZXRPcHRpb24iLCJhcmVhIiwiZ2V0QXJlYSIsInhUb1VzZWRIZWlnaHQiLCJwIiwiY2FudmFzeCIsIngiLCJ3IiwiY2FudmFzeSIsInkiLCJoIiwidGlja19oZWlnaHQiLCJ0aWNrSGVpZ2h0IiwiZGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJjbGFzc05hbWUiLCJjc3NDbGFzcyIsIndpZHRoIiwiaGVpZ2h0IiwiaW1nIiwic3JjIiwiaWNvbiIsImFwcGVuZENoaWxkIiwiY3JlYXRlVGV4dE5vZGUiLCJzaG9ydFRleHQiLCJsZWZ0IiwiZGl2VG9wIiwiYXR0YWNoQXRCb3R0b20iLCJ0b3AiLCJ0aXRsZSIsInRleHQiLCJjb2xvciIsImNvbG9yc01hcF8iLCJuYW1lIiwiYm9yZGVyQ29sb3IiLCJhZGRBbmRUcmFja0V2ZW50IiwicHVzaCIsImN0eCIsImRyYXdpbmdDb250ZXh0Iiwic2F2ZSIsInN0cm9rZVN0eWxlIiwidGlja0NvbG9yIiwibGluZVdpZHRoIiwidGlja1dpZHRoIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRv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QUFKLENBQVc1QyxFQUFFQyxPQUFiLEVBQXNCRCxFQUFFSSxPQUFGLEdBQVksQ0FBWixHQUFnQkcsV0FBdEM7QUFDRCxLQUhELE1BR087QUFDTCxVQUFJRixJQUFJbUIsU0FBU1IsTUFBakI7QUFDQW1CLFVBQUlRLE1BQUosQ0FBVzNDLEVBQUVDLE9BQWIsRUFBc0JJLENBQXRCO0FBQ0E4QixVQUFJUyxNQUFKLENBQVc1QyxFQUFFQyxPQUFiLEVBQXNCSSxJQUFJRSxXQUExQjtBQUNEO0FBQ0Q0QixRQUFJVSxTQUFKO0FBQ0FWLFFBQUlXLE1BQUo7QUFDQVgsUUFBSVksT0FBSjtBQUNEO0FBQ0YsQ0FuSEQ7O0FBcUhBL0UsWUFBWUUsU0FBWixDQUFzQjhFLE9BQXRCLEdBQWdDLFlBQVc7QUFDekMsT0FBS3hFLFlBQUw7QUFDRCxDQUZEOztBQUlBLHlEQUFlUixXQUFmIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTIgRGFuIFZhbmRlcmthbSAoZGFudmRrQGdtYWlsLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbkN1cnJlbnQgYml0cyBvZiBqYW5raW5lc3M6XG4tIFVzZXMgZHlncmFwaC5sYXlvdXRfIHRvIGdldCB0aGUgcGFyc2VkIGFubm90YXRpb25zLlxuLSBVc2VzIGR5Z3JhcGgucGxvdHRlcl8uYXJlYVxuXG5JdCB3b3VsZCBiZSBuaWNlIGlmIHRoZSBwbHVnaW4gZGlkbid0IHJlcXVpcmUgc28gbXVjaCBzcGVjaWFsIHN1cHBvcnQgaW5zaWRlXG50aGUgY29yZSBkeWdyYXBocyBjbGFzc2VzLCBidXQgYW5ub3RhdGlvbnMgaW52b2x2ZSBxdWl0ZSBhIGJpdCBvZiBwYXJzaW5nIGFuZFxubGF5b3V0LlxuXG5UT0RPKGRhbnZrKTogY2FjaGUgRE9NIGVsZW1lbnRzLlxuKi9cblxudmFyIGFubm90YXRpb25zID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYW5ub3RhdGlvbnNfID0gW107XG59O1xuXG5hbm5vdGF0aW9ucy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFwiQW5ub3RhdGlvbnMgUGx1Z2luXCI7XG59O1xuXG5hbm5vdGF0aW9ucy5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbihnKSB7XG4gIHJldHVybiB7XG4gICAgY2xlYXJDaGFydDogdGhpcy5jbGVhckNoYXJ0LFxuICAgIGRpZERyYXdDaGFydDogdGhpcy5kaWREcmF3Q2hhcnRcbiAgfTtcbn07XG5cbmFubm90YXRpb25zLnByb3RvdHlwZS5kZXRhY2hMYWJlbHMgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFubm90YXRpb25zXy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhID0gdGhpcy5hbm5vdGF0aW9uc19baV07XG4gICAgaWYgKGEucGFyZW50Tm9kZSkgYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpO1xuICAgIHRoaXMuYW5ub3RhdGlvbnNfW2ldID0gbnVsbDtcbiAgfVxuICB0aGlzLmFubm90YXRpb25zXyA9IFtdO1xufTtcblxuYW5ub3RhdGlvbnMucHJvdG90eXBlLmNsZWFyQ2hhcnQgPSBmdW5jdGlvbihlKSB7XG4gIHRoaXMuZGV0YWNoTGFiZWxzKCk7XG59O1xuXG5hbm5vdGF0aW9ucy5wcm90b3R5cGUuZGlkRHJhd0NoYXJ0ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgZyA9IGUuZHlncmFwaDtcblxuICAvLyBFYXJseSBvdXQgaW4gdGhlIChjb21tb24pIGNhc2Ugb2YgemVybyBhbm5vdGF0aW9ucy5cbiAgdmFyIHBvaW50cyA9IGcubGF5b3V0Xy5hbm5vdGF0ZWRfcG9pbnRzO1xuICBpZiAoIXBvaW50cyB8fCBwb2ludHMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgdmFyIGNvbnRhaW5lckRpdiA9IGUuY2FudmFzLnBhcmVudE5vZGU7XG5cbiAgdmFyIGJpbmRFdnQgPSBmdW5jdGlvbihldmVudE5hbWUsIGNsYXNzRXZlbnROYW1lLCBwdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihhbm5vdGF0aW9uX2V2ZW50KSB7XG4gICAgICB2YXIgYSA9IHB0LmFubm90YXRpb247XG4gICAgICBpZiAoYS5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgIGFbZXZlbnROYW1lXShhLCBwdCwgZywgYW5ub3RhdGlvbl9ldmVudCk7XG4gICAgICB9IGVsc2UgaWYgKGcuZ2V0T3B0aW9uKGNsYXNzRXZlbnROYW1lKSkge1xuICAgICAgICBnLmdldE9wdGlvbihjbGFzc0V2ZW50TmFtZSkoYSwgcHQsIGcsIGFubm90YXRpb25fZXZlbnQgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIEFkZCB0aGUgYW5ub3RhdGlvbnMgb25lLWJ5LW9uZS5cbiAgdmFyIGFyZWEgPSBlLmR5Z3JhcGguZ2V0QXJlYSgpO1xuXG4gIC8vIHgtY29vcmQgdG8gc3VtIG9mIHByZXZpb3VzIGFubm90YXRpb24ncyBoZWlnaHRzICh1c2VkIGZvciBzdGFja2luZykuXG4gIHZhciB4VG9Vc2VkSGVpZ2h0ID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICBpZiAocC5jYW52YXN4IDwgYXJlYS54IHx8IHAuY2FudmFzeCA+IGFyZWEueCArIGFyZWEudyB8fFxuICAgICAgICBwLmNhbnZhc3kgPCBhcmVhLnkgfHwgcC5jYW52YXN5ID4gYXJlYS55ICsgYXJlYS5oKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IHAuYW5ub3RhdGlvbjtcbiAgICB2YXIgdGlja19oZWlnaHQgPSA2O1xuICAgIGlmIChhLmhhc093blByb3BlcnR5KFwidGlja0hlaWdodFwiKSkge1xuICAgICAgdGlja19oZWlnaHQgPSBhLnRpY2tIZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogZGVwcmVjYXRlIGF4aXNMYWJlbEZvbnRTaXplIGluIGZhdm9yIG9mIENTU1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5zdHlsZVsnZm9udFNpemUnXSA9IGcuZ2V0T3B0aW9uKCdheGlzTGFiZWxGb250U2l6ZScpICsgXCJweFwiO1xuICAgIHZhciBjbGFzc05hbWUgPSAnZHlncmFwaC1hbm5vdGF0aW9uJztcbiAgICBpZiAoIWEuaGFzT3duUHJvcGVydHkoJ2ljb24nKSkge1xuICAgICAgLy8gY2FtZWxDYXNlIGNsYXNzIG5hbWVzIGFyZSBkZXByZWNhdGVkLlxuICAgICAgY2xhc3NOYW1lICs9ICcgZHlncmFwaERlZmF1bHRBbm5vdGF0aW9uIGR5Z3JhcGgtZGVmYXVsdC1hbm5vdGF0aW9uJztcbiAgICB9XG4gICAgaWYgKGEuaGFzT3duUHJvcGVydHkoJ2Nzc0NsYXNzJykpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBcIiArIGEuY3NzQ2xhc3M7XG4gICAgfVxuICAgIGRpdi5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG5cbiAgICB2YXIgd2lkdGggPSBhLmhhc093blByb3BlcnR5KCd3aWR0aCcpID8gYS53aWR0aCA6IDE2O1xuICAgIHZhciBoZWlnaHQgPSBhLmhhc093blByb3BlcnR5KCdoZWlnaHQnKSA/IGEuaGVpZ2h0IDogMTY7XG4gICAgaWYgKGEuaGFzT3duUHJvcGVydHkoJ2ljb24nKSkge1xuICAgICAgdmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICBpbWcuc3JjID0gYS5pY29uO1xuICAgICAgaW1nLndpZHRoID0gd2lkdGg7XG4gICAgICBpbWcuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgZGl2LmFwcGVuZENoaWxkKGltZyk7XG4gICAgfSBlbHNlIGlmIChwLmFubm90YXRpb24uaGFzT3duUHJvcGVydHkoJ3Nob3J0VGV4dCcpKSB7XG4gICAgICBkaXYuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocC5hbm5vdGF0aW9uLnNob3J0VGV4dCkpO1xuICAgIH1cbiAgICB2YXIgbGVmdCA9IHAuY2FudmFzeCAtIHdpZHRoIC8gMjtcbiAgICBkaXYuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgdmFyIGRpdlRvcCA9IDA7XG4gICAgaWYgKGEuYXR0YWNoQXRCb3R0b20pIHtcbiAgICAgIHZhciB5ID0gKGFyZWEueSArIGFyZWEuaCAtIGhlaWdodCAtIHRpY2tfaGVpZ2h0KTtcbiAgICAgIGlmICh4VG9Vc2VkSGVpZ2h0W2xlZnRdKSB7XG4gICAgICAgIHkgLT0geFRvVXNlZEhlaWdodFtsZWZ0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhUb1VzZWRIZWlnaHRbbGVmdF0gPSAwO1xuICAgICAgfVxuICAgICAgeFRvVXNlZEhlaWdodFtsZWZ0XSArPSAodGlja19oZWlnaHQgKyBoZWlnaHQpO1xuICAgICAgZGl2VG9wID0geTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGl2VG9wID0gcC5jYW52YXN5IC0gaGVpZ2h0IC0gdGlja19oZWlnaHQ7XG4gICAgfVxuICAgIGRpdi5zdHlsZS50b3AgPSBkaXZUb3AgKyBcInB4XCI7XG4gICAgZGl2LnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgZGl2LnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICBkaXYudGl0bGUgPSBwLmFubm90YXRpb24udGV4dDtcbiAgICBkaXYuc3R5bGUuY29sb3IgPSBnLmNvbG9yc01hcF9bcC5uYW1lXTtcbiAgICBkaXYuc3R5bGUuYm9yZGVyQ29sb3IgPSBnLmNvbG9yc01hcF9bcC5uYW1lXTtcbiAgICBhLmRpdiA9IGRpdjtcblxuICAgIGcuYWRkQW5kVHJhY2tFdmVudChkaXYsICdjbGljaycsXG4gICAgICAgIGJpbmRFdnQoJ2NsaWNrSGFuZGxlcicsICdhbm5vdGF0aW9uQ2xpY2tIYW5kbGVyJywgcCwgdGhpcykpO1xuICAgIGcuYWRkQW5kVHJhY2tFdmVudChkaXYsICdtb3VzZW92ZXInLFxuICAgICAgICBiaW5kRXZ0KCdtb3VzZU92ZXJIYW5kbGVyJywgJ2Fubm90YXRpb25Nb3VzZU92ZXJIYW5kbGVyJywgcCwgdGhpcykpO1xuICAgIGcuYWRkQW5kVHJhY2tFdmVudChkaXYsICdtb3VzZW91dCcsXG4gICAgICAgIGJpbmRFdnQoJ21vdXNlT3V0SGFuZGxlcicsICdhbm5vdGF0aW9uTW91c2VPdXRIYW5kbGVyJywgcCwgdGhpcykpO1xuICAgIGcuYWRkQW5kVHJhY2tFdmVudChkaXYsICdkYmxjbGljaycsXG4gICAgICAgIGJpbmRFdnQoJ2RibENsaWNrSGFuZGxlcicsICdhbm5vdGF0aW9uRGJsQ2xpY2tIYW5kbGVyJywgcCwgdGhpcykpO1xuXG4gICAgY29udGFpbmVyRGl2LmFwcGVuZENoaWxkKGRpdik7XG4gICAgdGhpcy5hbm5vdGF0aW9uc18ucHVzaChkaXYpO1xuXG4gICAgdmFyIGN0eCA9IGUuZHJhd2luZ0NvbnRleHQ7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBhLmhhc093blByb3BlcnR5KCd0aWNrQ29sb3InKSA/IGEudGlja0NvbG9yIDogZy5jb2xvcnNNYXBfW3AubmFtZV07XG4gICAgY3R4LmxpbmVXaWR0aCA9IGEuaGFzT3duUHJvcGVydHkoJ3RpY2tXaWR0aCcpID8gYS50aWNrV2lkdGggOiBnLmdldE9wdGlvbignc3Ryb2tlV2lkdGgnKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgaWYgKCFhLmF0dGFjaEF0Qm90dG9tKSB7XG4gICAgICBjdHgubW92ZVRvKHAuY2FudmFzeCwgcC5jYW52YXN5KTtcbiAgICAgIGN0eC5saW5lVG8ocC5jYW52YXN4LCBwLmNhbnZhc3kgLSAyIC0gdGlja19oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeSA9IGRpdlRvcCArIGhlaWdodDtcbiAgICAgIGN0eC5tb3ZlVG8ocC5jYW52YXN4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8ocC5jYW52YXN4LCB5ICsgdGlja19oZWlnaHQpO1xuICAgIH1cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn07XG5cbmFubm90YXRpb25zLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGV0YWNoTGFiZWxzKCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBhbm5vdGF0aW9ucztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZHlncmFwaHMvc3JjL3BsdWdpbnMvYW5ub3RhdGlvbnMuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///29\n");

/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__ = __webpack_require__(8);\n/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/*global Dygraph:false */\n\n\n\n/*\nBits of jankiness:\n- Direct layout access\n- Direct area access\n- Should include calculation of ticks, not just the drawing.\n\nOptions left to make axis-friendly.\n  ('drawAxesAtZero')\n  ('xAxisHeight')\n*/\n\n\n\n/**\n * Draws the axes. This includes the labels on the x- and y-axes, as well\n * as the tick marks on the axes.\n * It does _not_ draw the grid lines which span the entire chart.\n */\nvar axes = function axes() {\n  this.xlabels_ = [];\n  this.ylabels_ = [];\n};\n\naxes.prototype.toString = function () {\n  return 'Axes Plugin';\n};\n\naxes.prototype.activate = function (g) {\n  return {\n    layout: this.layout,\n    clearChart: this.clearChart,\n    willDrawChart: this.willDrawChart\n  };\n};\n\naxes.prototype.layout = function (e) {\n  var g = e.dygraph;\n\n  if (g.getOptionForAxis('drawAxis', 'y')) {\n    var w = g.getOptionForAxis('axisLabelWidth', 'y') + 2 * g.getOptionForAxis('axisTickSize', 'y');\n    e.reserveSpaceLeft(w);\n  }\n\n  if (g.getOptionForAxis('drawAxis', 'x')) {\n    var h;\n    // NOTE: I think this is probably broken now, since g.getOption() now\n    // hits the dictionary. (That is, g.getOption('xAxisHeight') now always\n    // has a value.)\n    if (g.getOption('xAxisHeight')) {\n      h = g.getOption('xAxisHeight');\n    } else {\n      h = g.getOptionForAxis('axisLabelFontSize', 'x') + 2 * g.getOptionForAxis('axisTickSize', 'x');\n    }\n    e.reserveSpaceBottom(h);\n  }\n\n  if (g.numAxes() == 2) {\n    if (g.getOptionForAxis('drawAxis', 'y2')) {\n      var w = g.getOptionForAxis('axisLabelWidth', 'y2') + 2 * g.getOptionForAxis('axisTickSize', 'y2');\n      e.reserveSpaceRight(w);\n    }\n  } else if (g.numAxes() > 2) {\n    g.error('Only two y-axes are supported at this time. (Trying ' + 'to use ' + g.numAxes() + ')');\n  }\n};\n\naxes.prototype.detachLabels = function () {\n  function removeArray(ary) {\n    for (var i = 0; i < ary.length; i++) {\n      var el = ary[i];\n      if (el.parentNode) el.parentNode.removeChild(el);\n    }\n  }\n\n  removeArray(this.xlabels_);\n  removeArray(this.ylabels_);\n  this.xlabels_ = [];\n  this.ylabels_ = [];\n};\n\naxes.prototype.clearChart = function (e) {\n  this.detachLabels();\n};\n\naxes.prototype.willDrawChart = function (e) {\n  var _this = this;\n\n  var g = e.dygraph;\n\n  if (!g.getOptionForAxis('drawAxis', 'x') && !g.getOptionForAxis('drawAxis', 'y') && !g.getOptionForAxis('drawAxis', 'y2')) {\n    return;\n  }\n\n  // Round pixels to half-integer boundaries for crisper drawing.\n  function halfUp(x) {\n    return Math.round(x) + 0.5;\n  }\n  function halfDown(y) {\n    return Math.round(y) - 0.5;\n  }\n\n  var context = e.drawingContext;\n  var containerDiv = e.canvas.parentNode;\n  var canvasWidth = g.width_; // e.canvas.width is affected by pixel ratio.\n  var canvasHeight = g.height_;\n\n  var label, x, y, tick, i;\n\n  var makeLabelStyle = function makeLabelStyle(axis) {\n    return {\n      position: 'absolute',\n      fontSize: g.getOptionForAxis('axisLabelFontSize', axis) + 'px',\n      width: g.getOptionForAxis('axisLabelWidth', axis) + 'px'\n    };\n  };\n\n  var labelStyles = {\n    x: makeLabelStyle('x'),\n    y: makeLabelStyle('y'),\n    y2: makeLabelStyle('y2')\n  };\n\n  var makeDiv = function makeDiv(txt, axis, prec_axis) {\n    /*\n     * This seems to be called with the following three sets of axis/prec_axis:\n     * x: undefined\n     * y: y1\n     * y: y2\n     */\n    var div = document.createElement('div');\n    var labelStyle = labelStyles[prec_axis == 'y2' ? 'y2' : axis];\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"a\" /* update */](div.style, labelStyle);\n    // TODO: combine outer & inner divs\n    var inner_div = document.createElement('div');\n    inner_div.className = 'dygraph-axis-label' + ' dygraph-axis-label-' + axis + (prec_axis ? ' dygraph-axis-label-' + prec_axis : '');\n    inner_div.innerHTML = txt;\n    div.appendChild(inner_div);\n    return div;\n  };\n\n  // axis lines\n  context.save();\n\n  var layout = g.layout_;\n  var area = e.dygraph.plotter_.area;\n\n  // Helper for repeated axis-option accesses.\n  var makeOptionGetter = function makeOptionGetter(axis) {\n    return function (option) {\n      return g.getOptionForAxis(option, axis);\n    };\n  };\n\n  if (g.getOptionForAxis('drawAxis', 'y')) {\n    if (layout.yticks && layout.yticks.length > 0) {\n      var num_axes = g.numAxes();\n      var getOptions = [makeOptionGetter('y'), makeOptionGetter('y2')];\n      layout.yticks.forEach(function (tick) {\n        if (tick.label === undefined) return; // this tick only has a grid line.\n        x = area.x;\n        var sgn = 1;\n        var prec_axis = 'y1';\n        var getAxisOption = getOptions[0];\n        if (tick.axis == 1) {\n          // right-side y-axis\n          x = area.x + area.w;\n          sgn = -1;\n          prec_axis = 'y2';\n          getAxisOption = getOptions[1];\n        }\n        var fontSize = getAxisOption('axisLabelFontSize');\n        y = area.y + tick.pos * area.h;\n\n        /* Tick marks are currently clipped, so don't bother drawing them.\n        context.beginPath();\n        context.moveTo(halfUp(x), halfDown(y));\n        context.lineTo(halfUp(x - sgn * this.attr_('axisTickSize')), halfDown(y));\n        context.closePath();\n        context.stroke();\n        */\n\n        label = makeDiv(tick.label, 'y', num_axes == 2 ? prec_axis : null);\n        var top = y - fontSize / 2;\n        if (top < 0) top = 0;\n\n        if (top + fontSize + 3 > canvasHeight) {\n          label.style.bottom = '0';\n        } else {\n          label.style.top = top + 'px';\n        }\n        // TODO: replace these with css classes?\n        if (tick.axis === 0) {\n          label.style.left = area.x - getAxisOption('axisLabelWidth') - getAxisOption('axisTickSize') + 'px';\n          label.style.textAlign = 'right';\n        } else if (tick.axis == 1) {\n          label.style.left = area.x + area.w + getAxisOption('axisTickSize') + 'px';\n          label.style.textAlign = 'left';\n        }\n        label.style.width = getAxisOption('axisLabelWidth') + 'px';\n        containerDiv.appendChild(label);\n        _this.ylabels_.push(label);\n      });\n\n      // The lowest tick on the y-axis often overlaps with the leftmost\n      // tick on the x-axis. Shift the bottom tick up a little bit to\n      // compensate if necessary.\n      var bottomTick = this.ylabels_[0];\n      // Interested in the y2 axis also?\n      var fontSize = g.getOptionForAxis('axisLabelFontSize', 'y');\n      var bottom = parseInt(bottomTick.style.top, 10) + fontSize;\n      if (bottom > canvasHeight - fontSize) {\n        bottomTick.style.top = parseInt(bottomTick.style.top, 10) - fontSize / 2 + 'px';\n      }\n    }\n\n    // draw a vertical line on the left to separate the chart from the labels.\n    var axisX;\n    if (g.getOption('drawAxesAtZero')) {\n      var r = g.toPercentXCoord(0);\n      if (r > 1 || r < 0 || isNaN(r)) r = 0;\n      axisX = halfUp(area.x + r * area.w);\n    } else {\n      axisX = halfUp(area.x);\n    }\n\n    context.strokeStyle = g.getOptionForAxis('axisLineColor', 'y');\n    context.lineWidth = g.getOptionForAxis('axisLineWidth', 'y');\n\n    context.beginPath();\n    context.moveTo(axisX, halfDown(area.y));\n    context.lineTo(axisX, halfDown(area.y + area.h));\n    context.closePath();\n    context.stroke();\n\n    // if there's a secondary y-axis, draw a vertical line for that, too.\n    if (g.numAxes() == 2) {\n      context.strokeStyle = g.getOptionForAxis('axisLineColor', 'y2');\n      context.lineWidth = g.getOptionForAxis('axisLineWidth', 'y2');\n      context.beginPath();\n      context.moveTo(halfDown(area.x + area.w), halfDown(area.y));\n      context.lineTo(halfDown(area.x + area.w), halfDown(area.y + area.h));\n      context.closePath();\n      context.stroke();\n    }\n  }\n\n  if (g.getOptionForAxis('drawAxis', 'x')) {\n    if (layout.xticks) {\n      var getAxisOption = makeOptionGetter('x');\n      layout.xticks.forEach(function (tick) {\n        if (tick.label === undefined) return; // this tick only has a grid line.\n        x = area.x + tick.pos * area.w;\n        y = area.y + area.h;\n\n        /* Tick marks are currently clipped, so don't bother drawing them.\n        context.beginPath();\n        context.moveTo(halfUp(x), halfDown(y));\n        context.lineTo(halfUp(x), halfDown(y + this.attr_('axisTickSize')));\n        context.closePath();\n        context.stroke();\n        */\n\n        label = makeDiv(tick.label, 'x');\n        label.style.textAlign = 'center';\n        label.style.top = y + getAxisOption('axisTickSize') + 'px';\n\n        var left = x - getAxisOption('axisLabelWidth') / 2;\n        if (left + getAxisOption('axisLabelWidth') > canvasWidth) {\n          left = canvasWidth - getAxisOption('axisLabelWidth');\n          label.style.textAlign = 'right';\n        }\n        if (left < 0) {\n          left = 0;\n          label.style.textAlign = 'left';\n        }\n\n        label.style.left = left + 'px';\n        label.style.width = getAxisOption('axisLabelWidth') + 'px';\n        containerDiv.appendChild(label);\n        _this.xlabels_.push(label);\n      });\n    }\n\n    context.strokeStyle = g.getOptionForAxis('axisLineColor', 'x');\n    context.lineWidth = g.getOptionForAxis('axisLineWidth', 'x');\n    context.beginPath();\n    var axisY;\n    if (g.getOption('drawAxesAtZero')) {\n      var r = g.toPercentYCoord(0, 0);\n      if (r > 1 || r < 0) r = 1;\n      axisY = halfDown(area.y + r * area.h);\n    } else {\n      axisY = halfDown(area.y + area.h);\n    }\n    context.moveTo(halfUp(area.x), axisY);\n    context.lineTo(halfUp(area.x + area.w), axisY);\n    context.closePath();\n    context.stroke();\n  }\n\n  context.restore();\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (axes);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL2F4ZXMuanM/OWQzMiJdLCJuYW1lcyI6WyJheGVzIiwieGxhYmVsc18iLCJ5bGFiZWxzXyIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiYWN0aXZhdGUiLCJnIiwibGF5b3V0IiwiY2xlYXJDaGFydCIsIndpbGxEcmF3Q2hhcnQiLCJlIiwiZHlncmFwaCIsImdldE9wdGlvbkZvckF4aXMiLCJ3IiwicmVzZXJ2ZVNwYWNlTGVmdCIsImgiLCJnZXRPcHRpb24iLCJyZXNlcnZlU3BhY2VCb3R0b20iLCJudW1BeGVzIiwicmVzZXJ2ZVNwYWNlUmlnaHQiLCJlcnJvciIsImRldGFjaExhYmVscyIsInJlbW92ZUFycmF5IiwiYXJ5IiwiaSIsImxlbmd0aCIsImVsIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiaGFsZlVwIiwieCIsIk1hdGgiLCJyb3VuZCIsImhhbGZEb3duIiwieSIsImNvbnRleHQiLCJkcmF3aW5nQ29udGV4dCIsImNvbnRhaW5lckRpdiIsImNhbnZhcyIsImNhbnZhc1dpZHRoIiwid2lkdGhfIiwiY2FudmFzSGVpZ2h0IiwiaGVpZ2h0XyIsImxhYmVsIiwidGljayIsIm1ha2VMYWJlbFN0eWxlIiwiYXhpcyIsInBvc2l0aW9uIiwiZm9udFNpemUiLCJ3aWR0aCIsImxhYmVsU3R5bGVzIiwieTIiLCJtYWtlRGl2IiwidHh0IiwicHJlY19heGlzIiwiZGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwibGFiZWxTdHlsZSIsInV0aWxzIiwic3R5bGUiLCJpbm5lcl9kaXYiLCJjbGFzc05hbWUiLCJpbm5lckhUTUwiLCJhcHBlbmRDaGlsZCIsInNhdmUiLCJsYXlvdXRfIiwiYXJlYSIsInBsb3R0ZXJfIiwibWFrZU9wdGlvbkdldHRlciIsIm9wdGlvbiIsInl0aWNrcyIsIm51bV9heGVzIiwiZ2V0T3B0aW9ucyIsImZvckVhY2giLCJ1bmRlZmluZWQiLCJzZ24iLCJnZXRBeGlzT3B0aW9uIiwicG9zIiwidG9wIiwiYm90dG9tIiwibGVmdCIsInRleHRBbGlnbiIsInB1c2giLCJib3R0b21UaWNrIiwicGFyc2VJbnQiLCJheGlzWCIsInIiLCJ0b1BlcmNlbnRYQ29vcmQiLCJpc05hTiIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwiY2xvc2VQYXRoIiwic3Ryb2tlIiwieHRpY2tzIiwiYXhpc1kiLCJ0b1BlcmNlbnRZQ29vcmQiLCJyZXN0b3JlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOzs7Ozs7QUFNQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQTs7Ozs7QUFLQSxJQUFJQSxPQUFPLFNBQVBBLElBQU8sR0FBVztBQUNwQixPQUFLQyxRQUFMLEdBQWdCLEVBQWhCO0FBQ0EsT0FBS0MsUUFBTCxHQUFnQixFQUFoQjtBQUNELENBSEQ7O0FBS0FGLEtBQUtHLFNBQUwsQ0FBZUMsUUFBZixHQUEwQixZQUFXO0FBQ25DLFNBQU8sYUFBUDtBQUNELENBRkQ7O0FBSUFKLEtBQUtHLFNBQUwsQ0FBZUUsUUFBZixHQUEwQixVQUFTQyxDQUFULEVBQVk7QUFDcEMsU0FBTztBQUNMQyxZQUFRLEtBQUtBLE1BRFI7QUFFTEMsZ0JBQVksS0FBS0EsVUFGWjtBQUdMQyxtQkFBZSxLQUFLQTtBQUhmLEdBQVA7QUFLRCxDQU5EOztBQVFBVCxLQUFLRyxTQUFMLENBQWVJLE1BQWYsR0FBd0IsVUFBU0csQ0FBVCxFQUFZO0FBQ2xDLE1BQUlKLElBQUlJLEVBQUVDLE9BQVY7O0FBRUEsTUFBSUwsRUFBRU0sZ0JBQUYsQ0FBbUIsVUFBbkIsRUFBK0IsR0FBL0IsQ0FBSixFQUF5QztBQUN2QyxRQUFJQyxJQUFJUCxFQUFFTSxnQkFBRixDQUFtQixnQkFBbkIsRUFBcUMsR0FBckMsSUFBNEMsSUFBSU4sRUFBRU0sZ0JBQUYsQ0FBbUIsY0FBbkIsRUFBbUMsR0FBbkMsQ0FBeEQ7QUFDQUYsTUFBRUksZ0JBQUYsQ0FBbUJELENBQW5C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RixDQUFZLGdCQUFaLENBQUosRUFBbUM7QUFDakMsVUFBSXVFLElBQUlqRixFQUFFNkYsZUFBRixDQUFrQixDQUFsQixFQUFxQixDQUFyQixDQUFSO0FBQ0EsVUFBSVosSUFBSSxDQUFKLElBQVNBLElBQUksQ0FBakIsRUFBb0JBLElBQUksQ0FBSjtBQUNwQlcsY0FBUWpFLFNBQVNrQyxLQUFLakMsQ0FBTCxHQUFTcUQsSUFBSXBCLEtBQUtwRCxDQUEzQixDQUFSO0FBQ0QsS0FKRCxNQUlPO0FBQ0xtRixjQUFRakUsU0FBU2tDLEtBQUtqQyxDQUFMLEdBQVNpQyxLQUFLcEQsQ0FBdkIsQ0FBUjtBQUNEO0FBQ0RvQixZQUFRMEQsTUFBUixDQUFlaEUsT0FBT3NDLEtBQUtyQyxDQUFaLENBQWYsRUFBK0JvRSxLQUEvQjtBQUNBL0QsWUFBUTJELE1BQVIsQ0FBZWpFLE9BQU9zQyxLQUFLckMsQ0FBTCxHQUFTcUMsS0FBS3RELENBQXJCLENBQWYsRUFBd0NxRixLQUF4QztBQUNBL0QsWUFBUTRELFNBQVI7QUFDQTVELFlBQVE2RCxNQUFSO0FBQ0Q7O0FBRUQ3RCxVQUFRaUUsT0FBUjtBQUNELENBeE5EOztBQTBOQSx5REFBZXBHLElBQWYiLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMiBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKlxuQml0cyBvZiBqYW5raW5lc3M6XG4tIERpcmVjdCBsYXlvdXQgYWNjZXNzXG4tIERpcmVjdCBhcmVhIGFjY2Vzc1xuLSBTaG91bGQgaW5jbHVkZSBjYWxjdWxhdGlvbiBvZiB0aWNrcywgbm90IGp1c3QgdGhlIGRyYXdpbmcuXG5cbk9wdGlvbnMgbGVmdCB0byBtYWtlIGF4aXMtZnJpZW5kbHkuXG4gICgnZHJhd0F4ZXNBdFplcm8nKVxuICAoJ3hBeGlzSGVpZ2h0JylcbiovXG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL2R5Z3JhcGgtdXRpbHMnO1xuXG4vKipcbiAqIERyYXdzIHRoZSBheGVzLiBUaGlzIGluY2x1ZGVzIHRoZSBsYWJlbHMgb24gdGhlIHgtIGFuZCB5LWF4ZXMsIGFzIHdlbGxcbiAqIGFzIHRoZSB0aWNrIG1hcmtzIG9uIHRoZSBheGVzLlxuICogSXQgZG9lcyBfbm90XyBkcmF3IHRoZSBncmlkIGxpbmVzIHdoaWNoIHNwYW4gdGhlIGVudGlyZSBjaGFydC5cbiAqL1xudmFyIGF4ZXMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy54bGFiZWxzXyA9IFtdO1xuICB0aGlzLnlsYWJlbHNfID0gW107XG59O1xuXG5heGVzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ0F4ZXMgUGx1Z2luJztcbn07XG5cbmF4ZXMucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oZykge1xuICByZXR1cm4ge1xuICAgIGxheW91dDogdGhpcy5sYXlvdXQsXG4gICAgY2xlYXJDaGFydDogdGhpcy5jbGVhckNoYXJ0LFxuICAgIHdpbGxEcmF3Q2hhcnQ6IHRoaXMud2lsbERyYXdDaGFydFxuICB9O1xufTtcblxuYXhlcy5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgZyA9IGUuZHlncmFwaDtcblxuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3QXhpcycsICd5JykpIHtcbiAgICB2YXIgdyA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xhYmVsV2lkdGgnLCAneScpICsgMiAqIGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc1RpY2tTaXplJywgJ3knKTtcbiAgICBlLnJlc2VydmVTcGFjZUxlZnQodyk7XG4gIH1cblxuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3QXhpcycsICd4JykpIHtcbiAgICB2YXIgaDtcbiAgICAvLyBOT1RFOiBJIHRoaW5rIHRoaXMgaXMgcHJvYmFibHkgYnJva2VuIG5vdywgc2luY2UgZy5nZXRPcHRpb24oKSBub3dcbiAgICAvLyBoaXRzIHRoZSBkaWN0aW9uYXJ5LiAoVGhhdCBpcywgZy5nZXRPcHRpb24oJ3hBeGlzSGVpZ2h0Jykgbm93IGFsd2F5c1xuICAgIC8vIGhhcyBhIHZhbHVlLilcbiAgICBpZiAoZy5nZXRPcHRpb24oJ3hBeGlzSGVpZ2h0JykpIHtcbiAgICAgIGggPSBnLmdldE9wdGlvbigneEF4aXNIZWlnaHQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xhYmVsRm9udFNpemUnLCAneCcpICsgMiAqIGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc1RpY2tTaXplJywgJ3gnKTtcbiAgICB9XG4gICAgZS5yZXNlcnZlU3BhY2VCb3R0b20oaCk7XG4gIH1cblxuICBpZiAoZy5udW1BeGVzKCkgPT0gMikge1xuICAgIGlmIChnLmdldE9wdGlvbkZvckF4aXMoJ2RyYXdBeGlzJywgJ3kyJykpIHtcbiAgICAgIHZhciB3ID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGFiZWxXaWR0aCcsICd5MicpICsgMiAqIGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc1RpY2tTaXplJywgJ3kyJyk7XG4gICAgICBlLnJlc2VydmVTcGFjZVJpZ2h0KHcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChnLm51bUF4ZXMoKSA+IDIpIHtcbiAgICBnLmVycm9yKCdPbmx5IHR3byB5LWF4ZXMgYXJlIHN1cHBvcnRlZCBhdCB0aGlzIHRpbWUuIChUcnlpbmcgJyArXG4gICAgICAgICAgICAndG8gdXNlICcgKyBnLm51bUF4ZXMoKSArICcpJyk7XG4gIH1cbn07XG5cbmF4ZXMucHJvdG90eXBlLmRldGFjaExhYmVscyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiByZW1vdmVBcnJheShhcnkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsID0gYXJ5W2ldO1xuICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUFycmF5KHRoaXMueGxhYmVsc18pO1xuICByZW1vdmVBcnJheSh0aGlzLnlsYWJlbHNfKTtcbiAgdGhpcy54bGFiZWxzXyA9IFtdO1xuICB0aGlzLnlsYWJlbHNfID0gW107XG59O1xuXG5heGVzLnByb3RvdHlwZS5jbGVhckNoYXJ0ID0gZnVuY3Rpb24oZSkge1xuICB0aGlzLmRldGFjaExhYmVscygpO1xufTtcblxuYXhlcy5wcm90b3R5cGUud2lsbERyYXdDaGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIGcgPSBlLmR5Z3JhcGg7XG5cbiAgaWYgKCFnLmdldE9wdGlvbkZvckF4aXMoJ2RyYXdBeGlzJywgJ3gnKSAmJlxuICAgICAgIWcuZ2V0T3B0aW9uRm9yQXhpcygnZHJhd0F4aXMnLCAneScpICYmXG4gICAgICAhZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3QXhpcycsICd5MicpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUm91bmQgcGl4ZWxzIHRvIGhhbGYtaW50ZWdlciBib3VuZGFyaWVzIGZvciBjcmlzcGVyIGRyYXdpbmcuXG4gIGZ1bmN0aW9uIGhhbGZVcCh4KSAgeyByZXR1cm4gTWF0aC5yb3VuZCh4KSArIDAuNTsgfVxuICBmdW5jdGlvbiBoYWxmRG93bih5KXsgcmV0dXJuIE1hdGgucm91bmQoeSkgLSAwLjU7IH1cblxuICB2YXIgY29udGV4dCA9IGUuZHJhd2luZ0NvbnRleHQ7XG4gIHZhciBjb250YWluZXJEaXYgPSBlLmNhbnZhcy5wYXJlbnROb2RlO1xuICB2YXIgY2FudmFzV2lkdGggPSBnLndpZHRoXzsgIC8vIGUuY2FudmFzLndpZHRoIGlzIGFmZmVjdGVkIGJ5IHBpeGVsIHJhdGlvLlxuICB2YXIgY2FudmFzSGVpZ2h0ID0gZy5oZWlnaHRfO1xuXG4gIHZhciBsYWJlbCwgeCwgeSwgdGljaywgaTtcblxuICB2YXIgbWFrZUxhYmVsU3R5bGUgPSBmdW5jdGlvbihheGlzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgZm9udFNpemU6IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xhYmVsRm9udFNpemUnLCBheGlzKSArICdweCcsXG4gICAgICB3aWR0aDogZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGFiZWxXaWR0aCcsIGF4aXMpICsgJ3B4JyxcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsYWJlbFN0eWxlcyA9IHtcbiAgICB4OiBtYWtlTGFiZWxTdHlsZSgneCcpLFxuICAgIHk6IG1ha2VMYWJlbFN0eWxlKCd5JyksXG4gICAgeTI6IG1ha2VMYWJlbFN0eWxlKCd5MicpXG4gIH07XG5cbiAgdmFyIG1ha2VEaXYgPSBmdW5jdGlvbih0eHQsIGF4aXMsIHByZWNfYXhpcykge1xuICAgIC8qXG4gICAgICogVGhpcyBzZWVtcyB0byBiZSBjYWxsZWQgd2l0aCB0aGUgZm9sbG93aW5nIHRocmVlIHNldHMgb2YgYXhpcy9wcmVjX2F4aXM6XG4gICAgICogeDogdW5kZWZpbmVkXG4gICAgICogeTogeTFcbiAgICAgKiB5OiB5MlxuICAgICAqL1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgbGFiZWxTdHlsZSA9IGxhYmVsU3R5bGVzW3ByZWNfYXhpcyA9PSAneTInID8gJ3kyJyA6IGF4aXNdO1xuICAgIHV0aWxzLnVwZGF0ZShkaXYuc3R5bGUsIGxhYmVsU3R5bGUpO1xuICAgIC8vIFRPRE86IGNvbWJpbmUgb3V0ZXIgJiBpbm5lciBkaXZzXG4gICAgdmFyIGlubmVyX2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGlubmVyX2Rpdi5jbGFzc05hbWUgPSAnZHlncmFwaC1heGlzLWxhYmVsJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICcgZHlncmFwaC1heGlzLWxhYmVsLScgKyBheGlzICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKHByZWNfYXhpcyA/ICcgZHlncmFwaC1heGlzLWxhYmVsLScgKyBwcmVjX2F4aXMgOiAnJyk7XG4gICAgaW5uZXJfZGl2LmlubmVySFRNTCA9IHR4dDtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoaW5uZXJfZGl2KTtcbiAgICByZXR1cm4gZGl2O1xuICB9O1xuXG4gIC8vIGF4aXMgbGluZXNcbiAgY29udGV4dC5zYXZlKCk7XG5cbiAgdmFyIGxheW91dCA9IGcubGF5b3V0XztcbiAgdmFyIGFyZWEgPSBlLmR5Z3JhcGgucGxvdHRlcl8uYXJlYTtcblxuICAvLyBIZWxwZXIgZm9yIHJlcGVhdGVkIGF4aXMtb3B0aW9uIGFjY2Vzc2VzLlxuICB2YXIgbWFrZU9wdGlvbkdldHRlciA9IGZ1bmN0aW9uKGF4aXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICByZXR1cm4gZy5nZXRPcHRpb25Gb3JBeGlzKG9wdGlvbiwgYXhpcyk7XG4gICAgfTtcbiAgfTtcblxuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3QXhpcycsICd5JykpIHtcbiAgICBpZiAobGF5b3V0Lnl0aWNrcyAmJiBsYXlvdXQueXRpY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBudW1fYXhlcyA9IGcubnVtQXhlcygpO1xuICAgICAgdmFyIGdldE9wdGlvbnMgPSBbbWFrZU9wdGlvbkdldHRlcigneScpLCBtYWtlT3B0aW9uR2V0dGVyKCd5MicpXTtcbiAgICAgIGxheW91dC55dGlja3MuZm9yRWFjaCh0aWNrID0+IHtcbiAgICAgICAgaWYgKHRpY2subGFiZWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAgLy8gdGhpcyB0aWNrIG9ubHkgaGFzIGEgZ3JpZCBsaW5lLlxuICAgICAgICB4ID0gYXJlYS54O1xuICAgICAgICB2YXIgc2duID0gMTtcbiAgICAgICAgdmFyIHByZWNfYXhpcyA9ICd5MSc7XG4gICAgICAgIHZhciBnZXRBeGlzT3B0aW9uID0gZ2V0T3B0aW9uc1swXTtcbiAgICAgICAgaWYgKHRpY2suYXhpcyA9PSAxKSB7ICAvLyByaWdodC1zaWRlIHktYXhpc1xuICAgICAgICAgIHggPSBhcmVhLnggKyBhcmVhLnc7XG4gICAgICAgICAgc2duID0gLTE7XG4gICAgICAgICAgcHJlY19heGlzID0gJ3kyJztcbiAgICAgICAgICBnZXRBeGlzT3B0aW9uID0gZ2V0T3B0aW9uc1sxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9udFNpemUgPSBnZXRBeGlzT3B0aW9uKCdheGlzTGFiZWxGb250U2l6ZScpO1xuICAgICAgICB5ID0gYXJlYS55ICsgdGljay5wb3MgKiBhcmVhLmg7XG5cbiAgICAgICAgLyogVGljayBtYXJrcyBhcmUgY3VycmVudGx5IGNsaXBwZWQsIHNvIGRvbid0IGJvdGhlciBkcmF3aW5nIHRoZW0uXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKGhhbGZVcCh4KSwgaGFsZkRvd24oeSkpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhoYWxmVXAoeCAtIHNnbiAqIHRoaXMuYXR0cl8oJ2F4aXNUaWNrU2l6ZScpKSwgaGFsZkRvd24oeSkpO1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAqL1xuXG4gICAgICAgIGxhYmVsID0gbWFrZURpdih0aWNrLmxhYmVsLCAneScsIG51bV9heGVzID09IDIgPyBwcmVjX2F4aXMgOiBudWxsKTtcbiAgICAgICAgdmFyIHRvcCA9ICh5IC0gZm9udFNpemUgLyAyKTtcbiAgICAgICAgaWYgKHRvcCA8IDApIHRvcCA9IDA7XG5cbiAgICAgICAgaWYgKHRvcCArIGZvbnRTaXplICsgMyA+IGNhbnZhc0hlaWdodCkge1xuICAgICAgICAgIGxhYmVsLnN0eWxlLmJvdHRvbSA9ICcwJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYWJlbC5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJlcGxhY2UgdGhlc2Ugd2l0aCBjc3MgY2xhc3Nlcz9cbiAgICAgICAgaWYgKHRpY2suYXhpcyA9PT0gMCkge1xuICAgICAgICAgIGxhYmVsLnN0eWxlLmxlZnQgPSAoYXJlYS54IC0gZ2V0QXhpc09wdGlvbignYXhpc0xhYmVsV2lkdGgnKSAtIGdldEF4aXNPcHRpb24oJ2F4aXNUaWNrU2l6ZScpKSArICdweCc7XG4gICAgICAgICAgbGFiZWwuc3R5bGUudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmICh0aWNrLmF4aXMgPT0gMSkge1xuICAgICAgICAgIGxhYmVsLnN0eWxlLmxlZnQgPSAoYXJlYS54ICsgYXJlYS53ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEF4aXNPcHRpb24oJ2F4aXNUaWNrU2l6ZScpKSArICdweCc7XG4gICAgICAgICAgbGFiZWwuc3R5bGUudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgICAgIGxhYmVsLnN0eWxlLndpZHRoID0gZ2V0QXhpc09wdGlvbignYXhpc0xhYmVsV2lkdGgnKSArICdweCc7XG4gICAgICAgIGNvbnRhaW5lckRpdi5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICAgIHRoaXMueWxhYmVsc18ucHVzaChsYWJlbCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gVGhlIGxvd2VzdCB0aWNrIG9uIHRoZSB5LWF4aXMgb2Z0ZW4gb3ZlcmxhcHMgd2l0aCB0aGUgbGVmdG1vc3RcbiAgICAgIC8vIHRpY2sgb24gdGhlIHgtYXhpcy4gU2hpZnQgdGhlIGJvdHRvbSB0aWNrIHVwIGEgbGl0dGxlIGJpdCB0b1xuICAgICAgLy8gY29tcGVuc2F0ZSBpZiBuZWNlc3NhcnkuXG4gICAgICB2YXIgYm90dG9tVGljayA9IHRoaXMueWxhYmVsc19bMF07XG4gICAgICAvLyBJbnRlcmVzdGVkIGluIHRoZSB5MiBheGlzIGFsc28/XG4gICAgICB2YXIgZm9udFNpemUgPSBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMYWJlbEZvbnRTaXplJywgJ3knKTtcbiAgICAgIHZhciBib3R0b20gPSBwYXJzZUludChib3R0b21UaWNrLnN0eWxlLnRvcCwgMTApICsgZm9udFNpemU7XG4gICAgICBpZiAoYm90dG9tID4gY2FudmFzSGVpZ2h0IC0gZm9udFNpemUpIHtcbiAgICAgICAgYm90dG9tVGljay5zdHlsZS50b3AgPSAocGFyc2VJbnQoYm90dG9tVGljay5zdHlsZS50b3AsIDEwKSAtXG4gICAgICAgICAgICBmb250U2l6ZSAvIDIpICsgJ3B4JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkcmF3IGEgdmVydGljYWwgbGluZSBvbiB0aGUgbGVmdCB0byBzZXBhcmF0ZSB0aGUgY2hhcnQgZnJvbSB0aGUgbGFiZWxzLlxuICAgIHZhciBheGlzWDtcbiAgICBpZiAoZy5nZXRPcHRpb24oJ2RyYXdBeGVzQXRaZXJvJykpIHtcbiAgICAgIHZhciByID0gZy50b1BlcmNlbnRYQ29vcmQoMCk7XG4gICAgICBpZiAociA+IDEgfHwgciA8IDAgfHwgaXNOYU4ocikpIHIgPSAwO1xuICAgICAgYXhpc1ggPSBoYWxmVXAoYXJlYS54ICsgciAqIGFyZWEudyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF4aXNYID0gaGFsZlVwKGFyZWEueCk7XG4gICAgfVxuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xpbmVDb2xvcicsICd5Jyk7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMaW5lV2lkdGgnLCAneScpO1xuXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhheGlzWCwgaGFsZkRvd24oYXJlYS55KSk7XG4gICAgY29udGV4dC5saW5lVG8oYXhpc1gsIGhhbGZEb3duKGFyZWEueSArIGFyZWEuaCkpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5zdHJva2UoKTtcblxuICAgIC8vIGlmIHRoZXJlJ3MgYSBzZWNvbmRhcnkgeS1heGlzLCBkcmF3IGEgdmVydGljYWwgbGluZSBmb3IgdGhhdCwgdG9vLlxuICAgIGlmIChnLm51bUF4ZXMoKSA9PSAyKSB7XG4gICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGluZUNvbG9yJywgJ3kyJyk7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xpbmVXaWR0aCcsICd5MicpO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKGhhbGZEb3duKGFyZWEueCArIGFyZWEudyksIGhhbGZEb3duKGFyZWEueSkpO1xuICAgICAgY29udGV4dC5saW5lVG8oaGFsZkRvd24oYXJlYS54ICsgYXJlYS53KSwgaGFsZkRvd24oYXJlYS55ICsgYXJlYS5oKSk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3QXhpcycsICd4JykpIHtcbiAgICBpZiAobGF5b3V0Lnh0aWNrcykge1xuICAgICAgdmFyIGdldEF4aXNPcHRpb24gPSBtYWtlT3B0aW9uR2V0dGVyKCd4Jyk7XG4gICAgICBsYXlvdXQueHRpY2tzLmZvckVhY2godGljayA9PiB7XG4gICAgICAgIGlmICh0aWNrLmxhYmVsID09PSB1bmRlZmluZWQpIHJldHVybjsgIC8vIHRoaXMgdGljayBvbmx5IGhhcyBhIGdyaWQgbGluZS5cbiAgICAgICAgeCA9IGFyZWEueCArIHRpY2sucG9zICogYXJlYS53O1xuICAgICAgICB5ID0gYXJlYS55ICsgYXJlYS5oO1xuXG4gICAgICAgIC8qIFRpY2sgbWFya3MgYXJlIGN1cnJlbnRseSBjbGlwcGVkLCBzbyBkb24ndCBib3RoZXIgZHJhd2luZyB0aGVtLlxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhoYWxmVXAoeCksIGhhbGZEb3duKHkpKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oaGFsZlVwKHgpLCBoYWxmRG93bih5ICsgdGhpcy5hdHRyXygnYXhpc1RpY2tTaXplJykpKTtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgKi9cblxuICAgICAgICBsYWJlbCA9IG1ha2VEaXYodGljay5sYWJlbCwgJ3gnKTtcbiAgICAgICAgbGFiZWwuc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIGxhYmVsLnN0eWxlLnRvcCA9ICh5ICsgZ2V0QXhpc09wdGlvbignYXhpc1RpY2tTaXplJykpICsgJ3B4JztcblxuICAgICAgICB2YXIgbGVmdCA9ICh4IC0gZ2V0QXhpc09wdGlvbignYXhpc0xhYmVsV2lkdGgnKS8yKTtcbiAgICAgICAgaWYgKGxlZnQgKyBnZXRBeGlzT3B0aW9uKCdheGlzTGFiZWxXaWR0aCcpID4gY2FudmFzV2lkdGgpIHtcbiAgICAgICAgICBsZWZ0ID0gY2FudmFzV2lkdGggLSBnZXRBeGlzT3B0aW9uKCdheGlzTGFiZWxXaWR0aCcpO1xuICAgICAgICAgIGxhYmVsLnN0eWxlLnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICAgICAgbGVmdCA9IDA7XG4gICAgICAgICAgbGFiZWwuc3R5bGUudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWwuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xuICAgICAgICBsYWJlbC5zdHlsZS53aWR0aCA9IGdldEF4aXNPcHRpb24oJ2F4aXNMYWJlbFdpZHRoJykgKyAncHgnO1xuICAgICAgICBjb250YWluZXJEaXYuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgICAgICB0aGlzLnhsYWJlbHNfLnB1c2gobGFiZWwpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xpbmVDb2xvcicsICd4Jyk7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMaW5lV2lkdGgnLCAneCcpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgdmFyIGF4aXNZO1xuICAgIGlmIChnLmdldE9wdGlvbignZHJhd0F4ZXNBdFplcm8nKSkge1xuICAgICAgdmFyIHIgPSBnLnRvUGVyY2VudFlDb29yZCgwLCAwKTtcbiAgICAgIGlmIChyID4gMSB8fCByIDwgMCkgciA9IDE7XG4gICAgICBheGlzWSA9IGhhbGZEb3duKGFyZWEueSArIHIgKiBhcmVhLmgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBheGlzWSA9IGhhbGZEb3duKGFyZWEueSArIGFyZWEuaCk7XG4gICAgfVxuICAgIGNvbnRleHQubW92ZVRvKGhhbGZVcChhcmVhLngpLCBheGlzWSk7XG4gICAgY29udGV4dC5saW5lVG8oaGFsZlVwKGFyZWEueCArIGFyZWEudyksIGF4aXNZKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH1cblxuICBjb250ZXh0LnJlc3RvcmUoKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGF4ZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL2F4ZXMuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///30\n");

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n/*global Dygraph:false */\n\n\n\n// TODO(danvk): move chart label options out of dygraphs and into the plugin.\n// TODO(danvk): only tear down & rebuild the DIVs when it's necessary.\n\nvar chart_labels = function chart_labels() {\n  this.title_div_ = null;\n  this.xlabel_div_ = null;\n  this.ylabel_div_ = null;\n  this.y2label_div_ = null;\n};\n\nchart_labels.prototype.toString = function () {\n  return \"ChartLabels Plugin\";\n};\n\nchart_labels.prototype.activate = function (g) {\n  return {\n    layout: this.layout,\n    // clearChart: this.clearChart,\n    didDrawChart: this.didDrawChart\n  };\n};\n\n// QUESTION: should there be a plugin-utils.js?\nvar createDivInRect = function createDivInRect(r) {\n  var div = document.createElement('div');\n  div.style.position = 'absolute';\n  div.style.left = r.x + 'px';\n  div.style.top = r.y + 'px';\n  div.style.width = r.w + 'px';\n  div.style.height = r.h + 'px';\n  return div;\n};\n\n// Detach and null out any existing nodes.\nchart_labels.prototype.detachLabels_ = function () {\n  var els = [this.title_div_, this.xlabel_div_, this.ylabel_div_, this.y2label_div_];\n  for (var i = 0; i < els.length; i++) {\n    var el = els[i];\n    if (!el) continue;\n    if (el.parentNode) el.parentNode.removeChild(el);\n  }\n\n  this.title_div_ = null;\n  this.xlabel_div_ = null;\n  this.ylabel_div_ = null;\n  this.y2label_div_ = null;\n};\n\nvar createRotatedDiv = function createRotatedDiv(g, box, axis, classes, html) {\n  // TODO(danvk): is this outer div actually necessary?\n  var div = document.createElement(\"div\");\n  div.style.position = 'absolute';\n  if (axis == 1) {\n    // NOTE: this is cheating. Should be positioned relative to the box.\n    div.style.left = '0px';\n  } else {\n    div.style.left = box.x + 'px';\n  }\n  div.style.top = box.y + 'px';\n  div.style.width = box.w + 'px';\n  div.style.height = box.h + 'px';\n  div.style.fontSize = g.getOption('yLabelWidth') - 2 + 'px';\n\n  var inner_div = document.createElement(\"div\");\n  inner_div.style.position = 'absolute';\n  inner_div.style.width = box.h + 'px';\n  inner_div.style.height = box.w + 'px';\n  inner_div.style.top = box.h / 2 - box.w / 2 + 'px';\n  inner_div.style.left = box.w / 2 - box.h / 2 + 'px';\n  // TODO: combine inner_div and class_div.\n  inner_div.className = 'dygraph-label-rotate-' + (axis == 1 ? 'right' : 'left');\n\n  var class_div = document.createElement(\"div\");\n  class_div.className = classes;\n  class_div.innerHTML = html;\n\n  inner_div.appendChild(class_div);\n  div.appendChild(inner_div);\n  return div;\n};\n\nchart_labels.prototype.layout = function (e) {\n  this.detachLabels_();\n\n  var g = e.dygraph;\n  var div = e.chart_div;\n  if (g.getOption('title')) {\n    // QUESTION: should this return an absolutely-positioned div instead?\n    var title_rect = e.reserveSpaceTop(g.getOption('titleHeight'));\n    this.title_div_ = createDivInRect(title_rect);\n    this.title_div_.style.fontSize = g.getOption('titleHeight') - 8 + 'px';\n\n    var class_div = document.createElement(\"div\");\n    class_div.className = 'dygraph-label dygraph-title';\n    class_div.innerHTML = g.getOption('title');\n    this.title_div_.appendChild(class_div);\n    div.appendChild(this.title_div_);\n  }\n\n  if (g.getOption('xlabel')) {\n    var x_rect = e.reserveSpaceBottom(g.getOption('xLabelHeight'));\n    this.xlabel_div_ = createDivInRect(x_rect);\n    this.xlabel_div_.style.fontSize = g.getOption('xLabelHeight') - 2 + 'px';\n\n    var class_div = document.createElement(\"div\");\n    class_div.className = 'dygraph-label dygraph-xlabel';\n    class_div.innerHTML = g.getOption('xlabel');\n    this.xlabel_div_.appendChild(class_div);\n    div.appendChild(this.xlabel_div_);\n  }\n\n  if (g.getOption('ylabel')) {\n    // It would make sense to shift the chart here to make room for the y-axis\n    // label, but the default yAxisLabelWidth is large enough that this results\n    // in overly-padded charts. The y-axis label should fit fine. If it\n    // doesn't, the yAxisLabelWidth option can be increased.\n    var y_rect = e.reserveSpaceLeft(0);\n\n    this.ylabel_div_ = createRotatedDiv(g, y_rect, 1, // primary (left) y-axis\n    'dygraph-label dygraph-ylabel', g.getOption('ylabel'));\n    div.appendChild(this.ylabel_div_);\n  }\n\n  if (g.getOption('y2label') && g.numAxes() == 2) {\n    // same logic applies here as for ylabel.\n    var y2_rect = e.reserveSpaceRight(0);\n    this.y2label_div_ = createRotatedDiv(g, y2_rect, 2, // secondary (right) y-axis\n    'dygraph-label dygraph-y2label', g.getOption('y2label'));\n    div.appendChild(this.y2label_div_);\n  }\n};\n\nchart_labels.prototype.didDrawChart = function (e) {\n  var g = e.dygraph;\n  if (this.title_div_) {\n    this.title_div_.children[0].innerHTML = g.getOption('title');\n  }\n  if (this.xlabel_div_) {\n    this.xlabel_div_.children[0].innerHTML = g.getOption('xlabel');\n  }\n  if (this.ylabel_div_) {\n    this.ylabel_div_.children[0].children[0].innerHTML = g.getOption('ylabel');\n  }\n  if (this.y2label_div_) {\n    this.y2label_div_.children[0].children[0].innerHTML = g.getOption('y2label');\n  }\n};\n\nchart_labels.prototype.clearChart = function () {};\n\nchart_labels.prototype.destroy = function () {\n  this.detachLabels_();\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (chart_labels);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL2NoYXJ0LWxhYmVscy5qcz9iZDJlIl0sIm5hbWVzIjpbImNoYXJ0X2xhYmVscyIsInRpdGxlX2Rpdl8iLCJ4bGFiZWxfZGl2XyIsInlsYWJlbF9kaXZfIiwieTJsYWJlbF9kaXZfIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJhY3RpdmF0ZSIsImciLCJsYXlvdXQiLCJkaWREcmF3Q2hhcnQiLCJjcmVhdGVEaXZJblJlY3QiLCJyIiwiZGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJwb3NpdGlvbiIsImxlZnQiLCJ4IiwidG9wIiwieSIsIndpZHRoIiwidyIsImhlaWdodCIsImgiLCJkZXRhY2hMYWJlbHNfIiwiZWxzIiwiaSIsImxlbmd0aCIsImVsIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY3JlYXRlUm90YXRlZERpdiIsImJveCIsImF4aXMiLCJjbGFzc2VzIiwiaHRtbCIsImZvbnRTaXplIiwiZ2V0T3B0aW9uIiwiaW5uZXJfZGl2IiwiY2xhc3NOYW1lIiwiY2xhc3NfZGl2IiwiaW5uZXJIVE1MIiwiYXBwZW5kQ2hpbGQiLCJlIiwiZHlncmFwaCIsImNoYXJ0X2RpdiIsInRpdGxlX3JlY3QiLCJyZXNlcnZlU3BhY2VUb3AiLCJ4X3JlY3QiLCJyZXNlcnZlU3BhY2VCb3R0b20iLCJ5X3JlY3QiLCJyZXNlcnZlU3BhY2VMZWZ0IiwibnVtQXhlcyIsInkyX3JlY3QiLCJyZXNlcnZlU3BhY2VSaWdodCIsImNoaWxkcmVuIiwiY2xlYXJDaGFydCIsImRlc3Ryb3kiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSUEsZUFBZSxTQUFmQSxZQUFlLEdBQVc7QUFDNUIsT0FBS0MsVUFBTCxHQUFrQixJQUFsQjtBQUNBLE9BQUtDLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxPQUFLQyxXQUFMLEdBQW1CLElBQW5CO0FB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K0IsU0FBRixDQUFZLFFBQVosQ0FBckQ7QUFDRDtBQUNELE1BQUksS0FBS25DLFlBQVQsRUFBdUI7QUFDckIsU0FBS0EsWUFBTCxDQUFrQnFELFFBQWxCLENBQTJCLENBQTNCLEVBQThCQSxRQUE5QixDQUF1QyxDQUF2QyxFQUEwQ2QsU0FBMUMsR0FBc0RuQyxFQUFFK0IsU0FBRixDQUFZLFNBQVosQ0FBdEQ7QUFDRDtBQUNGLENBZEQ7O0FBZ0JBdkMsYUFBYUssU0FBYixDQUF1QnFELFVBQXZCLEdBQW9DLFlBQVcsQ0FDOUMsQ0FERDs7QUFHQTFELGFBQWFLLFNBQWIsQ0FBdUJzRCxPQUF2QixHQUFpQyxZQUFXO0FBQzFDLE9BQUtqQyxhQUFMO0FBQ0QsQ0FGRDs7QUFJQSx5REFBZTFCLFlBQWYiLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMiBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBUT0RPKGRhbnZrKTogbW92ZSBjaGFydCBsYWJlbCBvcHRpb25zIG91dCBvZiBkeWdyYXBocyBhbmQgaW50byB0aGUgcGx1Z2luLlxuLy8gVE9ETyhkYW52ayk6IG9ubHkgdGVhciBkb3duICYgcmVidWlsZCB0aGUgRElWcyB3aGVuIGl0J3MgbmVjZXNzYXJ5LlxuXG52YXIgY2hhcnRfbGFiZWxzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMudGl0bGVfZGl2XyA9IG51bGw7XG4gIHRoaXMueGxhYmVsX2Rpdl8gPSBudWxsO1xuICB0aGlzLnlsYWJlbF9kaXZfID0gbnVsbDtcbiAgdGhpcy55MmxhYmVsX2Rpdl8gPSBudWxsO1xufTtcblxuY2hhcnRfbGFiZWxzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCJDaGFydExhYmVscyBQbHVnaW5cIjtcbn07XG5cbmNoYXJ0X2xhYmVscy5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbihnKSB7XG4gIHJldHVybiB7XG4gICAgbGF5b3V0OiB0aGlzLmxheW91dCxcbiAgICAvLyBjbGVhckNoYXJ0OiB0aGlzLmNsZWFyQ2hhcnQsXG4gICAgZGlkRHJhd0NoYXJ0OiB0aGlzLmRpZERyYXdDaGFydFxuICB9O1xufTtcblxuLy8gUVVFU1RJT046IHNob3VsZCB0aGVyZSBiZSBhIHBsdWdpbi11dGlscy5qcz9cbnZhciBjcmVhdGVEaXZJblJlY3QgPSBmdW5jdGlvbihyKSB7XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgZGl2LnN0eWxlLmxlZnQgPSByLnggKyAncHgnO1xuICBkaXYuc3R5bGUudG9wID0gci55ICsgJ3B4JztcbiAgZGl2LnN0eWxlLndpZHRoID0gci53ICsgJ3B4JztcbiAgZGl2LnN0eWxlLmhlaWdodCA9IHIuaCArICdweCc7XG4gIHJldHVybiBkaXY7XG59O1xuXG4vLyBEZXRhY2ggYW5kIG51bGwgb3V0IGFueSBleGlzdGluZyBub2Rlcy5cbmNoYXJ0X2xhYmVscy5wcm90b3R5cGUuZGV0YWNoTGFiZWxzXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZWxzID0gWyB0aGlzLnRpdGxlX2Rpdl8sXG4gICAgICAgICAgICAgIHRoaXMueGxhYmVsX2Rpdl8sXG4gICAgICAgICAgICAgIHRoaXMueWxhYmVsX2Rpdl8sXG4gICAgICAgICAgICAgIHRoaXMueTJsYWJlbF9kaXZfIF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gZWxzW2ldO1xuICAgIGlmICghZWwpIGNvbnRpbnVlO1xuICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgfVxuXG4gIHRoaXMudGl0bGVfZGl2XyA9IG51bGw7XG4gIHRoaXMueGxhYmVsX2Rpdl8gPSBudWxsO1xuICB0aGlzLnlsYWJlbF9kaXZfID0gbnVsbDtcbiAgdGhpcy55MmxhYmVsX2Rpdl8gPSBudWxsO1xufTtcblxudmFyIGNyZWF0ZVJvdGF0ZWREaXYgPSBmdW5jdGlvbihnLCBib3gsIGF4aXMsIGNsYXNzZXMsIGh0bWwpIHtcbiAgLy8gVE9ETyhkYW52ayk6IGlzIHRoaXMgb3V0ZXIgZGl2IGFjdHVhbGx5IG5lY2Vzc2FyeT9cbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGlmIChheGlzID09IDEpIHtcbiAgICAvLyBOT1RFOiB0aGlzIGlzIGNoZWF0aW5nLiBTaG91bGQgYmUgcG9zaXRpb25lZCByZWxhdGl2ZSB0byB0aGUgYm94LlxuICAgIGRpdi5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gIH0gZWxzZSB7XG4gICAgZGl2LnN0eWxlLmxlZnQgPSBib3gueCArICdweCc7XG4gIH1cbiAgZGl2LnN0eWxlLnRvcCA9IGJveC55ICsgJ3B4JztcbiAgZGl2LnN0eWxlLndpZHRoID0gYm94LncgKyAncHgnO1xuICBkaXYuc3R5bGUuaGVpZ2h0ID0gYm94LmggKyAncHgnO1xuICBkaXYuc3R5bGUuZm9udFNpemUgPSAoZy5nZXRPcHRpb24oJ3lMYWJlbFdpZHRoJykgLSAyKSArICdweCc7XG5cbiAgdmFyIGlubmVyX2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGlubmVyX2Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGlubmVyX2Rpdi5zdHlsZS53aWR0aCA9IGJveC5oICsgJ3B4JztcbiAgaW5uZXJfZGl2LnN0eWxlLmhlaWdodCA9IGJveC53ICsgJ3B4JztcbiAgaW5uZXJfZGl2LnN0eWxlLnRvcCA9IChib3guaCAvIDIgLSBib3gudyAvIDIpICsgJ3B4JztcbiAgaW5uZXJfZGl2LnN0eWxlLmxlZnQgPSAoYm94LncgLyAyIC0gYm94LmggLyAyKSArICdweCc7XG4gIC8vIFRPRE86IGNvbWJpbmUgaW5uZXJfZGl2IGFuZCBjbGFzc19kaXYuXG4gIGlubmVyX2Rpdi5jbGFzc05hbWUgPSAnZHlncmFwaC1sYWJlbC1yb3RhdGUtJyArIChheGlzID09IDEgPyAncmlnaHQnIDogJ2xlZnQnKTtcblxuICB2YXIgY2xhc3NfZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgY2xhc3NfZGl2LmNsYXNzTmFtZSA9IGNsYXNzZXM7XG4gIGNsYXNzX2Rpdi5pbm5lckhUTUwgPSBodG1sO1xuXG4gIGlubmVyX2Rpdi5hcHBlbmRDaGlsZChjbGFzc19kaXYpO1xuICBkaXYuYXBwZW5kQ2hpbGQoaW5uZXJfZGl2KTtcbiAgcmV0dXJuIGRpdjtcbn07XG5cbmNoYXJ0X2xhYmVscy5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24oZSkge1xuICB0aGlzLmRldGFjaExhYmVsc18oKTtcblxuICB2YXIgZyA9IGUuZHlncmFwaDtcbiAgdmFyIGRpdiA9IGUuY2hhcnRfZGl2O1xuICBpZiAoZy5nZXRPcHRpb24oJ3RpdGxlJykpIHtcbiAgICAvLyBRVUVTVElPTjogc2hvdWxkIHRoaXMgcmV0dXJuIGFuIGFic29sdXRlbHktcG9zaXRpb25lZCBkaXYgaW5zdGVhZD9cbiAgICB2YXIgdGl0bGVfcmVjdCA9IGUucmVzZXJ2ZVNwYWNlVG9wKGcuZ2V0T3B0aW9uKCd0aXRsZUhlaWdodCcpKTtcbiAgICB0aGlzLnRpdGxlX2Rpdl8gPSBjcmVhdGVEaXZJblJlY3QodGl0bGVfcmVjdCk7XG4gICAgdGhpcy50aXRsZV9kaXZfLnN0eWxlLmZvbnRTaXplID0gKGcuZ2V0T3B0aW9uKCd0aXRsZUhlaWdodCcpIC0gOCkgKyAncHgnO1xuXG4gICAgdmFyIGNsYXNzX2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgY2xhc3NfZGl2LmNsYXNzTmFtZSA9ICdkeWdyYXBoLWxhYmVsIGR5Z3JhcGgtdGl0bGUnO1xuICAgIGNsYXNzX2Rpdi5pbm5lckhUTUwgPSBnLmdldE9wdGlvbigndGl0bGUnKTtcbiAgICB0aGlzLnRpdGxlX2Rpdl8uYXBwZW5kQ2hpbGQoY2xhc3NfZGl2KTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQodGhpcy50aXRsZV9kaXZfKTtcbiAgfVxuXG4gIGlmIChnLmdldE9wdGlvbigneGxhYmVsJykpIHtcbiAgICB2YXIgeF9yZWN0ID0gZS5yZXNlcnZlU3BhY2VCb3R0b20oZy5nZXRPcHRpb24oJ3hMYWJlbEhlaWdodCcpKTtcbiAgICB0aGlzLnhsYWJlbF9kaXZfID0gY3JlYXRlRGl2SW5SZWN0KHhfcmVjdCk7XG4gICAgdGhpcy54bGFiZWxfZGl2Xy5zdHlsZS5mb250U2l6ZSA9IChnLmdldE9wdGlvbigneExhYmVsSGVpZ2h0JykgLSAyKSArICdweCc7XG5cbiAgICB2YXIgY2xhc3NfZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjbGFzc19kaXYuY2xhc3NOYW1lID0gJ2R5Z3JhcGgtbGFiZWwgZHlncmFwaC14bGFiZWwnO1xuICAgIGNsYXNzX2Rpdi5pbm5lckhUTUwgPSBnLmdldE9wdGlvbigneGxhYmVsJyk7XG4gICAgdGhpcy54bGFiZWxfZGl2Xy5hcHBlbmRDaGlsZChjbGFzc19kaXYpO1xuICAgIGRpdi5hcHBlbmRDaGlsZCh0aGlzLnhsYWJlbF9kaXZfKTtcbiAgfVxuXG4gIGlmIChnLmdldE9wdGlvbigneWxhYmVsJykpIHtcbiAgICAvLyBJdCB3b3VsZCBtYWtlIHNlbnNlIHRvIHNoaWZ0IHRoZSBjaGFydCBoZXJlIHRvIG1ha2Ugcm9vbSBmb3IgdGhlIHktYXhpc1xuICAgIC8vIGxhYmVsLCBidXQgdGhlIGRlZmF1bHQgeUF4aXNMYWJlbFdpZHRoIGlzIGxhcmdlIGVub3VnaCB0aGF0IHRoaXMgcmVzdWx0c1xuICAgIC8vIGluIG92ZXJseS1wYWRkZWQgY2hhcnRzLiBUaGUgeS1heGlzIGxhYmVsIHNob3VsZCBmaXQgZmluZS4gSWYgaXRcbiAgICAvLyBkb2Vzbid0LCB0aGUgeUF4aXNMYWJlbFdpZHRoIG9wdGlvbiBjYW4gYmUgaW5jcmVhc2VkLlxuICAgIHZhciB5X3JlY3QgPSBlLnJlc2VydmVTcGFjZUxlZnQoMCk7XG5cbiAgICB0aGlzLnlsYWJlbF9kaXZfID0gY3JlYXRlUm90YXRlZERpdihcbiAgICAgICAgZywgeV9yZWN0LFxuICAgICAgICAxLCAgLy8gcHJpbWFyeSAobGVmdCkgeS1heGlzXG4gICAgICAgICdkeWdyYXBoLWxhYmVsIGR5Z3JhcGgteWxhYmVsJyxcbiAgICAgICAgZy5nZXRPcHRpb24oJ3lsYWJlbCcpKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQodGhpcy55bGFiZWxfZGl2Xyk7XG4gIH1cblxuICBpZiAoZy5nZXRPcHRpb24oJ3kybGFiZWwnKSAmJiBnLm51bUF4ZXMoKSA9PSAyKSB7XG4gICAgLy8gc2FtZSBsb2dpYyBhcHBsaWVzIGhlcmUgYXMgZm9yIHlsYWJlbC5cbiAgICB2YXIgeTJfcmVjdCA9IGUucmVzZXJ2ZVNwYWNlUmlnaHQoMCk7XG4gICAgdGhpcy55MmxhYmVsX2Rpdl8gPSBjcmVhdGVSb3RhdGVkRGl2KFxuICAgICAgICBnLCB5Ml9yZWN0LFxuICAgICAgICAyLCAgLy8gc2Vjb25kYXJ5IChyaWdodCkgeS1heGlzXG4gICAgICAgICdkeWdyYXBoLWxhYmVsIGR5Z3JhcGgteTJsYWJlbCcsXG4gICAgICAgIGcuZ2V0T3B0aW9uKCd5MmxhYmVsJykpO1xuICAgIGRpdi5hcHBlbmRDaGlsZCh0aGlzLnkybGFiZWxfZGl2Xyk7XG4gIH1cbn07XG5cbmNoYXJ0X2xhYmVscy5wcm90b3R5cGUuZGlkRHJhd0NoYXJ0ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgZyA9IGUuZHlncmFwaDtcbiAgaWYgKHRoaXMudGl0bGVfZGl2Xykge1xuICAgIHRoaXMudGl0bGVfZGl2Xy5jaGlsZHJlblswXS5pbm5lckhUTUwgPSBnLmdldE9wdGlvbigndGl0bGUnKTtcbiAgfVxuICBpZiAodGhpcy54bGFiZWxfZGl2Xykge1xuICAgIHRoaXMueGxhYmVsX2Rpdl8uY2hpbGRyZW5bMF0uaW5uZXJIVE1MID0gZy5nZXRPcHRpb24oJ3hsYWJlbCcpO1xuICB9XG4gIGlmICh0aGlzLnlsYWJlbF9kaXZfKSB7XG4gICAgdGhpcy55bGFiZWxfZGl2Xy5jaGlsZHJlblswXS5jaGlsZHJlblswXS5pbm5lckhUTUwgPSBnLmdldE9wdGlvbigneWxhYmVsJyk7XG4gIH1cbiAgaWYgKHRoaXMueTJsYWJlbF9kaXZfKSB7XG4gICAgdGhpcy55MmxhYmVsX2Rpdl8uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uaW5uZXJIVE1MID0gZy5nZXRPcHRpb24oJ3kybGFiZWwnKTtcbiAgfVxufTtcblxuY2hhcnRfbGFiZWxzLnByb3RvdHlwZS5jbGVhckNoYXJ0ID0gZnVuY3Rpb24oKSB7XG59O1xuXG5jaGFydF9sYWJlbHMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kZXRhY2hMYWJlbHNfKCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjaGFydF9sYWJlbHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL2NoYXJ0LWxhYmVscy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///31\n");

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n/*global Dygraph:false */\n\n/*\n\nCurrent bits of jankiness:\n- Direct layout access\n- Direct area access\n\n*/\n\n\n\n/**\n * Draws the gridlines, i.e. the gray horizontal & vertical lines running the\n * length of the chart.\n *\n * @constructor\n */\n\nvar grid = function grid() {};\n\ngrid.prototype.toString = function () {\n  return \"Gridline Plugin\";\n};\n\ngrid.prototype.activate = function (g) {\n  return {\n    willDrawChart: this.willDrawChart\n  };\n};\n\ngrid.prototype.willDrawChart = function (e) {\n  // Draw the new X/Y grid. Lines appear crisper when pixels are rounded to\n  // half-integers. This prevents them from drawing in two rows/cols.\n  var g = e.dygraph;\n  var ctx = e.drawingContext;\n  var layout = g.layout_;\n  var area = e.dygraph.plotter_.area;\n\n  function halfUp(x) {\n    return Math.round(x) + 0.5;\n  }\n  function halfDown(y) {\n    return Math.round(y) - 0.5;\n  }\n\n  var x, y, i, ticks;\n  if (g.getOptionForAxis('drawGrid', 'y')) {\n    var axes = [\"y\", \"y2\"];\n    var strokeStyles = [],\n        lineWidths = [],\n        drawGrid = [],\n        stroking = [],\n        strokePattern = [];\n    for (var i = 0; i < axes.length; i++) {\n      drawGrid[i] = g.getOptionForAxis('drawGrid', axes[i]);\n      if (drawGrid[i]) {\n        strokeStyles[i] = g.getOptionForAxis('gridLineColor', axes[i]);\n        lineWidths[i] = g.getOptionForAxis('gridLineWidth', axes[i]);\n        strokePattern[i] = g.getOptionForAxis('gridLinePattern', axes[i]);\n        stroking[i] = strokePattern[i] && strokePattern[i].length >= 2;\n      }\n    }\n    ticks = layout.yticks;\n    ctx.save();\n    // draw grids for the different y axes\n    ticks.forEach(function (tick) {\n      if (!tick.has_tick) return;\n      var axis = tick.axis;\n      if (drawGrid[axis]) {\n        ctx.save();\n        if (stroking[axis]) {\n          if (ctx.setLineDash) ctx.setLineDash(strokePattern[axis]);\n        }\n        ctx.strokeStyle = strokeStyles[axis];\n        ctx.lineWidth = lineWidths[axis];\n\n        x = halfUp(area.x);\n        y = halfDown(area.y + tick.pos * area.h);\n        ctx.beginPath();\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + area.w, y);\n        ctx.stroke();\n\n        ctx.restore();\n      }\n    });\n    ctx.restore();\n  }\n\n  // draw grid for x axis\n  if (g.getOptionForAxis('drawGrid', 'x')) {\n    ticks = layout.xticks;\n    ctx.save();\n    var strokePattern = g.getOptionForAxis('gridLinePattern', 'x');\n    var stroking = strokePattern && strokePattern.length >= 2;\n    if (stroking) {\n      if (ctx.setLineDash) ctx.setLineDash(strokePattern);\n    }\n    ctx.strokeStyle = g.getOptionForAxis('gridLineColor', 'x');\n    ctx.lineWidth = g.getOptionForAxis('gridLineWidth', 'x');\n    ticks.forEach(function (tick) {\n      if (!tick.has_tick) return;\n      x = halfUp(area.x + tick.pos * area.w);\n      y = halfDown(area.y + area.h);\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(x, area.y);\n      ctx.closePath();\n      ctx.stroke();\n    });\n    if (stroking) {\n      if (ctx.setLineDash) ctx.setLineDash([]);\n    }\n    ctx.restore();\n  }\n};\n\ngrid.prototype.destroy = function () {};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (grid);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL2dyaWQuanM/YjE2NCJdLCJuYW1lcyI6WyJncmlkIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJhY3RpdmF0ZSIsImciLCJ3aWxsRHJhd0NoYXJ0IiwiZSIsImR5Z3JhcGgiLCJjdHgiLCJkcmF3aW5nQ29udGV4dCIsImxheW91dCIsImxheW91dF8iLCJhcmVhIiwicGxvdHRlcl8iLCJoYWxmVXAiLCJ4IiwiTWF0aCIsInJvdW5kIiwiaGFsZkRvd24iLCJ5IiwiaSIsInRpY2tzIiwiZ2V0T3B0aW9uRm9yQXhpcyIsImF4ZXMiLCJzdHJva2VTdHlsZXMiLCJsaW5lV2lkdGhzIiwiZHJhd0dyaWQiLCJzdHJva2luZyIsInN0cm9rZVBhdHRlcm4iLCJsZW5ndGgiLCJ5dGlja3MiLCJzYXZlIiwiZm9yRWFjaCIsInRpY2siLCJoYXNfdGljayIsImF4aXMiLCJzZXRMaW5lRGFzaCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwicG9zIiwiaCIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsInciLCJzdHJva2UiLCJyZXN0b3JlIiwieHRpY2tzIiwiY2xvc2VQYXRoIiwiZGVzdHJveSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FBS0E7O0FBRUE7Ozs7Ozs7O0FBUUE7O0FBRUE7Ozs7Ozs7QUFNQSxJQUFJQSxPQUFPLFNBQVBBLElBQU8sR0FBVyxDQUNyQixDQUREOztBQUdBQSxLQUFLQyxTQUFMLENBQWVDLFFBQWYsR0FBMEIsWUFBVztBQUNuQyxTQUFPLGlCQUFQO0FBQ0QsQ0FGRDs7QUFJQUYsS0FBS0MsU0FBTCxDQUFlRSxRQUFmLEdBQTBCLFVBQVNDLENBQVQsRUFBWTtBQUNwQyxTQUFPO0FBQ0xDLG1CQUFlLEtBQUtBO0FBRGYsR0FBUDtBQUdELENBSkQ7O0FBTUFMLEtBQUtDLFNBQUwsQ0FBZUksYUFBZixHQUErQixVQUFTQyxDQUFULEVBQVk7QUFDekM7QUFDQTtBQUNBLE1BQUlG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U0FBTCxDQUFlZ0QsT0FBZixHQUF5QixZQUFXLENBQ25DLENBREQ7O0FBR0EseURBQWVqRCxJQUFmIiwiZmlsZSI6IjMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTIgRGFuIFZhbmRlcmthbSAoZGFudmRrQGdtYWlsLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXG4vKlxuXG5DdXJyZW50IGJpdHMgb2YgamFua2luZXNzOlxuLSBEaXJlY3QgbGF5b3V0IGFjY2Vzc1xuLSBEaXJlY3QgYXJlYSBhY2Nlc3NcblxuKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogRHJhd3MgdGhlIGdyaWRsaW5lcywgaS5lLiB0aGUgZ3JheSBob3Jpem9udGFsICYgdmVydGljYWwgbGluZXMgcnVubmluZyB0aGVcbiAqIGxlbmd0aCBvZiB0aGUgY2hhcnQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBncmlkID0gZnVuY3Rpb24oKSB7XG59O1xuXG5ncmlkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCJHcmlkbGluZSBQbHVnaW5cIjtcbn07XG5cbmdyaWQucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oZykge1xuICByZXR1cm4ge1xuICAgIHdpbGxEcmF3Q2hhcnQ6IHRoaXMud2lsbERyYXdDaGFydFxuICB9O1xufTtcblxuZ3JpZC5wcm90b3R5cGUud2lsbERyYXdDaGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgLy8gRHJhdyB0aGUgbmV3IFgvWSBncmlkLiBMaW5lcyBhcHBlYXIgY3Jpc3BlciB3aGVuIHBpeGVscyBhcmUgcm91bmRlZCB0b1xuICAvLyBoYWxmLWludGVnZXJzLiBUaGlzIHByZXZlbnRzIHRoZW0gZnJvbSBkcmF3aW5nIGluIHR3byByb3dzL2NvbHMuXG4gIHZhciBnID0gZS5keWdyYXBoO1xuICB2YXIgY3R4ID0gZS5kcmF3aW5nQ29udGV4dDtcbiAgdmFyIGxheW91dCA9IGcubGF5b3V0XztcbiAgdmFyIGFyZWEgPSBlLmR5Z3JhcGgucGxvdHRlcl8uYXJlYTtcblxuICBmdW5jdGlvbiBoYWxmVXAoeCkgIHsgcmV0dXJuIE1hdGgucm91bmQoeCkgKyAwLjU7IH1cbiAgZnVuY3Rpb24gaGFsZkRvd24oeSl7IHJldHVybiBNYXRoLnJvdW5kKHkpIC0gMC41OyB9XG5cbiAgdmFyIHgsIHksIGksIHRpY2tzO1xuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3R3JpZCcsICd5JykpIHtcbiAgICB2YXIgYXhlcyA9IFtcInlcIiwgXCJ5MlwiXTtcbiAgICB2YXIgc3Ryb2tlU3R5bGVzID0gW10sIGxpbmVXaWR0aHMgPSBbXSwgZHJhd0dyaWQgPSBbXSwgc3Ryb2tpbmcgPSBbXSwgc3Ryb2tlUGF0dGVybiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZHJhd0dyaWRbaV0gPSBnLmdldE9wdGlvbkZvckF4aXMoJ2RyYXdHcmlkJywgYXhlc1tpXSk7XG4gICAgICBpZiAoZHJhd0dyaWRbaV0pIHtcbiAgICAgICAgc3Ryb2tlU3R5bGVzW2ldID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdncmlkTGluZUNvbG9yJywgYXhlc1tpXSk7XG4gICAgICAgIGxpbmVXaWR0aHNbaV0gPSBnLmdldE9wdGlvbkZvckF4aXMoJ2dyaWRMaW5lV2lkdGgnLCBheGVzW2ldKTtcbiAgICAgICAgc3Ryb2tlUGF0dGVybltpXSA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnZ3JpZExpbmVQYXR0ZXJuJywgYXhlc1tpXSk7XG4gICAgICAgIHN0cm9raW5nW2ldID0gc3Ryb2tlUGF0dGVybltpXSAmJiAoc3Ryb2tlUGF0dGVybltpXS5sZW5ndGggPj0gMik7XG4gICAgICB9XG4gICAgfVxuICAgIHRpY2tzID0gbGF5b3V0Lnl0aWNrcztcbiAgICBjdHguc2F2ZSgpO1xuICAgIC8vIGRyYXcgZ3JpZHMgZm9yIHRoZSBkaWZmZXJlbnQgeSBheGVzXG4gICAgdGlja3MuZm9yRWFjaCh0aWNrID0+IHtcbiAgICAgIGlmICghdGljay5oYXNfdGljaykgcmV0dXJuO1xuICAgICAgdmFyIGF4aXMgPSB0aWNrLmF4aXM7XG4gICAgICBpZiAoZHJhd0dyaWRbYXhpc10pIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYgKHN0cm9raW5nW2F4aXNdKSB7XG4gICAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCkgY3R4LnNldExpbmVEYXNoKHN0cm9rZVBhdHRlcm5bYXhpc10pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlc1theGlzXTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aHNbYXhpc107XG5cbiAgICAgICAgeCA9IGhhbGZVcChhcmVhLngpO1xuICAgICAgICB5ID0gaGFsZkRvd24oYXJlYS55ICsgdGljay5wb3MgKiBhcmVhLmgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIGFyZWEudywgeSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICAvLyBkcmF3IGdyaWQgZm9yIHggYXhpc1xuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3R3JpZCcsICd4JykpIHtcbiAgICB0aWNrcyA9IGxheW91dC54dGlja3M7XG4gICAgY3R4LnNhdmUoKTtcbiAgICB2YXIgc3Ryb2tlUGF0dGVybiA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnZ3JpZExpbmVQYXR0ZXJuJywgJ3gnKTtcbiAgICB2YXIgc3Ryb2tpbmcgPSBzdHJva2VQYXR0ZXJuICYmIChzdHJva2VQYXR0ZXJuLmxlbmd0aCA+PSAyKTtcbiAgICBpZiAoc3Ryb2tpbmcpIHtcbiAgICAgIGlmIChjdHguc2V0TGluZURhc2gpIGN0eC5zZXRMaW5lRGFzaChzdHJva2VQYXR0ZXJuKTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdncmlkTGluZUNvbG9yJywgJ3gnKTtcbiAgICBjdHgubGluZVdpZHRoID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdncmlkTGluZVdpZHRoJywgJ3gnKTtcbiAgICB0aWNrcy5mb3JFYWNoKHRpY2sgPT4ge1xuICAgICAgaWYgKCF0aWNrLmhhc190aWNrKSByZXR1cm47XG4gICAgICB4ID0gaGFsZlVwKGFyZWEueCArIHRpY2sucG9zICogYXJlYS53KTtcbiAgICAgIHkgPSBoYWxmRG93bihhcmVhLnkgKyBhcmVhLmgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCwgYXJlYS55KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9KTtcbiAgICBpZiAoc3Ryb2tpbmcpIHtcbiAgICAgIGlmIChjdHguc2V0TGluZURhc2gpIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn07XG5cbmdyaWQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdyaWQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL2dyaWQuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///32\n");

/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__ = __webpack_require__(8);\n/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n/*global Dygraph:false */\n\n/*\nCurrent bits of jankiness:\n- Uses two private APIs:\n    1. Dygraph.optionsViewForAxis_\n    2. dygraph.plotter_.area\n- Registers for a \"predraw\" event, which should be renamed.\n- I call calculateEmWidthInDiv more often than needed.\n*/\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * Creates the legend, which appears when the user hovers over the chart.\n * The legend can be either a user-specified or generated div.\n *\n * @constructor\n */\nvar Legend = function Legend() {\n  this.legend_div_ = null;\n  this.is_generated_div_ = false; // do we own this div, or was it user-specified?\n};\n\nLegend.prototype.toString = function () {\n  return \"Legend Plugin\";\n};\n\n/**\n * This is called during the dygraph constructor, after options have been set\n * but before the data is available.\n *\n * Proper tasks to do here include:\n * - Reading your own options\n * - DOM manipulation\n * - Registering event listeners\n *\n * @param {Dygraph} g Graph instance.\n * @return {object.<string, function(ev)>} Mapping of event names to callbacks.\n */\nLegend.prototype.activate = function (g) {\n  var div;\n\n  var userLabelsDiv = g.getOption('labelsDiv');\n  if (userLabelsDiv && null !== userLabelsDiv) {\n    if (typeof userLabelsDiv == \"string\" || userLabelsDiv instanceof String) {\n      div = document.getElementById(userLabelsDiv);\n    } else {\n      div = userLabelsDiv;\n    }\n  } else {\n    div = document.createElement(\"div\");\n    div.className = \"dygraph-legend\";\n    // TODO(danvk): come up with a cleaner way to expose this.\n    g.graphDiv.appendChild(div);\n    this.is_generated_div_ = true;\n  }\n\n  this.legend_div_ = div;\n  this.one_em_width_ = 10; // just a guess, will be updated.\n\n  return {\n    select: this.select,\n    deselect: this.deselect,\n    // TODO(danvk): rethink the name \"predraw\" before we commit to it in any API.\n    predraw: this.predraw,\n    didDrawChart: this.didDrawChart\n  };\n};\n\n// Needed for dashed lines.\nvar calculateEmWidthInDiv = function calculateEmWidthInDiv(div) {\n  var sizeSpan = document.createElement('span');\n  sizeSpan.setAttribute('style', 'margin: 0; padding: 0 0 0 1em; border: 0;');\n  div.appendChild(sizeSpan);\n  var oneEmWidth = sizeSpan.offsetWidth;\n  div.removeChild(sizeSpan);\n  return oneEmWidth;\n};\n\nvar escapeHTML = function escapeHTML(str) {\n  return str.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n};\n\nLegend.prototype.select = function (e) {\n  var xValue = e.selectedX;\n  var points = e.selectedPoints;\n  var row = e.selectedRow;\n\n  var legendMode = e.dygraph.getOption('legend');\n  if (legendMode === 'never') {\n    this.legend_div_.style.display = 'none';\n    return;\n  }\n\n  if (legendMode === 'follow') {\n    // create floating legend div\n    var area = e.dygraph.plotter_.area;\n    var labelsDivWidth = this.legend_div_.offsetWidth;\n    var yAxisLabelWidth = e.dygraph.getOptionForAxis('axisLabelWidth', 'y');\n    // determine floating [left, top] coordinates of the legend div\n    // within the plotter_ area\n    // offset 50 px to the right and down from the first selection point\n    // 50 px is guess based on mouse cursor size\n    var leftLegend = points[0].x * area.w + 50;\n    var topLegend = points[0].y * area.h - 50;\n\n    // if legend floats to end of the chart area, it flips to the other\n    // side of the selection point\n    if (leftLegend + labelsDivWidth + 1 > area.w) {\n      leftLegend = leftLegend - 2 * 50 - labelsDivWidth - (yAxisLabelWidth - area.x);\n    }\n\n    e.dygraph.graphDiv.appendChild(this.legend_div_);\n    this.legend_div_.style.left = yAxisLabelWidth + leftLegend + \"px\";\n    this.legend_div_.style.top = topLegend + \"px\";\n  }\n\n  var html = Legend.generateLegendHTML(e.dygraph, xValue, points, this.one_em_width_, row);\n  this.legend_div_.innerHTML = html;\n  this.legend_div_.style.display = '';\n};\n\nLegend.prototype.deselect = function (e) {\n  var legendMode = e.dygraph.getOption('legend');\n  if (legendMode !== 'always') {\n    this.legend_div_.style.display = \"none\";\n  }\n\n  // Have to do this every time, since styles might have changed.\n  var oneEmWidth = calculateEmWidthInDiv(this.legend_div_);\n  this.one_em_width_ = oneEmWidth;\n\n  var html = Legend.generateLegendHTML(e.dygraph, undefined, undefined, oneEmWidth, null);\n  this.legend_div_.innerHTML = html;\n};\n\nLegend.prototype.didDrawChart = function (e) {\n  this.deselect(e);\n};\n\n// Right edge should be flush with the right edge of the charting area (which\n// may not be the same as the right edge of the div, if we have two y-axes.\n// TODO(danvk): is any of this really necessary? Could just set \"right\" in \"activate\".\n/**\n * Position the labels div so that:\n * - its right edge is flush with the right edge of the charting area\n * - its top edge is flush with the top edge of the charting area\n * @private\n */\nLegend.prototype.predraw = function (e) {\n  // Don't touch a user-specified labelsDiv.\n  if (!this.is_generated_div_) return;\n\n  // TODO(danvk): only use real APIs for this.\n  e.dygraph.graphDiv.appendChild(this.legend_div_);\n  var area = e.dygraph.getArea();\n  var labelsDivWidth = this.legend_div_.offsetWidth;\n  this.legend_div_.style.left = area.x + area.w - labelsDivWidth - 1 + \"px\";\n  this.legend_div_.style.top = area.y + \"px\";\n};\n\n/**\n * Called when dygraph.destroy() is called.\n * You should null out any references and detach any DOM elements.\n */\nLegend.prototype.destroy = function () {\n  this.legend_div_ = null;\n};\n\n/**\n * Generates HTML for the legend which is displayed when hovering over the\n * chart. If no selected points are specified, a default legend is returned\n * (this may just be the empty string).\n * @param {number} x The x-value of the selected points.\n * @param {Object} sel_points List of selected points for the given\n *   x-value. Should have properties like 'name', 'yval' and 'canvasy'.\n * @param {number} oneEmWidth The pixel width for 1em in the legend. Only\n *   relevant when displaying a legend with no selection (i.e. {legend:\n *   'always'}) and with dashed lines.\n * @param {number} row The selected row index.\n * @private\n */\nLegend.generateLegendHTML = function (g, x, sel_points, oneEmWidth, row) {\n  // Data about the selection to pass to legendFormatter\n  var data = {\n    dygraph: g,\n    x: x,\n    series: []\n  };\n\n  var labelToSeries = {};\n  var labels = g.getLabels();\n  if (labels) {\n    for (var i = 1; i < labels.length; i++) {\n      var series = g.getPropertiesForSeries(labels[i]);\n      var strokePattern = g.getOption('strokePattern', labels[i]);\n      var seriesData = {\n        dashHTML: generateLegendDashHTML(strokePattern, series.color, oneEmWidth),\n        label: labels[i],\n        labelHTML: escapeHTML(labels[i]),\n        isVisible: series.visible,\n        color: series.color\n      };\n\n      data.series.push(seriesData);\n      labelToSeries[labels[i]] = seriesData;\n    }\n  }\n\n  if (typeof x !== 'undefined') {\n    var xOptView = g.optionsViewForAxis_('x');\n    var xvf = xOptView('valueFormatter');\n    data.xHTML = xvf.call(g, x, xOptView, labels[0], g, row, 0);\n\n    var yOptViews = [];\n    var num_axes = g.numAxes();\n    for (var i = 0; i < num_axes; i++) {\n      // TODO(danvk): remove this use of a private API\n      yOptViews[i] = g.optionsViewForAxis_('y' + (i ? 1 + i : ''));\n    }\n\n    var showZeros = g.getOption('labelsShowZeroValues');\n    var highlightSeries = g.getHighlightSeries();\n    for (i = 0; i < sel_points.length; i++) {\n      var pt = sel_points[i];\n      var seriesData = labelToSeries[pt.name];\n      seriesData.y = pt.yval;\n\n      if (pt.yval === 0 && !showZeros || isNaN(pt.canvasy)) {\n        seriesData.isVisible = false;\n        continue;\n      }\n\n      var series = g.getPropertiesForSeries(pt.name);\n      var yOptView = yOptViews[series.axis - 1];\n      var fmtFunc = yOptView('valueFormatter');\n      var yHTML = fmtFunc.call(g, pt.yval, yOptView, pt.name, g, row, labels.indexOf(pt.name));\n\n      __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"a\" /* update */](seriesData, { yHTML: yHTML });\n\n      if (pt.name == highlightSeries) {\n        seriesData.isHighlighted = true;\n      }\n    }\n  }\n\n  var formatter = g.getOption('legendFormatter') || Legend.defaultFormatter;\n  return formatter.call(g, data);\n};\n\nLegend.defaultFormatter = function (data) {\n  var g = data.dygraph;\n\n  // TODO(danvk): deprecate this option in place of {legend: 'never'}\n  // XXX should this logic be in the formatter?\n  if (g.getOption('showLabelsOnHighlight') !== true) return '';\n\n  var sepLines = g.getOption('labelsSeparateLines');\n  var html;\n\n  if (typeof data.x === 'undefined') {\n    // TODO: this check is duplicated in generateLegendHTML. Put it in one place.\n    if (g.getOption('legend') != 'always') {\n      return '';\n    }\n\n    html = '';\n    for (var i = 0; i < data.series.length; i++) {\n      var series = data.series[i];\n      if (!series.isVisible) continue;\n\n      if (html !== '') html += sepLines ? '<br/>' : ' ';\n      html += \"<span style='font-weight: bold; color: \" + series.color + \";'>\" + series.dashHTML + \" \" + series.labelHTML + \"</span>\";\n    }\n    return html;\n  }\n\n  html = data.xHTML + ':';\n  for (var i = 0; i < data.series.length; i++) {\n    var series = data.series[i];\n    if (!series.isVisible) continue;\n    if (sepLines) html += '<br>';\n    var cls = series.isHighlighted ? ' class=\"highlight\"' : '';\n    html += \"<span\" + cls + \"> <b><span style='color: \" + series.color + \";'>\" + series.labelHTML + \"</span></b>:&#160;\" + series.yHTML + \"</span>\";\n  }\n  return html;\n};\n\n/**\n * Generates html for the \"dash\" displayed on the legend when using \"legend: always\".\n * In particular, this works for dashed lines with any stroke pattern. It will\n * try to scale the pattern to fit in 1em width. Or if small enough repeat the\n * pattern for 1em width.\n *\n * @param strokePattern The pattern\n * @param color The color of the series.\n * @param oneEmWidth The width in pixels of 1em in the legend.\n * @private\n */\n// TODO(danvk): cache the results of this\nfunction generateLegendDashHTML(strokePattern, color, oneEmWidth) {\n  // Easy, common case: a solid line\n  if (!strokePattern || strokePattern.length <= 1) {\n    return \"<div class=\\\"dygraph-legend-line\\\" style=\\\"border-bottom-color: \" + color + \";\\\"></div>\";\n  }\n\n  var i, j, paddingLeft, marginRight;\n  var strokePixelLength = 0,\n      segmentLoop = 0;\n  var normalizedPattern = [];\n  var loop;\n\n  // Compute the length of the pixels including the first segment twice, \n  // since we repeat it.\n  for (i = 0; i <= strokePattern.length; i++) {\n    strokePixelLength += strokePattern[i % strokePattern.length];\n  }\n\n  // See if we can loop the pattern by itself at least twice.\n  loop = Math.floor(oneEmWidth / (strokePixelLength - strokePattern[0]));\n  if (loop > 1) {\n    // This pattern fits at least two times, no scaling just convert to em;\n    for (i = 0; i < strokePattern.length; i++) {\n      normalizedPattern[i] = strokePattern[i] / oneEmWidth;\n    }\n    // Since we are repeating the pattern, we don't worry about repeating the\n    // first segment in one draw.\n    segmentLoop = normalizedPattern.length;\n  } else {\n    // If the pattern doesn't fit in the legend we scale it to fit.\n    loop = 1;\n    for (i = 0; i < strokePattern.length; i++) {\n      normalizedPattern[i] = strokePattern[i] / strokePixelLength;\n    }\n    // For the scaled patterns we do redraw the first segment.\n    segmentLoop = normalizedPattern.length + 1;\n  }\n\n  // Now make the pattern.\n  var dash = \"\";\n  for (j = 0; j < loop; j++) {\n    for (i = 0; i < segmentLoop; i += 2) {\n      // The padding is the drawn segment.\n      paddingLeft = normalizedPattern[i % normalizedPattern.length];\n      if (i < strokePattern.length) {\n        // The margin is the space segment.\n        marginRight = normalizedPattern[(i + 1) % normalizedPattern.length];\n      } else {\n        // The repeated first segment has no right margin.\n        marginRight = 0;\n      }\n      dash += \"<div class=\\\"dygraph-legend-dash\\\" style=\\\"margin-right: \" + marginRight + \"em; padding-left: \" + paddingLeft + \"em;\\\"></div>\";\n    }\n  }\n  return dash;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Legend);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL2xlZ2VuZC5qcz8wNjFkIl0sIm5hbWVzIjpbIkxlZ2VuZCIsImxlZ2VuZF9kaXZfIiwiaXNfZ2VuZXJhdGVkX2Rpdl8iLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImFjdGl2YXRlIiwiZyIsImRpdiIsInVzZXJMYWJlbHNEaXYiLCJnZXRPcHRpb24iLCJTdHJpbmciLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImdyYXBoRGl2IiwiYXBwZW5kQ2hpbGQiLCJvbmVfZW1fd2lkdGhfIiwic2VsZWN0IiwiZGVzZWxlY3QiLCJwcmVkcmF3IiwiZGlkRHJhd0NoYXJ0IiwiY2FsY3VsYXRlRW1XaWR0aEluRGl2Iiwic2l6ZVNwYW4iLCJzZXRBdHRyaWJ1dGUiLCJvbmVFbVdpZHRoIiwib2Zmc2V0V2lkdGgiLCJyZW1vdmVDaGlsZCIsImVzY2FwZUhUTUwiLCJzdHIiLCJyZXBsYWNlIiwiZSIsInhWYWx1ZSIsInNlbGVjdGVkWCIsInBvaW50cyIsInNlbGVjdGVkUG9pbnRzIiwicm93Iiwic2VsZWN0ZWRSb3ciLCJsZWdlbmRNb2RlIiwiZHlncmFwaCIsInN0eWxlIiwiZGlzcGxheSIsImFyZWEiLCJwbG90dGVyXyIsImxhYmVsc0RpdldpZHRoIiwieUF4aXNMYWJlbFdpZHRoIiwiZ2V0T3B0aW9uRm9yQXhpcyIsImxlZnRMZWdlbmQiLCJ4IiwidyIsInRvcExlZ2VuZCIsInkiLCJoIiwibGVmdCIsInRvcCIsImh0bWwiLCJnZW5lcmF0ZUxlZ2VuZEhUTUwiLCJpbm5lckhUTUwiLCJ1bmRlZmluZWQiLCJnZXRBcmVhIiwiZGVzdHJveSIsInNlbF9wb2ludHMiLCJkYXRhIiwic2VyaWVzIiwibGFiZWxUb1NlcmllcyIsImxhYmVscyIsImdldExhYmVscyIsImkiLCJsZW5ndGgiLCJnZXRQcm9wZXJ0aWVzRm9yU2VyaWVzIiwic3Ryb2tlUGF0dGVybiIsInNlcmllc0RhdGEiLCJkYXNoSFRNTCIsImdlbmVyYXRlTGVnZW5kRGFzaEhUTUwiLCJjb2xvciIsImxhYmVsIiwibGFiZWxIVE1MIiwiaXNWaXNpYmxlIiwidmlzaWJsZSIsInB1c2giLCJ4T3B0VmlldyIsIm9wdGlvbnNWaWV3Rm9yQXhpc18iLCJ4dmYiLCJ4SFRNTCIsImNhbGwiLCJ5T3B0Vmlld3MiLCJudW1fYXhlcyIsIm51bUF4ZXMiLCJzaG93WmVyb3MiLCJoaWdobGlnaHRTZXJpZXMiLCJnZXRIaWdobGlnaHRTZXJpZXMiLCJwdCIsIm5hbWUiLCJ5dmFsIiwiaXNOYU4iLCJjYW52YXN5IiwieU9wdFZpZXciLCJheGlzIiwiZm10RnVuYyIsInlIVE1MIiwiaW5kZXhPZiIsInV0aWxzIiwiaXNIaWdobGlnaHRlZCIsImZvcm1hdHRlciIsImRlZmF1bHRGb3JtYXR0ZXIiLCJzZXBMaW5lcyIsImNscyIsImoiLCJwYWRkaW5nTGVmdCIsIm1hcmdpblJpZ2h0Iiwic3Ryb2tlUGl4ZWxMZW5ndGgiLCJzZWdtZW50TG9vcCIsIm5vcm1hbGl6ZWRQYXR0ZXJuIiwibG9vcCIsIk1hdGgiLCJmbG9vciIsImRhc2giXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Ozs7O0FBS0E7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0E7O0FBRUE7O0FBR0E7Ozs7OztBQU1BLElBQUlBLFNBQVMsU0FBVEEsTUFBUyxHQUFXO0FBQ3RCLE9BQUtDLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxPQUFLQyxpQkFBTCxHQUF5QixLQUF6QixDQUZzQixDQUVXO0FBQ2xDLENBSEQ7O0FBS0FGLE9BQU9HLFNBQVAsQ0FBaUJDLFFBQWpCLEdBQTRCLFlBQVc7QUFDckMsU0FBTyxlQUFQO0FBQ0QsQ0FGRDs7QUFJQTs7Ozs7Ozs7Ozs7O0FBWUFKLE9BQU9HLFNBQVAsQ0FBaUJFLFFBQWpCLEdBQTRCLFVBQVNDLENBQVQsRUFBWTtBQUN0QyxNQUFJQyxHQUFKOztBQUVBLE1BQUlDLGdCQUFnQkYsRUFBRUcsU0FBRixDQUFZLFdBQVosQ0FB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c2VcbiAqIENvcHlyaWdodCAyMDEyIERhbiBWYW5kZXJrYW0gKGRhbnZka0BnbWFpbC5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblxuLypcbkN1cnJlbnQgYml0cyBvZiBqYW5raW5lc3M6XG4tIFVzZXMgdHdvIHByaXZhdGUgQVBJczpcbiAgICAxLiBEeWdyYXBoLm9wdGlvbnNWaWV3Rm9yQXhpc19cbiAgICAyLiBkeWdyYXBoLnBsb3R0ZXJfLmFyZWFcbi0gUmVnaXN0ZXJzIGZvciBhIFwicHJlZHJhd1wiIGV2ZW50LCB3aGljaCBzaG91bGQgYmUgcmVuYW1lZC5cbi0gSSBjYWxsIGNhbGN1bGF0ZUVtV2lkdGhJbkRpdiBtb3JlIG9mdGVuIHRoYW4gbmVlZGVkLlxuKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL2R5Z3JhcGgtdXRpbHMnO1xuXG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgbGVnZW5kLCB3aGljaCBhcHBlYXJzIHdoZW4gdGhlIHVzZXIgaG92ZXJzIG92ZXIgdGhlIGNoYXJ0LlxuICogVGhlIGxlZ2VuZCBjYW4gYmUgZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgb3IgZ2VuZXJhdGVkIGRpdi5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIExlZ2VuZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxlZ2VuZF9kaXZfID0gbnVsbDtcbiAgdGhpcy5pc19nZW5lcmF0ZWRfZGl2XyA9IGZhbHNlOyAgLy8gZG8gd2Ugb3duIHRoaXMgZGl2LCBvciB3YXMgaXQgdXNlci1zcGVjaWZpZWQ/XG59O1xuXG5MZWdlbmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBcIkxlZ2VuZCBQbHVnaW5cIjtcbn07XG5cbi8qKlxuICogVGhpcyBpcyBjYWxsZWQgZHVyaW5nIHRoZSBkeWdyYXBoIGNvbnN0cnVjdG9yLCBhZnRlciBvcHRpb25zIGhhdmUgYmVlbiBzZXRcbiAqIGJ1dCBiZWZvcmUgdGhlIGRhdGEgaXMgYXZhaWxhYmxlLlxuICpcbiAqIFByb3BlciB0YXNrcyB0byBkbyBoZXJlIGluY2x1ZGU6XG4gKiAtIFJlYWRpbmcgeW91ciBvd24gb3B0aW9uc1xuICogLSBET00gbWFuaXB1bGF0aW9uXG4gKiAtIFJlZ2lzdGVyaW5nIGV2ZW50IGxpc3RlbmVyc1xuICpcbiAqIEBwYXJhbSB7RHlncmFwaH0gZyBHcmFwaCBpbnN0YW5jZS5cbiAqIEByZXR1cm4ge29iamVjdC48c3RyaW5nLCBmdW5jdGlvbihldik+fSBNYXBwaW5nIG9mIGV2ZW50IG5hbWVzIHRvIGNhbGxiYWNrcy5cbiAqL1xuTGVnZW5kLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKGcpIHtcbiAgdmFyIGRpdjtcblxuICB2YXIgdXNlckxhYmVsc0RpdiA9IGcuZ2V0T3B0aW9uKCdsYWJlbHNEaXYnKTtcbiAgaWYgKHVzZXJMYWJlbHNEaXYgJiYgbnVsbCAhPT0gdXNlckxhYmVsc0Rpdikge1xuICAgIGlmICh0eXBlb2YodXNlckxhYmVsc0RpdikgPT0gXCJzdHJpbmdcIiB8fCB1c2VyTGFiZWxzRGl2IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICBkaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh1c2VyTGFiZWxzRGl2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGl2ID0gdXNlckxhYmVsc0RpdjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuY2xhc3NOYW1lID0gXCJkeWdyYXBoLWxlZ2VuZFwiO1xuICAgIC8vIFRPRE8oZGFudmspOiBjb21lIHVwIHdpdGggYSBjbGVhbmVyIHdheSB0byBleHBvc2UgdGhpcy5cbiAgICBnLmdyYXBoRGl2LmFwcGVuZENoaWxkKGRpdik7XG4gICAgdGhpcy5pc19nZW5lcmF0ZWRfZGl2XyA9IHRydWU7XG4gIH1cblxuICB0aGlzLmxlZ2VuZF9kaXZfID0gZGl2O1xuICB0aGlzLm9uZV9lbV93aWR0aF8gPSAxMDsgIC8vIGp1c3QgYSBndWVzcywgd2lsbCBiZSB1cGRhdGVkLlxuXG4gIHJldHVybiB7XG4gICAgc2VsZWN0OiB0aGlzLnNlbGVjdCxcbiAgICBkZXNlbGVjdDogdGhpcy5kZXNlbGVjdCxcbiAgICAvLyBUT0RPKGRhbnZrKTogcmV0aGluayB0aGUgbmFtZSBcInByZWRyYXdcIiBiZWZvcmUgd2UgY29tbWl0IHRvIGl0IGluIGFueSBBUEkuXG4gICAgcHJlZHJhdzogdGhpcy5wcmVkcmF3LFxuICAgIGRpZERyYXdDaGFydDogdGhpcy5kaWREcmF3Q2hhcnRcbiAgfTtcbn07XG5cbi8vIE5lZWRlZCBmb3IgZGFzaGVkIGxpbmVzLlxudmFyIGNhbGN1bGF0ZUVtV2lkdGhJbkRpdiA9IGZ1bmN0aW9uKGRpdikge1xuICB2YXIgc2l6ZVNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIHNpemVTcGFuLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnbWFyZ2luOiAwOyBwYWRkaW5nOiAwIDAgMCAxZW07IGJvcmRlcjogMDsnKTtcbiAgZGl2LmFwcGVuZENoaWxkKHNpemVTcGFuKTtcbiAgdmFyIG9uZUVtV2lkdGg9c2l6ZVNwYW4ub2Zmc2V0V2lkdGg7XG4gIGRpdi5yZW1vdmVDaGlsZChzaXplU3Bhbik7XG4gIHJldHVybiBvbmVFbVdpZHRoO1xufTtcblxudmFyIGVzY2FwZUhUTUwgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIikucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIikucmVwbGFjZSgvPC9nLCBcIiZsdDtcIikucmVwbGFjZSgvPi9nLCBcIiZndDtcIik7XG59O1xuXG5MZWdlbmQucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHhWYWx1ZSA9IGUuc2VsZWN0ZWRYO1xuICB2YXIgcG9pbnRzID0gZS5zZWxlY3RlZFBvaW50cztcbiAgdmFyIHJvdyA9IGUuc2VsZWN0ZWRSb3c7XG5cbiAgdmFyIGxlZ2VuZE1vZGUgPSBlLmR5Z3JhcGguZ2V0T3B0aW9uKCdsZWdlbmQnKTtcbiAgaWYgKGxlZ2VuZE1vZGUgPT09ICduZXZlcicpIHtcbiAgICB0aGlzLmxlZ2VuZF9kaXZfLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGxlZ2VuZE1vZGUgPT09ICdmb2xsb3cnKSB7XG4gICAgLy8gY3JlYXRlIGZsb2F0aW5nIGxlZ2VuZCBkaXZcbiAgICB2YXIgYXJlYSA9IGUuZHlncmFwaC5wbG90dGVyXy5hcmVhO1xuICAgIHZhciBsYWJlbHNEaXZXaWR0aCA9IHRoaXMubGVnZW5kX2Rpdl8ub2Zmc2V0V2lkdGg7XG4gICAgdmFyIHlBeGlzTGFiZWxXaWR0aCA9IGUuZHlncmFwaC5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGFiZWxXaWR0aCcsICd5Jyk7XG4gICAgLy8gZGV0ZXJtaW5lIGZsb2F0aW5nIFtsZWZ0LCB0b3BdIGNvb3JkaW5hdGVzIG9mIHRoZSBsZWdlbmQgZGl2XG4gICAgLy8gd2l0aGluIHRoZSBwbG90dGVyXyBhcmVhXG4gICAgLy8gb2Zmc2V0IDUwIHB4IHRvIHRoZSByaWdodCBhbmQgZG93biBmcm9tIHRoZSBmaXJzdCBzZWxlY3Rpb24gcG9pbnRcbiAgICAvLyA1MCBweCBpcyBndWVzcyBiYXNlZCBvbiBtb3VzZSBjdXJzb3Igc2l6ZVxuICAgIHZhciBsZWZ0TGVnZW5kID0gcG9pbnRzWzBdLnggKiBhcmVhLncgKyA1MDtcbiAgICB2YXIgdG9wTGVnZW5kICA9IHBvaW50c1swXS55ICogYXJlYS5oIC0gNTA7XG5cbiAgICAvLyBpZiBsZWdlbmQgZmxvYXRzIHRvIGVuZCBvZiB0aGUgY2hhcnQgYXJlYSwgaXQgZmxpcHMgdG8gdGhlIG90aGVyXG4gICAgLy8gc2lkZSBvZiB0aGUgc2VsZWN0aW9uIHBvaW50XG4gICAgaWYgKChsZWZ0TGVnZW5kICsgbGFiZWxzRGl2V2lkdGggKyAxKSA+IGFyZWEudykge1xuICAgICAgbGVmdExlZ2VuZCA9IGxlZnRMZWdlbmQgLSAyICogNTAgLSBsYWJlbHNEaXZXaWR0aCAtICh5QXhpc0xhYmVsV2lkdGggLSBhcmVhLngpO1xuICAgIH1cblxuICAgIGUuZHlncmFwaC5ncmFwaERpdi5hcHBlbmRDaGlsZCh0aGlzLmxlZ2VuZF9kaXZfKTtcbiAgICB0aGlzLmxlZ2VuZF9kaXZfLnN0eWxlLmxlZnQgPSB5QXhpc0xhYmVsV2lkdGggKyBsZWZ0TGVnZW5kICsgXCJweFwiO1xuICAgIHRoaXMubGVnZW5kX2Rpdl8uc3R5bGUudG9wID0gdG9wTGVnZW5kICsgXCJweFwiO1xuICB9XG5cbiAgdmFyIGh0bWwgPSBMZWdlbmQuZ2VuZXJhdGVMZWdlbmRIVE1MKGUuZHlncmFwaCwgeFZhbHVlLCBwb2ludHMsIHRoaXMub25lX2VtX3dpZHRoXywgcm93KTtcbiAgdGhpcy5sZWdlbmRfZGl2Xy5pbm5lckhUTUwgPSBodG1sO1xuICB0aGlzLmxlZ2VuZF9kaXZfLnN0eWxlLmRpc3BsYXkgPSAnJztcbn07XG5cbkxlZ2VuZC5wcm90b3R5cGUuZGVzZWxlY3QgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBsZWdlbmRNb2RlID0gZS5keWdyYXBoLmdldE9wdGlvbignbGVnZW5kJyk7XG4gIGlmIChsZWdlbmRNb2RlICE9PSAnYWx3YXlzJykge1xuICAgIHRoaXMubGVnZW5kX2Rpdl8uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICB9XG5cbiAgLy8gSGF2ZSB0byBkbyB0aGlzIGV2ZXJ5IHRpbWUsIHNpbmNlIHN0eWxlcyBtaWdodCBoYXZlIGNoYW5nZWQuXG4gIHZhciBvbmVFbVdpZHRoID0gY2FsY3VsYXRlRW1XaWR0aEluRGl2KHRoaXMubGVnZW5kX2Rpdl8pO1xuICB0aGlzLm9uZV9lbV93aWR0aF8gPSBvbmVFbVdpZHRoO1xuXG4gIHZhciBodG1sID0gTGVnZW5kLmdlbmVyYXRlTGVnZW5kSFRNTChlLmR5Z3JhcGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbmVFbVdpZHRoLCBudWxsKTtcbiAgdGhpcy5sZWdlbmRfZGl2Xy5pbm5lckhUTUwgPSBodG1sO1xufTtcblxuTGVnZW5kLnByb3RvdHlwZS5kaWREcmF3Q2hhcnQgPSBmdW5jdGlvbihlKSB7XG4gIHRoaXMuZGVzZWxlY3QoZSk7XG59O1xuXG4vLyBSaWdodCBlZGdlIHNob3VsZCBiZSBmbHVzaCB3aXRoIHRoZSByaWdodCBlZGdlIG9mIHRoZSBjaGFydGluZyBhcmVhICh3aGljaFxuLy8gbWF5IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgZGl2LCBpZiB3ZSBoYXZlIHR3byB5LWF4ZXMuXG4vLyBUT0RPKGRhbnZrKTogaXMgYW55IG9mIHRoaXMgcmVhbGx5IG5lY2Vzc2FyeT8gQ291bGQganVzdCBzZXQgXCJyaWdodFwiIGluIFwiYWN0aXZhdGVcIi5cbi8qKlxuICogUG9zaXRpb24gdGhlIGxhYmVscyBkaXYgc28gdGhhdDpcbiAqIC0gaXRzIHJpZ2h0IGVkZ2UgaXMgZmx1c2ggd2l0aCB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgY2hhcnRpbmcgYXJlYVxuICogLSBpdHMgdG9wIGVkZ2UgaXMgZmx1c2ggd2l0aCB0aGUgdG9wIGVkZ2Ugb2YgdGhlIGNoYXJ0aW5nIGFyZWFcbiAqIEBwcml2YXRlXG4gKi9cbkxlZ2VuZC5wcm90b3R5cGUucHJlZHJhdyA9IGZ1bmN0aW9uKGUpIHtcbiAgLy8gRG9uJ3QgdG91Y2ggYSB1c2VyLXNwZWNpZmllZCBsYWJlbHNEaXYuXG4gIGlmICghdGhpcy5pc19nZW5lcmF0ZWRfZGl2XykgcmV0dXJuO1xuXG4gIC8vIFRPRE8oZGFudmspOiBvbmx5IHVzZSByZWFsIEFQSXMgZm9yIHRoaXMuXG4gIGUuZHlncmFwaC5ncmFwaERpdi5hcHBlbmRDaGlsZCh0aGlzLmxlZ2VuZF9kaXZfKTtcbiAgdmFyIGFyZWEgPSBlLmR5Z3JhcGguZ2V0QXJlYSgpO1xuICB2YXIgbGFiZWxzRGl2V2lkdGggPSB0aGlzLmxlZ2VuZF9kaXZfLm9mZnNldFdpZHRoO1xuICB0aGlzLmxlZ2VuZF9kaXZfLnN0eWxlLmxlZnQgPSBhcmVhLnggKyBhcmVhLncgLSBsYWJlbHNEaXZXaWR0aCAtIDEgKyBcInB4XCI7XG4gIHRoaXMubGVnZW5kX2Rpdl8uc3R5bGUudG9wID0gYXJlYS55ICsgXCJweFwiO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBkeWdyYXBoLmRlc3Ryb3koKSBpcyBjYWxsZWQuXG4gKiBZb3Ugc2hvdWxkIG51bGwgb3V0IGFueSByZWZlcmVuY2VzIGFuZCBkZXRhY2ggYW55IERPTSBlbGVtZW50cy5cbiAqL1xuTGVnZW5kLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubGVnZW5kX2Rpdl8gPSBudWxsO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgSFRNTCBmb3IgdGhlIGxlZ2VuZCB3aGljaCBpcyBkaXNwbGF5ZWQgd2hlbiBob3ZlcmluZyBvdmVyIHRoZVxuICogY2hhcnQuIElmIG5vIHNlbGVjdGVkIHBvaW50cyBhcmUgc3BlY2lmaWVkLCBhIGRlZmF1bHQgbGVnZW5kIGlzIHJldHVybmVkXG4gKiAodGhpcyBtYXkganVzdCBiZSB0aGUgZW1wdHkgc3RyaW5nKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSB4LXZhbHVlIG9mIHRoZSBzZWxlY3RlZCBwb2ludHMuXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsX3BvaW50cyBMaXN0IG9mIHNlbGVjdGVkIHBvaW50cyBmb3IgdGhlIGdpdmVuXG4gKiAgIHgtdmFsdWUuIFNob3VsZCBoYXZlIHByb3BlcnRpZXMgbGlrZSAnbmFtZScsICd5dmFsJyBhbmQgJ2NhbnZhc3knLlxuICogQHBhcmFtIHtudW1iZXJ9IG9uZUVtV2lkdGggVGhlIHBpeGVsIHdpZHRoIGZvciAxZW0gaW4gdGhlIGxlZ2VuZC4gT25seVxuICogICByZWxldmFudCB3aGVuIGRpc3BsYXlpbmcgYSBsZWdlbmQgd2l0aCBubyBzZWxlY3Rpb24gKGkuZS4ge2xlZ2VuZDpcbiAqICAgJ2Fsd2F5cyd9KSBhbmQgd2l0aCBkYXNoZWQgbGluZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gcm93IFRoZSBzZWxlY3RlZCByb3cgaW5kZXguXG4gKiBAcHJpdmF0ZVxuICovXG5MZWdlbmQuZ2VuZXJhdGVMZWdlbmRIVE1MID0gZnVuY3Rpb24oZywgeCwgc2VsX3BvaW50cywgb25lRW1XaWR0aCwgcm93KSB7XG4gIC8vIERhdGEgYWJvdXQgdGhlIHNlbGVjdGlvbiB0byBwYXNzIHRvIGxlZ2VuZEZvcm1hdHRlclxuICB2YXIgZGF0YSA9IHtcbiAgICBkeWdyYXBoOiBnLFxuICAgIHg6IHgsXG4gICAgc2VyaWVzOiBbXVxuICB9O1xuXG4gIHZhciBsYWJlbFRvU2VyaWVzID0ge307XG4gIHZhciBsYWJlbHMgPSBnLmdldExhYmVscygpO1xuICBpZiAobGFiZWxzKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZXJpZXMgPSBnLmdldFByb3BlcnRpZXNGb3JTZXJpZXMobGFiZWxzW2ldKTtcbiAgICAgIHZhciBzdHJva2VQYXR0ZXJuID0gZy5nZXRPcHRpb24oJ3N0cm9rZVBhdHRlcm4nLCBsYWJlbHNbaV0pO1xuICAgICAgdmFyIHNlcmllc0RhdGEgPSB7XG4gICAgICAgIGRhc2hIVE1MOiBnZW5lcmF0ZUxlZ2VuZERhc2hIVE1MKHN0cm9rZVBhdHRlcm4sIHNlcmllcy5jb2xvciwgb25lRW1XaWR0aCksXG4gICAgICAgIGxhYmVsOiBsYWJlbHNbaV0sXG4gICAgICAgIGxhYmVsSFRNTDogZXNjYXBlSFRNTChsYWJlbHNbaV0pLFxuICAgICAgICBpc1Zpc2libGU6IHNlcmllcy52aXNpYmxlLFxuICAgICAgICBjb2xvcjogc2VyaWVzLmNvbG9yXG4gICAgICB9O1xuXG4gICAgICBkYXRhLnNlcmllcy5wdXNoKHNlcmllc0RhdGEpO1xuICAgICAgbGFiZWxUb1Nlcmllc1tsYWJlbHNbaV1dID0gc2VyaWVzRGF0YTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mKHgpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciB4T3B0VmlldyA9IGcub3B0aW9uc1ZpZXdGb3JBeGlzXygneCcpO1xuICAgIHZhciB4dmYgPSB4T3B0VmlldygndmFsdWVGb3JtYXR0ZXInKTtcbiAgICBkYXRhLnhIVE1MID0geHZmLmNhbGwoZywgeCwgeE9wdFZpZXcsIGxhYmVsc1swXSwgZywgcm93LCAwKTtcblxuICAgIHZhciB5T3B0Vmlld3MgPSBbXTtcbiAgICB2YXIgbnVtX2F4ZXMgPSBnLm51bUF4ZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9heGVzOyBpKyspIHtcbiAgICAgIC8vIFRPRE8oZGFudmspOiByZW1vdmUgdGhpcyB1c2Ugb2YgYSBwcml2YXRlIEFQSVxuICAgICAgeU9wdFZpZXdzW2ldID0gZy5vcHRpb25zVmlld0ZvckF4aXNfKCd5JyArIChpID8gMSArIGkgOiAnJykpO1xuICAgIH1cblxuICAgIHZhciBzaG93WmVyb3MgPSBnLmdldE9wdGlvbignbGFiZWxzU2hvd1plcm9WYWx1ZXMnKTtcbiAgICB2YXIgaGlnaGxpZ2h0U2VyaWVzID0gZy5nZXRIaWdobGlnaHRTZXJpZXMoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VsX3BvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHB0ID0gc2VsX3BvaW50c1tpXTtcbiAgICAgIHZhciBzZXJpZXNEYXRhID0gbGFiZWxUb1Nlcmllc1twdC5uYW1lXTtcbiAgICAgIHNlcmllc0RhdGEueSA9IHB0Lnl2YWw7XG5cbiAgICAgIGlmICgocHQueXZhbCA9PT0gMCAmJiAhc2hvd1plcm9zKSB8fCBpc05hTihwdC5jYW52YXN5KSkge1xuICAgICAgICBzZXJpZXNEYXRhLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlcmllcyA9IGcuZ2V0UHJvcGVydGllc0ZvclNlcmllcyhwdC5uYW1lKTtcbiAgICAgIHZhciB5T3B0VmlldyA9IHlPcHRWaWV3c1tzZXJpZXMuYXhpcyAtIDFdO1xuICAgICAgdmFyIGZtdEZ1bmMgPSB5T3B0VmlldygndmFsdWVGb3JtYXR0ZXInKTtcbiAgICAgIHZhciB5SFRNTCA9IGZtdEZ1bmMuY2FsbChnLCBwdC55dmFsLCB5T3B0VmlldywgcHQubmFtZSwgZywgcm93LCBsYWJlbHMuaW5kZXhPZihwdC5uYW1lKSk7XG5cbiAgICAgIHV0aWxzLnVwZGF0ZShzZXJpZXNEYXRhLCB7eUhUTUx9KTtcblxuICAgICAgaWYgKHB0Lm5hbWUgPT0gaGlnaGxpZ2h0U2VyaWVzKSB7XG4gICAgICAgIHNlcmllc0RhdGEuaXNIaWdobGlnaHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGZvcm1hdHRlciA9IChnLmdldE9wdGlvbignbGVnZW5kRm9ybWF0dGVyJykgfHwgTGVnZW5kLmRlZmF1bHRGb3JtYXR0ZXIpO1xuICByZXR1cm4gZm9ybWF0dGVyLmNhbGwoZywgZGF0YSk7XG59XG5cbkxlZ2VuZC5kZWZhdWx0Rm9ybWF0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgZyA9IGRhdGEuZHlncmFwaDtcblxuICAvLyBUT0RPKGRhbnZrKTogZGVwcmVjYXRlIHRoaXMgb3B0aW9uIGluIHBsYWNlIG9mIHtsZWdlbmQ6ICduZXZlcid9XG4gIC8vIFhYWCBzaG91bGQgdGhpcyBsb2dpYyBiZSBpbiB0aGUgZm9ybWF0dGVyP1xuICBpZiAoZy5nZXRPcHRpb24oJ3Nob3dMYWJlbHNPbkhpZ2hsaWdodCcpICE9PSB0cnVlKSByZXR1cm4gJyc7XG5cbiAgdmFyIHNlcExpbmVzID0gZy5nZXRPcHRpb24oJ2xhYmVsc1NlcGFyYXRlTGluZXMnKTtcbiAgdmFyIGh0bWw7XG5cbiAgaWYgKHR5cGVvZihkYXRhLngpID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIFRPRE86IHRoaXMgY2hlY2sgaXMgZHVwbGljYXRlZCBpbiBnZW5lcmF0ZUxlZ2VuZEhUTUwuIFB1dCBpdCBpbiBvbmUgcGxhY2UuXG4gICAgaWYgKGcuZ2V0T3B0aW9uKCdsZWdlbmQnKSAhPSAnYWx3YXlzJykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGh0bWwgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VyaWVzID0gZGF0YS5zZXJpZXNbaV07XG4gICAgICBpZiAoIXNlcmllcy5pc1Zpc2libGUpIGNvbnRpbnVlO1xuXG4gICAgICBpZiAoaHRtbCAhPT0gJycpIGh0bWwgKz0gKHNlcExpbmVzID8gJzxici8+JyA6ICcgJyk7XG4gICAgICBodG1sICs9IGA8c3BhbiBzdHlsZT0nZm9udC13ZWlnaHQ6IGJvbGQ7IGNvbG9yOiAke3Nlcmllcy5jb2xvcn07Jz4ke3Nlcmllcy5kYXNoSFRNTH0gJHtzZXJpZXMubGFiZWxIVE1MfTwvc3Bhbj5gO1xuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbiAgfVxuXG4gIGh0bWwgPSBkYXRhLnhIVE1MICsgJzonO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlcmllcyA9IGRhdGEuc2VyaWVzW2ldO1xuICAgIGlmICghc2VyaWVzLmlzVmlzaWJsZSkgY29udGludWU7XG4gICAgaWYgKHNlcExpbmVzKSBodG1sICs9ICc8YnI+JztcbiAgICB2YXIgY2xzID0gc2VyaWVzLmlzSGlnaGxpZ2h0ZWQgPyAnIGNsYXNzPVwiaGlnaGxpZ2h0XCInIDogJyc7XG4gICAgaHRtbCArPSBgPHNwYW4ke2Nsc30+IDxiPjxzcGFuIHN0eWxlPSdjb2xvcjogJHtzZXJpZXMuY29sb3J9Oyc+JHtzZXJpZXMubGFiZWxIVE1MfTwvc3Bhbj48L2I+OiYjMTYwOyR7c2VyaWVzLnlIVE1MfTwvc3Bhbj5gO1xuICB9XG4gIHJldHVybiBodG1sO1xufTtcblxuXG4vKipcbiAqIEdlbmVyYXRlcyBodG1sIGZvciB0aGUgXCJkYXNoXCIgZGlzcGxheWVkIG9uIHRoZSBsZWdlbmQgd2hlbiB1c2luZyBcImxlZ2VuZDogYWx3YXlzXCIuXG4gKiBJbiBwYXJ0aWN1bGFyLCB0aGlzIHdvcmtzIGZvciBkYXNoZWQgbGluZXMgd2l0aCBhbnkgc3Ryb2tlIHBhdHRlcm4uIEl0IHdpbGxcbiAqIHRyeSB0byBzY2FsZSB0aGUgcGF0dGVybiB0byBmaXQgaW4gMWVtIHdpZHRoLiBPciBpZiBzbWFsbCBlbm91Z2ggcmVwZWF0IHRoZVxuICogcGF0dGVybiBmb3IgMWVtIHdpZHRoLlxuICpcbiAqIEBwYXJhbSBzdHJva2VQYXR0ZXJuIFRoZSBwYXR0ZXJuXG4gKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSBzZXJpZXMuXG4gKiBAcGFyYW0gb25lRW1XaWR0aCBUaGUgd2lkdGggaW4gcGl4ZWxzIG9mIDFlbSBpbiB0aGUgbGVnZW5kLlxuICogQHByaXZhdGVcbiAqL1xuLy8gVE9ETyhkYW52ayk6IGNhY2hlIHRoZSByZXN1bHRzIG9mIHRoaXNcbmZ1bmN0aW9uIGdlbmVyYXRlTGVnZW5kRGFzaEhUTUwoc3Ryb2tlUGF0dGVybiwgY29sb3IsIG9uZUVtV2lkdGgpIHtcbiAgLy8gRWFzeSwgY29tbW9uIGNhc2U6IGEgc29saWQgbGluZVxuICBpZiAoIXN0cm9rZVBhdHRlcm4gfHwgc3Ryb2tlUGF0dGVybi5sZW5ndGggPD0gMSkge1xuICAgIHJldHVybiBgPGRpdiBjbGFzcz1cImR5Z3JhcGgtbGVnZW5kLWxpbmVcIiBzdHlsZT1cImJvcmRlci1ib3R0b20tY29sb3I6ICR7Y29sb3J9O1wiPjwvZGl2PmA7XG4gIH1cblxuICB2YXIgaSwgaiwgcGFkZGluZ0xlZnQsIG1hcmdpblJpZ2h0O1xuICB2YXIgc3Ryb2tlUGl4ZWxMZW5ndGggPSAwLCBzZWdtZW50TG9vcCA9IDA7XG4gIHZhciBub3JtYWxpemVkUGF0dGVybiA9IFtdO1xuICB2YXIgbG9vcDtcblxuICAvLyBDb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIHBpeGVscyBpbmNsdWRpbmcgdGhlIGZpcnN0IHNlZ21lbnQgdHdpY2UsIFxuICAvLyBzaW5jZSB3ZSByZXBlYXQgaXQuXG4gIGZvciAoaSA9IDA7IGkgPD0gc3Ryb2tlUGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgIHN0cm9rZVBpeGVsTGVuZ3RoICs9IHN0cm9rZVBhdHRlcm5baSVzdHJva2VQYXR0ZXJuLmxlbmd0aF07XG4gIH1cblxuICAvLyBTZWUgaWYgd2UgY2FuIGxvb3AgdGhlIHBhdHRlcm4gYnkgaXRzZWxmIGF0IGxlYXN0IHR3aWNlLlxuICBsb29wID0gTWF0aC5mbG9vcihvbmVFbVdpZHRoLyhzdHJva2VQaXhlbExlbmd0aC1zdHJva2VQYXR0ZXJuWzBdKSk7XG4gIGlmIChsb29wID4gMSkge1xuICAgIC8vIFRoaXMgcGF0dGVybiBmaXRzIGF0IGxlYXN0IHR3byB0aW1lcywgbm8gc2NhbGluZyBqdXN0IGNvbnZlcnQgdG8gZW07XG4gICAgZm9yIChpID0gMDsgaSA8IHN0cm9rZVBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRQYXR0ZXJuW2ldID0gc3Ryb2tlUGF0dGVybltpXS9vbmVFbVdpZHRoO1xuICAgIH1cbiAgICAvLyBTaW5jZSB3ZSBhcmUgcmVwZWF0aW5nIHRoZSBwYXR0ZXJuLCB3ZSBkb24ndCB3b3JyeSBhYm91dCByZXBlYXRpbmcgdGhlXG4gICAgLy8gZmlyc3Qgc2VnbWVudCBpbiBvbmUgZHJhdy5cbiAgICBzZWdtZW50TG9vcCA9IG5vcm1hbGl6ZWRQYXR0ZXJuLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgcGF0dGVybiBkb2Vzbid0IGZpdCBpbiB0aGUgbGVnZW5kIHdlIHNjYWxlIGl0IHRvIGZpdC5cbiAgICBsb29wID0gMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3Ryb2tlUGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgbm9ybWFsaXplZFBhdHRlcm5baV0gPSBzdHJva2VQYXR0ZXJuW2ldL3N0cm9rZVBpeGVsTGVuZ3RoO1xuICAgIH1cbiAgICAvLyBGb3IgdGhlIHNjYWxlZCBwYXR0ZXJucyB3ZSBkbyByZWRyYXcgdGhlIGZpcnN0IHNlZ21lbnQuXG4gICAgc2VnbWVudExvb3AgPSBub3JtYWxpemVkUGF0dGVybi5sZW5ndGgrMTtcbiAgfVxuXG4gIC8vIE5vdyBtYWtlIHRoZSBwYXR0ZXJuLlxuICB2YXIgZGFzaCA9IFwiXCI7XG4gIGZvciAoaiA9IDA7IGogPCBsb29wOyBqKyspIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VnbWVudExvb3A7IGkrPTIpIHtcbiAgICAgIC8vIFRoZSBwYWRkaW5nIGlzIHRoZSBkcmF3biBzZWdtZW50LlxuICAgICAgcGFkZGluZ0xlZnQgPSBub3JtYWxpemVkUGF0dGVybltpJW5vcm1hbGl6ZWRQYXR0ZXJuLmxlbmd0aF07XG4gICAgICBpZiAoaSA8IHN0cm9rZVBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgICAgIC8vIFRoZSBtYXJnaW4gaXMgdGhlIHNwYWNlIHNlZ21lbnQuXG4gICAgICAgIG1hcmdpblJpZ2h0ID0gbm9ybWFsaXplZFBhdHRlcm5bKGkrMSklbm9ybWFsaXplZFBhdHRlcm4ubGVuZ3RoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSByZXBlYXRlZCBmaXJzdCBzZWdtZW50IGhhcyBubyByaWdodCBtYXJnaW4uXG4gICAgICAgIG1hcmdpblJpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICAgIGRhc2ggKz0gYDxkaXYgY2xhc3M9XCJkeWdyYXBoLWxlZ2VuZC1kYXNoXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6ICR7bWFyZ2luUmlnaHR9ZW07IHBhZGRpbmctbGVmdDogJHtwYWRkaW5nTGVmdH1lbTtcIj48L2Rpdj5gO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGFzaDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IExlZ2VuZDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZHlncmFwaHMvc3JjL3BsdWdpbnMvbGVnZW5kLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///33\n");

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dygraph_interaction_model__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iframe_tarp__ = __webpack_require__(20);\n/**\n * @license\n * Copyright 2011 Paul Felix (paul.eric.felix@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n/*global Dygraph:false,TouchEvent:false */\n\n/**\n * @fileoverview This file contains the RangeSelector plugin used to provide\n * a timeline range selector widget for dygraphs.\n */\n\n/*global Dygraph:false */\n\n\n\n\n\n\nvar rangeSelector = function rangeSelector() {\n  this.hasTouchInterface_ = typeof TouchEvent != 'undefined';\n  this.isMobileDevice_ = /mobile|android/gi.test(navigator.appVersion);\n  this.interfaceCreated_ = false;\n};\n\nrangeSelector.prototype.toString = function () {\n  return \"RangeSelector Plugin\";\n};\n\nrangeSelector.prototype.activate = function (dygraph) {\n  this.dygraph_ = dygraph;\n  if (this.getOption_('showRangeSelector')) {\n    this.createInterface_();\n  }\n  return {\n    layout: this.reserveSpace_,\n    predraw: this.renderStaticLayer_,\n    didDrawChart: this.renderInteractiveLayer_\n  };\n};\n\nrangeSelector.prototype.destroy = function () {\n  this.bgcanvas_ = null;\n  this.fgcanvas_ = null;\n  this.leftZoomHandle_ = null;\n  this.rightZoomHandle_ = null;\n};\n\n//------------------------------------------------------------------\n// Private methods\n//------------------------------------------------------------------\n\nrangeSelector.prototype.getOption_ = function (name, opt_series) {\n  return this.dygraph_.getOption(name, opt_series);\n};\n\nrangeSelector.prototype.setDefaultOption_ = function (name, value) {\n  this.dygraph_.attrs_[name] = value;\n};\n\n/**\n * @private\n * Creates the range selector elements and adds them to the graph.\n */\nrangeSelector.prototype.createInterface_ = function () {\n  this.createCanvases_();\n  this.createZoomHandles_();\n  this.initInteraction_();\n\n  // Range selector and animatedZooms have a bad interaction. See issue 359.\n  if (this.getOption_('animatedZooms')) {\n    console.warn('Animated zooms and range selector are not compatible; disabling animatedZooms.');\n    this.dygraph_.updateOptions({ animatedZooms: false }, true);\n  }\n\n  this.interfaceCreated_ = true;\n  this.addToGraph_();\n};\n\n/**\n * @private\n * Adds the range selector to the graph.\n */\nrangeSelector.prototype.addToGraph_ = function () {\n  var graphDiv = this.graphDiv_ = this.dygraph_.graphDiv;\n  graphDiv.appendChild(this.bgcanvas_);\n  graphDiv.appendChild(this.fgcanvas_);\n  graphDiv.appendChild(this.leftZoomHandle_);\n  graphDiv.appendChild(this.rightZoomHandle_);\n};\n\n/**\n * @private\n * Removes the range selector from the graph.\n */\nrangeSelector.prototype.removeFromGraph_ = function () {\n  var graphDiv = this.graphDiv_;\n  graphDiv.removeChild(this.bgcanvas_);\n  graphDiv.removeChild(this.fgcanvas_);\n  graphDiv.removeChild(this.leftZoomHandle_);\n  graphDiv.removeChild(this.rightZoomHandle_);\n  this.graphDiv_ = null;\n};\n\n/**\n * @private\n * Called by Layout to allow range selector to reserve its space.\n */\nrangeSelector.prototype.reserveSpace_ = function (e) {\n  if (this.getOption_('showRangeSelector')) {\n    e.reserveSpaceBottom(this.getOption_('rangeSelectorHeight') + 4);\n  }\n};\n\n/**\n * @private\n * Renders the static portion of the range selector at the predraw stage.\n */\nrangeSelector.prototype.renderStaticLayer_ = function () {\n  if (!this.updateVisibility_()) {\n    return;\n  }\n  this.resize_();\n  this.drawStaticLayer_();\n};\n\n/**\n * @private\n * Renders the interactive portion of the range selector after the chart has been drawn.\n */\nrangeSelector.prototype.renderInteractiveLayer_ = function () {\n  if (!this.updateVisibility_() || this.isChangingRange_) {\n    return;\n  }\n  this.placeZoomHandles_();\n  this.drawInteractiveLayer_();\n};\n\n/**\n * @private\n * Check to see if the range selector is enabled/disabled and update visibility accordingly.\n */\nrangeSelector.prototype.updateVisibility_ = function () {\n  var enabled = this.getOption_('showRangeSelector');\n  if (enabled) {\n    if (!this.interfaceCreated_) {\n      this.createInterface_();\n    } else if (!this.graphDiv_ || !this.graphDiv_.parentNode) {\n      this.addToGraph_();\n    }\n  } else if (this.graphDiv_) {\n    this.removeFromGraph_();\n    var dygraph = this.dygraph_;\n    setTimeout(function () {\n      dygraph.width_ = 0;dygraph.resize();\n    }, 1);\n  }\n  return enabled;\n};\n\n/**\n * @private\n * Resizes the range selector.\n */\nrangeSelector.prototype.resize_ = function () {\n  function setElementRect(canvas, context, rect, pixelRatioOption) {\n    var canvasScale = pixelRatioOption || __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"h\" /* getContextPixelRatio */](context);\n\n    canvas.style.top = rect.y + 'px';\n    canvas.style.left = rect.x + 'px';\n    canvas.width = rect.w * canvasScale;\n    canvas.height = rect.h * canvasScale;\n    canvas.style.width = rect.w + 'px';\n    canvas.style.height = rect.h + 'px';\n\n    if (canvasScale != 1) {\n      context.scale(canvasScale, canvasScale);\n    }\n  }\n\n  var plotArea = this.dygraph_.layout_.getPlotArea();\n\n  var xAxisLabelHeight = 0;\n  if (this.dygraph_.getOptionForAxis('drawAxis', 'x')) {\n    xAxisLabelHeight = this.getOption_('xAxisHeight') || this.getOption_('axisLabelFontSize') + 2 * this.getOption_('axisTickSize');\n  }\n  this.canvasRect_ = {\n    x: plotArea.x,\n    y: plotArea.y + plotArea.h + xAxisLabelHeight + 4,\n    w: plotArea.w,\n    h: this.getOption_('rangeSelectorHeight')\n  };\n\n  var pixelRatioOption = this.dygraph_.getNumericOption('pixelRatio');\n  setElementRect(this.bgcanvas_, this.bgcanvas_ctx_, this.canvasRect_, pixelRatioOption);\n  setElementRect(this.fgcanvas_, this.fgcanvas_ctx_, this.canvasRect_, pixelRatioOption);\n};\n\n/**\n * @private\n * Creates the background and foreground canvases.\n */\nrangeSelector.prototype.createCanvases_ = function () {\n  this.bgcanvas_ = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"e\" /* createCanvas */]();\n  this.bgcanvas_.className = 'dygraph-rangesel-bgcanvas';\n  this.bgcanvas_.style.position = 'absolute';\n  this.bgcanvas_.style.zIndex = 9;\n  this.bgcanvas_ctx_ = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"f\" /* getContext */](this.bgcanvas_);\n\n  this.fgcanvas_ = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"e\" /* createCanvas */]();\n  this.fgcanvas_.className = 'dygraph-rangesel-fgcanvas';\n  this.fgcanvas_.style.position = 'absolute';\n  this.fgcanvas_.style.zIndex = 9;\n  this.fgcanvas_.style.cursor = 'default';\n  this.fgcanvas_ctx_ = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"f\" /* getContext */](this.fgcanvas_);\n};\n\n/**\n * @private\n * Creates the zoom handle elements.\n */\nrangeSelector.prototype.createZoomHandles_ = function () {\n  var img = new Image();\n  img.className = 'dygraph-rangesel-zoomhandle';\n  img.style.position = 'absolute';\n  img.style.zIndex = 10;\n  img.style.visibility = 'hidden'; // Initially hidden so they don't show up in the wrong place.\n  img.style.cursor = 'col-resize';\n  // TODO: change image to more options\n  img.width = 9;\n  img.height = 16;\n  img.src = 'data:image/png;base64,' + 'iVBORw0KGgoAAAANSUhEUgAAAAkAAAAQCAYAAADESFVDAAAAAXNSR0IArs4c6QAAAAZiS0dEANAA' + 'zwDP4Z7KegAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAAd0SU1FB9sHGw0cMqdt1UwAAAAZdEVYdENv' + 'bW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAaElEQVQoz+3SsRFAQBCF4Z9WJM8KCDVwownl' + '6YXsTmCUsyKGkZzcl7zkz3YLkypgAnreFmDEpHkIwVOMfpdi9CEEN2nGpFdwD03yEqDtOgCaun7s' + 'qSTDH32I1pQA2Pb9sZecAxc5r3IAb21d6878xsAAAAAASUVORK5CYII=';\n\n  if (this.isMobileDevice_) {\n    img.width *= 2;\n    img.height *= 2;\n  }\n\n  this.leftZoomHandle_ = img;\n  this.rightZoomHandle_ = img.cloneNode(false);\n};\n\n/**\n * @private\n * Sets up the interaction for the range selector.\n */\nrangeSelector.prototype.initInteraction_ = function () {\n  var self = this;\n  var topElem = document;\n  var clientXLast = 0;\n  var handle = null;\n  var isZooming = false;\n  var isPanning = false;\n  var dynamic = !this.isMobileDevice_;\n\n  // We cover iframes during mouse interactions. See comments in\n  // dygraph-utils.js for more info on why this is a good idea.\n  var tarp = new __WEBPACK_IMPORTED_MODULE_2__iframe_tarp__[\"a\" /* default */]();\n\n  // functions, defined below.  Defining them this way (rather than with\n  // \"function foo() {...}\" makes JSHint happy.\n  var toXDataWindow, onZoomStart, onZoom, _onZoomEnd, doZoom, isMouseInPanZone, onPanStart, onPan, _onPanEnd, doPan, onCanvasHover;\n\n  // Touch event functions\n  var onZoomHandleTouchEvent, onCanvasTouchEvent, addTouchEvents;\n\n  toXDataWindow = function toXDataWindow(zoomHandleStatus) {\n    var xDataLimits = self.dygraph_.xAxisExtremes();\n    var fact = (xDataLimits[1] - xDataLimits[0]) / self.canvasRect_.w;\n    var xDataMin = xDataLimits[0] + (zoomHandleStatus.leftHandlePos - self.canvasRect_.x) * fact;\n    var xDataMax = xDataLimits[0] + (zoomHandleStatus.rightHandlePos - self.canvasRect_.x) * fact;\n    return [xDataMin, xDataMax];\n  };\n\n  onZoomStart = function onZoomStart(e) {\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"O\" /* cancelEvent */](e);\n    isZooming = true;\n    clientXLast = e.clientX;\n    handle = e.target ? e.target : e.srcElement;\n    if (e.type === 'mousedown' || e.type === 'dragstart') {\n      // These events are removed manually.\n      __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"F\" /* addEvent */](topElem, 'mousemove', onZoom);\n      __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"F\" /* addEvent */](topElem, 'mouseup', _onZoomEnd);\n    }\n    self.fgcanvas_.style.cursor = 'col-resize';\n    tarp.cover();\n    return true;\n  };\n\n  onZoom = function onZoom(e) {\n    if (!isZooming) {\n      return false;\n    }\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"O\" /* cancelEvent */](e);\n\n    var delX = e.clientX - clientXLast;\n    if (Math.abs(delX) < 4) {\n      return true;\n    }\n    clientXLast = e.clientX;\n\n    // Move handle.\n    var zoomHandleStatus = self.getZoomHandleStatus_();\n    var newPos;\n    if (handle == self.leftZoomHandle_) {\n      newPos = zoomHandleStatus.leftHandlePos + delX;\n      newPos = Math.min(newPos, zoomHandleStatus.rightHandlePos - handle.width - 3);\n      newPos = Math.max(newPos, self.canvasRect_.x);\n    } else {\n      newPos = zoomHandleStatus.rightHandlePos + delX;\n      newPos = Math.min(newPos, self.canvasRect_.x + self.canvasRect_.w);\n      newPos = Math.max(newPos, zoomHandleStatus.leftHandlePos + handle.width + 3);\n    }\n    var halfHandleWidth = handle.width / 2;\n    handle.style.left = newPos - halfHandleWidth + 'px';\n    self.drawInteractiveLayer_();\n\n    // Zoom on the fly.\n    if (dynamic) {\n      doZoom();\n    }\n    return true;\n  };\n\n  _onZoomEnd = function onZoomEnd(e) {\n    if (!isZooming) {\n      return false;\n    }\n    isZooming = false;\n    tarp.uncover();\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"i\" /* removeEvent */](topElem, 'mousemove', onZoom);\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"i\" /* removeEvent */](topElem, 'mouseup', _onZoomEnd);\n    self.fgcanvas_.style.cursor = 'default';\n\n    // If on a slower device, zoom now.\n    if (!dynamic) {\n      doZoom();\n    }\n    return true;\n  };\n\n  doZoom = function doZoom() {\n    try {\n      var zoomHandleStatus = self.getZoomHandleStatus_();\n      self.isChangingRange_ = true;\n      if (!zoomHandleStatus.isZoomed) {\n        self.dygraph_.resetZoom();\n      } else {\n        var xDataWindow = toXDataWindow(zoomHandleStatus);\n        self.dygraph_.doZoomXDates_(xDataWindow[0], xDataWindow[1]);\n      }\n    } finally {\n      self.isChangingRange_ = false;\n    }\n  };\n\n  isMouseInPanZone = function isMouseInPanZone(e) {\n    var rect = self.leftZoomHandle_.getBoundingClientRect();\n    var leftHandleClientX = rect.left + rect.width / 2;\n    rect = self.rightZoomHandle_.getBoundingClientRect();\n    var rightHandleClientX = rect.left + rect.width / 2;\n    return e.clientX > leftHandleClientX && e.clientX < rightHandleClientX;\n  };\n\n  onPanStart = function onPanStart(e) {\n    if (!isPanning && isMouseInPanZone(e) && self.getZoomHandleStatus_().isZoomed) {\n      __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"O\" /* cancelEvent */](e);\n      isPanning = true;\n      clientXLast = e.clientX;\n      if (e.type === 'mousedown') {\n        // These events are removed manually.\n        __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"F\" /* addEvent */](topElem, 'mousemove', onPan);\n        __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"F\" /* addEvent */](topElem, 'mouseup', _onPanEnd);\n      }\n      return true;\n    }\n    return false;\n  };\n\n  onPan = function onPan(e) {\n    if (!isPanning) {\n      return false;\n    }\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"O\" /* cancelEvent */](e);\n\n    var delX = e.clientX - clientXLast;\n    if (Math.abs(delX) < 4) {\n      return true;\n    }\n    clientXLast = e.clientX;\n\n    // Move range view\n    var zoomHandleStatus = self.getZoomHandleStatus_();\n    var leftHandlePos = zoomHandleStatus.leftHandlePos;\n    var rightHandlePos = zoomHandleStatus.rightHandlePos;\n    var rangeSize = rightHandlePos - leftHandlePos;\n    if (leftHandlePos + delX <= self.canvasRect_.x) {\n      leftHandlePos = self.canvasRect_.x;\n      rightHandlePos = leftHandlePos + rangeSize;\n    } else if (rightHandlePos + delX >= self.canvasRect_.x + self.canvasRect_.w) {\n      rightHandlePos = self.canvasRect_.x + self.canvasRect_.w;\n      leftHandlePos = rightHandlePos - rangeSize;\n    } else {\n      leftHandlePos += delX;\n      rightHandlePos += delX;\n    }\n    var halfHandleWidth = self.leftZoomHandle_.width / 2;\n    self.leftZoomHandle_.style.left = leftHandlePos - halfHandleWidth + 'px';\n    self.rightZoomHandle_.style.left = rightHandlePos - halfHandleWidth + 'px';\n    self.drawInteractiveLayer_();\n\n    // Do pan on the fly.\n    if (dynamic) {\n      doPan();\n    }\n    return true;\n  };\n\n  _onPanEnd = function onPanEnd(e) {\n    if (!isPanning) {\n      return false;\n    }\n    isPanning = false;\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"i\" /* removeEvent */](topElem, 'mousemove', onPan);\n    __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"i\" /* removeEvent */](topElem, 'mouseup', _onPanEnd);\n    // If on a slower device, do pan now.\n    if (!dynamic) {\n      doPan();\n    }\n    return true;\n  };\n\n  doPan = function doPan() {\n    try {\n      self.isChangingRange_ = true;\n      self.dygraph_.dateWindow_ = toXDataWindow(self.getZoomHandleStatus_());\n      self.dygraph_.drawGraph_(false);\n    } finally {\n      self.isChangingRange_ = false;\n    }\n  };\n\n  onCanvasHover = function onCanvasHover(e) {\n    if (isZooming || isPanning) {\n      return;\n    }\n    var cursor = isMouseInPanZone(e) ? 'move' : 'default';\n    if (cursor != self.fgcanvas_.style.cursor) {\n      self.fgcanvas_.style.cursor = cursor;\n    }\n  };\n\n  onZoomHandleTouchEvent = function onZoomHandleTouchEvent(e) {\n    if (e.type == 'touchstart' && e.targetTouches.length == 1) {\n      if (onZoomStart(e.targetTouches[0])) {\n        __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"O\" /* cancelEvent */](e);\n      }\n    } else if (e.type == 'touchmove' && e.targetTouches.length == 1) {\n      if (onZoom(e.targetTouches[0])) {\n        __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"O\" /* cancelEvent */](e);\n      }\n    } else {\n      _onZoomEnd(e);\n    }\n  };\n\n  onCanvasTouchEvent = function onCanvasTouchEvent(e) {\n    if (e.type == 'touchstart' && e.targetTouches.length == 1) {\n      if (onPanStart(e.targetTouches[0])) {\n        __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"O\" /* cancelEvent */](e);\n      }\n    } else if (e.type == 'touchmove' && e.targetTouches.length == 1) {\n      if (onPan(e.targetTouches[0])) {\n        __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"O\" /* cancelEvent */](e);\n      }\n    } else {\n      _onPanEnd(e);\n    }\n  };\n\n  addTouchEvents = function addTouchEvents(elem, fn) {\n    var types = ['touchstart', 'touchend', 'touchmove', 'touchcancel'];\n    for (var i = 0; i < types.length; i++) {\n      self.dygraph_.addAndTrackEvent(elem, types[i], fn);\n    }\n  };\n\n  this.setDefaultOption_('interactionModel', __WEBPACK_IMPORTED_MODULE_1__dygraph_interaction_model__[\"a\" /* default */].dragIsPanInteractionModel);\n  this.setDefaultOption_('panEdgeFraction', 0.0001);\n\n  var dragStartEvent = window.opera ? 'mousedown' : 'dragstart';\n  this.dygraph_.addAndTrackEvent(this.leftZoomHandle_, dragStartEvent, onZoomStart);\n  this.dygraph_.addAndTrackEvent(this.rightZoomHandle_, dragStartEvent, onZoomStart);\n\n  this.dygraph_.addAndTrackEvent(this.fgcanvas_, 'mousedown', onPanStart);\n  this.dygraph_.addAndTrackEvent(this.fgcanvas_, 'mousemove', onCanvasHover);\n\n  // Touch events\n  if (this.hasTouchInterface_) {\n    addTouchEvents(this.leftZoomHandle_, onZoomHandleTouchEvent);\n    addTouchEvents(this.rightZoomHandle_, onZoomHandleTouchEvent);\n    addTouchEvents(this.fgcanvas_, onCanvasTouchEvent);\n  }\n};\n\n/**\n * @private\n * Draws the static layer in the background canvas.\n */\nrangeSelector.prototype.drawStaticLayer_ = function () {\n  var ctx = this.bgcanvas_ctx_;\n  ctx.clearRect(0, 0, this.canvasRect_.w, this.canvasRect_.h);\n  try {\n    this.drawMiniPlot_();\n  } catch (ex) {\n    console.warn(ex);\n  }\n\n  var margin = 0.5;\n  this.bgcanvas_ctx_.lineWidth = this.getOption_('rangeSelectorBackgroundLineWidth');\n  ctx.strokeStyle = this.getOption_('rangeSelectorBackgroundStrokeColor');\n  ctx.beginPath();\n  ctx.moveTo(margin, margin);\n  ctx.lineTo(margin, this.canvasRect_.h - margin);\n  ctx.lineTo(this.canvasRect_.w - margin, this.canvasRect_.h - margin);\n  ctx.lineTo(this.canvasRect_.w - margin, margin);\n  ctx.stroke();\n};\n\n/**\n * @private\n * Draws the mini plot in the background canvas.\n */\nrangeSelector.prototype.drawMiniPlot_ = function () {\n  var fillStyle = this.getOption_('rangeSelectorPlotFillColor');\n  var fillGradientStyle = this.getOption_('rangeSelectorPlotFillGradientColor');\n  var strokeStyle = this.getOption_('rangeSelectorPlotStrokeColor');\n  if (!fillStyle && !strokeStyle) {\n    return;\n  }\n\n  var stepPlot = this.getOption_('stepPlot');\n\n  var combinedSeriesData = this.computeCombinedSeriesAndLimits_();\n  var yRange = combinedSeriesData.yMax - combinedSeriesData.yMin;\n\n  // Draw the mini plot.\n  var ctx = this.bgcanvas_ctx_;\n  var margin = 0.5;\n\n  var xExtremes = this.dygraph_.xAxisExtremes();\n  var xRange = Math.max(xExtremes[1] - xExtremes[0], 1.e-30);\n  var xFact = (this.canvasRect_.w - margin) / xRange;\n  var yFact = (this.canvasRect_.h - margin) / yRange;\n  var canvasWidth = this.canvasRect_.w - margin;\n  var canvasHeight = this.canvasRect_.h - margin;\n\n  var prevX = null,\n      prevY = null;\n\n  ctx.beginPath();\n  ctx.moveTo(margin, canvasHeight);\n  for (var i = 0; i < combinedSeriesData.data.length; i++) {\n    var dataPoint = combinedSeriesData.data[i];\n    var x = dataPoint[0] !== null ? (dataPoint[0] - xExtremes[0]) * xFact : NaN;\n    var y = dataPoint[1] !== null ? canvasHeight - (dataPoint[1] - combinedSeriesData.yMin) * yFact : NaN;\n\n    // Skip points that don't change the x-value. Overly fine-grained points\n    // can cause major slowdowns with the ctx.fill() call below.\n    if (!stepPlot && prevX !== null && Math.round(x) == Math.round(prevX)) {\n      continue;\n    }\n\n    if (isFinite(x) && isFinite(y)) {\n      if (prevX === null) {\n        ctx.lineTo(x, canvasHeight);\n      } else if (stepPlot) {\n        ctx.lineTo(x, prevY);\n      }\n      ctx.lineTo(x, y);\n      prevX = x;\n      prevY = y;\n    } else {\n      if (prevX !== null) {\n        if (stepPlot) {\n          ctx.lineTo(x, prevY);\n          ctx.lineTo(x, canvasHeight);\n        } else {\n          ctx.lineTo(prevX, canvasHeight);\n        }\n      }\n      prevX = prevY = null;\n    }\n  }\n  ctx.lineTo(canvasWidth, canvasHeight);\n  ctx.closePath();\n\n  if (fillStyle) {\n    var lingrad = this.bgcanvas_ctx_.createLinearGradient(0, 0, 0, canvasHeight);\n    if (fillGradientStyle) {\n      lingrad.addColorStop(0, fillGradientStyle);\n    }\n    lingrad.addColorStop(1, fillStyle);\n    this.bgcanvas_ctx_.fillStyle = lingrad;\n    ctx.fill();\n  }\n\n  if (strokeStyle) {\n    this.bgcanvas_ctx_.strokeStyle = strokeStyle;\n    this.bgcanvas_ctx_.lineWidth = this.getOption_('rangeSelectorPlotLineWidth');\n    ctx.stroke();\n  }\n};\n\n/**\n * @private\n * Computes and returns the combined series data along with min/max for the mini plot.\n * The combined series consists of averaged values for all series.\n * When series have error bars, the error bars are ignored.\n * @return {Object} An object containing combined series array, ymin, ymax.\n */\nrangeSelector.prototype.computeCombinedSeriesAndLimits_ = function () {\n  var g = this.dygraph_;\n  var logscale = this.getOption_('logscale');\n  var i;\n\n  // Select series to combine. By default, all series are combined.\n  var numColumns = g.numColumns();\n  var labels = g.getLabels();\n  var includeSeries = new Array(numColumns);\n  var anySet = false;\n  var visibility = g.visibility();\n  var inclusion = [];\n\n  for (i = 1; i < numColumns; i++) {\n    var include = this.getOption_('showInRangeSelector', labels[i]);\n    inclusion.push(include);\n    if (include !== null) anySet = true; // it's set explicitly for this series\n  }\n\n  if (anySet) {\n    for (i = 1; i < numColumns; i++) {\n      includeSeries[i] = inclusion[i - 1];\n    }\n  } else {\n    for (i = 1; i < numColumns; i++) {\n      includeSeries[i] = visibility[i - 1];\n    }\n  }\n\n  // Create a combined series (average of selected series values).\n  // TODO(danvk): short-circuit if there's only one series.\n  var rolledSeries = [];\n  var dataHandler = g.dataHandler_;\n  var options = g.attributes_;\n  for (i = 1; i < g.numColumns(); i++) {\n    if (!includeSeries[i]) continue;\n    var series = dataHandler.extractSeries(g.rawData_, i, options);\n    if (g.rollPeriod() > 1) {\n      series = dataHandler.rollingAverage(series, g.rollPeriod(), options);\n    }\n\n    rolledSeries.push(series);\n  }\n\n  var combinedSeries = [];\n  for (i = 0; i < rolledSeries[0].length; i++) {\n    var sum = 0;\n    var count = 0;\n    for (var j = 0; j < rolledSeries.length; j++) {\n      var y = rolledSeries[j][i][1];\n      if (y === null || isNaN(y)) continue;\n      count++;\n      sum += y;\n    }\n    combinedSeries.push([rolledSeries[0][i][0], sum / count]);\n  }\n\n  // Compute the y range.\n  var yMin = Number.MAX_VALUE;\n  var yMax = -Number.MAX_VALUE;\n  for (i = 0; i < combinedSeries.length; i++) {\n    var yVal = combinedSeries[i][1];\n    if (yVal !== null && isFinite(yVal) && (!logscale || yVal > 0)) {\n      yMin = Math.min(yMin, yVal);\n      yMax = Math.max(yMax, yVal);\n    }\n  }\n\n  // Convert Y data to log scale if needed.\n  // Also, expand the Y range to compress the mini plot a little.\n  var extraPercent = 0.25;\n  if (logscale) {\n    yMax = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](yMax);\n    yMax += yMax * extraPercent;\n    yMin = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](yMin);\n    for (i = 0; i < combinedSeries.length; i++) {\n      combinedSeries[i][1] = __WEBPACK_IMPORTED_MODULE_0__dygraph_utils__[\"d\" /* log10 */](combinedSeries[i][1]);\n    }\n  } else {\n    var yExtra;\n    var yRange = yMax - yMin;\n    if (yRange <= Number.MIN_VALUE) {\n      yExtra = yMax * extraPercent;\n    } else {\n      yExtra = yRange * extraPercent;\n    }\n    yMax += yExtra;\n    yMin -= yExtra;\n  }\n\n  return { data: combinedSeries, yMin: yMin, yMax: yMax };\n};\n\n/**\n * @private\n * Places the zoom handles in the proper position based on the current X data window.\n */\nrangeSelector.prototype.placeZoomHandles_ = function () {\n  var xExtremes = this.dygraph_.xAxisExtremes();\n  var xWindowLimits = this.dygraph_.xAxisRange();\n  var xRange = xExtremes[1] - xExtremes[0];\n  var leftPercent = Math.max(0, (xWindowLimits[0] - xExtremes[0]) / xRange);\n  var rightPercent = Math.max(0, (xExtremes[1] - xWindowLimits[1]) / xRange);\n  var leftCoord = this.canvasRect_.x + this.canvasRect_.w * leftPercent;\n  var rightCoord = this.canvasRect_.x + this.canvasRect_.w * (1 - rightPercent);\n  var handleTop = Math.max(this.canvasRect_.y, this.canvasRect_.y + (this.canvasRect_.h - this.leftZoomHandle_.height) / 2);\n  var halfHandleWidth = this.leftZoomHandle_.width / 2;\n  this.leftZoomHandle_.style.left = leftCoord - halfHandleWidth + 'px';\n  this.leftZoomHandle_.style.top = handleTop + 'px';\n  this.rightZoomHandle_.style.left = rightCoord - halfHandleWidth + 'px';\n  this.rightZoomHandle_.style.top = this.leftZoomHandle_.style.top;\n\n  this.leftZoomHandle_.style.visibility = 'visible';\n  this.rightZoomHandle_.style.visibility = 'visible';\n};\n\n/**\n * @private\n * Draws the interactive layer in the foreground canvas.\n */\nrangeSelector.prototype.drawInteractiveLayer_ = function () {\n  var ctx = this.fgcanvas_ctx_;\n  ctx.clearRect(0, 0, this.canvasRect_.w, this.canvasRect_.h);\n  var margin = 1;\n  var width = this.canvasRect_.w - margin;\n  var height = this.canvasRect_.h - margin;\n  var zoomHandleStatus = this.getZoomHandleStatus_();\n\n  ctx.strokeStyle = this.getOption_('rangeSelectorForegroundStrokeColor');\n  ctx.lineWidth = this.getOption_('rangeSelectorForegroundLineWidth');\n  if (!zoomHandleStatus.isZoomed) {\n    ctx.beginPath();\n    ctx.moveTo(margin, margin);\n    ctx.lineTo(margin, height);\n    ctx.lineTo(width, height);\n    ctx.lineTo(width, margin);\n    ctx.stroke();\n  } else {\n    var leftHandleCanvasPos = Math.max(margin, zoomHandleStatus.leftHandlePos - this.canvasRect_.x);\n    var rightHandleCanvasPos = Math.min(width, zoomHandleStatus.rightHandlePos - this.canvasRect_.x);\n\n    ctx.fillStyle = 'rgba(240, 240, 240, ' + this.getOption_('rangeSelectorAlpha').toString() + ')';\n    ctx.fillRect(0, 0, leftHandleCanvasPos, this.canvasRect_.h);\n    ctx.fillRect(rightHandleCanvasPos, 0, this.canvasRect_.w - rightHandleCanvasPos, this.canvasRect_.h);\n\n    ctx.beginPath();\n    ctx.moveTo(margin, margin);\n    ctx.lineTo(leftHandleCanvasPos, margin);\n    ctx.lineTo(leftHandleCanvasPos, height);\n    ctx.lineTo(rightHandleCanvasPos, height);\n    ctx.lineTo(rightHandleCanvasPos, margin);\n    ctx.lineTo(width, margin);\n    ctx.stroke();\n  }\n};\n\n/**\n * @private\n * Returns the current zoom handle position information.\n * @return {Object} The zoom handle status.\n */\nrangeSelector.prototype.getZoomHandleStatus_ = function () {\n  var halfHandleWidth = this.leftZoomHandle_.width / 2;\n  var leftHandlePos = parseFloat(this.leftZoomHandle_.style.left) + halfHandleWidth;\n  var rightHandlePos = parseFloat(this.rightZoomHandle_.style.left) + halfHandleWidth;\n  return {\n    leftHandlePos: leftHandlePos,\n    rightHandlePos: rightHandlePos,\n    isZoomed: leftHandlePos - 1 > this.canvasRect_.x || rightHandlePos + 1 < this.canvasRect_.x + this.canvasRect_.w\n  };\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (rangeSelector);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL3JhbmdlLXNlbGVjdG9yLmpzPzJhNGIiXSwibmFtZXMiOlsicmFuZ2VTZWxlY3RvciIsImhhc1RvdWNoSW50ZXJmYWNlXyIsIlRvdWNoRXZlbnQiLCJpc01vYmlsZURldmljZV8iLCJ0ZXN0IiwibmF2aWdhdG9yIiwiYXBwVmVyc2lvbiIsImludGVyZmFjZUNyZWF0ZWRfIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJhY3RpdmF0ZSIsImR5Z3JhcGgiLCJkeWdyYXBoXyIsImdldE9wdGlvbl8iLCJjcmVhdGVJbnRlcmZhY2VfIiwibGF5b3V0IiwicmVzZXJ2ZVNwYWNlXyIsInByZWRyYXciLCJyZW5kZXJTdGF0aWNMYXllcl8iLCJkaWREcmF3Q2hhcnQiLCJyZW5kZXJJbnRlcmFjdGl2ZUxheWVyXyIsImRlc3Ryb3kiLCJiZ2NhbnZhc18iLCJmZ2NhbnZhc18iLCJsZWZ0Wm9vbUhhbmRsZV8iLCJyaWdodFpvb21IYW5kbGVfIiwibmFtZSIsIm9wdF9zZXJpZXMiLCJnZXRPcHRpb24iLCJzZXREZWZhdWx0T3B0aW9uXyIsInZhbHVlIiwiYXR0cnNfIiwiY3JlYXRlQ2FudmFzZXNfIiwiY3JlYXRlWm9vbUhhbmRsZXNfIiwiaW5pdEludGVyYWN0aW9uXyIsImNvbnNvbGUiLCJ3YXJuIiwidXBkYXRlT3B0aW9ucyIsImFuaW1hdGVkWm9vbXMiLCJhZGRUb0dyYXBoXyIsImdyYXBoRGl2IiwiZ3JhcGhEaXZfIiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVGcm9tR3JhcGhfIiwicmVtb3ZlQ2hpbGQiLCJlIiwicmVzZXJ2ZVNwYWNlQm90dG9tIiwidXBkYXRlVmlzaWJpbGl0eV8iLCJyZXNpemVfIiwiZHJhd1N0YXRpY0xheWVyXyIsImlzQ2hhbmdpbmdSYW5nZV8iLCJwbGFjZVpvb21IYW5kbGVzXyIsImRyYXdJbnRlcmFjdGl2ZUxheWVyXyIsImVuYWJsZWQiLCJwYXJlbnROb2RlIiwic2V0VGltZW91dCIsIndpZHRoXyIsInJlc2l6ZSIsInNldEVsZW1lbnRSZWN0IiwiY2FudmFzIiwiY29udGV4dCIsInJlY3QiLCJwaXhlbFJhdGlvT3B0aW9uIiwiY2FudmFzU2NhbGUiLCJzdHlsZSIsInRvcCIsInkiLCJsZWZ0IiwieCIsIndpZHRoIiwidyIsImhlaWdodCIsImgiLCJzY2FsZSIsInBsb3RBcmVhIiwibGF5b3V0XyIsImdldFBsb3RBcmVhIiwieEF4aXNMYWJlbEhlaWdodCIsImdldE9wdGlvbkZvckF4aXMiLCJjYW52YXNSZWN0XyIsImdldE51bWVyaWNPcHRpb24iLCJiZ2NhbnZhc19jdHhfIiwiZmdjYW52YXNfY3R4XyIsImNsYXNzTmFtZSIsInBvc2l0aW9uIiwiekluZGV4IiwiY3Vyc29yIiwiaW1nIiwiSW1hZ2UiLCJ2aXNpYmlsaXR5Iiwic3JjIiwiY2xvbmVOb2RlIiwic2VsZiIsInRvcEVsZW0iLCJkb2N1bWVudCIsImNsaWVudFhMYXN0IiwiaGFuZGxlIiwiaXNab29taW5nIiwiaXNQYW5uaW5nIiwiZHluYW1pYyIsInRhcnAiLCJ0b1hEYXRhV2luZG93Iiwib25ab29tU3RhcnQiLCJvblpvb20iLCJvblpvb21FbmQiLCJkb1pvb20iLCJpc01vdXNlSW5QYW5ab25lIiwib25QYW5TdGFydCIsIm9uUGFuIiwib25QYW5FbmQiLCJkb1BhbiIsIm9uQ2FudmFzSG92ZXIiLCJvblpvb21IYW5kbGVUb3VjaEV2ZW50Iiwib25DYW52YXNUb3VjaEV2ZW50IiwiYWRkVG91Y2hFdmVudHMiLCJ6b29tSGFuZGxlU3RhdHVzIiwieERhdGFMaW1pdHMiLCJ4QXhpc0V4dHJlbWVzIiwiZmFjdCIsInhEYXRhTWluIiwibGVmdEhhbmRsZVBvcyIsInhEYXRhTWF4IiwicmlnaHRIYW5kbGVQb3MiLCJ1dGlscyIsImNsaWVudFgiLCJ0YXJnZXQiLCJzcmNFbGVtZW50IiwidHlwZSIsImNvdmVyIiwiZGVsWCIsIk1hdGgiLCJhYnMiLCJnZXRab29tSGFuZGxlU3RhdHVzXyIsIm5ld1BvcyIsIm1pbiIsIm1heCIsImhhbGZIYW5kbGVXaWR0aCIsInVuY292ZXIiLCJpc1pvb21lZCIsInJlc2V0Wm9vbSIsInhEYXRhV2luZG93IiwiZG9ab29tWERhdGVzXyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxlZnRIYW5kbGVDbGllbnRYIiwicmlnaHRIYW5kbGVDbGllbnRYIiwicmFuZ2VTaXplIiwiZGF0ZVdpbmRvd18iLCJkcmF3R3JhcGhfIiwidGFyZ2V0VG91Y2hlcyIsImxlbmd0aCIsImVsZW0iLCJmbiIsInR5cGVzIiwiaSIsImFkZEFuZFRyYWNrRXZlbnQiLCJEeWdyYXBoSW50ZXJhY3Rpb24iLCJkcmFnSXNQYW5JbnRlcmFjdGlvbk1vZGVsIiwiZHJhZ1N0YXJ0RXZlbnQiLCJ3aW5kb3ciLCJvcGVyYSIsImN0eCIsImNsZWFyUmVjdCIsImRyYXdNaW5pUGxvdF8iLCJleCIsIm1hcmdpbiIsImxpbmVXaWR0aCIsInN0cm9rZVN0eWxlIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwiZmlsbFN0eWxlIiwiZmlsbEdyYWRpZW50U3R5bGUiLCJzdGVwUGxvdCIsImNvbWJpbmVkU2VyaWVzRGF0YSIsImNvbXB1dGVDb21iaW5lZFNlcmllc0FuZExpbWl0c18iLCJ5UmFuZ2UiLCJ5TWF4IiwieU1pbiIsInhFeHRyZW1lcyIsInhSYW5nZSIsInhGYWN0IiwieUZhY3QiLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsInByZXZYIiwicHJldlkiLCJkYXRhIiwiZGF0YVBvaW50IiwiTmFOIiwicm91bmQiLCJpc0Zpbml0ZSIsImNsb3NlUGF0aCIsImxpbmdyYWQiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsImFkZENvbG9yU3RvcCIsImZpbGwiLCJnIiwibG9nc2NhbGUiLCJudW1Db2x1bW5zIiwibGFiZWxzIiwiZ2V0TGFiZWxzIiwiaW5jbHVkZVNlcmllcyIsIkFycmF5IiwiYW55U2V0IiwiaW5jbHVzaW9uIiwiaW5jbHVkZSIsInB1c2giLCJyb2xsZWRTZXJpZXMiLCJkYXRhSGFuZGxlciIsImRhdGFIYW5kbGVyXyIsIm9wdGlvbnMiLCJhdHRyaWJ1dGVzXyIsInNlcmllcyIsImV4dHJhY3RTZXJpZXMiLCJyYXdEYXRhXyIsInJvbGxQZXJpb2QiLCJyb2xsaW5nQXZlcmFnZSIsImNvbWJpbmVkU2VyaWVzIiwic3VtIiwiY291bnQiLCJqIiwiaXNOYU4iLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJ5VmFsIiwiZXh0cmFQZXJjZW50IiwieUV4dHJhIiwiTUlOX1ZBTFVFIiwieFdpbmRvd0xpbWl0cyIsInhBeGlzUmFuZ2UiLCJsZWZ0UGVyY2VudCIsInJpZ2h0UGVyY2VudCIsImxlZnRDb29yZCIsInJpZ2h0Q29vcmQiLCJoYW5kbGVUb3AiLCJsZWZ0SGFuZGxlQ2FudmFzUG9zIiwicmlnaHRIYW5kbGVDYW52YXNQb3MiLCJmaWxsUmVjdCIsInBhcnNlRmxvYXQiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFBQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJQSxnQkFBZ0IsU0FBaEJBLGFBQWdCLEdBQVc7QUFDN0IsT0FBS0Msa0JBQUwsR0FBMEIsT0FBT0MsVUFBUCxJQUFzQixXQUFoRDtBQUNBLE9BQUtDLGVBQUwsR0FBdUIsbUJBQW1CQyxJQUFuQixDQUF3QkMsVUFBVUMsVUFBbEMsQ0FBdkI7QUFDQSxPQUFLQyxpQkFBTCxHQUF5QixLQUF6QjtBQUNELENBSkQ7O0FBTUFQLGNBQWNRLFNBQWQsQ0FBd0JDLFFBQXhCLEdBQW1DLFlBQVc7QUFDNUMsU0FBTyxzQkFBUDtBQUNELENBRkQ7O0FBSUFULGNBQWNRLFNBQWQsQ0FBd0JFLFFBQXhCLEdBQW1DLFVBQVNDLE9BQVQsRUFBa0I7QUFDbkQsT0FBS0MsUUFBTCxHQUFnQkQsT0FBaEI7QUFDQSxNQUFJLEtBQUtFLFVBQUwsQ0FBZ0IsbUJBQWhCLENBQUosRUFBMEM7QUFDeEMsU0FBS0MsZ0JBQUw7QUFDRDtBQUNELFNBQU87QUFDTEMsWUFBUSxLQUFLQyxhQURSO0FBRUxDLGFBQVMs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IjoiMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMSBQYXVsIEZlbGl4IChwYXVsLmVyaWMuZmVsaXhAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlLFRvdWNoRXZlbnQ6ZmFsc2UgKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgZmlsZSBjb250YWlucyB0aGUgUmFuZ2VTZWxlY3RvciBwbHVnaW4gdXNlZCB0byBwcm92aWRlXG4gKiBhIHRpbWVsaW5lIHJhbmdlIHNlbGVjdG9yIHdpZGdldCBmb3IgZHlncmFwaHMuXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL2R5Z3JhcGgtdXRpbHMnO1xuaW1wb3J0IER5Z3JhcGhJbnRlcmFjdGlvbiBmcm9tICcuLi9keWdyYXBoLWludGVyYWN0aW9uLW1vZGVsJztcbmltcG9ydCBJRnJhbWVUYXJwIGZyb20gJy4uL2lmcmFtZS10YXJwJztcblxudmFyIHJhbmdlU2VsZWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5oYXNUb3VjaEludGVyZmFjZV8gPSB0eXBlb2YoVG91Y2hFdmVudCkgIT0gJ3VuZGVmaW5lZCc7XG4gIHRoaXMuaXNNb2JpbGVEZXZpY2VfID0gL21vYmlsZXxhbmRyb2lkL2dpLnRlc3QobmF2aWdhdG9yLmFwcFZlcnNpb24pO1xuICB0aGlzLmludGVyZmFjZUNyZWF0ZWRfID0gZmFsc2U7XG59O1xuXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCJSYW5nZVNlbGVjdG9yIFBsdWdpblwiO1xufTtcblxucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbihkeWdyYXBoKSB7XG4gIHRoaXMuZHlncmFwaF8gPSBkeWdyYXBoO1xuICBpZiAodGhpcy5nZXRPcHRpb25fKCdzaG93UmFuZ2VTZWxlY3RvcicpKSB7XG4gICAgdGhpcy5jcmVhdGVJbnRlcmZhY2VfKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsYXlvdXQ6IHRoaXMucmVzZXJ2ZVNwYWNlXyxcbiAgICBwcmVkcmF3OiB0aGlzLnJlbmRlclN0YXRpY0xheWVyXyxcbiAgICBkaWREcmF3Q2hhcnQ6IHRoaXMucmVuZGVySW50ZXJhY3RpdmVMYXllcl9cbiAgfTtcbn07XG5cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5iZ2NhbnZhc18gPSBudWxsO1xuICB0aGlzLmZnY2FudmFzXyA9IG51bGw7XG4gIHRoaXMubGVmdFpvb21IYW5kbGVfID0gbnVsbDtcbiAgdGhpcy5yaWdodFpvb21IYW5kbGVfID0gbnVsbDtcbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIG1ldGhvZHNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmdldE9wdGlvbl8gPSBmdW5jdGlvbihuYW1lLCBvcHRfc2VyaWVzKSB7XG4gIHJldHVybiB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbihuYW1lLCBvcHRfc2VyaWVzKTtcbn07XG5cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnNldERlZmF1bHRPcHRpb25fID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5keWdyYXBoXy5hdHRyc19bbmFtZV0gPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENyZWF0ZXMgdGhlIHJhbmdlIHNlbGVjdG9yIGVsZW1lbnRzIGFuZCBhZGRzIHRoZW0gdG8gdGhlIGdyYXBoLlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5jcmVhdGVJbnRlcmZhY2VfID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3JlYXRlQ2FudmFzZXNfKCk7XG4gIHRoaXMuY3JlYXRlWm9vbUhhbmRsZXNfKCk7XG4gIHRoaXMuaW5pdEludGVyYWN0aW9uXygpO1xuXG4gIC8vIFJhbmdlIHNlbGVjdG9yIGFuZCBhbmltYXRlZFpvb21zIGhhdmUgYSBiYWQgaW50ZXJhY3Rpb24uIFNlZSBpc3N1ZSAzNTkuXG4gIGlmICh0aGlzLmdldE9wdGlvbl8oJ2FuaW1hdGVkWm9vbXMnKSkge1xuICAgIGNvbnNvbGUud2FybignQW5pbWF0ZWQgem9vbXMgYW5kIHJhbmdlIHNlbGVjdG9yIGFyZSBub3QgY29tcGF0aWJsZTsgZGlzYWJsaW5nIGFuaW1hdGVkWm9vbXMuJyk7XG4gICAgdGhpcy5keWdyYXBoXy51cGRhdGVPcHRpb25zKHthbmltYXRlZFpvb21zOiBmYWxzZX0sIHRydWUpO1xuICB9XG5cbiAgdGhpcy5pbnRlcmZhY2VDcmVhdGVkXyA9IHRydWU7XG4gIHRoaXMuYWRkVG9HcmFwaF8oKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEFkZHMgdGhlIHJhbmdlIHNlbGVjdG9yIHRvIHRoZSBncmFwaC5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuYWRkVG9HcmFwaF8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGdyYXBoRGl2ID0gdGhpcy5ncmFwaERpdl8gPSB0aGlzLmR5Z3JhcGhfLmdyYXBoRGl2O1xuICBncmFwaERpdi5hcHBlbmRDaGlsZCh0aGlzLmJnY2FudmFzXyk7XG4gIGdyYXBoRGl2LmFwcGVuZENoaWxkKHRoaXMuZmdjYW52YXNfKTtcbiAgZ3JhcGhEaXYuYXBwZW5kQ2hpbGQodGhpcy5sZWZ0Wm9vbUhhbmRsZV8pO1xuICBncmFwaERpdi5hcHBlbmRDaGlsZCh0aGlzLnJpZ2h0Wm9vbUhhbmRsZV8pO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmVtb3ZlcyB0aGUgcmFuZ2Ugc2VsZWN0b3IgZnJvbSB0aGUgZ3JhcGguXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnJlbW92ZUZyb21HcmFwaF8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGdyYXBoRGl2ID0gdGhpcy5ncmFwaERpdl87XG4gIGdyYXBoRGl2LnJlbW92ZUNoaWxkKHRoaXMuYmdjYW52YXNfKTtcbiAgZ3JhcGhEaXYucmVtb3ZlQ2hpbGQodGhpcy5mZ2NhbnZhc18pO1xuICBncmFwaERpdi5yZW1vdmVDaGlsZCh0aGlzLmxlZnRab29tSGFuZGxlXyk7XG4gIGdyYXBoRGl2LnJlbW92ZUNoaWxkKHRoaXMucmlnaHRab29tSGFuZGxlXyk7XG4gIHRoaXMuZ3JhcGhEaXZfID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENhbGxlZCBieSBMYXlvdXQgdG8gYWxsb3cgcmFuZ2Ugc2VsZWN0b3IgdG8gcmVzZXJ2ZSBpdHMgc3BhY2UuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnJlc2VydmVTcGFjZV8gPSBmdW5jdGlvbihlKSB7XG4gIGlmICh0aGlzLmdldE9wdGlvbl8oJ3Nob3dSYW5nZVNlbGVjdG9yJykpIHtcbiAgICBlLnJlc2VydmVTcGFjZUJvdHRvbSh0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JIZWlnaHQnKSArIDQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZW5kZXJzIHRoZSBzdGF0aWMgcG9ydGlvbiBvZiB0aGUgcmFuZ2Ugc2VsZWN0b3IgYXQgdGhlIHByZWRyYXcgc3RhZ2UuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnJlbmRlclN0YXRpY0xheWVyXyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMudXBkYXRlVmlzaWJpbGl0eV8oKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlc2l6ZV8oKTtcbiAgdGhpcy5kcmF3U3RhdGljTGF5ZXJfKCk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZW5kZXJzIHRoZSBpbnRlcmFjdGl2ZSBwb3J0aW9uIG9mIHRoZSByYW5nZSBzZWxlY3RvciBhZnRlciB0aGUgY2hhcnQgaGFzIGJlZW4gZHJhd24uXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnJlbmRlckludGVyYWN0aXZlTGF5ZXJfID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy51cGRhdGVWaXNpYmlsaXR5XygpIHx8IHRoaXMuaXNDaGFuZ2luZ1JhbmdlXykge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnBsYWNlWm9vbUhhbmRsZXNfKCk7XG4gIHRoaXMuZHJhd0ludGVyYWN0aXZlTGF5ZXJfKCk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBDaGVjayB0byBzZWUgaWYgdGhlIHJhbmdlIHNlbGVjdG9yIGlzIGVuYWJsZWQvZGlzYWJsZWQgYW5kIHVwZGF0ZSB2aXNpYmlsaXR5IGFjY29yZGluZ2x5LlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS51cGRhdGVWaXNpYmlsaXR5XyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZW5hYmxlZCA9IHRoaXMuZ2V0T3B0aW9uXygnc2hvd1JhbmdlU2VsZWN0b3InKTtcbiAgaWYgKGVuYWJsZWQpIHtcbiAgICBpZiAoIXRoaXMuaW50ZXJmYWNlQ3JlYXRlZF8pIHtcbiAgICAgIHRoaXMuY3JlYXRlSW50ZXJmYWNlXygpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuZ3JhcGhEaXZfIHx8ICF0aGlzLmdyYXBoRGl2Xy5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmFkZFRvR3JhcGhfKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuZ3JhcGhEaXZfKSB7XG4gICAgdGhpcy5yZW1vdmVGcm9tR3JhcGhfKCk7XG4gICAgdmFyIGR5Z3JhcGggPSB0aGlzLmR5Z3JhcGhfO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGR5Z3JhcGgud2lkdGhfID0gMDsgZHlncmFwaC5yZXNpemUoKTsgfSwgMSk7XG4gIH1cbiAgcmV0dXJuIGVuYWJsZWQ7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZXNpemVzIHRoZSByYW5nZSBzZWxlY3Rvci5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUucmVzaXplXyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzZXRFbGVtZW50UmVjdChjYW52YXMsIGNvbnRleHQsIHJlY3QsIHBpeGVsUmF0aW9PcHRpb24pIHtcbiAgICB2YXIgY2FudmFzU2NhbGUgPSBwaXhlbFJhdGlvT3B0aW9uIHx8IHV0aWxzLmdldENvbnRleHRQaXhlbFJhdGlvKGNvbnRleHQpO1xuXG4gICAgY2FudmFzLnN0eWxlLnRvcCA9IHJlY3QueSArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmxlZnQgPSByZWN0LnggKyAncHgnO1xuICAgIGNhbnZhcy53aWR0aCA9IHJlY3QudyAqIGNhbnZhc1NjYWxlO1xuICAgIGNhbnZhcy5oZWlnaHQgPSByZWN0LmggKiBjYW52YXNTY2FsZTtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSByZWN0LncgKyAncHgnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSByZWN0LmggKyAncHgnO1xuXG4gICAgaWYoY2FudmFzU2NhbGUgIT0gMSkge1xuICAgICAgY29udGV4dC5zY2FsZShjYW52YXNTY2FsZSwgY2FudmFzU2NhbGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwbG90QXJlYSA9IHRoaXMuZHlncmFwaF8ubGF5b3V0Xy5nZXRQbG90QXJlYSgpO1xuXG4gIHZhciB4QXhpc0xhYmVsSGVpZ2h0ID0gMDtcbiAgaWYgKHRoaXMuZHlncmFwaF8uZ2V0T3B0aW9uRm9yQXhpcygnZHJhd0F4aXMnLCAneCcpKSB7XG4gICAgeEF4aXNMYWJlbEhlaWdodCA9IHRoaXMuZ2V0T3B0aW9uXygneEF4aXNIZWlnaHQnKSB8fCAodGhpcy5nZXRPcHRpb25fKCdheGlzTGFiZWxGb250U2l6ZScpICsgMiAqIHRoaXMuZ2V0T3B0aW9uXygnYXhpc1RpY2tTaXplJykpO1xuICB9XG4gIHRoaXMuY2FudmFzUmVjdF8gPSB7XG4gICAgeDogcGxvdEFyZWEueCxcbiAgICB5OiBwbG90QXJlYS55ICsgcGxvdEFyZWEuaCArIHhBeGlzTGFiZWxIZWlnaHQgKyA0LFxuICAgIHc6IHBsb3RBcmVhLncsXG4gICAgaDogdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9ySGVpZ2h0JylcbiAgfTtcblxuICB2YXIgcGl4ZWxSYXRpb09wdGlvbiA9IHRoaXMuZHlncmFwaF8uZ2V0TnVtZXJpY09wdGlvbigncGl4ZWxSYXRpbycpO1xuICBzZXRFbGVtZW50UmVjdCh0aGlzLmJnY2FudmFzXywgdGhpcy5iZ2NhbnZhc19jdHhfLCB0aGlzLmNhbnZhc1JlY3RfLCBwaXhlbFJhdGlvT3B0aW9uKTtcbiAgc2V0RWxlbWVudFJlY3QodGhpcy5mZ2NhbnZhc18sIHRoaXMuZmdjYW52YXNfY3R4XywgdGhpcy5jYW52YXNSZWN0XywgcGl4ZWxSYXRpb09wdGlvbik7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBDcmVhdGVzIHRoZSBiYWNrZ3JvdW5kIGFuZCBmb3JlZ3JvdW5kIGNhbnZhc2VzLlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5jcmVhdGVDYW52YXNlc18gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5iZ2NhbnZhc18gPSB1dGlscy5jcmVhdGVDYW52YXMoKTtcbiAgdGhpcy5iZ2NhbnZhc18uY2xhc3NOYW1lID0gJ2R5Z3JhcGgtcmFuZ2VzZWwtYmdjYW52YXMnO1xuICB0aGlzLmJnY2FudmFzXy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIHRoaXMuYmdjYW52YXNfLnN0eWxlLnpJbmRleCA9IDk7XG4gIHRoaXMuYmdjYW52YXNfY3R4XyA9IHV0aWxzLmdldENvbnRleHQodGhpcy5iZ2NhbnZhc18pO1xuXG4gIHRoaXMuZmdjYW52YXNfID0gdXRpbHMuY3JlYXRlQ2FudmFzKCk7XG4gIHRoaXMuZmdjYW52YXNfLmNsYXNzTmFtZSA9ICdkeWdyYXBoLXJhbmdlc2VsLWZnY2FudmFzJztcbiAgdGhpcy5mZ2NhbnZhc18uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICB0aGlzLmZnY2FudmFzXy5zdHlsZS56SW5kZXggPSA5O1xuICB0aGlzLmZnY2FudmFzXy5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gIHRoaXMuZmdjYW52YXNfY3R4XyA9IHV0aWxzLmdldENvbnRleHQodGhpcy5mZ2NhbnZhc18pO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQ3JlYXRlcyB0aGUgem9vbSBoYW5kbGUgZWxlbWVudHMuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmNyZWF0ZVpvb21IYW5kbGVzXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gIGltZy5jbGFzc05hbWUgPSAnZHlncmFwaC1yYW5nZXNlbC16b29taGFuZGxlJztcbiAgaW1nLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgaW1nLnN0eWxlLnpJbmRleCA9IDEwO1xuICBpbWcuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nOyAvLyBJbml0aWFsbHkgaGlkZGVuIHNvIHRoZXkgZG9uJ3Qgc2hvdyB1cCBpbiB0aGUgd3JvbmcgcGxhY2UuXG4gIGltZy5zdHlsZS5jdXJzb3IgPSAnY29sLXJlc2l6ZSc7XG4gIC8vIFRPRE86IGNoYW5nZSBpbWFnZSB0byBtb3JlIG9wdGlvbnNcbiAgaW1nLndpZHRoID0gOTtcbiAgaW1nLmhlaWdodCA9IDE2O1xuICBpbWcuc3JjID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwnICtcbidpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQWtBQUFBUUNBWUFBQURFU0ZWREFBQUFBWE5TUjBJQXJzNGM2UUFBQUFaaVMwZEVBTkFBJyArXG4nendEUDRaN0tlZ0FBQUFsd1NGbHpBQUFPeEFBQURzUUJsU3NPR3dBQUFBZDBTVTFGQjlzSEd3MGNNcWR0MVV3QUFBQVpkRVZZZEVOdicgK1xuJ2JXMWxiblFBUTNKbFlYUmxaQ0IzYVhSb0lFZEpUVkJYZ1E0WEFBQUFhRWxFUVZRb3orM1NzUkZBUUJDRjRaOVdKTThLQ0RWd293bmwnICtcbic2WVhzVG1DVXN5S0drWnpjbDd6a3ozWUxreXBnQW5yZUZtREVwSGtJd1ZPTWZwZGk5Q0VFTjJuR3BGZHdEMDN5RXFEdE9nQ2F1bjdzJyArXG4ncVNUREgzMkkxcFFBMlBiOXNaZWNBeGM1cjNJQWIyMWQ2ODc4eHNBQUFBQUFTVVZPUks1Q1lJST0nO1xuXG4gIGlmICh0aGlzLmlzTW9iaWxlRGV2aWNlXykge1xuICAgIGltZy53aWR0aCAqPSAyO1xuICAgIGltZy5oZWlnaHQgKj0gMjtcbiAgfVxuXG4gIHRoaXMubGVmdFpvb21IYW5kbGVfID0gaW1nO1xuICB0aGlzLnJpZ2h0Wm9vbUhhbmRsZV8gPSBpbWcuY2xvbmVOb2RlKGZhbHNlKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFNldHMgdXAgdGhlIGludGVyYWN0aW9uIGZvciB0aGUgcmFuZ2Ugc2VsZWN0b3IuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmluaXRJbnRlcmFjdGlvbl8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdG9wRWxlbSA9IGRvY3VtZW50O1xuICB2YXIgY2xpZW50WExhc3QgPSAwO1xuICB2YXIgaGFuZGxlID0gbnVsbDtcbiAgdmFyIGlzWm9vbWluZyA9IGZhbHNlO1xuICB2YXIgaXNQYW5uaW5nID0gZmFsc2U7XG4gIHZhciBkeW5hbWljID0gIXRoaXMuaXNNb2JpbGVEZXZpY2VfO1xuXG4gIC8vIFdlIGNvdmVyIGlmcmFtZXMgZHVyaW5nIG1vdXNlIGludGVyYWN0aW9ucy4gU2VlIGNvbW1lbnRzIGluXG4gIC8vIGR5Z3JhcGgtdXRpbHMuanMgZm9yIG1vcmUgaW5mbyBvbiB3aHkgdGhpcyBpcyBhIGdvb2QgaWRlYS5cbiAgdmFyIHRhcnAgPSBuZXcgSUZyYW1lVGFycCgpO1xuXG4gIC8vIGZ1bmN0aW9ucywgZGVmaW5lZCBiZWxvdy4gIERlZmluaW5nIHRoZW0gdGhpcyB3YXkgKHJhdGhlciB0aGFuIHdpdGhcbiAgLy8gXCJmdW5jdGlvbiBmb28oKSB7Li4ufVwiIG1ha2VzIEpTSGludCBoYXBweS5cbiAgdmFyIHRvWERhdGFXaW5kb3csIG9uWm9vbVN0YXJ0LCBvblpvb20sIG9uWm9vbUVuZCwgZG9ab29tLCBpc01vdXNlSW5QYW5ab25lLFxuICAgICAgb25QYW5TdGFydCwgb25QYW4sIG9uUGFuRW5kLCBkb1Bhbiwgb25DYW52YXNIb3ZlcjtcblxuICAvLyBUb3VjaCBldmVudCBmdW5jdGlvbnNcbiAgdmFyIG9uWm9vbUhhbmRsZVRvdWNoRXZlbnQsIG9uQ2FudmFzVG91Y2hFdmVudCwgYWRkVG91Y2hFdmVudHM7XG5cbiAgdG9YRGF0YVdpbmRvdyA9IGZ1bmN0aW9uKHpvb21IYW5kbGVTdGF0dXMpIHtcbiAgICB2YXIgeERhdGFMaW1pdHMgPSBzZWxmLmR5Z3JhcGhfLnhBeGlzRXh0cmVtZXMoKTtcbiAgICB2YXIgZmFjdCA9ICh4RGF0YUxpbWl0c1sxXSAtIHhEYXRhTGltaXRzWzBdKS9zZWxmLmNhbnZhc1JlY3RfLnc7XG4gICAgdmFyIHhEYXRhTWluID0geERhdGFMaW1pdHNbMF0gKyAoem9vbUhhbmRsZVN0YXR1cy5sZWZ0SGFuZGxlUG9zIC0gc2VsZi5jYW52YXNSZWN0Xy54KSpmYWN0O1xuICAgIHZhciB4RGF0YU1heCA9IHhEYXRhTGltaXRzWzBdICsgKHpvb21IYW5kbGVTdGF0dXMucmlnaHRIYW5kbGVQb3MgLSBzZWxmLmNhbnZhc1JlY3RfLngpKmZhY3Q7XG4gICAgcmV0dXJuIFt4RGF0YU1pbiwgeERhdGFNYXhdO1xuICB9O1xuXG4gIG9uWm9vbVN0YXJ0ID0gZnVuY3Rpb24oZSkge1xuICAgIHV0aWxzLmNhbmNlbEV2ZW50KGUpO1xuICAgIGlzWm9vbWluZyA9IHRydWU7XG4gICAgY2xpZW50WExhc3QgPSBlLmNsaWVudFg7XG4gICAgaGFuZGxlID0gZS50YXJnZXQgPyBlLnRhcmdldCA6IGUuc3JjRWxlbWVudDtcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vkb3duJyB8fCBlLnR5cGUgPT09ICdkcmFnc3RhcnQnKSB7XG4gICAgICAvLyBUaGVzZSBldmVudHMgYXJlIHJlbW92ZWQgbWFudWFsbHkuXG4gICAgICB1dGlscy5hZGRFdmVudCh0b3BFbGVtLCAnbW91c2Vtb3ZlJywgb25ab29tKTtcbiAgICAgIHV0aWxzLmFkZEV2ZW50KHRvcEVsZW0sICdtb3VzZXVwJywgb25ab29tRW5kKTtcbiAgICB9XG4gICAgc2VsZi5mZ2NhbnZhc18uc3R5bGUuY3Vyc29yID0gJ2NvbC1yZXNpemUnO1xuICAgIHRhcnAuY292ZXIoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBvblpvb20gPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFpc1pvb21pbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdXRpbHMuY2FuY2VsRXZlbnQoZSk7XG5cbiAgICB2YXIgZGVsWCA9IGUuY2xpZW50WCAtIGNsaWVudFhMYXN0O1xuICAgIGlmIChNYXRoLmFicyhkZWxYKSA8IDQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjbGllbnRYTGFzdCA9IGUuY2xpZW50WDtcblxuICAgIC8vIE1vdmUgaGFuZGxlLlxuICAgIHZhciB6b29tSGFuZGxlU3RhdHVzID0gc2VsZi5nZXRab29tSGFuZGxlU3RhdHVzXygpO1xuICAgIHZhciBuZXdQb3M7XG4gICAgaWYgKGhhbmRsZSA9PSBzZWxmLmxlZnRab29tSGFuZGxlXykge1xuICAgICAgbmV3UG9zID0gem9vbUhhbmRsZVN0YXR1cy5sZWZ0SGFuZGxlUG9zICsgZGVsWDtcbiAgICAgIG5ld1BvcyA9IE1hdGgubWluKG5ld1Bvcywgem9vbUhhbmRsZVN0YXR1cy5yaWdodEhhbmRsZVBvcyAtIGhhbmRsZS53aWR0aCAtIDMpO1xuICAgICAgbmV3UG9zID0gTWF0aC5tYXgobmV3UG9zLCBzZWxmLmNhbnZhc1JlY3RfLngpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdQb3MgPSB6b29tSGFuZGxlU3RhdHVzLnJpZ2h0SGFuZGxlUG9zICsgZGVsWDtcbiAgICAgIG5ld1BvcyA9IE1hdGgubWluKG5ld1Bvcywgc2VsZi5jYW52YXNSZWN0Xy54ICsgc2VsZi5jYW52YXNSZWN0Xy53KTtcbiAgICAgIG5ld1BvcyA9IE1hdGgubWF4KG5ld1Bvcywgem9vbUhhbmRsZVN0YXR1cy5sZWZ0SGFuZGxlUG9zICsgaGFuZGxlLndpZHRoICsgMyk7XG4gICAgfVxuICAgIHZhciBoYWxmSGFuZGxlV2lkdGggPSBoYW5kbGUud2lkdGgvMjtcbiAgICBoYW5kbGUuc3R5bGUubGVmdCA9IChuZXdQb3MgLSBoYWxmSGFuZGxlV2lkdGgpICsgJ3B4JztcbiAgICBzZWxmLmRyYXdJbnRlcmFjdGl2ZUxheWVyXygpO1xuXG4gICAgLy8gWm9vbSBvbiB0aGUgZmx5LlxuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBkb1pvb20oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgb25ab29tRW5kID0gZnVuY3Rpb24oZSkge1xuICAgIGlmICghaXNab29taW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlzWm9vbWluZyA9IGZhbHNlO1xuICAgIHRhcnAudW5jb3ZlcigpO1xuICAgIHV0aWxzLnJlbW92ZUV2ZW50KHRvcEVsZW0sICdtb3VzZW1vdmUnLCBvblpvb20pO1xuICAgIHV0aWxzLnJlbW92ZUV2ZW50KHRvcEVsZW0sICdtb3VzZXVwJywgb25ab29tRW5kKTtcbiAgICBzZWxmLmZnY2FudmFzXy5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG5cbiAgICAvLyBJZiBvbiBhIHNsb3dlciBkZXZpY2UsIHpvb20gbm93LlxuICAgIGlmICghZHluYW1pYykge1xuICAgICAgZG9ab29tKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIGRvWm9vbSA9IGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgem9vbUhhbmRsZVN0YXR1cyA9IHNlbGYuZ2V0Wm9vbUhhbmRsZVN0YXR1c18oKTtcbiAgICAgIHNlbGYuaXNDaGFuZ2luZ1JhbmdlXyA9IHRydWU7XG4gICAgICBpZiAoIXpvb21IYW5kbGVTdGF0dXMuaXNab29tZWQpIHtcbiAgICAgICAgc2VsZi5keWdyYXBoXy5yZXNldFpvb20oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4RGF0YVdpbmRvdyA9IHRvWERhdGFXaW5kb3coem9vbUhhbmRsZVN0YXR1cyk7XG4gICAgICAgIHNlbGYuZHlncmFwaF8uZG9ab29tWERhdGVzXyh4RGF0YVdpbmRvd1swXSwgeERhdGFXaW5kb3dbMV0pO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZWxmLmlzQ2hhbmdpbmdSYW5nZV8gPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgaXNNb3VzZUluUGFuWm9uZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgcmVjdCA9IHNlbGYubGVmdFpvb21IYW5kbGVfLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBsZWZ0SGFuZGxlQ2xpZW50WCA9IHJlY3QubGVmdCArIHJlY3Qud2lkdGgvMjtcbiAgICByZWN0ID0gc2VsZi5yaWdodFpvb21IYW5kbGVfLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciByaWdodEhhbmRsZUNsaWVudFggPSByZWN0LmxlZnQgKyByZWN0LndpZHRoLzI7XG4gICAgcmV0dXJuIChlLmNsaWVudFggPiBsZWZ0SGFuZGxlQ2xpZW50WCAmJiBlLmNsaWVudFggPCByaWdodEhhbmRsZUNsaWVudFgpO1xuICB9O1xuXG4gIG9uUGFuU3RhcnQgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFpc1Bhbm5pbmcgJiYgaXNNb3VzZUluUGFuWm9uZShlKSAmJiBzZWxmLmdldFpvb21IYW5kbGVTdGF0dXNfKCkuaXNab29tZWQpIHtcbiAgICAgIHV0aWxzLmNhbmNlbEV2ZW50KGUpO1xuICAgICAgaXNQYW5uaW5nID0gdHJ1ZTtcbiAgICAgIGNsaWVudFhMYXN0ID0gZS5jbGllbnRYO1xuICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgLy8gVGhlc2UgZXZlbnRzIGFyZSByZW1vdmVkIG1hbnVhbGx5LlxuICAgICAgICB1dGlscy5hZGRFdmVudCh0b3BFbGVtLCAnbW91c2Vtb3ZlJywgb25QYW4pO1xuICAgICAgICB1dGlscy5hZGRFdmVudCh0b3BFbGVtLCAnbW91c2V1cCcsIG9uUGFuRW5kKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgb25QYW4gPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFpc1Bhbm5pbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdXRpbHMuY2FuY2VsRXZlbnQoZSk7XG5cbiAgICB2YXIgZGVsWCA9IGUuY2xpZW50WCAtIGNsaWVudFhMYXN0O1xuICAgIGlmIChNYXRoLmFicyhkZWxYKSA8IDQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjbGllbnRYTGFzdCA9IGUuY2xpZW50WDtcblxuICAgIC8vIE1vdmUgcmFuZ2Ugdmlld1xuICAgIHZhciB6b29tSGFuZGxlU3RhdHVzID0gc2VsZi5nZXRab29tSGFuZGxlU3RhdHVzXygpO1xuICAgIHZhciBsZWZ0SGFuZGxlUG9zID0gem9vbUhhbmRsZVN0YXR1cy5sZWZ0SGFuZGxlUG9zO1xuICAgIHZhciByaWdodEhhbmRsZVBvcyA9IHpvb21IYW5kbGVTdGF0dXMucmlnaHRIYW5kbGVQb3M7XG4gICAgdmFyIHJhbmdlU2l6ZSA9IHJpZ2h0SGFuZGxlUG9zIC0gbGVmdEhhbmRsZVBvcztcbiAgICBpZiAobGVmdEhhbmRsZVBvcyArIGRlbFggPD0gc2VsZi5jYW52YXNSZWN0Xy54KSB7XG4gICAgICBsZWZ0SGFuZGxlUG9zID0gc2VsZi5jYW52YXNSZWN0Xy54O1xuICAgICAgcmlnaHRIYW5kbGVQb3MgPSBsZWZ0SGFuZGxlUG9zICsgcmFuZ2VTaXplO1xuICAgIH0gZWxzZSBpZiAocmlnaHRIYW5kbGVQb3MgKyBkZWxYID49IHNlbGYuY2FudmFzUmVjdF8ueCArIHNlbGYuY2FudmFzUmVjdF8udykge1xuICAgICAgcmlnaHRIYW5kbGVQb3MgPSBzZWxmLmNhbnZhc1JlY3RfLnggKyBzZWxmLmNhbnZhc1JlY3RfLnc7XG4gICAgICBsZWZ0SGFuZGxlUG9zID0gcmlnaHRIYW5kbGVQb3MgLSByYW5nZVNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnRIYW5kbGVQb3MgKz0gZGVsWDtcbiAgICAgIHJpZ2h0SGFuZGxlUG9zICs9IGRlbFg7XG4gICAgfVxuICAgIHZhciBoYWxmSGFuZGxlV2lkdGggPSBzZWxmLmxlZnRab29tSGFuZGxlXy53aWR0aC8yO1xuICAgIHNlbGYubGVmdFpvb21IYW5kbGVfLnN0eWxlLmxlZnQgPSAobGVmdEhhbmRsZVBvcyAtIGhhbGZIYW5kbGVXaWR0aCkgKyAncHgnO1xuICAgIHNlbGYucmlnaHRab29tSGFuZGxlXy5zdHlsZS5sZWZ0ID0gKHJpZ2h0SGFuZGxlUG9zIC0gaGFsZkhhbmRsZVdpZHRoKSArICdweCc7XG4gICAgc2VsZi5kcmF3SW50ZXJhY3RpdmVMYXllcl8oKTtcblxuICAgIC8vIERvIHBhbiBvbiB0aGUgZmx5LlxuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBkb1BhbigpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBvblBhbkVuZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIWlzUGFubmluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpc1Bhbm5pbmcgPSBmYWxzZTtcbiAgICB1dGlscy5yZW1vdmVFdmVudCh0b3BFbGVtLCAnbW91c2Vtb3ZlJywgb25QYW4pO1xuICAgIHV0aWxzLnJlbW92ZUV2ZW50KHRvcEVsZW0sICdtb3VzZXVwJywgb25QYW5FbmQpO1xuICAgIC8vIElmIG9uIGEgc2xvd2VyIGRldmljZSwgZG8gcGFuIG5vdy5cbiAgICBpZiAoIWR5bmFtaWMpIHtcbiAgICAgIGRvUGFuKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIGRvUGFuID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuaXNDaGFuZ2luZ1JhbmdlXyA9IHRydWU7XG4gICAgICBzZWxmLmR5Z3JhcGhfLmRhdGVXaW5kb3dfID0gdG9YRGF0YVdpbmRvdyhzZWxmLmdldFpvb21IYW5kbGVTdGF0dXNfKCkpO1xuICAgICAgc2VsZi5keWdyYXBoXy5kcmF3R3JhcGhfKGZhbHNlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2VsZi5pc0NoYW5naW5nUmFuZ2VfID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIG9uQ2FudmFzSG92ZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGlzWm9vbWluZyB8fCBpc1Bhbm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGN1cnNvciA9IGlzTW91c2VJblBhblpvbmUoZSkgPyAnbW92ZScgOiAnZGVmYXVsdCc7XG4gICAgaWYgKGN1cnNvciAhPSBzZWxmLmZnY2FudmFzXy5zdHlsZS5jdXJzb3IpIHtcbiAgICAgIHNlbGYuZmdjYW52YXNfLnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcbiAgICB9XG4gIH07XG5cbiAgb25ab29tSGFuZGxlVG91Y2hFdmVudCA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZS50eXBlID09ICd0b3VjaHN0YXJ0JyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAgIGlmIChvblpvb21TdGFydChlLnRhcmdldFRvdWNoZXNbMF0pKSB7XG4gICAgICAgIHV0aWxzLmNhbmNlbEV2ZW50KGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZS50eXBlID09ICd0b3VjaG1vdmUnICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgICAgaWYgKG9uWm9vbShlLnRhcmdldFRvdWNoZXNbMF0pKSB7XG4gICAgICAgIHV0aWxzLmNhbmNlbEV2ZW50KGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvblpvb21FbmQoZSk7XG4gICAgfVxuICB9O1xuXG4gIG9uQ2FudmFzVG91Y2hFdmVudCA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZS50eXBlID09ICd0b3VjaHN0YXJ0JyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAgIGlmIChvblBhblN0YXJ0KGUudGFyZ2V0VG91Y2hlc1swXSkpIHtcbiAgICAgICAgdXRpbHMuY2FuY2VsRXZlbnQoZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlLnR5cGUgPT0gJ3RvdWNobW92ZScgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICBpZiAob25QYW4oZS50YXJnZXRUb3VjaGVzWzBdKSkge1xuICAgICAgICB1dGlscy5jYW5jZWxFdmVudChlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb25QYW5FbmQoZSk7XG4gICAgfVxuICB9O1xuXG4gIGFkZFRvdWNoRXZlbnRzID0gZnVuY3Rpb24oZWxlbSwgZm4pIHtcbiAgICB2YXIgdHlwZXMgPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnLCAndG91Y2htb3ZlJywgJ3RvdWNoY2FuY2VsJ107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgc2VsZi5keWdyYXBoXy5hZGRBbmRUcmFja0V2ZW50KGVsZW0sIHR5cGVzW2ldLCBmbik7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuc2V0RGVmYXVsdE9wdGlvbl8oJ2ludGVyYWN0aW9uTW9kZWwnLCBEeWdyYXBoSW50ZXJhY3Rpb24uZHJhZ0lzUGFuSW50ZXJhY3Rpb25Nb2RlbCk7XG4gIHRoaXMuc2V0RGVmYXVsdE9wdGlvbl8oJ3BhbkVkZ2VGcmFjdGlvbicsIDAuMDAwMSk7XG5cbiAgdmFyIGRyYWdTdGFydEV2ZW50ID0gd2luZG93Lm9wZXJhID8gJ21vdXNlZG93bicgOiAnZHJhZ3N0YXJ0JztcbiAgdGhpcy5keWdyYXBoXy5hZGRBbmRUcmFja0V2ZW50KHRoaXMubGVmdFpvb21IYW5kbGVfLCBkcmFnU3RhcnRFdmVudCwgb25ab29tU3RhcnQpO1xuICB0aGlzLmR5Z3JhcGhfLmFkZEFuZFRyYWNrRXZlbnQodGhpcy5yaWdodFpvb21IYW5kbGVfLCBkcmFnU3RhcnRFdmVudCwgb25ab29tU3RhcnQpO1xuXG4gIHRoaXMuZHlncmFwaF8uYWRkQW5kVHJhY2tFdmVudCh0aGlzLmZnY2FudmFzXywgJ21vdXNlZG93bicsIG9uUGFuU3RhcnQpO1xuICB0aGlzLmR5Z3JhcGhfLmFkZEFuZFRyYWNrRXZlbnQodGhpcy5mZ2NhbnZhc18sICdtb3VzZW1vdmUnLCBvbkNhbnZhc0hvdmVyKTtcblxuICAvLyBUb3VjaCBldmVudHNcbiAgaWYgKHRoaXMuaGFzVG91Y2hJbnRlcmZhY2VfKSB7XG4gICAgYWRkVG91Y2hFdmVudHModGhpcy5sZWZ0Wm9vbUhhbmRsZV8sIG9uWm9vbUhhbmRsZVRvdWNoRXZlbnQpO1xuICAgIGFkZFRvdWNoRXZlbnRzKHRoaXMucmlnaHRab29tSGFuZGxlXywgb25ab29tSGFuZGxlVG91Y2hFdmVudCk7XG4gICAgYWRkVG91Y2hFdmVudHModGhpcy5mZ2NhbnZhc18sIG9uQ2FudmFzVG91Y2hFdmVudCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIERyYXdzIHRoZSBzdGF0aWMgbGF5ZXIgaW4gdGhlIGJhY2tncm91bmQgY2FudmFzLlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5kcmF3U3RhdGljTGF5ZXJfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjdHggPSB0aGlzLmJnY2FudmFzX2N0eF87XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXNSZWN0Xy53LCB0aGlzLmNhbnZhc1JlY3RfLmgpO1xuICB0cnkge1xuICAgIHRoaXMuZHJhd01pbmlQbG90XygpO1xuICB9IGNhdGNoKGV4KSB7XG4gICAgY29uc29sZS53YXJuKGV4KTtcbiAgfVxuXG4gIHZhciBtYXJnaW4gPSAwLjU7XG4gIHRoaXMuYmdjYW52YXNfY3R4Xy5saW5lV2lkdGggPSB0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JCYWNrZ3JvdW5kTGluZVdpZHRoJyk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuZ2V0T3B0aW9uXygncmFuZ2VTZWxlY3RvckJhY2tncm91bmRTdHJva2VDb2xvcicpO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5tb3ZlVG8obWFyZ2luLCBtYXJnaW4pO1xuICBjdHgubGluZVRvKG1hcmdpbiwgdGhpcy5jYW52YXNSZWN0Xy5oLW1hcmdpbik7XG4gIGN0eC5saW5lVG8odGhpcy5jYW52YXNSZWN0Xy53LW1hcmdpbiwgdGhpcy5jYW52YXNSZWN0Xy5oLW1hcmdpbik7XG4gIGN0eC5saW5lVG8odGhpcy5jYW52YXNSZWN0Xy53LW1hcmdpbiwgbWFyZ2luKTtcbiAgY3R4LnN0cm9rZSgpO1xufTtcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBEcmF3cyB0aGUgbWluaSBwbG90IGluIHRoZSBiYWNrZ3JvdW5kIGNhbnZhcy5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuZHJhd01pbmlQbG90XyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlsbFN0eWxlID0gdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yUGxvdEZpbGxDb2xvcicpO1xuICB2YXIgZmlsbEdyYWRpZW50U3R5bGUgPSB0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JQbG90RmlsbEdyYWRpZW50Q29sb3InKTtcbiAgdmFyIHN0cm9rZVN0eWxlID0gdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yUGxvdFN0cm9rZUNvbG9yJyk7XG4gIGlmICghZmlsbFN0eWxlICYmICFzdHJva2VTdHlsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzdGVwUGxvdCA9IHRoaXMuZ2V0T3B0aW9uXygnc3RlcFBsb3QnKTtcblxuICB2YXIgY29tYmluZWRTZXJpZXNEYXRhID0gdGhpcy5jb21wdXRlQ29tYmluZWRTZXJpZXNBbmRMaW1pdHNfKCk7XG4gIHZhciB5UmFuZ2UgPSBjb21iaW5lZFNlcmllc0RhdGEueU1heCAtIGNvbWJpbmVkU2VyaWVzRGF0YS55TWluO1xuXG4gIC8vIERyYXcgdGhlIG1pbmkgcGxvdC5cbiAgdmFyIGN0eCA9IHRoaXMuYmdjYW52YXNfY3R4XztcbiAgdmFyIG1hcmdpbiA9IDAuNTtcblxuICB2YXIgeEV4dHJlbWVzID0gdGhpcy5keWdyYXBoXy54QXhpc0V4dHJlbWVzKCk7XG4gIHZhciB4UmFuZ2UgPSBNYXRoLm1heCh4RXh0cmVtZXNbMV0gLSB4RXh0cmVtZXNbMF0sIDEuZS0zMCk7XG4gIHZhciB4RmFjdCA9ICh0aGlzLmNhbnZhc1JlY3RfLncgLSBtYXJnaW4pL3hSYW5nZTtcbiAgdmFyIHlGYWN0ID0gKHRoaXMuY2FudmFzUmVjdF8uaCAtIG1hcmdpbikveVJhbmdlO1xuICB2YXIgY2FudmFzV2lkdGggPSB0aGlzLmNhbnZhc1JlY3RfLncgLSBtYXJnaW47XG4gIHZhciBjYW52YXNIZWlnaHQgPSB0aGlzLmNhbnZhc1JlY3RfLmggLSBtYXJnaW47XG5cbiAgdmFyIHByZXZYID0gbnVsbCwgcHJldlkgPSBudWxsO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyhtYXJnaW4sIGNhbnZhc0hlaWdodCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29tYmluZWRTZXJpZXNEYXRhLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGF0YVBvaW50ID0gY29tYmluZWRTZXJpZXNEYXRhLmRhdGFbaV07XG4gICAgdmFyIHggPSAoKGRhdGFQb2ludFswXSAhPT0gbnVsbCkgPyAoKGRhdGFQb2ludFswXSAtIHhFeHRyZW1lc1swXSkqeEZhY3QpIDogTmFOKTtcbiAgICB2YXIgeSA9ICgoZGF0YVBvaW50WzFdICE9PSBudWxsKSA/IChjYW52YXNIZWlnaHQgLSAoZGF0YVBvaW50WzFdIC0gY29tYmluZWRTZXJpZXNEYXRhLnlNaW4pKnlGYWN0KSA6IE5hTik7XG5cbiAgICAvLyBTa2lwIHBvaW50cyB0aGF0IGRvbid0IGNoYW5nZSB0aGUgeC12YWx1ZS4gT3Zlcmx5IGZpbmUtZ3JhaW5lZCBwb2ludHNcbiAgICAvLyBjYW4gY2F1c2UgbWFqb3Igc2xvd2Rvd25zIHdpdGggdGhlIGN0eC5maWxsKCkgY2FsbCBiZWxvdy5cbiAgICBpZiAoIXN0ZXBQbG90ICYmIHByZXZYICE9PSBudWxsICYmIE1hdGgucm91bmQoeCkgPT0gTWF0aC5yb3VuZChwcmV2WCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChpc0Zpbml0ZSh4KSAmJiBpc0Zpbml0ZSh5KSkge1xuICAgICAgaWYocHJldlggPT09IG51bGwpIHtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCBjYW52YXNIZWlnaHQpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RlcFBsb3QpIHtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCBwcmV2WSk7XG4gICAgICB9XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgcHJldlggPSB4O1xuICAgICAgcHJldlkgPSB5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmKHByZXZYICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzdGVwUGxvdCkge1xuICAgICAgICAgIGN0eC5saW5lVG8oeCwgcHJldlkpO1xuICAgICAgICAgIGN0eC5saW5lVG8oeCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjdHgubGluZVRvKHByZXZYLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcmV2WCA9IHByZXZZID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgY3R4LmxpbmVUbyhjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gIGlmIChmaWxsU3R5bGUpIHtcbiAgICB2YXIgbGluZ3JhZCA9IHRoaXMuYmdjYW52YXNfY3R4Xy5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCBjYW52YXNIZWlnaHQpO1xuICAgIGlmIChmaWxsR3JhZGllbnRTdHlsZSkge1xuICAgICAgbGluZ3JhZC5hZGRDb2xvclN0b3AoMCwgZmlsbEdyYWRpZW50U3R5bGUpO1xuICAgIH1cbiAgICBsaW5ncmFkLmFkZENvbG9yU3RvcCgxLCBmaWxsU3R5bGUpO1xuICAgIHRoaXMuYmdjYW52YXNfY3R4Xy5maWxsU3R5bGUgPSBsaW5ncmFkO1xuICAgIGN0eC5maWxsKCk7XG4gIH1cblxuICBpZiAoc3Ryb2tlU3R5bGUpIHtcbiAgICB0aGlzLmJnY2FudmFzX2N0eF8uc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICB0aGlzLmJnY2FudmFzX2N0eF8ubGluZVdpZHRoID0gdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yUGxvdExpbmVXaWR0aCcpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQ29tcHV0ZXMgYW5kIHJldHVybnMgdGhlIGNvbWJpbmVkIHNlcmllcyBkYXRhIGFsb25nIHdpdGggbWluL21heCBmb3IgdGhlIG1pbmkgcGxvdC5cbiAqIFRoZSBjb21iaW5lZCBzZXJpZXMgY29uc2lzdHMgb2YgYXZlcmFnZWQgdmFsdWVzIGZvciBhbGwgc2VyaWVzLlxuICogV2hlbiBzZXJpZXMgaGF2ZSBlcnJvciBiYXJzLCB0aGUgZXJyb3IgYmFycyBhcmUgaWdub3JlZC5cbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tYmluZWQgc2VyaWVzIGFycmF5LCB5bWluLCB5bWF4LlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5jb21wdXRlQ29tYmluZWRTZXJpZXNBbmRMaW1pdHNfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBnID0gdGhpcy5keWdyYXBoXztcbiAgdmFyIGxvZ3NjYWxlID0gdGhpcy5nZXRPcHRpb25fKCdsb2dzY2FsZScpO1xuICB2YXIgaTtcblxuICAvLyBTZWxlY3Qgc2VyaWVzIHRvIGNvbWJpbmUuIEJ5IGRlZmF1bHQsIGFsbCBzZXJpZXMgYXJlIGNvbWJpbmVkLlxuICB2YXIgbnVtQ29sdW1ucyA9IGcubnVtQ29sdW1ucygpO1xuICB2YXIgbGFiZWxzID0gZy5nZXRMYWJlbHMoKTtcbiAgdmFyIGluY2x1ZGVTZXJpZXMgPSBuZXcgQXJyYXkobnVtQ29sdW1ucyk7XG4gIHZhciBhbnlTZXQgPSBmYWxzZTtcbiAgdmFyIHZpc2liaWxpdHkgPSBnLnZpc2liaWxpdHkoKTtcbiAgdmFyIGluY2x1c2lvbiA9IFtdO1xuXG4gIGZvciAoaSA9IDE7IGkgPCBudW1Db2x1bW5zOyBpKyspIHtcbiAgICB2YXIgaW5jbHVkZSA9IHRoaXMuZ2V0T3B0aW9uXygnc2hvd0luUmFuZ2VTZWxlY3RvcicsIGxhYmVsc1tpXSk7XG4gICAgaW5jbHVzaW9uLnB1c2goaW5jbHVkZSk7XG4gICAgaWYgKGluY2x1ZGUgIT09IG51bGwpIGFueVNldCA9IHRydWU7ICAvLyBpdCdzIHNldCBleHBsaWNpdGx5IGZvciB0aGlzIHNlcmllc1xuICB9XG5cbiAgaWYgKGFueVNldCkge1xuICAgIGZvciAoaSA9IDE7IGkgPCBudW1Db2x1bW5zOyBpKyspIHtcbiAgICAgIGluY2x1ZGVTZXJpZXNbaV0gPSBpbmNsdXNpb25baSAtIDFdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbnVtQ29sdW1uczsgaSsrKSB7XG4gICAgICBpbmNsdWRlU2VyaWVzW2ldID0gdmlzaWJpbGl0eVtpIC0gMV07XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGEgY29tYmluZWQgc2VyaWVzIChhdmVyYWdlIG9mIHNlbGVjdGVkIHNlcmllcyB2YWx1ZXMpLlxuICAvLyBUT0RPKGRhbnZrKTogc2hvcnQtY2lyY3VpdCBpZiB0aGVyZSdzIG9ubHkgb25lIHNlcmllcy5cbiAgdmFyIHJvbGxlZFNlcmllcyA9IFtdO1xuICB2YXIgZGF0YUhhbmRsZXIgPSBnLmRhdGFIYW5kbGVyXztcbiAgdmFyIG9wdGlvbnMgPSBnLmF0dHJpYnV0ZXNfO1xuICBmb3IgKGkgPSAxOyBpIDwgZy5udW1Db2x1bW5zKCk7IGkrKykge1xuICAgIGlmICghaW5jbHVkZVNlcmllc1tpXSkgY29udGludWU7XG4gICAgdmFyIHNlcmllcyA9IGRhdGFIYW5kbGVyLmV4dHJhY3RTZXJpZXMoZy5yYXdEYXRhXywgaSwgb3B0aW9ucyk7XG4gICAgaWYgKGcucm9sbFBlcmlvZCgpID4gMSkge1xuICAgICAgc2VyaWVzID0gZGF0YUhhbmRsZXIucm9sbGluZ0F2ZXJhZ2Uoc2VyaWVzLCBnLnJvbGxQZXJpb2QoKSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcm9sbGVkU2VyaWVzLnB1c2goc2VyaWVzKTtcbiAgfVxuXG4gIHZhciBjb21iaW5lZFNlcmllcyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgcm9sbGVkU2VyaWVzWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvbGxlZFNlcmllcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHkgPSByb2xsZWRTZXJpZXNbal1baV1bMV07XG4gICAgICBpZiAoeSA9PT0gbnVsbCB8fCBpc05hTih5KSkgY29udGludWU7XG4gICAgICBjb3VudCsrO1xuICAgICAgc3VtICs9IHk7XG4gICAgfVxuICAgIGNvbWJpbmVkU2VyaWVzLnB1c2goW3JvbGxlZFNlcmllc1swXVtpXVswXSwgc3VtIC8gY291bnRdKTtcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIHkgcmFuZ2UuXG4gIHZhciB5TWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgdmFyIHlNYXggPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgZm9yIChpID0gMDsgaSA8IGNvbWJpbmVkU2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHlWYWwgPSBjb21iaW5lZFNlcmllc1tpXVsxXTtcbiAgICBpZiAoeVZhbCAhPT0gbnVsbCAmJiBpc0Zpbml0ZSh5VmFsKSAmJiAoIWxvZ3NjYWxlIHx8IHlWYWwgPiAwKSkge1xuICAgICAgeU1pbiA9IE1hdGgubWluKHlNaW4sIHlWYWwpO1xuICAgICAgeU1heCA9IE1hdGgubWF4KHlNYXgsIHlWYWwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbnZlcnQgWSBkYXRhIHRvIGxvZyBzY2FsZSBpZiBuZWVkZWQuXG4gIC8vIEFsc28sIGV4cGFuZCB0aGUgWSByYW5nZSB0byBjb21wcmVzcyB0aGUgbWluaSBwbG90IGEgbGl0dGxlLlxuICB2YXIgZXh0cmFQZXJjZW50ID0gMC4yNTtcbiAgaWYgKGxvZ3NjYWxlKSB7XG4gICAgeU1heCA9IHV0aWxzLmxvZzEwKHlNYXgpO1xuICAgIHlNYXggKz0geU1heCpleHRyYVBlcmNlbnQ7XG4gICAgeU1pbiA9IHV0aWxzLmxvZzEwKHlNaW4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb21iaW5lZFNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29tYmluZWRTZXJpZXNbaV1bMV0gPSB1dGlscy5sb2cxMChjb21iaW5lZFNlcmllc1tpXVsxXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB5RXh0cmE7XG4gICAgdmFyIHlSYW5nZSA9IHlNYXggLSB5TWluO1xuICAgIGlmICh5UmFuZ2UgPD0gTnVtYmVyLk1JTl9WQUxVRSkge1xuICAgICAgeUV4dHJhID0geU1heCpleHRyYVBlcmNlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHlFeHRyYSA9IHlSYW5nZSpleHRyYVBlcmNlbnQ7XG4gICAgfVxuICAgIHlNYXggKz0geUV4dHJhO1xuICAgIHlNaW4gLT0geUV4dHJhO1xuICB9XG5cbiAgcmV0dXJuIHtkYXRhOiBjb21iaW5lZFNlcmllcywgeU1pbjogeU1pbiwgeU1heDogeU1heH07XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBQbGFjZXMgdGhlIHpvb20gaGFuZGxlcyBpbiB0aGUgcHJvcGVyIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IFggZGF0YSB3aW5kb3cuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnBsYWNlWm9vbUhhbmRsZXNfID0gZnVuY3Rpb24oKSB7XG4gIHZhciB4RXh0cmVtZXMgPSB0aGlzLmR5Z3JhcGhfLnhBeGlzRXh0cmVtZXMoKTtcbiAgdmFyIHhXaW5kb3dMaW1pdHMgPSB0aGlzLmR5Z3JhcGhfLnhBeGlzUmFuZ2UoKTtcbiAgdmFyIHhSYW5nZSA9IHhFeHRyZW1lc1sxXSAtIHhFeHRyZW1lc1swXTtcbiAgdmFyIGxlZnRQZXJjZW50ID0gTWF0aC5tYXgoMCwgKHhXaW5kb3dMaW1pdHNbMF0gLSB4RXh0cmVtZXNbMF0pL3hSYW5nZSk7XG4gIHZhciByaWdodFBlcmNlbnQgPSBNYXRoLm1heCgwLCAoeEV4dHJlbWVzWzFdIC0geFdpbmRvd0xpbWl0c1sxXSkveFJhbmdlKTtcbiAgdmFyIGxlZnRDb29yZCA9IHRoaXMuY2FudmFzUmVjdF8ueCArIHRoaXMuY2FudmFzUmVjdF8udypsZWZ0UGVyY2VudDtcbiAgdmFyIHJpZ2h0Q29vcmQgPSB0aGlzLmNhbnZhc1JlY3RfLnggKyB0aGlzLmNhbnZhc1JlY3RfLncqKDEgLSByaWdodFBlcmNlbnQpO1xuICB2YXIgaGFuZGxlVG9wID0gTWF0aC5tYXgodGhpcy5jYW52YXNSZWN0Xy55LCB0aGlzLmNhbnZhc1JlY3RfLnkgKyAodGhpcy5jYW52YXNSZWN0Xy5oIC0gdGhpcy5sZWZ0Wm9vbUhhbmRsZV8uaGVpZ2h0KS8yKTtcbiAgdmFyIGhhbGZIYW5kbGVXaWR0aCA9IHRoaXMubGVmdFpvb21IYW5kbGVfLndpZHRoLzI7XG4gIHRoaXMubGVmdFpvb21IYW5kbGVfLnN0eWxlLmxlZnQgPSAobGVmdENvb3JkIC0gaGFsZkhhbmRsZVdpZHRoKSArICdweCc7XG4gIHRoaXMubGVmdFpvb21IYW5kbGVfLnN0eWxlLnRvcCA9IGhhbmRsZVRvcCArICdweCc7XG4gIHRoaXMucmlnaHRab29tSGFuZGxlXy5zdHlsZS5sZWZ0ID0gKHJpZ2h0Q29vcmQgLSBoYWxmSGFuZGxlV2lkdGgpICsgJ3B4JztcbiAgdGhpcy5yaWdodFpvb21IYW5kbGVfLnN0eWxlLnRvcCA9IHRoaXMubGVmdFpvb21IYW5kbGVfLnN0eWxlLnRvcDtcblxuICB0aGlzLmxlZnRab29tSGFuZGxlXy5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICB0aGlzLnJpZ2h0Wm9vbUhhbmRsZV8uc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIERyYXdzIHRoZSBpbnRlcmFjdGl2ZSBsYXllciBpbiB0aGUgZm9yZWdyb3VuZCBjYW52YXMuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmRyYXdJbnRlcmFjdGl2ZUxheWVyXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY3R4ID0gdGhpcy5mZ2NhbnZhc19jdHhfO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzUmVjdF8udywgdGhpcy5jYW52YXNSZWN0Xy5oKTtcbiAgdmFyIG1hcmdpbiA9IDE7XG4gIHZhciB3aWR0aCA9IHRoaXMuY2FudmFzUmVjdF8udyAtIG1hcmdpbjtcbiAgdmFyIGhlaWdodCA9IHRoaXMuY2FudmFzUmVjdF8uaCAtIG1hcmdpbjtcbiAgdmFyIHpvb21IYW5kbGVTdGF0dXMgPSB0aGlzLmdldFpvb21IYW5kbGVTdGF0dXNfKCk7XG5cbiAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yRm9yZWdyb3VuZFN0cm9rZUNvbG9yJyk7XG4gIGN0eC5saW5lV2lkdGggPSB0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JGb3JlZ3JvdW5kTGluZVdpZHRoJyk7XG4gIGlmICghem9vbUhhbmRsZVN0YXR1cy5pc1pvb21lZCkge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKG1hcmdpbiwgbWFyZ2luKTtcbiAgICBjdHgubGluZVRvKG1hcmdpbiwgaGVpZ2h0KTtcbiAgICBjdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgIGN0eC5saW5lVG8od2lkdGgsIG1hcmdpbik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZWZ0SGFuZGxlQ2FudmFzUG9zID0gTWF0aC5tYXgobWFyZ2luLCB6b29tSGFuZGxlU3RhdHVzLmxlZnRIYW5kbGVQb3MgLSB0aGlzLmNhbnZhc1JlY3RfLngpO1xuICAgIHZhciByaWdodEhhbmRsZUNhbnZhc1BvcyA9IE1hdGgubWluKHdpZHRoLCB6b29tSGFuZGxlU3RhdHVzLnJpZ2h0SGFuZGxlUG9zIC0gdGhpcy5jYW52YXNSZWN0Xy54KTtcblxuICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgyNDAsIDI0MCwgMjQwLCAnICsgdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yQWxwaGEnKS50b1N0cmluZygpICsgJyknO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBsZWZ0SGFuZGxlQ2FudmFzUG9zLCB0aGlzLmNhbnZhc1JlY3RfLmgpO1xuICAgIGN0eC5maWxsUmVjdChyaWdodEhhbmRsZUNhbnZhc1BvcywgMCwgdGhpcy5jYW52YXNSZWN0Xy53IC0gcmlnaHRIYW5kbGVDYW52YXNQb3MsIHRoaXMuY2FudmFzUmVjdF8uaCk7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyhtYXJnaW4sIG1hcmdpbik7XG4gICAgY3R4LmxpbmVUbyhsZWZ0SGFuZGxlQ2FudmFzUG9zLCBtYXJnaW4pO1xuICAgIGN0eC5saW5lVG8obGVmdEhhbmRsZUNhbnZhc1BvcywgaGVpZ2h0KTtcbiAgICBjdHgubGluZVRvKHJpZ2h0SGFuZGxlQ2FudmFzUG9zLCBoZWlnaHQpO1xuICAgIGN0eC5saW5lVG8ocmlnaHRIYW5kbGVDYW52YXNQb3MsIG1hcmdpbik7XG4gICAgY3R4LmxpbmVUbyh3aWR0aCwgbWFyZ2luKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBoYW5kbGUgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB6b29tIGhhbmRsZSBzdGF0dXMuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmdldFpvb21IYW5kbGVTdGF0dXNfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYWxmSGFuZGxlV2lkdGggPSB0aGlzLmxlZnRab29tSGFuZGxlXy53aWR0aC8yO1xuICB2YXIgbGVmdEhhbmRsZVBvcyA9IHBhcnNlRmxvYXQodGhpcy5sZWZ0Wm9vbUhhbmRsZV8uc3R5bGUubGVmdCkgKyBoYWxmSGFuZGxlV2lkdGg7XG4gIHZhciByaWdodEhhbmRsZVBvcyA9IHBhcnNlRmxvYXQodGhpcy5yaWdodFpvb21IYW5kbGVfLnN0eWxlLmxlZnQpICsgaGFsZkhhbmRsZVdpZHRoO1xuICByZXR1cm4ge1xuICAgICAgbGVmdEhhbmRsZVBvczogbGVmdEhhbmRsZVBvcyxcbiAgICAgIHJpZ2h0SGFuZGxlUG9zOiByaWdodEhhbmRsZVBvcyxcbiAgICAgIGlzWm9vbWVkOiAobGVmdEhhbmRsZVBvcyAtIDEgPiB0aGlzLmNhbnZhc1JlY3RfLnggfHwgcmlnaHRIYW5kbGVQb3MgKyAxIDwgdGhpcy5jYW52YXNSZWN0Xy54K3RoaXMuY2FudmFzUmVjdF8udylcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJhbmdlU2VsZWN0b3I7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2R5Z3JhcGhzL3NyYy9wbHVnaW5zL3JhbmdlLXNlbGVjdG9yLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///34\n");

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_dygraphs__ = __webpack_require__(22);\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  render: function render(createElement) {\n    return createElement('div', {\n      attrs: {\n        id: 'vue-dygraphs' + this._uid\n      }\n    });\n  },\n  data: function data() {\n    return {\n      _graph: null\n    };\n  },\n\n  props: {\n    graphData: {\n      required: true\n    },\n    graphOptions: {},\n    graphEvents: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    }\n  },\n  methods: {\n    renderGraph: function renderGraph(data, options) {\n      this._graph = new __WEBPACK_IMPORTED_MODULE_0_dygraphs__[\"a\" /* default */]('vue-dygraphs' + this._uid, data, options);\n    }\n  },\n  watch: {\n    'graphData': {\n      handler: function handler(val, oldVal) {\n        this._graph.updateOptions({ file: val });\n      }\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vRHlncmFwaHMudnVlPzIyZDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0E7O0FBRUE7eUNBRUE7OztrQ0FPQTtBQUpBO0FBREEsS0FEQTtBQU9BO3dCQUNBOztjQUdBO0FBRkE7QUFHQTs7OztnQkFJQTtBQUZBO2tCQUlBOztZQUVBOztlQUdBOztBQUpBO0FBTkE7O3FEQVlBO29IQUNBO0FBRUE7QUFKQTs7OzZDQU9BOzBDQUNBO0FBR0E7QUFMQTtBQURBO0FBL0JBIiwiZmlsZSI6IjM1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbmltcG9ydCBEeWdyYXBocyBmcm9tICdkeWdyYXBocydcblxuZXhwb3J0IGRlZmF1bHQge1xuICByZW5kZXIgKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLCB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6ICd2dWUtZHlncmFwaHMnICsgdGhpcy5fdWlkLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICApXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBfZ3JhcGg6IG51bGwsXG4gICAgfVxuICB9LFxuICBwcm9wczoge1xuICAgIGdyYXBoRGF0YToge1xuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgICBncmFwaE9wdGlvbnM6IHtcbiAgICB9LFxuICAgIGdyYXBoRXZlbnRzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6ICgpID0+IFtdLFxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHJlbmRlckdyYXBoKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2dyYXBoID0gbmV3IER5Z3JhcGhzKCd2dWUtZHlncmFwaHMnICsgdGhpcy5fdWlkLCBkYXRhLCBvcHRpb25zKVxuICAgIH0sXG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgJ2dyYXBoRGF0YSc6IHtcbiAgICAgIGhhbmRsZXIgKHZhbCwgb2xkVmFsKSB7XG4gICAgICAgIHRoaXMuX2dyYXBoLnVwZGF0ZU9wdGlvbnMoe2ZpbGU6IHZhbH0pXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG59XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXG48L3N0eWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIER5Z3JhcGhzLnZ1ZT9kNWEzM2I2YyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///35\n");

/***/ }),
/* 36 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9EeWdyYXBocy52dWU/YWY3YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1wib21pdFwiOjAsXCJyZW1vdmVcIjp0cnVlfSEuL34vY3NzLWxvYWRlciEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/aWQ9ZGF0YS12LTA2YTJhOWE4IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvRHlncmFwaHMudnVlXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///36\n");

/***/ }),
/* 37 */,
/* 38 */
/***/ (function(module, exports) {

eval("module.exports = {\n  data: function data() {\n    return {\n      test: null\n    };\n  },\n\n  mounted: function mounted() {\n    this.graphOptions.clickCallback = this.clickCallback;\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWl4aW5zL21peGlucy5qcz8yMWY4Il0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJkYXRhIiwidGVzdCIsIm1vdW50ZWQiLCJncmFwaE9wdGlvbnMiLCJjbGlja0NhbGxiYWNrIl0sIm1hcHBpbmdzIjoiQUFBQUEsT0FBT0MsT0FBUCxHQUFpQjtBQUNmQyxNQURlLGtCQUNQO0FBQ04sV0FBTztBQUNMQyxZQUFNO0FBREQsS0FBUDtBQUdELEdBTGM7O0FBTWZDLFdBQVMsbUJBQVc7QUFDbEIsU0FBS0MsWUFBTCxDQUFrQkMsYUFBbEIsR0FBa0MsS0FBS0EsYUFBdkM7QUFDRDtBQVJjLENBQWpCIiwiZmlsZSI6IjM4LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXN0OiBudWxsLFxuICAgIH1cbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5ncmFwaE9wdGlvbnMuY2xpY2tDYWxsYmFjayA9IHRoaXMuY2xpY2tDYWxsYmFja1xuICB9LFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21peGlucy9taXhpbnMuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///38\n");

/***/ })
/******/ ]);
});